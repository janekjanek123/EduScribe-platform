"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/signal-exit";
exports.ids = ["vendor-chunks/signal-exit"];
exports.modules = {

/***/ "(rsc)/./node_modules/signal-exit/dist/mjs/index.js":
/*!****************************************************!*\
  !*** ./node_modules/signal-exit/dist/mjs/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   onExit: () => (/* binding */ onExit),\n/* harmony export */   signals: () => (/* reexport safe */ _signals_js__WEBPACK_IMPORTED_MODULE_0__.signals),\n/* harmony export */   unload: () => (/* binding */ unload)\n/* harmony export */ });\n/* harmony import */ var _signals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signals.js */ \"(rsc)/./node_modules/signal-exit/dist/mjs/signals.js\");\n// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\n// grab a reference to node's real process object right away\n\n\nconst processOk = (process) => !!process &&\n    typeof process === 'object' &&\n    typeof process.removeListener === 'function' &&\n    typeof process.emit === 'function' &&\n    typeof process.reallyExit === 'function' &&\n    typeof process.listeners === 'function' &&\n    typeof process.kill === 'function' &&\n    typeof process.pid === 'number' &&\n    typeof process.on === 'function';\nconst kExitEmitter = Symbol.for('signal-exit emitter');\nconst global = globalThis;\nconst ObjectDefineProperty = Object.defineProperty.bind(Object);\n// teeny special purpose ee\nclass Emitter {\n    emitted = {\n        afterExit: false,\n        exit: false,\n    };\n    listeners = {\n        afterExit: [],\n        exit: [],\n    };\n    count = 0;\n    id = Math.random();\n    constructor() {\n        if (global[kExitEmitter]) {\n            return global[kExitEmitter];\n        }\n        ObjectDefineProperty(global, kExitEmitter, {\n            value: this,\n            writable: false,\n            enumerable: false,\n            configurable: false,\n        });\n    }\n    on(ev, fn) {\n        this.listeners[ev].push(fn);\n    }\n    removeListener(ev, fn) {\n        const list = this.listeners[ev];\n        const i = list.indexOf(fn);\n        /* c8 ignore start */\n        if (i === -1) {\n            return;\n        }\n        /* c8 ignore stop */\n        if (i === 0 && list.length === 1) {\n            list.length = 0;\n        }\n        else {\n            list.splice(i, 1);\n        }\n    }\n    emit(ev, code, signal) {\n        if (this.emitted[ev]) {\n            return false;\n        }\n        this.emitted[ev] = true;\n        let ret = false;\n        for (const fn of this.listeners[ev]) {\n            ret = fn(code, signal) === true || ret;\n        }\n        if (ev === 'exit') {\n            ret = this.emit('afterExit', code, signal) || ret;\n        }\n        return ret;\n    }\n}\nclass SignalExitBase {\n}\nconst signalExitWrap = (handler) => {\n    return {\n        onExit(cb, opts) {\n            return handler.onExit(cb, opts);\n        },\n        load() {\n            return handler.load();\n        },\n        unload() {\n            return handler.unload();\n        },\n    };\n};\nclass SignalExitFallback extends SignalExitBase {\n    onExit() {\n        return () => { };\n    }\n    load() { }\n    unload() { }\n}\nclass SignalExit extends SignalExitBase {\n    // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n    // so use a supported signal instead\n    /* c8 ignore start */\n    #hupSig = process.platform === 'win32' ? 'SIGINT' : 'SIGHUP';\n    /* c8 ignore stop */\n    #emitter = new Emitter();\n    #process;\n    #originalProcessEmit;\n    #originalProcessReallyExit;\n    #sigListeners = {};\n    #loaded = false;\n    constructor(process) {\n        super();\n        this.#process = process;\n        // { <signal>: <listener fn>, ... }\n        this.#sigListeners = {};\n        for (const sig of _signals_js__WEBPACK_IMPORTED_MODULE_0__.signals) {\n            this.#sigListeners[sig] = () => {\n                // If there are no other listeners, an exit is coming!\n                // Simplest way: remove us and then re-send the signal.\n                // We know that this will kill the process, so we can\n                // safely emit now.\n                const listeners = this.#process.listeners(sig);\n                let { count } = this.#emitter;\n                // This is a workaround for the fact that signal-exit v3 and signal\n                // exit v4 are not aware of each other, and each will attempt to let\n                // the other handle it, so neither of them do. To correct this, we\n                // detect if we're the only handler *except* for previous versions\n                // of signal-exit, and increment by the count of listeners it has\n                // created.\n                /* c8 ignore start */\n                const p = process;\n                if (typeof p.__signal_exit_emitter__ === 'object' &&\n                    typeof p.__signal_exit_emitter__.count === 'number') {\n                    count += p.__signal_exit_emitter__.count;\n                }\n                /* c8 ignore stop */\n                if (listeners.length === count) {\n                    this.unload();\n                    const ret = this.#emitter.emit('exit', null, sig);\n                    /* c8 ignore start */\n                    const s = sig === 'SIGHUP' ? this.#hupSig : sig;\n                    if (!ret)\n                        process.kill(process.pid, s);\n                    /* c8 ignore stop */\n                }\n            };\n        }\n        this.#originalProcessReallyExit = process.reallyExit;\n        this.#originalProcessEmit = process.emit;\n    }\n    onExit(cb, opts) {\n        /* c8 ignore start */\n        if (!processOk(this.#process)) {\n            return () => { };\n        }\n        /* c8 ignore stop */\n        if (this.#loaded === false) {\n            this.load();\n        }\n        const ev = opts?.alwaysLast ? 'afterExit' : 'exit';\n        this.#emitter.on(ev, cb);\n        return () => {\n            this.#emitter.removeListener(ev, cb);\n            if (this.#emitter.listeners['exit'].length === 0 &&\n                this.#emitter.listeners['afterExit'].length === 0) {\n                this.unload();\n            }\n        };\n    }\n    load() {\n        if (this.#loaded) {\n            return;\n        }\n        this.#loaded = true;\n        // This is the number of onSignalExit's that are in play.\n        // It's important so that we can count the correct number of\n        // listeners on signals, and don't wait for the other one to\n        // handle it instead of us.\n        this.#emitter.count += 1;\n        for (const sig of _signals_js__WEBPACK_IMPORTED_MODULE_0__.signals) {\n            try {\n                const fn = this.#sigListeners[sig];\n                if (fn)\n                    this.#process.on(sig, fn);\n            }\n            catch (_) { }\n        }\n        this.#process.emit = (ev, ...a) => {\n            return this.#processEmit(ev, ...a);\n        };\n        this.#process.reallyExit = (code) => {\n            return this.#processReallyExit(code);\n        };\n    }\n    unload() {\n        if (!this.#loaded) {\n            return;\n        }\n        this.#loaded = false;\n        _signals_js__WEBPACK_IMPORTED_MODULE_0__.signals.forEach(sig => {\n            const listener = this.#sigListeners[sig];\n            /* c8 ignore start */\n            if (!listener) {\n                throw new Error('Listener not defined for signal: ' + sig);\n            }\n            /* c8 ignore stop */\n            try {\n                this.#process.removeListener(sig, listener);\n                /* c8 ignore start */\n            }\n            catch (_) { }\n            /* c8 ignore stop */\n        });\n        this.#process.emit = this.#originalProcessEmit;\n        this.#process.reallyExit = this.#originalProcessReallyExit;\n        this.#emitter.count -= 1;\n    }\n    #processReallyExit(code) {\n        /* c8 ignore start */\n        if (!processOk(this.#process)) {\n            return 0;\n        }\n        this.#process.exitCode = code || 0;\n        /* c8 ignore stop */\n        this.#emitter.emit('exit', this.#process.exitCode, null);\n        return this.#originalProcessReallyExit.call(this.#process, this.#process.exitCode);\n    }\n    #processEmit(ev, ...args) {\n        const og = this.#originalProcessEmit;\n        if (ev === 'exit' && processOk(this.#process)) {\n            if (typeof args[0] === 'number') {\n                this.#process.exitCode = args[0];\n                /* c8 ignore start */\n            }\n            /* c8 ignore start */\n            const ret = og.call(this.#process, ev, ...args);\n            /* c8 ignore start */\n            this.#emitter.emit('exit', this.#process.exitCode, null);\n            /* c8 ignore stop */\n            return ret;\n        }\n        else {\n            return og.call(this.#process, ev, ...args);\n        }\n    }\n}\nconst process = globalThis.process;\n// wrap so that we call the method on the actual handler, without\n// exporting it directly.\nconst { \n/**\n * Called when the process is exiting, whether via signal, explicit\n * exit, or running out of stuff to do.\n *\n * If the global process object is not suitable for instrumentation,\n * then this will be a no-op.\n *\n * Returns a function that may be used to unload signal-exit.\n */\nonExit, \n/**\n * Load the listeners.  Likely you never need to call this, unless\n * doing a rather deep integration with signal-exit functionality.\n * Mostly exposed for the benefit of testing.\n *\n * @internal\n */\nload, \n/**\n * Unload the listeners.  Likely you never need to call this, unless\n * doing a rather deep integration with signal-exit functionality.\n * Mostly exposed for the benefit of testing.\n *\n * @internal\n */\nunload, } = signalExitWrap(processOk(process) ? new SignalExit(process) : new SignalExitFallback());\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvZGlzdC9tanMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUN1QztBQUNwQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQixnREFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL3NpZ25hbC1leGl0L2Rpc3QvbWpzL2luZGV4LmpzPzMzY2UiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTm90ZTogc2luY2UgbnljIHVzZXMgdGhpcyBtb2R1bGUgdG8gb3V0cHV0IGNvdmVyYWdlLCBhbnkgbGluZXNcbi8vIHRoYXQgYXJlIGluIHRoZSBkaXJlY3Qgc3luYyBmbG93IG9mIG55YydzIG91dHB1dENvdmVyYWdlIGFyZVxuLy8gaWdub3JlZCwgc2luY2Ugd2UgY2FuIG5ldmVyIGdldCBjb3ZlcmFnZSBmb3IgdGhlbS5cbi8vIGdyYWIgYSByZWZlcmVuY2UgdG8gbm9kZSdzIHJlYWwgcHJvY2VzcyBvYmplY3QgcmlnaHQgYXdheVxuaW1wb3J0IHsgc2lnbmFscyB9IGZyb20gJy4vc2lnbmFscy5qcyc7XG5leHBvcnQgeyBzaWduYWxzIH07XG5jb25zdCBwcm9jZXNzT2sgPSAocHJvY2VzcykgPT4gISFwcm9jZXNzICYmXG4gICAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHByb2Nlc3MucmVhbGx5RXhpdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLmxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBwcm9jZXNzLmtpbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgcHJvY2Vzcy5waWQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIHByb2Nlc3Mub24gPT09ICdmdW5jdGlvbic7XG5jb25zdCBrRXhpdEVtaXR0ZXIgPSBTeW1ib2wuZm9yKCdzaWduYWwtZXhpdCBlbWl0dGVyJyk7XG5jb25zdCBnbG9iYWwgPSBnbG9iYWxUaGlzO1xuY29uc3QgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkuYmluZChPYmplY3QpO1xuLy8gdGVlbnkgc3BlY2lhbCBwdXJwb3NlIGVlXG5jbGFzcyBFbWl0dGVyIHtcbiAgICBlbWl0dGVkID0ge1xuICAgICAgICBhZnRlckV4aXQ6IGZhbHNlLFxuICAgICAgICBleGl0OiBmYWxzZSxcbiAgICB9O1xuICAgIGxpc3RlbmVycyA9IHtcbiAgICAgICAgYWZ0ZXJFeGl0OiBbXSxcbiAgICAgICAgZXhpdDogW10sXG4gICAgfTtcbiAgICBjb3VudCA9IDA7XG4gICAgaWQgPSBNYXRoLnJhbmRvbSgpO1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBpZiAoZ2xvYmFsW2tFeGl0RW1pdHRlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxba0V4aXRFbWl0dGVyXTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShnbG9iYWwsIGtFeGl0RW1pdHRlciwge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbihldiwgZm4pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZdLnB1c2goZm4pO1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcihldiwgZm4pIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMubGlzdGVuZXJzW2V2XTtcbiAgICAgICAgY29uc3QgaSA9IGxpc3QuaW5kZXhPZihmbik7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICBpZiAoaSA9PT0gMCAmJiBsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdChldiwgY29kZSwgc2lnbmFsKSB7XG4gICAgICAgIGlmICh0aGlzLmVtaXR0ZWRbZXZdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0dGVkW2V2XSA9IHRydWU7XG4gICAgICAgIGxldCByZXQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiB0aGlzLmxpc3RlbmVyc1tldl0pIHtcbiAgICAgICAgICAgIHJldCA9IGZuKGNvZGUsIHNpZ25hbCkgPT09IHRydWUgfHwgcmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChldiA9PT0gJ2V4aXQnKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLmVtaXQoJ2FmdGVyRXhpdCcsIGNvZGUsIHNpZ25hbCkgfHwgcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxufVxuY2xhc3MgU2lnbmFsRXhpdEJhc2Uge1xufVxuY29uc3Qgc2lnbmFsRXhpdFdyYXAgPSAoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uRXhpdChjYiwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIub25FeGl0KGNiLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9hZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyLmxvYWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5sb2FkKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIudW5sb2FkKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5jbGFzcyBTaWduYWxFeGl0RmFsbGJhY2sgZXh0ZW5kcyBTaWduYWxFeGl0QmFzZSB7XG4gICAgb25FeGl0KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuICAgIH1cbiAgICBsb2FkKCkgeyB9XG4gICAgdW5sb2FkKCkgeyB9XG59XG5jbGFzcyBTaWduYWxFeGl0IGV4dGVuZHMgU2lnbmFsRXhpdEJhc2Uge1xuICAgIC8vIFwiU0lHSFVQXCIgdGhyb3dzIGFuIGBFTk9TWVNgIGVycm9yIG9uIFdpbmRvd3MsXG4gICAgLy8gc28gdXNlIGEgc3VwcG9ydGVkIHNpZ25hbCBpbnN0ZWFkXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgI2h1cFNpZyA9IHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicgPyAnU0lHSU5UJyA6ICdTSUdIVVAnO1xuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgI2VtaXR0ZXIgPSBuZXcgRW1pdHRlcigpO1xuICAgICNwcm9jZXNzO1xuICAgICNvcmlnaW5hbFByb2Nlc3NFbWl0O1xuICAgICNvcmlnaW5hbFByb2Nlc3NSZWFsbHlFeGl0O1xuICAgICNzaWdMaXN0ZW5lcnMgPSB7fTtcbiAgICAjbG9hZGVkID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IocHJvY2Vzcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLiNwcm9jZXNzID0gcHJvY2VzcztcbiAgICAgICAgLy8geyA8c2lnbmFsPjogPGxpc3RlbmVyIGZuPiwgLi4uIH1cbiAgICAgICAgdGhpcy4jc2lnTGlzdGVuZXJzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgc2lnIG9mIHNpZ25hbHMpIHtcbiAgICAgICAgICAgIHRoaXMuI3NpZ0xpc3RlbmVyc1tzaWddID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBsaXN0ZW5lcnMsIGFuIGV4aXQgaXMgY29taW5nIVxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZXN0IHdheTogcmVtb3ZlIHVzIGFuZCB0aGVuIHJlLXNlbmQgdGhlIHNpZ25hbC5cbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgdGhpcyB3aWxsIGtpbGwgdGhlIHByb2Nlc3MsIHNvIHdlIGNhblxuICAgICAgICAgICAgICAgIC8vIHNhZmVseSBlbWl0IG5vdy5cbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLiNwcm9jZXNzLmxpc3RlbmVycyhzaWcpO1xuICAgICAgICAgICAgICAgIGxldCB7IGNvdW50IH0gPSB0aGlzLiNlbWl0dGVyO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciB0aGUgZmFjdCB0aGF0IHNpZ25hbC1leGl0IHYzIGFuZCBzaWduYWxcbiAgICAgICAgICAgICAgICAvLyBleGl0IHY0IGFyZSBub3QgYXdhcmUgb2YgZWFjaCBvdGhlciwgYW5kIGVhY2ggd2lsbCBhdHRlbXB0IHRvIGxldFxuICAgICAgICAgICAgICAgIC8vIHRoZSBvdGhlciBoYW5kbGUgaXQsIHNvIG5laXRoZXIgb2YgdGhlbSBkby4gVG8gY29ycmVjdCB0aGlzLCB3ZVxuICAgICAgICAgICAgICAgIC8vIGRldGVjdCBpZiB3ZSdyZSB0aGUgb25seSBoYW5kbGVyICpleGNlcHQqIGZvciBwcmV2aW91cyB2ZXJzaW9uc1xuICAgICAgICAgICAgICAgIC8vIG9mIHNpZ25hbC1leGl0LCBhbmQgaW5jcmVtZW50IGJ5IHRoZSBjb3VudCBvZiBsaXN0ZW5lcnMgaXQgaGFzXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlZC5cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBwID0gcHJvY2VzcztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHAuX19zaWduYWxfZXhpdF9lbWl0dGVyX18gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwLl9fc2lnbmFsX2V4aXRfZW1pdHRlcl9fLmNvdW50ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCArPSBwLl9fc2lnbmFsX2V4aXRfZW1pdHRlcl9fLmNvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSBjb3VudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLiNlbWl0dGVyLmVtaXQoJ2V4aXQnLCBudWxsLCBzaWcpO1xuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IHNpZyA9PT0gJ1NJR0hVUCcgPyB0aGlzLiNodXBTaWcgOiBzaWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5raWxsKHByb2Nlc3MucGlkLCBzKTtcbiAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI29yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQgPSBwcm9jZXNzLnJlYWxseUV4aXQ7XG4gICAgICAgIHRoaXMuI29yaWdpbmFsUHJvY2Vzc0VtaXQgPSBwcm9jZXNzLmVtaXQ7XG4gICAgfVxuICAgIG9uRXhpdChjYiwgb3B0cykge1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKCFwcm9jZXNzT2sodGhpcy4jcHJvY2VzcykpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgaWYgKHRoaXMuI2xvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ID0gb3B0cz8uYWx3YXlzTGFzdCA/ICdhZnRlckV4aXQnIDogJ2V4aXQnO1xuICAgICAgICB0aGlzLiNlbWl0dGVyLm9uKGV2LCBjYik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2LCBjYik7XG4gICAgICAgICAgICBpZiAodGhpcy4jZW1pdHRlci5saXN0ZW5lcnNbJ2V4aXQnXS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICB0aGlzLiNlbWl0dGVyLmxpc3RlbmVyc1snYWZ0ZXJFeGl0J10ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgbG9hZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2xvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2xvYWRlZCA9IHRydWU7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG51bWJlciBvZiBvblNpZ25hbEV4aXQncyB0aGF0IGFyZSBpbiBwbGF5LlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCBzbyB0aGF0IHdlIGNhbiBjb3VudCB0aGUgY29ycmVjdCBudW1iZXIgb2ZcbiAgICAgICAgLy8gbGlzdGVuZXJzIG9uIHNpZ25hbHMsIGFuZCBkb24ndCB3YWl0IGZvciB0aGUgb3RoZXIgb25lIHRvXG4gICAgICAgIC8vIGhhbmRsZSBpdCBpbnN0ZWFkIG9mIHVzLlxuICAgICAgICB0aGlzLiNlbWl0dGVyLmNvdW50ICs9IDE7XG4gICAgICAgIGZvciAoY29uc3Qgc2lnIG9mIHNpZ25hbHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm4gPSB0aGlzLiNzaWdMaXN0ZW5lcnNbc2lnXTtcbiAgICAgICAgICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3Byb2Nlc3Mub24oc2lnLCBmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHJvY2Vzcy5lbWl0ID0gKGV2LCAuLi5hKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcHJvY2Vzc0VtaXQoZXYsIC4uLmEpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNwcm9jZXNzLnJlYWxseUV4aXQgPSAoY29kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3Byb2Nlc3NSZWFsbHlFeGl0KGNvZGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1bmxvYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy4jbG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHNpZ25hbHMuZm9yRWFjaChzaWcgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSB0aGlzLiNzaWdMaXN0ZW5lcnNbc2lnXTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGlzdGVuZXIgbm90IGRlZmluZWQgZm9yIHNpZ25hbDogJyArIHNpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKHNpZywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MuZW1pdCA9IHRoaXMuI29yaWdpbmFsUHJvY2Vzc0VtaXQ7XG4gICAgICAgIHRoaXMuI3Byb2Nlc3MucmVhbGx5RXhpdCA9IHRoaXMuI29yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQ7XG4gICAgICAgIHRoaXMuI2VtaXR0ZXIuY291bnQgLT0gMTtcbiAgICB9XG4gICAgI3Byb2Nlc3NSZWFsbHlFeGl0KGNvZGUpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghcHJvY2Vzc09rKHRoaXMuI3Byb2Nlc3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwcm9jZXNzLmV4aXRDb2RlID0gY29kZSB8fCAwO1xuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICB0aGlzLiNlbWl0dGVyLmVtaXQoJ2V4aXQnLCB0aGlzLiNwcm9jZXNzLmV4aXRDb2RlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuI29yaWdpbmFsUHJvY2Vzc1JlYWxseUV4aXQuY2FsbCh0aGlzLiNwcm9jZXNzLCB0aGlzLiNwcm9jZXNzLmV4aXRDb2RlKTtcbiAgICB9XG4gICAgI3Byb2Nlc3NFbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9nID0gdGhpcy4jb3JpZ2luYWxQcm9jZXNzRW1pdDtcbiAgICAgICAgaWYgKGV2ID09PSAnZXhpdCcgJiYgcHJvY2Vzc09rKHRoaXMuI3Byb2Nlc3MpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcHJvY2Vzcy5leGl0Q29kZSA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGNvbnN0IHJldCA9IG9nLmNhbGwodGhpcy4jcHJvY2VzcywgZXYsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICB0aGlzLiNlbWl0dGVyLmVtaXQoJ2V4aXQnLCB0aGlzLiNwcm9jZXNzLmV4aXRDb2RlLCBudWxsKTtcbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9nLmNhbGwodGhpcy4jcHJvY2VzcywgZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgcHJvY2VzcyA9IGdsb2JhbFRoaXMucHJvY2Vzcztcbi8vIHdyYXAgc28gdGhhdCB3ZSBjYWxsIHRoZSBtZXRob2Qgb24gdGhlIGFjdHVhbCBoYW5kbGVyLCB3aXRob3V0XG4vLyBleHBvcnRpbmcgaXQgZGlyZWN0bHkuXG5leHBvcnQgY29uc3QgeyBcbi8qKlxuICogQ2FsbGVkIHdoZW4gdGhlIHByb2Nlc3MgaXMgZXhpdGluZywgd2hldGhlciB2aWEgc2lnbmFsLCBleHBsaWNpdFxuICogZXhpdCwgb3IgcnVubmluZyBvdXQgb2Ygc3R1ZmYgdG8gZG8uXG4gKlxuICogSWYgdGhlIGdsb2JhbCBwcm9jZXNzIG9iamVjdCBpcyBub3Qgc3VpdGFibGUgZm9yIGluc3RydW1lbnRhdGlvbixcbiAqIHRoZW4gdGhpcyB3aWxsIGJlIGEgbm8tb3AuXG4gKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5sb2FkIHNpZ25hbC1leGl0LlxuICovXG5vbkV4aXQsIFxuLyoqXG4gKiBMb2FkIHRoZSBsaXN0ZW5lcnMuICBMaWtlbHkgeW91IG5ldmVyIG5lZWQgdG8gY2FsbCB0aGlzLCB1bmxlc3NcbiAqIGRvaW5nIGEgcmF0aGVyIGRlZXAgaW50ZWdyYXRpb24gd2l0aCBzaWduYWwtZXhpdCBmdW5jdGlvbmFsaXR5LlxuICogTW9zdGx5IGV4cG9zZWQgZm9yIHRoZSBiZW5lZml0IG9mIHRlc3RpbmcuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmxvYWQsIFxuLyoqXG4gKiBVbmxvYWQgdGhlIGxpc3RlbmVycy4gIExpa2VseSB5b3UgbmV2ZXIgbmVlZCB0byBjYWxsIHRoaXMsIHVubGVzc1xuICogZG9pbmcgYSByYXRoZXIgZGVlcCBpbnRlZ3JhdGlvbiB3aXRoIHNpZ25hbC1leGl0IGZ1bmN0aW9uYWxpdHkuXG4gKiBNb3N0bHkgZXhwb3NlZCBmb3IgdGhlIGJlbmVmaXQgb2YgdGVzdGluZy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudW5sb2FkLCB9ID0gc2lnbmFsRXhpdFdyYXAocHJvY2Vzc09rKHByb2Nlc3MpID8gbmV3IFNpZ25hbEV4aXQocHJvY2VzcykgOiBuZXcgU2lnbmFsRXhpdEZhbGxiYWNrKCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/signal-exit/dist/mjs/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/signal-exit/dist/mjs/signals.js":
/*!******************************************************!*\
  !*** ./node_modules/signal-exit/dist/mjs/signals.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   signals: () => (/* binding */ signals)\n/* harmony export */ });\n/**\n * This is not the set of all possible signals.\n *\n * It IS, however, the set of all signals that trigger\n * an exit on either Linux or BSD systems.  Linux is a\n * superset of the signal names supported on BSD, and\n * the unknown signals just fail to register, so we can\n * catch that easily enough.\n *\n * Windows signals are a different set, since there are\n * signals that terminate Windows processes, but don't\n * terminate (or don't even exist) on Posix systems.\n *\n * Don't bother with SIGKILL.  It's uncatchable, which\n * means that we can't fire any callbacks anyway.\n *\n * If a user does happen to register a handler on a non-\n * fatal signal like SIGWINCH or something, and then\n * exit, it'll end up firing `process.emit('exit')`, so\n * the handler will be fired anyway.\n *\n * SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n * artificially, inherently leave the process in a\n * state from which it is not safe to try and enter JS\n * listeners.\n */\nconst signals = [];\nsignals.push('SIGHUP', 'SIGINT', 'SIGTERM');\nif (process.platform !== 'win32') {\n    signals.push('SIGALRM', 'SIGABRT', 'SIGVTALRM', 'SIGXCPU', 'SIGXFSZ', 'SIGUSR2', 'SIGTRAP', 'SIGSYS', 'SIGQUIT', 'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n    );\n}\nif (process.platform === 'linux') {\n    signals.push('SIGIO', 'SIGPOLL', 'SIGPWR', 'SIGSTKFLT');\n}\n//# sourceMappingURL=signals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvZGlzdC9tanMvc2lnbmFscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL3NpZ25hbC1leGl0L2Rpc3QvbWpzL3NpZ25hbHMuanM/ZDA2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoaXMgaXMgbm90IHRoZSBzZXQgb2YgYWxsIHBvc3NpYmxlIHNpZ25hbHMuXG4gKlxuICogSXQgSVMsIGhvd2V2ZXIsIHRoZSBzZXQgb2YgYWxsIHNpZ25hbHMgdGhhdCB0cmlnZ2VyXG4gKiBhbiBleGl0IG9uIGVpdGhlciBMaW51eCBvciBCU0Qgc3lzdGVtcy4gIExpbnV4IGlzIGFcbiAqIHN1cGVyc2V0IG9mIHRoZSBzaWduYWwgbmFtZXMgc3VwcG9ydGVkIG9uIEJTRCwgYW5kXG4gKiB0aGUgdW5rbm93biBzaWduYWxzIGp1c3QgZmFpbCB0byByZWdpc3Rlciwgc28gd2UgY2FuXG4gKiBjYXRjaCB0aGF0IGVhc2lseSBlbm91Z2guXG4gKlxuICogV2luZG93cyBzaWduYWxzIGFyZSBhIGRpZmZlcmVudCBzZXQsIHNpbmNlIHRoZXJlIGFyZVxuICogc2lnbmFscyB0aGF0IHRlcm1pbmF0ZSBXaW5kb3dzIHByb2Nlc3NlcywgYnV0IGRvbid0XG4gKiB0ZXJtaW5hdGUgKG9yIGRvbid0IGV2ZW4gZXhpc3QpIG9uIFBvc2l4IHN5c3RlbXMuXG4gKlxuICogRG9uJ3QgYm90aGVyIHdpdGggU0lHS0lMTC4gIEl0J3MgdW5jYXRjaGFibGUsIHdoaWNoXG4gKiBtZWFucyB0aGF0IHdlIGNhbid0IGZpcmUgYW55IGNhbGxiYWNrcyBhbnl3YXkuXG4gKlxuICogSWYgYSB1c2VyIGRvZXMgaGFwcGVuIHRvIHJlZ2lzdGVyIGEgaGFuZGxlciBvbiBhIG5vbi1cbiAqIGZhdGFsIHNpZ25hbCBsaWtlIFNJR1dJTkNIIG9yIHNvbWV0aGluZywgYW5kIHRoZW5cbiAqIGV4aXQsIGl0J2xsIGVuZCB1cCBmaXJpbmcgYHByb2Nlc3MuZW1pdCgnZXhpdCcpYCwgc29cbiAqIHRoZSBoYW5kbGVyIHdpbGwgYmUgZmlyZWQgYW55d2F5LlxuICpcbiAqIFNJR0JVUywgU0lHRlBFLCBTSUdTRUdWIGFuZCBTSUdJTEwsIHdoZW4gbm90IHJhaXNlZFxuICogYXJ0aWZpY2lhbGx5LCBpbmhlcmVudGx5IGxlYXZlIHRoZSBwcm9jZXNzIGluIGFcbiAqIHN0YXRlIGZyb20gd2hpY2ggaXQgaXMgbm90IHNhZmUgdG8gdHJ5IGFuZCBlbnRlciBKU1xuICogbGlzdGVuZXJzLlxuICovXG5leHBvcnQgY29uc3Qgc2lnbmFscyA9IFtdO1xuc2lnbmFscy5wdXNoKCdTSUdIVVAnLCAnU0lHSU5UJywgJ1NJR1RFUk0nKTtcbmlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gICAgc2lnbmFscy5wdXNoKCdTSUdBTFJNJywgJ1NJR0FCUlQnLCAnU0lHVlRBTFJNJywgJ1NJR1hDUFUnLCAnU0lHWEZTWicsICdTSUdVU1IyJywgJ1NJR1RSQVAnLCAnU0lHU1lTJywgJ1NJR1FVSVQnLCAnU0lHSU9UJ1xuICAgIC8vIHNob3VsZCBkZXRlY3QgcHJvZmlsZXIgYW5kIGVuYWJsZS9kaXNhYmxlIGFjY29yZGluZ2x5LlxuICAgIC8vIHNlZSAjMjFcbiAgICAvLyAnU0lHUFJPRidcbiAgICApO1xufVxuaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpIHtcbiAgICBzaWduYWxzLnB1c2goJ1NJR0lPJywgJ1NJR1BPTEwnLCAnU0lHUFdSJywgJ1NJR1NUS0ZMVCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbmFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/signal-exit/dist/mjs/signals.js\n");

/***/ })

};
;