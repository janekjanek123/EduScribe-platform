/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fluent-ffmpeg";
exports.ids = ["vendor-chunks/fluent-ffmpeg"];
exports.modules = {

/***/ "(rsc)/./node_modules/fluent-ffmpeg/index.js":
/*!*********************************************!*\
  !*** ./node_modules/fluent-ffmpeg/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/fluent-ffmpeg */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwSEFBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9pbmRleC5qcz8yZWUzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvZmx1ZW50LWZmbXBlZycpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/capabilities.js":
/*!********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/capabilities.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/lib/async.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n/*\n *! Capability helpers\n */\n\nvar avCodecRegexp = /^\\s*([D ])([E ])([VAS])([S ])([D ])([T ]) ([^ ]+) +(.*)$/;\nvar ffCodecRegexp = /^\\s*([D\\.])([E\\.])([VAS])([I\\.])([L\\.])([S\\.]) ([^ ]+) +(.*)$/;\nvar ffEncodersRegexp = /\\(encoders:([^\\)]+)\\)/;\nvar ffDecodersRegexp = /\\(decoders:([^\\)]+)\\)/;\nvar encodersRegexp = /^\\s*([VAS\\.])([F\\.])([S\\.])([X\\.])([B\\.])([D\\.]) ([^ ]+) +(.*)$/;\nvar formatRegexp = /^\\s*([D ])([E ])\\s+([^ ]+)\\s+(.*)$/;\nvar lineBreakRegexp = /\\r\\n|\\r|\\n/;\nvar filterRegexp = /^(?: [T\\.][S\\.][C\\.] )?([^ ]+) +(AA?|VV?|\\|)->(AA?|VV?|\\|) +(.*)$/;\n\nvar cache = {};\n\nmodule.exports = function(proto) {\n  /**\n   * Manually define the ffmpeg binary full path.\n   *\n   * @method FfmpegCommand#setFfmpegPath\n   *\n   * @param {String} ffmpegPath The full path to the ffmpeg binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfmpegPath = function(ffmpegPath) {\n    cache.ffmpegPath = ffmpegPath;\n    return this;\n  };\n\n  /**\n   * Manually define the ffprobe binary full path.\n   *\n   * @method FfmpegCommand#setFfprobePath\n   *\n   * @param {String} ffprobePath The full path to the ffprobe binary.\n   * @return FfmpegCommand\n   */\n  proto.setFfprobePath = function(ffprobePath) {\n    cache.ffprobePath = ffprobePath;\n    return this;\n  };\n\n  /**\n   * Manually define the flvtool2/flvmeta binary full path.\n   *\n   * @method FfmpegCommand#setFlvtoolPath\n   *\n   * @param {String} flvtool The full path to the flvtool2 or flvmeta binary.\n   * @return FfmpegCommand\n   */\n  proto.setFlvtoolPath = function(flvtool) {\n    cache.flvtoolPath = flvtool;\n    return this;\n  };\n\n  /**\n   * Forget executable paths\n   *\n   * (only used for testing purposes)\n   *\n   * @method FfmpegCommand#_forgetPaths\n   * @private\n   */\n  proto._forgetPaths = function() {\n    delete cache.ffmpegPath;\n    delete cache.ffprobePath;\n    delete cache.flvtoolPath;\n  };\n\n  /**\n   * Check for ffmpeg availability\n   *\n   * If the FFMPEG_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffmpeg in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFfmpegPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfmpegPath = function(callback) {\n    if ('ffmpegPath' in cache) {\n      return callback(null, cache.ffmpegPath);\n    }\n\n    async.waterfall([\n      // Try FFMPEG_PATH\n      function(cb) {\n        if (process.env.FFMPEG_PATH) {\n          fs.exists(process.env.FFMPEG_PATH, function(exists) {\n            if (exists) {\n              cb(null, process.env.FFMPEG_PATH);\n            } else {\n              cb(null, '');\n            }\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffmpeg, cb) {\n        if (ffmpeg.length) {\n          return cb(null, ffmpeg);\n        }\n\n        utils.which('ffmpeg', function(err, ffmpeg) {\n          cb(err, ffmpeg);\n        });\n      }\n    ], function(err, ffmpeg) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffmpegPath = (ffmpeg || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for ffprobe availability\n   *\n   * If the FFPROBE_PATH environment variable is set, try to use it.\n   * If it is unset or incorrect, try to find ffprobe in the PATH instead.\n   * If this still fails, try to find ffprobe in the same directory as ffmpeg.\n   *\n   * @method FfmpegCommand#_getFfprobePath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  proto._getFfprobePath = function(callback) {\n    var self = this;\n\n    if ('ffprobePath' in cache) {\n      return callback(null, cache.ffprobePath);\n    }\n\n    async.waterfall([\n      // Try FFPROBE_PATH\n      function(cb) {\n        if (process.env.FFPROBE_PATH) {\n          fs.exists(process.env.FFPROBE_PATH, function(exists) {\n            cb(null, exists ? process.env.FFPROBE_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search in the PATH\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        utils.which('ffprobe', function(err, ffprobe) {\n          cb(err, ffprobe);\n        });\n      },\n\n      // Search in the same directory as ffmpeg\n      function(ffprobe, cb) {\n        if (ffprobe.length) {\n          return cb(null, ffprobe);\n        }\n\n        self._getFfmpegPath(function(err, ffmpeg) {\n          if (err) {\n            cb(err);\n          } else if (ffmpeg.length) {\n            var name = utils.isWindows ? 'ffprobe.exe' : 'ffprobe';\n            var ffprobe = path.join(path.dirname(ffmpeg), name);\n            fs.exists(ffprobe, function(exists) {\n              cb(null, exists ? ffprobe : '');\n            });\n          } else {\n            cb(null, '');\n          }\n        });\n      }\n    ], function(err, ffprobe) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.ffprobePath = (ffprobe || ''));\n      }\n    });\n  };\n\n\n  /**\n   * Check for flvtool2/flvmeta availability\n   *\n   * If the FLVTOOL2_PATH or FLVMETA_PATH environment variable are set, try to use them.\n   * If both are either unset or incorrect, try to find flvtool2 or flvmeta in the PATH instead.\n   *\n   * @method FfmpegCommand#_getFlvtoolPath\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n   proto._getFlvtoolPath = function(callback) {\n    if ('flvtoolPath' in cache) {\n      return callback(null, cache.flvtoolPath);\n    }\n\n    async.waterfall([\n      // Try FLVMETA_PATH\n      function(cb) {\n        if (process.env.FLVMETA_PATH) {\n          fs.exists(process.env.FLVMETA_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVMETA_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Try FLVTOOL2_PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        if (process.env.FLVTOOL2_PATH) {\n          fs.exists(process.env.FLVTOOL2_PATH, function(exists) {\n            cb(null, exists ? process.env.FLVTOOL2_PATH : '');\n          });\n        } else {\n          cb(null, '');\n        }\n      },\n\n      // Search for flvmeta in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvmeta', function(err, flvmeta) {\n          cb(err, flvmeta);\n        });\n      },\n\n      // Search for flvtool2 in the PATH\n      function(flvtool, cb) {\n        if (flvtool.length) {\n          return cb(null, flvtool);\n        }\n\n        utils.which('flvtool2', function(err, flvtool2) {\n          cb(err, flvtool2);\n        });\n      },\n    ], function(err, flvtool) {\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, cache.flvtoolPath = (flvtool || ''));\n      }\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFilters}.\n   *\n   * @callback FfmpegCommand~filterCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} filters filter object with filter names as keys and the following\n   *   properties for each filter:\n   * @param {String} filters.description filter description\n   * @param {String} filters.input input type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleInputs whether the filter supports multiple inputs\n   * @param {String} filters.output output type, one of 'audio', 'video' and 'none'\n   * @param {Boolean} filters.multipleOutputs whether the filter supports multiple outputs\n   */\n\n  /**\n   * Query ffmpeg for available filters\n   *\n   * @method FfmpegCommand#availableFilters\n   * @category Capabilities\n   * @aliases getAvailableFilters\n   *\n   * @param {FfmpegCommand~filterCallback} callback callback function\n   */\n  proto.availableFilters =\n  proto.getAvailableFilters = function(callback) {\n    if ('filters' in cache) {\n      return callback(null, cache.filters);\n    }\n\n    this._spawnFfmpeg(['-filters'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split('\\n');\n      var data = {};\n      var types = { A: 'audio', V: 'video', '|': 'none' };\n\n      lines.forEach(function(line) {\n        var match = line.match(filterRegexp);\n        if (match) {\n          data[match[1]] = {\n            description: match[4],\n            input: types[match[2].charAt(0)],\n            multipleInputs: match[2].length > 1,\n            output: types[match[3].charAt(0)],\n            multipleOutputs: match[3].length > 1\n          };\n        }\n      });\n\n      callback(null, cache.filters = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableCodecs}.\n   *\n   * @callback FfmpegCommand~codecCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} codecs codec object with codec names as keys and the following\n   *   properties for each codec (more properties may be available depending on the\n   *   ffmpeg version used):\n   * @param {String} codecs.description codec description\n   * @param {Boolean} codecs.canDecode whether the codec is able to decode streams\n   * @param {Boolean} codecs.canEncode whether the codec is able to encode streams\n   */\n\n  /**\n   * Query ffmpeg for available codecs\n   *\n   * @method FfmpegCommand#availableCodecs\n   * @category Capabilities\n   * @aliases getAvailableCodecs\n   *\n   * @param {FfmpegCommand~codecCallback} callback callback function\n   */\n  proto.availableCodecs =\n  proto.getAvailableCodecs = function(callback) {\n    if ('codecs' in cache) {\n      return callback(null, cache.codecs);\n    }\n\n    this._spawnFfmpeg(['-codecs'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(avCodecRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            drawHorizBand: match[4] === 'S',\n            directRendering: match[5] === 'D',\n            weirdFrameTruncation: match[6] === 'T'\n          };\n        }\n\n        match = line.match(ffCodecRegexp);\n        if (match && match[7] !== '=') {\n          var codecData = data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[3]],\n            description: match[8],\n            canDecode: match[1] === 'D',\n            canEncode: match[2] === 'E',\n            intraFrameOnly: match[4] === 'I',\n            isLossy: match[5] === 'L',\n            isLossless: match[6] === 'S'\n          };\n\n          var encoders = codecData.description.match(ffEncodersRegexp);\n          encoders = encoders ? encoders[1].trim().split(' ') : [];\n\n          var decoders = codecData.description.match(ffDecodersRegexp);\n          decoders = decoders ? decoders[1].trim().split(' ') : [];\n\n          if (encoders.length || decoders.length) {\n            var coderData = {};\n            utils.copy(codecData, coderData);\n            delete coderData.canEncode;\n            delete coderData.canDecode;\n\n            encoders.forEach(function(name) {\n              data[name] = {};\n              utils.copy(coderData, data[name]);\n              data[name].canEncode = true;\n            });\n\n            decoders.forEach(function(name) {\n              if (name in data) {\n                data[name].canDecode = true;\n              } else {\n                data[name] = {};\n                utils.copy(coderData, data[name]);\n                data[name].canDecode = true;\n              }\n            });\n          }\n        }\n      });\n\n      callback(null, cache.codecs = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableEncoders}.\n   *\n   * @callback FfmpegCommand~encodersCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} encoders encoders object with encoder names as keys and the following\n   *   properties for each encoder:\n   * @param {String} encoders.description codec description\n   * @param {Boolean} encoders.type \"audio\", \"video\" or \"subtitle\"\n   * @param {Boolean} encoders.frameMT whether the encoder is able to do frame-level multithreading\n   * @param {Boolean} encoders.sliceMT whether the encoder is able to do slice-level multithreading\n   * @param {Boolean} encoders.experimental whether the encoder is experimental\n   * @param {Boolean} encoders.drawHorizBand whether the encoder supports draw_horiz_band\n   * @param {Boolean} encoders.directRendering whether the encoder supports direct encoding method 1\n   */\n\n  /**\n   * Query ffmpeg for available encoders\n   *\n   * @method FfmpegCommand#availableEncoders\n   * @category Capabilities\n   * @aliases getAvailableEncoders\n   *\n   * @param {FfmpegCommand~encodersCallback} callback callback function\n   */\n  proto.availableEncoders =\n  proto.getAvailableEncoders = function(callback) {\n    if ('encoders' in cache) {\n      return callback(null, cache.encoders);\n    }\n\n    this._spawnFfmpeg(['-encoders'], { captureStdout: true, stdoutLines: 0 }, function(err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(encodersRegexp);\n        if (match && match[7] !== '=') {\n          data[match[7]] = {\n            type: { 'V': 'video', 'A': 'audio', 'S': 'subtitle' }[match[1]],\n            description: match[8],\n            frameMT: match[2] === 'F',\n            sliceMT: match[3] === 'S',\n            experimental: match[4] === 'X',\n            drawHorizBand: match[5] === 'B',\n            directRendering: match[6] === 'D'\n          };\n        }\n      });\n\n      callback(null, cache.encoders = data);\n    });\n  };\n\n\n  /**\n   * A callback passed to {@link FfmpegCommand#availableFormats}.\n   *\n   * @callback FfmpegCommand~formatCallback\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} formats format object with format names as keys and the following\n   *   properties for each format:\n   * @param {String} formats.description format description\n   * @param {Boolean} formats.canDemux whether the format is able to demux streams from an input file\n   * @param {Boolean} formats.canMux whether the format is able to mux streams into an output file\n   */\n\n  /**\n   * Query ffmpeg for available formats\n   *\n   * @method FfmpegCommand#availableFormats\n   * @category Capabilities\n   * @aliases getAvailableFormats\n   *\n   * @param {FfmpegCommand~formatCallback} callback callback function\n   */\n  proto.availableFormats =\n  proto.getAvailableFormats = function(callback) {\n    if ('formats' in cache) {\n      return callback(null, cache.formats);\n    }\n\n    // Run ffmpeg -formats\n    this._spawnFfmpeg(['-formats'], { captureStdout: true, stdoutLines: 0 }, function (err, stdoutRing) {\n      if (err) {\n        return callback(err);\n      }\n\n      // Parse output\n      var stdout = stdoutRing.get();\n      var lines = stdout.split(lineBreakRegexp);\n      var data = {};\n\n      lines.forEach(function(line) {\n        var match = line.match(formatRegexp);\n        if (match) {\n          match[3].split(',').forEach(function(format) {\n            if (!(format in data)) {\n              data[format] = {\n                description: match[4],\n                canDemux: false,\n                canMux: false\n              };\n            }\n\n            if (match[1] === 'D') {\n              data[format].canDemux = true;\n            }\n            if (match[2] === 'E') {\n              data[format].canMux = true;\n            }\n          });\n        }\n      });\n\n      callback(null, cache.formats = data);\n    });\n  };\n\n\n  /**\n   * Check capabilities before executing a command\n   *\n   * Checks whether all used codecs and formats are indeed available\n   *\n   * @method FfmpegCommand#_checkCapabilities\n   * @param {Function} callback callback with signature (err)\n   * @private\n   */\n  proto._checkCapabilities = function(callback) {\n    var self = this;\n    async.waterfall([\n      // Get available formats\n      function(cb) {\n        self.availableFormats(cb);\n      },\n\n      // Check whether specified formats are available\n      function(formats, cb) {\n        var unavailable;\n\n        // Output format(s)\n        unavailable = self._outputs\n          .reduce(function(fmts, output) {\n            var format = output.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canMux)) {\n                fmts.push(format);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Output format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Output formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Input format(s)\n        unavailable = self._inputs\n          .reduce(function(fmts, input) {\n            var format = input.options.find('-f', 1);\n            if (format) {\n              if (!(format[0] in formats) || !(formats[format[0]].canDemux)) {\n                fmts.push(format[0]);\n              }\n            }\n\n            return fmts;\n          }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Input format ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Input formats ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      },\n\n      // Get available codecs\n      function(cb) {\n        self.availableEncoders(cb);\n      },\n\n      // Check whether specified codecs are available and add strict experimental options if needed\n      function(encoders, cb) {\n        var unavailable;\n\n        // Audio codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var acodec = output.audio.find('-acodec', 1);\n          if (acodec && acodec[0] !== 'copy') {\n            if (!(acodec[0] in encoders) || encoders[acodec[0]].type !== 'audio') {\n              cdcs.push(acodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Audio codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Audio codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        // Video codec(s)\n        unavailable = self._outputs.reduce(function(cdcs, output) {\n          var vcodec = output.video.find('-vcodec', 1);\n          if (vcodec && vcodec[0] !== 'copy') {\n            if (!(vcodec[0] in encoders) || encoders[vcodec[0]].type !== 'video') {\n              cdcs.push(vcodec[0]);\n            }\n          }\n\n          return cdcs;\n        }, []);\n\n        if (unavailable.length === 1) {\n          return cb(new Error('Video codec ' + unavailable[0] + ' is not available'));\n        } else if (unavailable.length > 1) {\n          return cb(new Error('Video codecs ' + unavailable.join(', ') + ' are not available'));\n        }\n\n        cb();\n      }\n    ], callback);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvY2FwYWJpbGl0aWVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxxQ0FBcUM7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLHFDQUFxQztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZDQUE2QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQSwyQkFBMkIsc0NBQXNDO0FBQ2pFO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QyxxQ0FBcUM7QUFDNUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBNkM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0EsMkJBQTJCLHFDQUFxQztBQUNoRTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEIsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLHFDQUFxQztBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvY2FwYWJpbGl0aWVzLmpzPzA1YTkiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGFzeW5jID0gcmVxdWlyZSgnYXN5bmMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLypcbiAqISBDYXBhYmlsaXR5IGhlbHBlcnNcbiAqL1xuXG52YXIgYXZDb2RlY1JlZ2V4cCA9IC9eXFxzKihbRCBdKShbRSBdKShbVkFTXSkoW1MgXSkoW0QgXSkoW1QgXSkgKFteIF0rKSArKC4qKSQvO1xudmFyIGZmQ29kZWNSZWdleHAgPSAvXlxccyooW0RcXC5dKShbRVxcLl0pKFtWQVNdKShbSVxcLl0pKFtMXFwuXSkoW1NcXC5dKSAoW14gXSspICsoLiopJC87XG52YXIgZmZFbmNvZGVyc1JlZ2V4cCA9IC9cXChlbmNvZGVyczooW15cXCldKylcXCkvO1xudmFyIGZmRGVjb2RlcnNSZWdleHAgPSAvXFwoZGVjb2RlcnM6KFteXFwpXSspXFwpLztcbnZhciBlbmNvZGVyc1JlZ2V4cCA9IC9eXFxzKihbVkFTXFwuXSkoW0ZcXC5dKShbU1xcLl0pKFtYXFwuXSkoW0JcXC5dKShbRFxcLl0pIChbXiBdKykgKyguKikkLztcbnZhciBmb3JtYXRSZWdleHAgPSAvXlxccyooW0QgXSkoW0UgXSlcXHMrKFteIF0rKVxccysoLiopJC87XG52YXIgbGluZUJyZWFrUmVnZXhwID0gL1xcclxcbnxcXHJ8XFxuLztcbnZhciBmaWx0ZXJSZWdleHAgPSAvXig/OiBbVFxcLl1bU1xcLl1bQ1xcLl0gKT8oW14gXSspICsoQUE/fFZWP3xcXHwpLT4oQUE/fFZWP3xcXHwpICsoLiopJC87XG5cbnZhciBjYWNoZSA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8qKlxuICAgKiBNYW51YWxseSBkZWZpbmUgdGhlIGZmbXBlZyBiaW5hcnkgZnVsbCBwYXRoLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjc2V0RmZtcGVnUGF0aFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmZtcGVnUGF0aCBUaGUgZnVsbCBwYXRoIHRvIHRoZSBmZm1wZWcgYmluYXJ5LlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnNldEZmbXBlZ1BhdGggPSBmdW5jdGlvbihmZm1wZWdQYXRoKSB7XG4gICAgY2FjaGUuZmZtcGVnUGF0aCA9IGZmbXBlZ1BhdGg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIE1hbnVhbGx5IGRlZmluZSB0aGUgZmZwcm9iZSBiaW5hcnkgZnVsbCBwYXRoLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjc2V0RmZwcm9iZVBhdGhcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZmcHJvYmVQYXRoIFRoZSBmdWxsIHBhdGggdG8gdGhlIGZmcHJvYmUgYmluYXJ5LlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnNldEZmcHJvYmVQYXRoID0gZnVuY3Rpb24oZmZwcm9iZVBhdGgpIHtcbiAgICBjYWNoZS5mZnByb2JlUGF0aCA9IGZmcHJvYmVQYXRoO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBNYW51YWxseSBkZWZpbmUgdGhlIGZsdnRvb2wyL2Zsdm1ldGEgYmluYXJ5IGZ1bGwgcGF0aC5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NldEZsdnRvb2xQYXRoXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmbHZ0b29sIFRoZSBmdWxsIHBhdGggdG8gdGhlIGZsdnRvb2wyIG9yIGZsdm1ldGEgYmluYXJ5LlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnNldEZsdnRvb2xQYXRoID0gZnVuY3Rpb24oZmx2dG9vbCkge1xuICAgIGNhY2hlLmZsdnRvb2xQYXRoID0gZmx2dG9vbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogRm9yZ2V0IGV4ZWN1dGFibGUgcGF0aHNcbiAgICpcbiAgICogKG9ubHkgdXNlZCBmb3IgdGVzdGluZyBwdXJwb3NlcylcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19mb3JnZXRQYXRoc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX2ZvcmdldFBhdGhzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIGNhY2hlLmZmbXBlZ1BhdGg7XG4gICAgZGVsZXRlIGNhY2hlLmZmcHJvYmVQYXRoO1xuICAgIGRlbGV0ZSBjYWNoZS5mbHZ0b29sUGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2sgZm9yIGZmbXBlZyBhdmFpbGFiaWxpdHlcbiAgICpcbiAgICogSWYgdGhlIEZGTVBFR19QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIGlzIHNldCwgdHJ5IHRvIHVzZSBpdC5cbiAgICogSWYgaXQgaXMgdW5zZXQgb3IgaW5jb3JyZWN0LCB0cnkgdG8gZmluZCBmZm1wZWcgaW4gdGhlIFBBVEggaW5zdGVhZC5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19nZXRGZm1wZWdQYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHdpdGggc2lnbmF0dXJlIChlcnIsIHBhdGgpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90by5fZ2V0RmZtcGVnUGF0aCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCdmZm1wZWdQYXRoJyBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZmbXBlZ1BhdGgpO1xuICAgIH1cblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICAvLyBUcnkgRkZNUEVHX1BBVEhcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5GRk1QRUdfUEFUSCkge1xuICAgICAgICAgIGZzLmV4aXN0cyhwcm9jZXNzLmVudi5GRk1QRUdfUEFUSCwgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3RzKSB7XG4gICAgICAgICAgICAgIGNiKG51bGwsIHByb2Nlc3MuZW52LkZGTVBFR19QQVRIKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNiKG51bGwsICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIFNlYXJjaCBpbiB0aGUgUEFUSFxuICAgICAgZnVuY3Rpb24oZmZtcGVnLCBjYikge1xuICAgICAgICBpZiAoZmZtcGVnLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmZm1wZWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbHMud2hpY2goJ2ZmbXBlZycsIGZ1bmN0aW9uKGVyciwgZmZtcGVnKSB7XG4gICAgICAgICAgY2IoZXJyLCBmZm1wZWcpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBdLCBmdW5jdGlvbihlcnIsIGZmbXBlZykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2FjaGUuZmZtcGVnUGF0aCA9IChmZm1wZWcgfHwgJycpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgZmZwcm9iZSBhdmFpbGFiaWxpdHlcbiAgICpcbiAgICogSWYgdGhlIEZGUFJPQkVfUEFUSCBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBzZXQsIHRyeSB0byB1c2UgaXQuXG4gICAqIElmIGl0IGlzIHVuc2V0IG9yIGluY29ycmVjdCwgdHJ5IHRvIGZpbmQgZmZwcm9iZSBpbiB0aGUgUEFUSCBpbnN0ZWFkLlxuICAgKiBJZiB0aGlzIHN0aWxsIGZhaWxzLCB0cnkgdG8gZmluZCBmZnByb2JlIGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyBmZm1wZWcuXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNfZ2V0RmZwcm9iZVBhdGhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgd2l0aCBzaWduYXR1cmUgKGVyciwgcGF0aClcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByb3RvLl9nZXRGZnByb2JlUGF0aCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCdmZnByb2JlUGF0aCcgaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZS5mZnByb2JlUGF0aCk7XG4gICAgfVxuXG4gICAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgIC8vIFRyeSBGRlBST0JFX1BBVEhcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5GRlBST0JFX1BBVEgpIHtcbiAgICAgICAgICBmcy5leGlzdHMocHJvY2Vzcy5lbnYuRkZQUk9CRV9QQVRILCBmdW5jdGlvbihleGlzdHMpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGV4aXN0cyA/IHByb2Nlc3MuZW52LkZGUFJPQkVfUEFUSCA6ICcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIFNlYXJjaCBpbiB0aGUgUEFUSFxuICAgICAgZnVuY3Rpb24oZmZwcm9iZSwgY2IpIHtcbiAgICAgICAgaWYgKGZmcHJvYmUubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZmcHJvYmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbHMud2hpY2goJ2ZmcHJvYmUnLCBmdW5jdGlvbihlcnIsIGZmcHJvYmUpIHtcbiAgICAgICAgICBjYihlcnIsIGZmcHJvYmUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFNlYXJjaCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgZmZtcGVnXG4gICAgICBmdW5jdGlvbihmZnByb2JlLCBjYikge1xuICAgICAgICBpZiAoZmZwcm9iZS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gY2IobnVsbCwgZmZwcm9iZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl9nZXRGZm1wZWdQYXRoKGZ1bmN0aW9uKGVyciwgZmZtcGVnKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZmbXBlZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gdXRpbHMuaXNXaW5kb3dzID8gJ2ZmcHJvYmUuZXhlJyA6ICdmZnByb2JlJztcbiAgICAgICAgICAgIHZhciBmZnByb2JlID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShmZm1wZWcpLCBuYW1lKTtcbiAgICAgICAgICAgIGZzLmV4aXN0cyhmZnByb2JlLCBmdW5jdGlvbihleGlzdHMpIHtcbiAgICAgICAgICAgICAgY2IobnVsbCwgZXhpc3RzID8gZmZwcm9iZSA6ICcnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBdLCBmdW5jdGlvbihlcnIsIGZmcHJvYmUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZmcHJvYmVQYXRoID0gKGZmcHJvYmUgfHwgJycpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDaGVjayBmb3IgZmx2dG9vbDIvZmx2bWV0YSBhdmFpbGFiaWxpdHlcbiAgICpcbiAgICogSWYgdGhlIEZMVlRPT0wyX1BBVEggb3IgRkxWTUVUQV9QQVRIIGVudmlyb25tZW50IHZhcmlhYmxlIGFyZSBzZXQsIHRyeSB0byB1c2UgdGhlbS5cbiAgICogSWYgYm90aCBhcmUgZWl0aGVyIHVuc2V0IG9yIGluY29ycmVjdCwgdHJ5IHRvIGZpbmQgZmx2dG9vbDIgb3IgZmx2bWV0YSBpbiB0aGUgUEFUSCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjX2dldEZsdnRvb2xQYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHdpdGggc2lnbmF0dXJlIChlcnIsIHBhdGgpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAgcHJvdG8uX2dldEZsdnRvb2xQYXRoID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoJ2ZsdnRvb2xQYXRoJyBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlLmZsdnRvb2xQYXRoKTtcbiAgICB9XG5cbiAgICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgLy8gVHJ5IEZMVk1FVEFfUEFUSFxuICAgICAgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52LkZMVk1FVEFfUEFUSCkge1xuICAgICAgICAgIGZzLmV4aXN0cyhwcm9jZXNzLmVudi5GTFZNRVRBX1BBVEgsIGZ1bmN0aW9uKGV4aXN0cykge1xuICAgICAgICAgICAgY2IobnVsbCwgZXhpc3RzID8gcHJvY2Vzcy5lbnYuRkxWTUVUQV9QQVRIIDogJycpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG51bGwsICcnKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLy8gVHJ5IEZMVlRPT0wyX1BBVEhcbiAgICAgIGZ1bmN0aW9uKGZsdnRvb2wsIGNiKSB7XG4gICAgICAgIGlmIChmbHZ0b29sLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmbHZ0b29sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5GTFZUT09MMl9QQVRIKSB7XG4gICAgICAgICAgZnMuZXhpc3RzKHByb2Nlc3MuZW52LkZMVlRPT0wyX1BBVEgsIGZ1bmN0aW9uKGV4aXN0cykge1xuICAgICAgICAgICAgY2IobnVsbCwgZXhpc3RzID8gcHJvY2Vzcy5lbnYuRkxWVE9PTDJfUEFUSCA6ICcnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihudWxsLCAnJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIFNlYXJjaCBmb3IgZmx2bWV0YSBpbiB0aGUgUEFUSFxuICAgICAgZnVuY3Rpb24oZmx2dG9vbCwgY2IpIHtcbiAgICAgICAgaWYgKGZsdnRvb2wubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG51bGwsIGZsdnRvb2wpO1xuICAgICAgICB9XG5cbiAgICAgICAgdXRpbHMud2hpY2goJ2Zsdm1ldGEnLCBmdW5jdGlvbihlcnIsIGZsdm1ldGEpIHtcbiAgICAgICAgICBjYihlcnIsIGZsdm1ldGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFNlYXJjaCBmb3IgZmx2dG9vbDIgaW4gdGhlIFBBVEhcbiAgICAgIGZ1bmN0aW9uKGZsdnRvb2wsIGNiKSB7XG4gICAgICAgIGlmIChmbHZ0b29sLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmbHZ0b29sKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLndoaWNoKCdmbHZ0b29sMicsIGZ1bmN0aW9uKGVyciwgZmx2dG9vbDIpIHtcbiAgICAgICAgICBjYihlcnIsIGZsdnRvb2wyKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgIF0sIGZ1bmN0aW9uKGVyciwgZmx2dG9vbCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2FjaGUuZmx2dG9vbFBhdGggPSAoZmx2dG9vbCB8fCAnJykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUZpbHRlcnN9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgRmZtcGVnQ29tbWFuZH5maWx0ZXJDYWxsYmFja1xuICAgKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVyciBlcnJvciBvYmplY3Qgb3IgbnVsbCBpZiBubyBlcnJvciBoYXBwZW5lZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZmlsdGVycyBmaWx0ZXIgb2JqZWN0IHdpdGggZmlsdGVyIG5hbWVzIGFzIGtleXMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICogICBwcm9wZXJ0aWVzIGZvciBlYWNoIGZpbHRlcjpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlcnMuZGVzY3JpcHRpb24gZmlsdGVyIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWx0ZXJzLmlucHV0IGlucHV0IHR5cGUsIG9uZSBvZiAnYXVkaW8nLCAndmlkZW8nIGFuZCAnbm9uZSdcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaWx0ZXJzLm11bHRpcGxlSW5wdXRzIHdoZXRoZXIgdGhlIGZpbHRlciBzdXBwb3J0cyBtdWx0aXBsZSBpbnB1dHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlcnMub3V0cHV0IG91dHB1dCB0eXBlLCBvbmUgb2YgJ2F1ZGlvJywgJ3ZpZGVvJyBhbmQgJ25vbmUnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlsdGVycy5tdWx0aXBsZU91dHB1dHMgd2hldGhlciB0aGUgZmlsdGVyIHN1cHBvcnRzIG11bHRpcGxlIG91dHB1dHNcbiAgICovXG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGZmbXBlZyBmb3IgYXZhaWxhYmxlIGZpbHRlcnNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUZpbHRlcnNcbiAgICogQGNhdGVnb3J5IENhcGFiaWxpdGllc1xuICAgKiBAYWxpYXNlcyBnZXRBdmFpbGFibGVGaWx0ZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH5maWx0ZXJDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIHByb3RvLmF2YWlsYWJsZUZpbHRlcnMgPVxuICBwcm90by5nZXRBdmFpbGFibGVGaWx0ZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoJ2ZpbHRlcnMnIGluIGNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGUuZmlsdGVycyk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3Bhd25GZm1wZWcoWyctZmlsdGVycyddLCB7IGNhcHR1cmVTdGRvdXQ6IHRydWUsIHN0ZG91dExpbmVzOiAwIH0sIGZ1bmN0aW9uIChlcnIsIHN0ZG91dFJpbmcpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGRvdXQgPSBzdGRvdXRSaW5nLmdldCgpO1xuICAgICAgdmFyIGxpbmVzID0gc3Rkb3V0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBkYXRhID0ge307XG4gICAgICB2YXIgdHlwZXMgPSB7IEE6ICdhdWRpbycsIFY6ICd2aWRlbycsICd8JzogJ25vbmUnIH07XG5cbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKGZpbHRlclJlZ2V4cCk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIGRhdGFbbWF0Y2hbMV1dID0ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IG1hdGNoWzRdLFxuICAgICAgICAgICAgaW5wdXQ6IHR5cGVzW21hdGNoWzJdLmNoYXJBdCgwKV0sXG4gICAgICAgICAgICBtdWx0aXBsZUlucHV0czogbWF0Y2hbMl0ubGVuZ3RoID4gMSxcbiAgICAgICAgICAgIG91dHB1dDogdHlwZXNbbWF0Y2hbM10uY2hhckF0KDApXSxcbiAgICAgICAgICAgIG11bHRpcGxlT3V0cHV0czogbWF0Y2hbM10ubGVuZ3RoID4gMVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjYWxsYmFjayhudWxsLCBjYWNoZS5maWx0ZXJzID0gZGF0YSk7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQSBjYWxsYmFjayBwYXNzZWQgdG8ge0BsaW5rIEZmbXBlZ0NvbW1hbmQjYXZhaWxhYmxlQ29kZWNzfS5cbiAgICpcbiAgICogQGNhbGxiYWNrIEZmbXBlZ0NvbW1hbmR+Y29kZWNDYWxsYmFja1xuICAgKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVyciBlcnJvciBvYmplY3Qgb3IgbnVsbCBpZiBubyBlcnJvciBoYXBwZW5lZFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29kZWNzIGNvZGVjIG9iamVjdCB3aXRoIGNvZGVjIG5hbWVzIGFzIGtleXMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICogICBwcm9wZXJ0aWVzIGZvciBlYWNoIGNvZGVjIChtb3JlIHByb3BlcnRpZXMgbWF5IGJlIGF2YWlsYWJsZSBkZXBlbmRpbmcgb24gdGhlXG4gICAqICAgZmZtcGVnIHZlcnNpb24gdXNlZCk6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlY3MuZGVzY3JpcHRpb24gY29kZWMgZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtCb29sZWFufSBjb2RlY3MuY2FuRGVjb2RlIHdoZXRoZXIgdGhlIGNvZGVjIGlzIGFibGUgdG8gZGVjb2RlIHN0cmVhbXNcbiAgICogQHBhcmFtIHtCb29sZWFufSBjb2RlY3MuY2FuRW5jb2RlIHdoZXRoZXIgdGhlIGNvZGVjIGlzIGFibGUgdG8gZW5jb2RlIHN0cmVhbXNcbiAgICovXG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGZmbXBlZyBmb3IgYXZhaWxhYmxlIGNvZGVjc1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXZhaWxhYmxlQ29kZWNzXG4gICAqIEBjYXRlZ29yeSBDYXBhYmlsaXRpZXNcbiAgICogQGFsaWFzZXMgZ2V0QXZhaWxhYmxlQ29kZWNzXG4gICAqXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH5jb2RlY0NhbGxiYWNrfSBjYWxsYmFjayBjYWxsYmFjayBmdW5jdGlvblxuICAgKi9cbiAgcHJvdG8uYXZhaWxhYmxlQ29kZWNzID1cbiAgcHJvdG8uZ2V0QXZhaWxhYmxlQ29kZWNzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoJ2NvZGVjcycgaW4gY2FjaGUpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjYWNoZS5jb2RlY3MpO1xuICAgIH1cblxuICAgIHRoaXMuX3NwYXduRmZtcGVnKFsnLWNvZGVjcyddLCB7IGNhcHR1cmVTdGRvdXQ6IHRydWUsIHN0ZG91dExpbmVzOiAwIH0sIGZ1bmN0aW9uKGVyciwgc3Rkb3V0UmluZykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZG91dCA9IHN0ZG91dFJpbmcuZ2V0KCk7XG4gICAgICB2YXIgbGluZXMgPSBzdGRvdXQuc3BsaXQobGluZUJyZWFrUmVnZXhwKTtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKGF2Q29kZWNSZWdleHApO1xuICAgICAgICBpZiAobWF0Y2ggJiYgbWF0Y2hbN10gIT09ICc9Jykge1xuICAgICAgICAgIGRhdGFbbWF0Y2hbN11dID0ge1xuICAgICAgICAgICAgdHlwZTogeyAnVic6ICd2aWRlbycsICdBJzogJ2F1ZGlvJywgJ1MnOiAnc3VidGl0bGUnIH1bbWF0Y2hbM11dLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IG1hdGNoWzhdLFxuICAgICAgICAgICAgY2FuRGVjb2RlOiBtYXRjaFsxXSA9PT0gJ0QnLFxuICAgICAgICAgICAgY2FuRW5jb2RlOiBtYXRjaFsyXSA9PT0gJ0UnLFxuICAgICAgICAgICAgZHJhd0hvcml6QmFuZDogbWF0Y2hbNF0gPT09ICdTJyxcbiAgICAgICAgICAgIGRpcmVjdFJlbmRlcmluZzogbWF0Y2hbNV0gPT09ICdEJyxcbiAgICAgICAgICAgIHdlaXJkRnJhbWVUcnVuY2F0aW9uOiBtYXRjaFs2XSA9PT0gJ1QnXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoID0gbGluZS5tYXRjaChmZkNvZGVjUmVnZXhwKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzddICE9PSAnPScpIHtcbiAgICAgICAgICB2YXIgY29kZWNEYXRhID0gZGF0YVttYXRjaFs3XV0gPSB7XG4gICAgICAgICAgICB0eXBlOiB7ICdWJzogJ3ZpZGVvJywgJ0EnOiAnYXVkaW8nLCAnUyc6ICdzdWJ0aXRsZScgfVttYXRjaFszXV0sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbWF0Y2hbOF0sXG4gICAgICAgICAgICBjYW5EZWNvZGU6IG1hdGNoWzFdID09PSAnRCcsXG4gICAgICAgICAgICBjYW5FbmNvZGU6IG1hdGNoWzJdID09PSAnRScsXG4gICAgICAgICAgICBpbnRyYUZyYW1lT25seTogbWF0Y2hbNF0gPT09ICdJJyxcbiAgICAgICAgICAgIGlzTG9zc3k6IG1hdGNoWzVdID09PSAnTCcsXG4gICAgICAgICAgICBpc0xvc3NsZXNzOiBtYXRjaFs2XSA9PT0gJ1MnXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBlbmNvZGVycyA9IGNvZGVjRGF0YS5kZXNjcmlwdGlvbi5tYXRjaChmZkVuY29kZXJzUmVnZXhwKTtcbiAgICAgICAgICBlbmNvZGVycyA9IGVuY29kZXJzID8gZW5jb2RlcnNbMV0udHJpbSgpLnNwbGl0KCcgJykgOiBbXTtcblxuICAgICAgICAgIHZhciBkZWNvZGVycyA9IGNvZGVjRGF0YS5kZXNjcmlwdGlvbi5tYXRjaChmZkRlY29kZXJzUmVnZXhwKTtcbiAgICAgICAgICBkZWNvZGVycyA9IGRlY29kZXJzID8gZGVjb2RlcnNbMV0udHJpbSgpLnNwbGl0KCcgJykgOiBbXTtcblxuICAgICAgICAgIGlmIChlbmNvZGVycy5sZW5ndGggfHwgZGVjb2RlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY29kZXJEYXRhID0ge307XG4gICAgICAgICAgICB1dGlscy5jb3B5KGNvZGVjRGF0YSwgY29kZXJEYXRhKTtcbiAgICAgICAgICAgIGRlbGV0ZSBjb2RlckRhdGEuY2FuRW5jb2RlO1xuICAgICAgICAgICAgZGVsZXRlIGNvZGVyRGF0YS5jYW5EZWNvZGU7XG5cbiAgICAgICAgICAgIGVuY29kZXJzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBkYXRhW25hbWVdID0ge307XG4gICAgICAgICAgICAgIHV0aWxzLmNvcHkoY29kZXJEYXRhLCBkYXRhW25hbWVdKTtcbiAgICAgICAgICAgICAgZGF0YVtuYW1lXS5jYW5FbmNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRlY29kZXJzLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBpZiAobmFtZSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtuYW1lXS5jYW5EZWNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFbbmFtZV0gPSB7fTtcbiAgICAgICAgICAgICAgICB1dGlscy5jb3B5KGNvZGVyRGF0YSwgZGF0YVtuYW1lXSk7XG4gICAgICAgICAgICAgICAgZGF0YVtuYW1lXS5jYW5EZWNvZGUgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjYWxsYmFjayhudWxsLCBjYWNoZS5jb2RlY3MgPSBkYXRhKTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHBhc3NlZCB0byB7QGxpbmsgRmZtcGVnQ29tbWFuZCNhdmFpbGFibGVFbmNvZGVyc30uXG4gICAqXG4gICAqIEBjYWxsYmFjayBGZm1wZWdDb21tYW5kfmVuY29kZXJzQ2FsbGJhY2tcbiAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnIgZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgbm8gZXJyb3IgaGFwcGVuZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGVuY29kZXJzIGVuY29kZXJzIG9iamVjdCB3aXRoIGVuY29kZXIgbmFtZXMgYXMga2V5cyBhbmQgdGhlIGZvbGxvd2luZ1xuICAgKiAgIHByb3BlcnRpZXMgZm9yIGVhY2ggZW5jb2RlcjpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kZXJzLmRlc2NyaXB0aW9uIGNvZGVjIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5jb2RlcnMudHlwZSBcImF1ZGlvXCIsIFwidmlkZW9cIiBvciBcInN1YnRpdGxlXCJcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmNvZGVycy5mcmFtZU1UIHdoZXRoZXIgdGhlIGVuY29kZXIgaXMgYWJsZSB0byBkbyBmcmFtZS1sZXZlbCBtdWx0aXRocmVhZGluZ1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZXJzLnNsaWNlTVQgd2hldGhlciB0aGUgZW5jb2RlciBpcyBhYmxlIHRvIGRvIHNsaWNlLWxldmVsIG11bHRpdGhyZWFkaW5nXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5jb2RlcnMuZXhwZXJpbWVudGFsIHdoZXRoZXIgdGhlIGVuY29kZXIgaXMgZXhwZXJpbWVudGFsXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5jb2RlcnMuZHJhd0hvcml6QmFuZCB3aGV0aGVyIHRoZSBlbmNvZGVyIHN1cHBvcnRzIGRyYXdfaG9yaXpfYmFuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuY29kZXJzLmRpcmVjdFJlbmRlcmluZyB3aGV0aGVyIHRoZSBlbmNvZGVyIHN1cHBvcnRzIGRpcmVjdCBlbmNvZGluZyBtZXRob2QgMVxuICAgKi9cblxuICAvKipcbiAgICogUXVlcnkgZmZtcGVnIGZvciBhdmFpbGFibGUgZW5jb2RlcnNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUVuY29kZXJzXG4gICAqIEBjYXRlZ29yeSBDYXBhYmlsaXRpZXNcbiAgICogQGFsaWFzZXMgZ2V0QXZhaWxhYmxlRW5jb2RlcnNcbiAgICpcbiAgICogQHBhcmFtIHtGZm1wZWdDb21tYW5kfmVuY29kZXJzQ2FsbGJhY2t9IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqL1xuICBwcm90by5hdmFpbGFibGVFbmNvZGVycyA9XG4gIHByb3RvLmdldEF2YWlsYWJsZUVuY29kZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoJ2VuY29kZXJzJyBpbiBjYWNoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGNhY2hlLmVuY29kZXJzKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zcGF3bkZmbXBlZyhbJy1lbmNvZGVycyddLCB7IGNhcHR1cmVTdGRvdXQ6IHRydWUsIHN0ZG91dExpbmVzOiAwIH0sIGZ1bmN0aW9uKGVyciwgc3Rkb3V0UmluZykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZG91dCA9IHN0ZG91dFJpbmcuZ2V0KCk7XG4gICAgICB2YXIgbGluZXMgPSBzdGRvdXQuc3BsaXQobGluZUJyZWFrUmVnZXhwKTtcbiAgICAgIHZhciBkYXRhID0ge307XG5cbiAgICAgIGxpbmVzLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKGVuY29kZXJzUmVnZXhwKTtcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoWzddICE9PSAnPScpIHtcbiAgICAgICAgICBkYXRhW21hdGNoWzddXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IHsgJ1YnOiAndmlkZW8nLCAnQSc6ICdhdWRpbycsICdTJzogJ3N1YnRpdGxlJyB9W21hdGNoWzFdXSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtYXRjaFs4XSxcbiAgICAgICAgICAgIGZyYW1lTVQ6IG1hdGNoWzJdID09PSAnRicsXG4gICAgICAgICAgICBzbGljZU1UOiBtYXRjaFszXSA9PT0gJ1MnLFxuICAgICAgICAgICAgZXhwZXJpbWVudGFsOiBtYXRjaFs0XSA9PT0gJ1gnLFxuICAgICAgICAgICAgZHJhd0hvcml6QmFuZDogbWF0Y2hbNV0gPT09ICdCJyxcbiAgICAgICAgICAgIGRpcmVjdFJlbmRlcmluZzogbWF0Y2hbNl0gPT09ICdEJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjYWxsYmFjayhudWxsLCBjYWNoZS5lbmNvZGVycyA9IGRhdGEpO1xuICAgIH0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEEgY2FsbGJhY2sgcGFzc2VkIHRvIHtAbGluayBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUZvcm1hdHN9LlxuICAgKlxuICAgKiBAY2FsbGJhY2sgRmZtcGVnQ29tbWFuZH5mb3JtYXRDYWxsYmFja1xuICAgKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVyciBlcnJvciBvYmplY3Qgb3IgbnVsbCBpZiBubyBlcnJvciBoYXBwZW5lZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0cyBmb3JtYXQgb2JqZWN0IHdpdGggZm9ybWF0IG5hbWVzIGFzIGtleXMgYW5kIHRoZSBmb2xsb3dpbmdcbiAgICogICBwcm9wZXJ0aWVzIGZvciBlYWNoIGZvcm1hdDpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdHMuZGVzY3JpcHRpb24gZm9ybWF0IGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9ybWF0cy5jYW5EZW11eCB3aGV0aGVyIHRoZSBmb3JtYXQgaXMgYWJsZSB0byBkZW11eCBzdHJlYW1zIGZyb20gYW4gaW5wdXQgZmlsZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcm1hdHMuY2FuTXV4IHdoZXRoZXIgdGhlIGZvcm1hdCBpcyBhYmxlIHRvIG11eCBzdHJlYW1zIGludG8gYW4gb3V0cHV0IGZpbGVcbiAgICovXG5cbiAgLyoqXG4gICAqIFF1ZXJ5IGZmbXBlZyBmb3IgYXZhaWxhYmxlIGZvcm1hdHNcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F2YWlsYWJsZUZvcm1hdHNcbiAgICogQGNhdGVnb3J5IENhcGFiaWxpdGllc1xuICAgKiBAYWxpYXNlcyBnZXRBdmFpbGFibGVGb3JtYXRzXG4gICAqXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH5mb3JtYXRDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIHByb3RvLmF2YWlsYWJsZUZvcm1hdHMgPVxuICBwcm90by5nZXRBdmFpbGFibGVGb3JtYXRzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAoJ2Zvcm1hdHMnIGluIGNhY2hlKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGUuZm9ybWF0cyk7XG4gICAgfVxuXG4gICAgLy8gUnVuIGZmbXBlZyAtZm9ybWF0c1xuICAgIHRoaXMuX3NwYXduRmZtcGVnKFsnLWZvcm1hdHMnXSwgeyBjYXB0dXJlU3Rkb3V0OiB0cnVlLCBzdGRvdXRMaW5lczogMCB9LCBmdW5jdGlvbiAoZXJyLCBzdGRvdXRSaW5nKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXJzZSBvdXRwdXRcbiAgICAgIHZhciBzdGRvdXQgPSBzdGRvdXRSaW5nLmdldCgpO1xuICAgICAgdmFyIGxpbmVzID0gc3Rkb3V0LnNwbGl0KGxpbmVCcmVha1JlZ2V4cCk7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgICBsaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaChmb3JtYXRSZWdleHApO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICBtYXRjaFszXS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgICBpZiAoIShmb3JtYXQgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgZGF0YVtmb3JtYXRdID0ge1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBjYW5EZW11eDogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2FuTXV4OiBmYWxzZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICdEJykge1xuICAgICAgICAgICAgICBkYXRhW2Zvcm1hdF0uY2FuRGVtdXggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzJdID09PSAnRScpIHtcbiAgICAgICAgICAgICAgZGF0YVtmb3JtYXRdLmNhbk11eCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjYWxsYmFjayhudWxsLCBjYWNoZS5mb3JtYXRzID0gZGF0YSk7XG4gICAgfSk7XG4gIH07XG5cblxuICAvKipcbiAgICogQ2hlY2sgY2FwYWJpbGl0aWVzIGJlZm9yZSBleGVjdXRpbmcgYSBjb21tYW5kXG4gICAqXG4gICAqIENoZWNrcyB3aGV0aGVyIGFsbCB1c2VkIGNvZGVjcyBhbmQgZm9ybWF0cyBhcmUgaW5kZWVkIGF2YWlsYWJsZVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjX2NoZWNrQ2FwYWJpbGl0aWVzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHdpdGggc2lnbmF0dXJlIChlcnIpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90by5fY2hlY2tDYXBhYmlsaXRpZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBhc3luYy53YXRlcmZhbGwoW1xuICAgICAgLy8gR2V0IGF2YWlsYWJsZSBmb3JtYXRzXG4gICAgICBmdW5jdGlvbihjYikge1xuICAgICAgICBzZWxmLmF2YWlsYWJsZUZvcm1hdHMoY2IpO1xuICAgICAgfSxcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciBzcGVjaWZpZWQgZm9ybWF0cyBhcmUgYXZhaWxhYmxlXG4gICAgICBmdW5jdGlvbihmb3JtYXRzLCBjYikge1xuICAgICAgICB2YXIgdW5hdmFpbGFibGU7XG5cbiAgICAgICAgLy8gT3V0cHV0IGZvcm1hdChzKVxuICAgICAgICB1bmF2YWlsYWJsZSA9IHNlbGYuX291dHB1dHNcbiAgICAgICAgICAucmVkdWNlKGZ1bmN0aW9uKGZtdHMsIG91dHB1dCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IG91dHB1dC5vcHRpb25zLmZpbmQoJy1mJywgMSk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgIGlmICghKGZvcm1hdFswXSBpbiBmb3JtYXRzKSB8fCAhKGZvcm1hdHNbZm9ybWF0WzBdXS5jYW5NdXgpKSB7XG4gICAgICAgICAgICAgICAgZm10cy5wdXNoKGZvcm1hdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZtdHM7XG4gICAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGlmICh1bmF2YWlsYWJsZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdPdXRwdXQgZm9ybWF0ICcgKyB1bmF2YWlsYWJsZVswXSArICcgaXMgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bmF2YWlsYWJsZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignT3V0cHV0IGZvcm1hdHMgJyArIHVuYXZhaWxhYmxlLmpvaW4oJywgJykgKyAnIGFyZSBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5wdXQgZm9ybWF0KHMpXG4gICAgICAgIHVuYXZhaWxhYmxlID0gc2VsZi5faW5wdXRzXG4gICAgICAgICAgLnJlZHVjZShmdW5jdGlvbihmbXRzLCBpbnB1dCkge1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IGlucHV0Lm9wdGlvbnMuZmluZCgnLWYnLCAxKTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgaWYgKCEoZm9ybWF0WzBdIGluIGZvcm1hdHMpIHx8ICEoZm9ybWF0c1tmb3JtYXRbMF1dLmNhbkRlbXV4KSkge1xuICAgICAgICAgICAgICAgIGZtdHMucHVzaChmb3JtYXRbMF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmbXRzO1xuICAgICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAodW5hdmFpbGFibGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignSW5wdXQgZm9ybWF0ICcgKyB1bmF2YWlsYWJsZVswXSArICcgaXMgbm90IGF2YWlsYWJsZScpKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bmF2YWlsYWJsZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignSW5wdXQgZm9ybWF0cyAnICsgdW5hdmFpbGFibGUuam9pbignLCAnKSArICcgYXJlIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYigpO1xuICAgICAgfSxcblxuICAgICAgLy8gR2V0IGF2YWlsYWJsZSBjb2RlY3NcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHNlbGYuYXZhaWxhYmxlRW5jb2RlcnMoY2IpO1xuICAgICAgfSxcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciBzcGVjaWZpZWQgY29kZWNzIGFyZSBhdmFpbGFibGUgYW5kIGFkZCBzdHJpY3QgZXhwZXJpbWVudGFsIG9wdGlvbnMgaWYgbmVlZGVkXG4gICAgICBmdW5jdGlvbihlbmNvZGVycywgY2IpIHtcbiAgICAgICAgdmFyIHVuYXZhaWxhYmxlO1xuXG4gICAgICAgIC8vIEF1ZGlvIGNvZGVjKHMpXG4gICAgICAgIHVuYXZhaWxhYmxlID0gc2VsZi5fb3V0cHV0cy5yZWR1Y2UoZnVuY3Rpb24oY2Rjcywgb3V0cHV0KSB7XG4gICAgICAgICAgdmFyIGFjb2RlYyA9IG91dHB1dC5hdWRpby5maW5kKCctYWNvZGVjJywgMSk7XG4gICAgICAgICAgaWYgKGFjb2RlYyAmJiBhY29kZWNbMF0gIT09ICdjb3B5Jykge1xuICAgICAgICAgICAgaWYgKCEoYWNvZGVjWzBdIGluIGVuY29kZXJzKSB8fCBlbmNvZGVyc1thY29kZWNbMF1dLnR5cGUgIT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgY2Rjcy5wdXNoKGFjb2RlY1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNkY3M7XG4gICAgICAgIH0sIFtdKTtcblxuICAgICAgICBpZiAodW5hdmFpbGFibGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignQXVkaW8gY29kZWMgJyArIHVuYXZhaWxhYmxlWzBdICsgJyBpcyBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9IGVsc2UgaWYgKHVuYXZhaWxhYmxlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdBdWRpbyBjb2RlY3MgJyArIHVuYXZhaWxhYmxlLmpvaW4oJywgJykgKyAnIGFyZSBub3QgYXZhaWxhYmxlJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVmlkZW8gY29kZWMocylcbiAgICAgICAgdW5hdmFpbGFibGUgPSBzZWxmLl9vdXRwdXRzLnJlZHVjZShmdW5jdGlvbihjZGNzLCBvdXRwdXQpIHtcbiAgICAgICAgICB2YXIgdmNvZGVjID0gb3V0cHV0LnZpZGVvLmZpbmQoJy12Y29kZWMnLCAxKTtcbiAgICAgICAgICBpZiAodmNvZGVjICYmIHZjb2RlY1swXSAhPT0gJ2NvcHknKSB7XG4gICAgICAgICAgICBpZiAoISh2Y29kZWNbMF0gaW4gZW5jb2RlcnMpIHx8IGVuY29kZXJzW3Zjb2RlY1swXV0udHlwZSAhPT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICBjZGNzLnB1c2godmNvZGVjWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2RjcztcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGlmICh1bmF2YWlsYWJsZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdWaWRlbyBjb2RlYyAnICsgdW5hdmFpbGFibGVbMF0gKyAnIGlzIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodW5hdmFpbGFibGUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1ZpZGVvIGNvZGVjcyAnICsgdW5hdmFpbGFibGUuam9pbignLCAnKSArICcgYXJlIG5vdCBhdmFpbGFibGUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYigpO1xuICAgICAgfVxuICAgIF0sIGNhbGxiYWNrKTtcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/capabilities.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/ffprobe.js":
/*!***************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/ffprobe.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true, laxcomma:true*/\n\n\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\n\n\nfunction legacyTag(key) { return key.match(/^TAG:/); }\nfunction legacyDisposition(key) { return key.match(/^DISPOSITION:/); }\n\nfunction parseFfprobeOutput(out) {\n  var lines = out.split(/\\r\\n|\\r|\\n/);\n\n  lines = lines.filter(function (line) {\n    return line.length > 0;\n  });\n\n  var data = {\n    streams: [],\n    format: {},\n    chapters: []\n  };\n\n  function parseBlock(name) {\n    var data = {};\n\n    var line = lines.shift();\n    while (typeof line !== 'undefined') {\n      if (line.toLowerCase() == '[/'+name+']') {\n        return data;\n      } else if (line.match(/^\\[/)) {\n        line = lines.shift();\n        continue;\n      }\n\n      var kv = line.match(/^([^=]+)=(.*)$/);\n      if (kv) {\n        if (!(kv[1].match(/^TAG:/)) && kv[2].match(/^[0-9]+(\\.[0-9]+)?$/)) {\n          data[kv[1]] = Number(kv[2]);\n        } else {\n          data[kv[1]] = kv[2];\n        }\n      }\n\n      line = lines.shift();\n    }\n\n    return data;\n  }\n\n  var line = lines.shift();\n  while (typeof line !== 'undefined') {\n    if (line.match(/^\\[stream/i)) {\n      var stream = parseBlock('stream');\n      data.streams.push(stream);\n    } else if (line.match(/^\\[chapter/i)) {\n      var chapter = parseBlock('chapter');\n      data.chapters.push(chapter);\n    } else if (line.toLowerCase() === '[format]') {\n      data.format = parseBlock('format');\n    }\n\n    line = lines.shift();\n  }\n\n  return data;\n}\n\n\n\nmodule.exports = function(proto) {\n  /**\n   * A callback passed to the {@link FfmpegCommand#ffprobe} method.\n   *\n   * @callback FfmpegCommand~ffprobeCallback\n   *\n   * @param {Error|null} err error object or null if no error happened\n   * @param {Object} ffprobeData ffprobe output data; this object\n   *   has the same format as what the following command returns:\n   *\n   *     `ffprobe -print_format json -show_streams -show_format INPUTFILE`\n   * @param {Array} ffprobeData.streams stream information\n   * @param {Object} ffprobeData.format format information\n   */\n\n  /**\n   * Run ffprobe on last specified input\n   *\n   * @method FfmpegCommand#ffprobe\n   * @category Metadata\n   *\n   * @param {?Number} [index] 0-based index of input to probe (defaults to last input)\n   * @param {?String[]} [options] array of output options to return\n   * @param {FfmpegCommand~ffprobeCallback} callback callback function\n   *\n   */\n  proto.ffprobe = function() {\n    var input, index = null, options = [], callback;\n\n    // the last argument should be the callback\n    var callback = arguments[arguments.length - 1];\n\n    var ended = false\n    function handleCallback(err, data) {\n      if (!ended) {\n        ended = true;\n        callback(err, data);\n      }\n    };\n\n    // map the arguments to the correct variable names\n    switch (arguments.length) {\n      case 3:\n        index = arguments[0];\n        options = arguments[1];\n        break;\n      case 2:\n        if (typeof arguments[0] === 'number') {\n          index = arguments[0];\n        } else if (Array.isArray(arguments[0])) {\n          options = arguments[0];\n        }\n        break;\n    }\n\n\n    if (index === null) {\n      if (!this._currentInput) {\n        return handleCallback(new Error('No input specified'));\n      }\n\n      input = this._currentInput;\n    } else {\n      input = this._inputs[index];\n\n      if (!input) {\n        return handleCallback(new Error('Invalid input index'));\n      }\n    }\n\n    // Find ffprobe\n    this._getFfprobePath(function(err, path) {\n      if (err) {\n        return handleCallback(err);\n      } else if (!path) {\n        return handleCallback(new Error('Cannot find ffprobe'));\n      }\n\n      var stdout = '';\n      var stdoutClosed = false;\n      var stderr = '';\n      var stderrClosed = false;\n\n      // Spawn ffprobe\n      var src = input.isStream ? 'pipe:0' : input.source;\n      var ffprobe = spawn(path, ['-show_streams', '-show_format'].concat(options, src), {windowsHide: true});\n\n      if (input.isStream) {\n        // Skip errors on stdin. These get thrown when ffprobe is complete and\n        // there seems to be no way hook in and close stdin before it throws.\n        ffprobe.stdin.on('error', function(err) {\n          if (['ECONNRESET', 'EPIPE', 'EOF'].indexOf(err.code) >= 0) { return; }\n          handleCallback(err);\n        });\n\n        // Once ffprobe's input stream closes, we need no more data from the\n        // input\n        ffprobe.stdin.on('close', function() {\n            input.source.pause();\n            input.source.unpipe(ffprobe.stdin);\n        });\n\n        input.source.pipe(ffprobe.stdin);\n      }\n\n      ffprobe.on('error', callback);\n\n      // Ensure we wait for captured streams to end before calling callback\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && stdoutClosed && stderrClosed) {\n          if (exitError) {\n            if (stderr) {\n              exitError.message += '\\n' + stderr;\n            }\n\n            return handleCallback(exitError);\n          }\n\n          // Process output\n          var data = parseFfprobeOutput(stdout);\n\n          // Handle legacy output with \"TAG:x\" and \"DISPOSITION:x\" keys\n          [data.format].concat(data.streams).forEach(function(target) {\n            if (target) {\n              var legacyTagKeys = Object.keys(target).filter(legacyTag);\n\n              if (legacyTagKeys.length) {\n                target.tags = target.tags || {};\n\n                legacyTagKeys.forEach(function(tagKey) {\n                  target.tags[tagKey.substr(4)] = target[tagKey];\n                  delete target[tagKey];\n                });\n              }\n\n              var legacyDispositionKeys = Object.keys(target).filter(legacyDisposition);\n\n              if (legacyDispositionKeys.length) {\n                target.disposition = target.disposition || {};\n\n                legacyDispositionKeys.forEach(function(dispositionKey) {\n                  target.disposition[dispositionKey.substr(12)] = target[dispositionKey];\n                  delete target[dispositionKey];\n                });\n              }\n            }\n          });\n\n          handleCallback(null, data);\n        }\n      }\n\n      // Handle ffprobe exit\n      var processExited = false;\n      ffprobe.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (code) {\n          handleExit(new Error('ffprobe exited with code ' + code));\n        } else if (signal) {\n          handleExit(new Error('ffprobe was killed with signal ' + signal));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Handle stdout/stderr streams\n      ffprobe.stdout.on('data', function(data) {\n        stdout += data;\n      });\n\n      ffprobe.stdout.on('close', function() {\n        stdoutClosed = true;\n        handleExit();\n      });\n\n      ffprobe.stderr.on('data', function(data) {\n        stderr += data;\n      });\n\n      ffprobe.stderr.on('close', function() {\n        stderrClosed = true;\n        handleExit();\n      });\n    });\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvZmZwcm9iZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFlBQVksaUVBQThCOzs7QUFHMUMsMEJBQTBCO0FBQzFCLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsK0JBQStCLDZCQUE2QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxRQUFRLGlDQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFdBQVc7QUFDeEIsYUFBYSwrQkFBK0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5RixrQkFBa0I7O0FBRTNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL2ZmcHJvYmUuanM/NzAxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUsIGxheGNvbW1hOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG5cblxuZnVuY3Rpb24gbGVnYWN5VGFnKGtleSkgeyByZXR1cm4ga2V5Lm1hdGNoKC9eVEFHOi8pOyB9XG5mdW5jdGlvbiBsZWdhY3lEaXNwb3NpdGlvbihrZXkpIHsgcmV0dXJuIGtleS5tYXRjaCgvXkRJU1BPU0lUSU9OOi8pOyB9XG5cbmZ1bmN0aW9uIHBhcnNlRmZwcm9iZU91dHB1dChvdXQpIHtcbiAgdmFyIGxpbmVzID0gb3V0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuXG4gIGxpbmVzID0gbGluZXMuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgcmV0dXJuIGxpbmUubGVuZ3RoID4gMDtcbiAgfSk7XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgc3RyZWFtczogW10sXG4gICAgZm9ybWF0OiB7fSxcbiAgICBjaGFwdGVyczogW11cbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJsb2NrKG5hbWUpIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuXG4gICAgdmFyIGxpbmUgPSBsaW5lcy5zaGlmdCgpO1xuICAgIHdoaWxlICh0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChsaW5lLnRvTG93ZXJDYXNlKCkgPT0gJ1svJytuYW1lKyddJykge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaCgvXlxcWy8pKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lcy5zaGlmdCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGt2ID0gbGluZS5tYXRjaCgvXihbXj1dKyk9KC4qKSQvKTtcbiAgICAgIGlmIChrdikge1xuICAgICAgICBpZiAoIShrdlsxXS5tYXRjaCgvXlRBRzovKSkgJiYga3ZbMl0ubWF0Y2goL15bMC05XSsoXFwuWzAtOV0rKT8kLykpIHtcbiAgICAgICAgICBkYXRhW2t2WzFdXSA9IE51bWJlcihrdlsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtrdlsxXV0gPSBrdlsyXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaW5lID0gbGluZXMuc2hpZnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBsaW5lID0gbGluZXMuc2hpZnQoKTtcbiAgd2hpbGUgKHR5cGVvZiBsaW5lICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChsaW5lLm1hdGNoKC9eXFxbc3RyZWFtL2kpKSB7XG4gICAgICB2YXIgc3RyZWFtID0gcGFyc2VCbG9jaygnc3RyZWFtJyk7XG4gICAgICBkYXRhLnN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgIH0gZWxzZSBpZiAobGluZS5tYXRjaCgvXlxcW2NoYXB0ZXIvaSkpIHtcbiAgICAgIHZhciBjaGFwdGVyID0gcGFyc2VCbG9jaygnY2hhcHRlcicpO1xuICAgICAgZGF0YS5jaGFwdGVycy5wdXNoKGNoYXB0ZXIpO1xuICAgIH0gZWxzZSBpZiAobGluZS50b0xvd2VyQ2FzZSgpID09PSAnW2Zvcm1hdF0nKSB7XG4gICAgICBkYXRhLmZvcm1hdCA9IHBhcnNlQmxvY2soJ2Zvcm1hdCcpO1xuICAgIH1cblxuICAgIGxpbmUgPSBsaW5lcy5zaGlmdCgpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8qKlxuICAgKiBBIGNhbGxiYWNrIHBhc3NlZCB0byB0aGUge0BsaW5rIEZmbXBlZ0NvbW1hbmQjZmZwcm9iZX0gbWV0aG9kLlxuICAgKlxuICAgKiBAY2FsbGJhY2sgRmZtcGVnQ29tbWFuZH5mZnByb2JlQ2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIHtFcnJvcnxudWxsfSBlcnIgZXJyb3Igb2JqZWN0IG9yIG51bGwgaWYgbm8gZXJyb3IgaGFwcGVuZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IGZmcHJvYmVEYXRhIGZmcHJvYmUgb3V0cHV0IGRhdGE7IHRoaXMgb2JqZWN0XG4gICAqICAgaGFzIHRoZSBzYW1lIGZvcm1hdCBhcyB3aGF0IHRoZSBmb2xsb3dpbmcgY29tbWFuZCByZXR1cm5zOlxuICAgKlxuICAgKiAgICAgYGZmcHJvYmUgLXByaW50X2Zvcm1hdCBqc29uIC1zaG93X3N0cmVhbXMgLXNob3dfZm9ybWF0IElOUFVURklMRWBcbiAgICogQHBhcmFtIHtBcnJheX0gZmZwcm9iZURhdGEuc3RyZWFtcyBzdHJlYW0gaW5mb3JtYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGZmcHJvYmVEYXRhLmZvcm1hdCBmb3JtYXQgaW5mb3JtYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIFJ1biBmZnByb2JlIG9uIGxhc3Qgc3BlY2lmaWVkIGlucHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNmZnByb2JlXG4gICAqIEBjYXRlZ29yeSBNZXRhZGF0YVxuICAgKlxuICAgKiBAcGFyYW0gez9OdW1iZXJ9IFtpbmRleF0gMC1iYXNlZCBpbmRleCBvZiBpbnB1dCB0byBwcm9iZSAoZGVmYXVsdHMgdG8gbGFzdCBpbnB1dClcbiAgICogQHBhcmFtIHs/U3RyaW5nW119IFtvcHRpb25zXSBhcnJheSBvZiBvdXRwdXQgb3B0aW9ucyB0byByZXR1cm5cbiAgICogQHBhcmFtIHtGZm1wZWdDb21tYW5kfmZmcHJvYmVDYWxsYmFja30gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICpcbiAgICovXG4gIHByb3RvLmZmcHJvYmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5wdXQsIGluZGV4ID0gbnVsbCwgb3B0aW9ucyA9IFtdLCBjYWxsYmFjaztcblxuICAgIC8vIHRoZSBsYXN0IGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2tcbiAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgdmFyIGVuZGVkID0gZmFsc2VcbiAgICBmdW5jdGlvbiBoYW5kbGVDYWxsYmFjayhlcnIsIGRhdGEpIHtcbiAgICAgIGlmICghZW5kZWQpIHtcbiAgICAgICAgZW5kZWQgPSB0cnVlO1xuICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBtYXAgdGhlIGFyZ3VtZW50cyB0byB0aGUgY29ycmVjdCB2YXJpYWJsZSBuYW1lc1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG5cbiAgICBpZiAoaW5kZXggPT09IG51bGwpIHtcbiAgICAgIGlmICghdGhpcy5fY3VycmVudElucHV0KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVDYWxsYmFjayhuZXcgRXJyb3IoJ05vIGlucHV0IHNwZWNpZmllZCcpKTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQgPSB0aGlzLl9jdXJyZW50SW5wdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0ID0gdGhpcy5faW5wdXRzW2luZGV4XTtcblxuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2sobmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IGluZGV4JykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmQgZmZwcm9iZVxuICAgIHRoaXMuX2dldEZmcHJvYmVQYXRoKGZ1bmN0aW9uKGVyciwgcGF0aCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gaGFuZGxlQ2FsbGJhY2soZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKG5ldyBFcnJvcignQ2Fubm90IGZpbmQgZmZwcm9iZScpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZG91dCA9ICcnO1xuICAgICAgdmFyIHN0ZG91dENsb3NlZCA9IGZhbHNlO1xuICAgICAgdmFyIHN0ZGVyciA9ICcnO1xuICAgICAgdmFyIHN0ZGVyckNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICAvLyBTcGF3biBmZnByb2JlXG4gICAgICB2YXIgc3JjID0gaW5wdXQuaXNTdHJlYW0gPyAncGlwZTowJyA6IGlucHV0LnNvdXJjZTtcbiAgICAgIHZhciBmZnByb2JlID0gc3Bhd24ocGF0aCwgWyctc2hvd19zdHJlYW1zJywgJy1zaG93X2Zvcm1hdCddLmNvbmNhdChvcHRpb25zLCBzcmMpLCB7d2luZG93c0hpZGU6IHRydWV9KTtcblxuICAgICAgaWYgKGlucHV0LmlzU3RyZWFtKSB7XG4gICAgICAgIC8vIFNraXAgZXJyb3JzIG9uIHN0ZGluLiBUaGVzZSBnZXQgdGhyb3duIHdoZW4gZmZwcm9iZSBpcyBjb21wbGV0ZSBhbmRcbiAgICAgICAgLy8gdGhlcmUgc2VlbXMgdG8gYmUgbm8gd2F5IGhvb2sgaW4gYW5kIGNsb3NlIHN0ZGluIGJlZm9yZSBpdCB0aHJvd3MuXG4gICAgICAgIGZmcHJvYmUuc3RkaW4ub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgaWYgKFsnRUNPTk5SRVNFVCcsICdFUElQRScsICdFT0YnXS5pbmRleE9mKGVyci5jb2RlKSA+PSAwKSB7IHJldHVybjsgfVxuICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGVycik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE9uY2UgZmZwcm9iZSdzIGlucHV0IHN0cmVhbSBjbG9zZXMsIHdlIG5lZWQgbm8gbW9yZSBkYXRhIGZyb20gdGhlXG4gICAgICAgIC8vIGlucHV0XG4gICAgICAgIGZmcHJvYmUuc3RkaW4ub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbnB1dC5zb3VyY2UucGF1c2UoKTtcbiAgICAgICAgICAgIGlucHV0LnNvdXJjZS51bnBpcGUoZmZwcm9iZS5zdGRpbik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlucHV0LnNvdXJjZS5waXBlKGZmcHJvYmUuc3RkaW4pO1xuICAgICAgfVxuXG4gICAgICBmZnByb2JlLm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcblxuICAgICAgLy8gRW5zdXJlIHdlIHdhaXQgZm9yIGNhcHR1cmVkIHN0cmVhbXMgdG8gZW5kIGJlZm9yZSBjYWxsaW5nIGNhbGxiYWNrXG4gICAgICB2YXIgZXhpdEVycm9yID0gbnVsbDtcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUV4aXQoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBleGl0RXJyb3IgPSBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvY2Vzc0V4aXRlZCAmJiBzdGRvdXRDbG9zZWQgJiYgc3RkZXJyQ2xvc2VkKSB7XG4gICAgICAgICAgaWYgKGV4aXRFcnJvcikge1xuICAgICAgICAgICAgaWYgKHN0ZGVycikge1xuICAgICAgICAgICAgICBleGl0RXJyb3IubWVzc2FnZSArPSAnXFxuJyArIHN0ZGVycjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKGV4aXRFcnJvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUHJvY2VzcyBvdXRwdXRcbiAgICAgICAgICB2YXIgZGF0YSA9IHBhcnNlRmZwcm9iZU91dHB1dChzdGRvdXQpO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIGxlZ2FjeSBvdXRwdXQgd2l0aCBcIlRBRzp4XCIgYW5kIFwiRElTUE9TSVRJT046eFwiIGtleXNcbiAgICAgICAgICBbZGF0YS5mb3JtYXRdLmNvbmNhdChkYXRhLnN0cmVhbXMpLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHZhciBsZWdhY3lUYWdLZXlzID0gT2JqZWN0LmtleXModGFyZ2V0KS5maWx0ZXIobGVnYWN5VGFnKTtcblxuICAgICAgICAgICAgICBpZiAobGVnYWN5VGFnS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQudGFncyA9IHRhcmdldC50YWdzIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgbGVnYWN5VGFnS2V5cy5mb3JFYWNoKGZ1bmN0aW9uKHRhZ0tleSkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0LnRhZ3NbdGFnS2V5LnN1YnN0cig0KV0gPSB0YXJnZXRbdGFnS2V5XTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbdGFnS2V5XTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBsZWdhY3lEaXNwb3NpdGlvbktleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihsZWdhY3lEaXNwb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgaWYgKGxlZ2FjeURpc3Bvc2l0aW9uS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuZGlzcG9zaXRpb24gPSB0YXJnZXQuZGlzcG9zaXRpb24gfHwge307XG5cbiAgICAgICAgICAgICAgICBsZWdhY3lEaXNwb3NpdGlvbktleXMuZm9yRWFjaChmdW5jdGlvbihkaXNwb3NpdGlvbktleSkge1xuICAgICAgICAgICAgICAgICAgdGFyZ2V0LmRpc3Bvc2l0aW9uW2Rpc3Bvc2l0aW9uS2V5LnN1YnN0cigxMildID0gdGFyZ2V0W2Rpc3Bvc2l0aW9uS2V5XTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbZGlzcG9zaXRpb25LZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBoYW5kbGVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgZmZwcm9iZSBleGl0XG4gICAgICB2YXIgcHJvY2Vzc0V4aXRlZCA9IGZhbHNlO1xuICAgICAgZmZwcm9iZS5vbignZXhpdCcsIGZ1bmN0aW9uKGNvZGUsIHNpZ25hbCkge1xuICAgICAgICBwcm9jZXNzRXhpdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgIGhhbmRsZUV4aXQobmV3IEVycm9yKCdmZnByb2JlIGV4aXRlZCB3aXRoIGNvZGUgJyArIGNvZGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBoYW5kbGVFeGl0KG5ldyBFcnJvcignZmZwcm9iZSB3YXMga2lsbGVkIHdpdGggc2lnbmFsICcgKyBzaWduYWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBIYW5kbGUgc3Rkb3V0L3N0ZGVyciBzdHJlYW1zXG4gICAgICBmZnByb2JlLnN0ZG91dC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc3Rkb3V0ICs9IGRhdGE7XG4gICAgICB9KTtcblxuICAgICAgZmZwcm9iZS5zdGRvdXQub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0ZG91dENsb3NlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZUV4aXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBmZnByb2JlLnN0ZGVyci5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgc3RkZXJyICs9IGRhdGE7XG4gICAgICB9KTtcblxuICAgICAgZmZwcm9iZS5zdGRlcnIub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0ZGVyckNsb3NlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZUV4aXQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/ffprobe.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js":
/*!*********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar path = __webpack_require__(/*! path */ \"path\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\n\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\nvar ARGLISTS = ['_global', '_audio', '_audioFilters', '_video', '_videoFilters', '_sizeFilters', '_complexFilters'];\n\n\n/**\n * Create an ffmpeg command\n *\n * Can be called with or without the 'new' operator, and the 'input' parameter\n * may be specified as 'options.source' instead (or passed later with the\n * addInput method).\n *\n * @constructor\n * @param {String|ReadableStream} [input] input file path or readable stream\n * @param {Object} [options] command options\n * @param {Object} [options.logger=<no logging>] logger object with 'error', 'warning', 'info' and 'debug' methods\n * @param {Number} [options.niceness=0] ffmpeg process niceness, ignored on Windows\n * @param {Number} [options.priority=0] alias for `niceness`\n * @param {String} [options.presets=\"fluent-ffmpeg/lib/presets\"] directory to load presets from\n * @param {String} [options.preset=\"fluent-ffmpeg/lib/presets\"] alias for `presets`\n * @param {String} [options.stdoutLines=100] maximum lines of ffmpeg output to keep in memory, use 0 for unlimited\n * @param {Number} [options.timeout=<no timeout>] ffmpeg processing timeout in seconds\n * @param {String|ReadableStream} [options.source=<no input>] alias for the `input` parameter\n */\nfunction FfmpegCommand(input, options) {\n  // Make 'new' optional\n  if (!(this instanceof FfmpegCommand)) {\n    return new FfmpegCommand(input, options);\n  }\n\n  EventEmitter.call(this);\n\n  if (typeof input === 'object' && !('readable' in input)) {\n    // Options object passed directly\n    options = input;\n  } else {\n    // Input passed first\n    options = options || {};\n    options.source = input;\n  }\n\n  // Add input if present\n  this._inputs = [];\n  if (options.source) {\n    this.input(options.source);\n  }\n\n  // Add target-less output for backwards compatibility\n  this._outputs = [];\n  this.output();\n\n  // Create argument lists\n  var self = this;\n  ['_global', '_complexFilters'].forEach(function(prop) {\n    self[prop] = utils.args();\n  });\n\n  // Set default option values\n  options.stdoutLines = 'stdoutLines' in options ? options.stdoutLines : 100;\n  options.presets = options.presets || options.preset || path.join(__dirname, 'presets');\n  options.niceness = options.niceness || options.priority || 0;\n\n  // Save options\n  this.options = options;\n\n  // Setup logger\n  this.logger = options.logger || {\n    debug: function() {},\n    info: function() {},\n    warn: function() {},\n    error: function() {}\n  };\n}\nutil.inherits(FfmpegCommand, EventEmitter);\nmodule.exports = FfmpegCommand;\n\n\n/**\n * Clone an ffmpeg command\n *\n * This method is useful when you want to process the same input multiple times.\n * It returns a new FfmpegCommand instance with the exact same options.\n *\n * All options set _after_ the clone() call will only be applied to the instance\n * it has been called on.\n *\n * @example\n *   var command = ffmpeg('/path/to/source.avi')\n *     .audioCodec('libfaac')\n *     .videoCodec('libx264')\n *     .format('mp4');\n *\n *   command.clone()\n *     .size('320x200')\n *     .save('/path/to/output-small.mp4');\n *\n *   command.clone()\n *     .size('640x400')\n *     .save('/path/to/output-medium.mp4');\n *\n *   command.save('/path/to/output-original-size.mp4');\n *\n * @method FfmpegCommand#clone\n * @return FfmpegCommand\n */\nFfmpegCommand.prototype.clone = function() {\n  var clone = new FfmpegCommand();\n  var self = this;\n\n  // Clone options and logger\n  clone.options = this.options;\n  clone.logger = this.logger;\n\n  // Clone inputs\n  clone._inputs = this._inputs.map(function(input) {\n    return {\n      source: input.source,\n      options: input.options.clone()\n    };\n  });\n\n  // Create first output\n  if ('target' in this._outputs[0]) {\n    // We have outputs set, don't clone them and create first output\n    clone._outputs = [];\n    clone.output();\n  } else {\n    // No outputs set, clone first output options\n    clone._outputs = [\n      clone._currentOutput = {\n        flags: {}\n      }\n    ];\n\n    ['audio', 'audioFilters', 'video', 'videoFilters', 'sizeFilters', 'options'].forEach(function(key) {\n      clone._currentOutput[key] = self._currentOutput[key].clone();\n    });\n\n    if (this._currentOutput.sizeData) {\n      clone._currentOutput.sizeData = {};\n      utils.copy(this._currentOutput.sizeData, clone._currentOutput.sizeData);\n    }\n\n    utils.copy(this._currentOutput.flags, clone._currentOutput.flags);\n  }\n\n  // Clone argument lists\n  ['_global', '_complexFilters'].forEach(function(prop) {\n    clone[prop] = self[prop].clone();\n  });\n\n  return clone;\n};\n\n\n/* Add methods from options submodules */\n\n__webpack_require__(/*! ./options/inputs */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/inputs.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/audio */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/audio.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/video */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/video.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/videosize */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/videosize.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/output */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/output.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/custom */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/custom.js\")(FfmpegCommand.prototype);\n__webpack_require__(/*! ./options/misc */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/options/misc.js\")(FfmpegCommand.prototype);\n\n\n/* Add processor methods */\n\n__webpack_require__(/*! ./processor */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/processor.js\")(FfmpegCommand.prototype);\n\n\n/* Add capabilities methods */\n\n__webpack_require__(/*! ./capabilities */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/capabilities.js\")(FfmpegCommand.prototype);\n\nFfmpegCommand.setFfmpegPath = function(path) {\n  (new FfmpegCommand()).setFfmpegPath(path);\n};\n\nFfmpegCommand.setFfprobePath = function(path) {\n  (new FfmpegCommand()).setFfprobePath(path);\n};\n\nFfmpegCommand.setFlvtoolPath = function(path) {\n  (new FfmpegCommand()).setFlvtoolPath(path);\n};\n\nFfmpegCommand.availableFilters =\nFfmpegCommand.getAvailableFilters = function(callback) {\n  (new FfmpegCommand()).availableFilters(callback);\n};\n\nFfmpegCommand.availableCodecs =\nFfmpegCommand.getAvailableCodecs = function(callback) {\n  (new FfmpegCommand()).availableCodecs(callback);\n};\n\nFfmpegCommand.availableFormats =\nFfmpegCommand.getAvailableFormats = function(callback) {\n  (new FfmpegCommand()).availableFormats(callback);\n};\n\nFfmpegCommand.availableEncoders =\nFfmpegCommand.getAvailableEncoders = function(callback) {\n  (new FfmpegCommand()).availableEncoders(callback);\n};\n\n\n/* Add ffprobe methods */\n\n__webpack_require__(/*! ./ffprobe */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/ffprobe.js\")(FfmpegCommand.prototype);\n\nFfmpegCommand.ffprobe = function(file) {\n  var instance = new FfmpegCommand(file);\n  instance.ffprobe.apply(instance, Array.prototype.slice.call(arguments, 1));\n};\n\n/* Add processing recipes */\n\n__webpack_require__(/*! ./recipes */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/recipes.js\")(FfmpegCommand.prototype);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvZmx1ZW50LWZmbXBlZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixXQUFXLG1CQUFPLENBQUMsa0JBQU07QUFDekIsbUJBQW1CLDBEQUE4Qjs7QUFFakQsWUFBWSxtQkFBTyxDQUFDLGdFQUFTO0FBQzdCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7O0FBRUEsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDMUIsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekIsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDekIsbUJBQU8sQ0FBQyx3RkFBcUI7QUFDN0IsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDMUIsbUJBQU8sQ0FBQyxrRkFBa0I7QUFDMUIsbUJBQU8sQ0FBQyw4RUFBZ0I7OztBQUd4Qjs7QUFFQSxtQkFBTyxDQUFDLHdFQUFhOzs7QUFHckI7O0FBRUEsbUJBQU8sQ0FBQyw4RUFBZ0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxtQkFBTyxDQUFDLG9FQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxtQkFBTyxDQUFDLG9FQUFXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL2ZsdWVudC1mZm1wZWcuanM/ZjRlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIEFSR0xJU1RTID0gWydfZ2xvYmFsJywgJ19hdWRpbycsICdfYXVkaW9GaWx0ZXJzJywgJ192aWRlbycsICdfdmlkZW9GaWx0ZXJzJywgJ19zaXplRmlsdGVycycsICdfY29tcGxleEZpbHRlcnMnXTtcblxuXG4vKipcbiAqIENyZWF0ZSBhbiBmZm1wZWcgY29tbWFuZFxuICpcbiAqIENhbiBiZSBjYWxsZWQgd2l0aCBvciB3aXRob3V0IHRoZSAnbmV3JyBvcGVyYXRvciwgYW5kIHRoZSAnaW5wdXQnIHBhcmFtZXRlclxuICogbWF5IGJlIHNwZWNpZmllZCBhcyAnb3B0aW9ucy5zb3VyY2UnIGluc3RlYWQgKG9yIHBhc3NlZCBsYXRlciB3aXRoIHRoZVxuICogYWRkSW5wdXQgbWV0aG9kKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfFJlYWRhYmxlU3RyZWFtfSBbaW5wdXRdIGlucHV0IGZpbGUgcGF0aCBvciByZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gY29tbWFuZCBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubG9nZ2VyPTxubyBsb2dnaW5nPl0gbG9nZ2VyIG9iamVjdCB3aXRoICdlcnJvcicsICd3YXJuaW5nJywgJ2luZm8nIGFuZCAnZGVidWcnIG1ldGhvZHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5uaWNlbmVzcz0wXSBmZm1wZWcgcHJvY2VzcyBuaWNlbmVzcywgaWdub3JlZCBvbiBXaW5kb3dzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMucHJpb3JpdHk9MF0gYWxpYXMgZm9yIGBuaWNlbmVzc2BcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcmVzZXRzPVwiZmx1ZW50LWZmbXBlZy9saWIvcHJlc2V0c1wiXSBkaXJlY3RvcnkgdG8gbG9hZCBwcmVzZXRzIGZyb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5wcmVzZXQ9XCJmbHVlbnQtZmZtcGVnL2xpYi9wcmVzZXRzXCJdIGFsaWFzIGZvciBgcHJlc2V0c2BcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5zdGRvdXRMaW5lcz0xMDBdIG1heGltdW0gbGluZXMgb2YgZmZtcGVnIG91dHB1dCB0byBrZWVwIGluIG1lbW9yeSwgdXNlIDAgZm9yIHVubGltaXRlZFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRpbWVvdXQ9PG5vIHRpbWVvdXQ+XSBmZm1wZWcgcHJvY2Vzc2luZyB0aW1lb3V0IGluIHNlY29uZHNcbiAqIEBwYXJhbSB7U3RyaW5nfFJlYWRhYmxlU3RyZWFtfSBbb3B0aW9ucy5zb3VyY2U9PG5vIGlucHV0Pl0gYWxpYXMgZm9yIHRoZSBgaW5wdXRgIHBhcmFtZXRlclxuICovXG5mdW5jdGlvbiBGZm1wZWdDb21tYW5kKGlucHV0LCBvcHRpb25zKSB7XG4gIC8vIE1ha2UgJ25ldycgb3B0aW9uYWxcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEZmbXBlZ0NvbW1hbmQpKSB7XG4gICAgcmV0dXJuIG5ldyBGZm1wZWdDb21tYW5kKGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmICEoJ3JlYWRhYmxlJyBpbiBpbnB1dCkpIHtcbiAgICAvLyBPcHRpb25zIG9iamVjdCBwYXNzZWQgZGlyZWN0bHlcbiAgICBvcHRpb25zID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW5wdXQgcGFzc2VkIGZpcnN0XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy5zb3VyY2UgPSBpbnB1dDtcbiAgfVxuXG4gIC8vIEFkZCBpbnB1dCBpZiBwcmVzZW50XG4gIHRoaXMuX2lucHV0cyA9IFtdO1xuICBpZiAob3B0aW9ucy5zb3VyY2UpIHtcbiAgICB0aGlzLmlucHV0KG9wdGlvbnMuc291cmNlKTtcbiAgfVxuXG4gIC8vIEFkZCB0YXJnZXQtbGVzcyBvdXRwdXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIHRoaXMuX291dHB1dHMgPSBbXTtcbiAgdGhpcy5vdXRwdXQoKTtcblxuICAvLyBDcmVhdGUgYXJndW1lbnQgbGlzdHNcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBbJ19nbG9iYWwnLCAnX2NvbXBsZXhGaWx0ZXJzJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgc2VsZltwcm9wXSA9IHV0aWxzLmFyZ3MoKTtcbiAgfSk7XG5cbiAgLy8gU2V0IGRlZmF1bHQgb3B0aW9uIHZhbHVlc1xuICBvcHRpb25zLnN0ZG91dExpbmVzID0gJ3N0ZG91dExpbmVzJyBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGRvdXRMaW5lcyA6IDEwMDtcbiAgb3B0aW9ucy5wcmVzZXRzID0gb3B0aW9ucy5wcmVzZXRzIHx8IG9wdGlvbnMucHJlc2V0IHx8IHBhdGguam9pbihfX2Rpcm5hbWUsICdwcmVzZXRzJyk7XG4gIG9wdGlvbnMubmljZW5lc3MgPSBvcHRpb25zLm5pY2VuZXNzIHx8IG9wdGlvbnMucHJpb3JpdHkgfHwgMDtcblxuICAvLyBTYXZlIG9wdGlvbnNcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAvLyBTZXR1cCBsb2dnZXJcbiAgdGhpcy5sb2dnZXIgPSBvcHRpb25zLmxvZ2dlciB8fCB7XG4gICAgZGVidWc6IGZ1bmN0aW9uKCkge30sXG4gICAgaW5mbzogZnVuY3Rpb24oKSB7fSxcbiAgICB3YXJuOiBmdW5jdGlvbigpIHt9LFxuICAgIGVycm9yOiBmdW5jdGlvbigpIHt9XG4gIH07XG59XG51dGlsLmluaGVyaXRzKEZmbXBlZ0NvbW1hbmQsIEV2ZW50RW1pdHRlcik7XG5tb2R1bGUuZXhwb3J0cyA9IEZmbXBlZ0NvbW1hbmQ7XG5cblxuLyoqXG4gKiBDbG9uZSBhbiBmZm1wZWcgY29tbWFuZFxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHByb2Nlc3MgdGhlIHNhbWUgaW5wdXQgbXVsdGlwbGUgdGltZXMuXG4gKiBJdCByZXR1cm5zIGEgbmV3IEZmbXBlZ0NvbW1hbmQgaW5zdGFuY2Ugd2l0aCB0aGUgZXhhY3Qgc2FtZSBvcHRpb25zLlxuICpcbiAqIEFsbCBvcHRpb25zIHNldCBfYWZ0ZXJfIHRoZSBjbG9uZSgpIGNhbGwgd2lsbCBvbmx5IGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG4gKiBpdCBoYXMgYmVlbiBjYWxsZWQgb24uXG4gKlxuICogQGV4YW1wbGVcbiAqICAgdmFyIGNvbW1hbmQgPSBmZm1wZWcoJy9wYXRoL3RvL3NvdXJjZS5hdmknKVxuICogICAgIC5hdWRpb0NvZGVjKCdsaWJmYWFjJylcbiAqICAgICAudmlkZW9Db2RlYygnbGlieDI2NCcpXG4gKiAgICAgLmZvcm1hdCgnbXA0Jyk7XG4gKlxuICogICBjb21tYW5kLmNsb25lKClcbiAqICAgICAuc2l6ZSgnMzIweDIwMCcpXG4gKiAgICAgLnNhdmUoJy9wYXRoL3RvL291dHB1dC1zbWFsbC5tcDQnKTtcbiAqXG4gKiAgIGNvbW1hbmQuY2xvbmUoKVxuICogICAgIC5zaXplKCc2NDB4NDAwJylcbiAqICAgICAuc2F2ZSgnL3BhdGgvdG8vb3V0cHV0LW1lZGl1bS5tcDQnKTtcbiAqXG4gKiAgIGNvbW1hbmQuc2F2ZSgnL3BhdGgvdG8vb3V0cHV0LW9yaWdpbmFsLXNpemUubXA0Jyk7XG4gKlxuICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2Nsb25lXG4gKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAqL1xuRmZtcGVnQ29tbWFuZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNsb25lID0gbmV3IEZmbXBlZ0NvbW1hbmQoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIENsb25lIG9wdGlvbnMgYW5kIGxvZ2dlclxuICBjbG9uZS5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICBjbG9uZS5sb2dnZXIgPSB0aGlzLmxvZ2dlcjtcblxuICAvLyBDbG9uZSBpbnB1dHNcbiAgY2xvbmUuX2lucHV0cyA9IHRoaXMuX2lucHV0cy5tYXAoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBpbnB1dC5zb3VyY2UsXG4gICAgICBvcHRpb25zOiBpbnB1dC5vcHRpb25zLmNsb25lKClcbiAgICB9O1xuICB9KTtcblxuICAvLyBDcmVhdGUgZmlyc3Qgb3V0cHV0XG4gIGlmICgndGFyZ2V0JyBpbiB0aGlzLl9vdXRwdXRzWzBdKSB7XG4gICAgLy8gV2UgaGF2ZSBvdXRwdXRzIHNldCwgZG9uJ3QgY2xvbmUgdGhlbSBhbmQgY3JlYXRlIGZpcnN0IG91dHB1dFxuICAgIGNsb25lLl9vdXRwdXRzID0gW107XG4gICAgY2xvbmUub3V0cHV0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gb3V0cHV0cyBzZXQsIGNsb25lIGZpcnN0IG91dHB1dCBvcHRpb25zXG4gICAgY2xvbmUuX291dHB1dHMgPSBbXG4gICAgICBjbG9uZS5fY3VycmVudE91dHB1dCA9IHtcbiAgICAgICAgZmxhZ3M6IHt9XG4gICAgICB9XG4gICAgXTtcblxuICAgIFsnYXVkaW8nLCAnYXVkaW9GaWx0ZXJzJywgJ3ZpZGVvJywgJ3ZpZGVvRmlsdGVycycsICdzaXplRmlsdGVycycsICdvcHRpb25zJ10uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGNsb25lLl9jdXJyZW50T3V0cHV0W2tleV0gPSBzZWxmLl9jdXJyZW50T3V0cHV0W2tleV0uY2xvbmUoKTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVEYXRhKSB7XG4gICAgICBjbG9uZS5fY3VycmVudE91dHB1dC5zaXplRGF0YSA9IHt9O1xuICAgICAgdXRpbHMuY29weSh0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVEYXRhLCBjbG9uZS5fY3VycmVudE91dHB1dC5zaXplRGF0YSk7XG4gICAgfVxuXG4gICAgdXRpbHMuY29weSh0aGlzLl9jdXJyZW50T3V0cHV0LmZsYWdzLCBjbG9uZS5fY3VycmVudE91dHB1dC5mbGFncyk7XG4gIH1cblxuICAvLyBDbG9uZSBhcmd1bWVudCBsaXN0c1xuICBbJ19nbG9iYWwnLCAnX2NvbXBsZXhGaWx0ZXJzJ10uZm9yRWFjaChmdW5jdGlvbihwcm9wKSB7XG4gICAgY2xvbmVbcHJvcF0gPSBzZWxmW3Byb3BdLmNsb25lKCk7XG4gIH0pO1xuXG4gIHJldHVybiBjbG9uZTtcbn07XG5cblxuLyogQWRkIG1ldGhvZHMgZnJvbSBvcHRpb25zIHN1Ym1vZHVsZXMgKi9cblxucmVxdWlyZSgnLi9vcHRpb25zL2lucHV0cycpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcbnJlcXVpcmUoJy4vb3B0aW9ucy9hdWRpbycpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcbnJlcXVpcmUoJy4vb3B0aW9ucy92aWRlbycpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcbnJlcXVpcmUoJy4vb3B0aW9ucy92aWRlb3NpemUnKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5yZXF1aXJlKCcuL29wdGlvbnMvb3V0cHV0JykoRmZtcGVnQ29tbWFuZC5wcm90b3R5cGUpO1xucmVxdWlyZSgnLi9vcHRpb25zL2N1c3RvbScpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcbnJlcXVpcmUoJy4vb3B0aW9ucy9taXNjJykoRmZtcGVnQ29tbWFuZC5wcm90b3R5cGUpO1xuXG5cbi8qIEFkZCBwcm9jZXNzb3IgbWV0aG9kcyAqL1xuXG5yZXF1aXJlKCcuL3Byb2Nlc3NvcicpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcblxuXG4vKiBBZGQgY2FwYWJpbGl0aWVzIG1ldGhvZHMgKi9cblxucmVxdWlyZSgnLi9jYXBhYmlsaXRpZXMnKShGZm1wZWdDb21tYW5kLnByb3RvdHlwZSk7XG5cbkZmbXBlZ0NvbW1hbmQuc2V0RmZtcGVnUGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLnNldEZmbXBlZ1BhdGgocGF0aCk7XG59O1xuXG5GZm1wZWdDb21tYW5kLnNldEZmcHJvYmVQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAobmV3IEZmbXBlZ0NvbW1hbmQoKSkuc2V0RmZwcm9iZVBhdGgocGF0aCk7XG59O1xuXG5GZm1wZWdDb21tYW5kLnNldEZsdnRvb2xQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICAobmV3IEZmbXBlZ0NvbW1hbmQoKSkuc2V0Rmx2dG9vbFBhdGgocGF0aCk7XG59O1xuXG5GZm1wZWdDb21tYW5kLmF2YWlsYWJsZUZpbHRlcnMgPVxuRmZtcGVnQ29tbWFuZC5nZXRBdmFpbGFibGVGaWx0ZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgKG5ldyBGZm1wZWdDb21tYW5kKCkpLmF2YWlsYWJsZUZpbHRlcnMoY2FsbGJhY2spO1xufTtcblxuRmZtcGVnQ29tbWFuZC5hdmFpbGFibGVDb2RlY3MgPVxuRmZtcGVnQ29tbWFuZC5nZXRBdmFpbGFibGVDb2RlY3MgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAobmV3IEZmbXBlZ0NvbW1hbmQoKSkuYXZhaWxhYmxlQ29kZWNzKGNhbGxiYWNrKTtcbn07XG5cbkZmbXBlZ0NvbW1hbmQuYXZhaWxhYmxlRm9ybWF0cyA9XG5GZm1wZWdDb21tYW5kLmdldEF2YWlsYWJsZUZvcm1hdHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAobmV3IEZmbXBlZ0NvbW1hbmQoKSkuYXZhaWxhYmxlRm9ybWF0cyhjYWxsYmFjayk7XG59O1xuXG5GZm1wZWdDb21tYW5kLmF2YWlsYWJsZUVuY29kZXJzID1cbkZmbXBlZ0NvbW1hbmQuZ2V0QXZhaWxhYmxlRW5jb2RlcnMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAobmV3IEZmbXBlZ0NvbW1hbmQoKSkuYXZhaWxhYmxlRW5jb2RlcnMoY2FsbGJhY2spO1xufTtcblxuXG4vKiBBZGQgZmZwcm9iZSBtZXRob2RzICovXG5cbnJlcXVpcmUoJy4vZmZwcm9iZScpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcblxuRmZtcGVnQ29tbWFuZC5mZnByb2JlID0gZnVuY3Rpb24oZmlsZSkge1xuICB2YXIgaW5zdGFuY2UgPSBuZXcgRmZtcGVnQ29tbWFuZChmaWxlKTtcbiAgaW5zdGFuY2UuZmZwcm9iZS5hcHBseShpbnN0YW5jZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG59O1xuXG4vKiBBZGQgcHJvY2Vzc2luZyByZWNpcGVzICovXG5cbnJlcXVpcmUoJy4vcmVjaXBlcycpKEZmbXBlZ0NvbW1hbmQucHJvdG90eXBlKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/fluent-ffmpeg.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/audio.js":
/*!*********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/audio.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Audio-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Disable audio in the output\n   *\n   * @method FfmpegCommand#noAudio\n   * @category Audio\n   * @aliases withNoAudio\n   * @return FfmpegCommand\n   */\n  proto.withNoAudio =\n  proto.noAudio = function() {\n    this._currentOutput.audio.clear();\n    this._currentOutput.audioFilters.clear();\n    this._currentOutput.audio('-an');\n\n    return this;\n  };\n\n\n  /**\n   * Specify audio codec\n   *\n   * @method FfmpegCommand#audioCodec\n   * @category Audio\n   * @aliases withAudioCodec\n   *\n   * @param {String} codec audio codec name\n   * @return FfmpegCommand\n   */\n  proto.withAudioCodec =\n  proto.audioCodec = function(codec) {\n    this._currentOutput.audio('-acodec', codec);\n\n    return this;\n  };\n\n\n  /**\n   * Specify audio bitrate\n   *\n   * @method FfmpegCommand#audioBitrate\n   * @category Audio\n   * @aliases withAudioBitrate\n   *\n   * @param {String|Number} bitrate audio bitrate in kbps (with an optional 'k' suffix)\n   * @return FfmpegCommand\n   */\n  proto.withAudioBitrate =\n  proto.audioBitrate = function(bitrate) {\n    this._currentOutput.audio('-b:a', ('' + bitrate).replace(/k?$/, 'k'));\n    return this;\n  };\n\n\n  /**\n   * Specify audio channel count\n   *\n   * @method FfmpegCommand#audioChannels\n   * @category Audio\n   * @aliases withAudioChannels\n   *\n   * @param {Number} channels channel count\n   * @return FfmpegCommand\n   */\n  proto.withAudioChannels =\n  proto.audioChannels = function(channels) {\n    this._currentOutput.audio('-ac', channels);\n    return this;\n  };\n\n\n  /**\n   * Specify audio frequency\n   *\n   * @method FfmpegCommand#audioFrequency\n   * @category Audio\n   * @aliases withAudioFrequency\n   *\n   * @param {Number} freq audio frequency in Hz\n   * @return FfmpegCommand\n   */\n  proto.withAudioFrequency =\n  proto.audioFrequency = function(freq) {\n    this._currentOutput.audio('-ar', freq);\n    return this;\n  };\n\n\n  /**\n   * Specify audio quality\n   *\n   * @method FfmpegCommand#audioQuality\n   * @category Audio\n   * @aliases withAudioQuality\n   *\n   * @param {Number} quality audio quality factor\n   * @return FfmpegCommand\n   */\n  proto.withAudioQuality =\n  proto.audioQuality = function(quality) {\n    this._currentOutput.audio('-aq', quality);\n    return this;\n  };\n\n\n  /**\n   * Specify custom audio filter(s)\n   *\n   * Can be called both with one or many filters, or a filter array.\n   *\n   * @example\n   * command.audioFilters('filter1');\n   *\n   * @example\n   * command.audioFilters('filter1', 'filter2=param1=value1:param2=value2');\n   *\n   * @example\n   * command.audioFilters(['filter1', 'filter2']);\n   *\n   * @example\n   * command.audioFilters([\n   *   {\n   *     filter: 'filter1'\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: 'param=value:param=value'\n   *   }\n   * ]);\n   *\n   * @example\n   * command.audioFilters(\n   *   {\n   *     filter: 'filter1',\n   *     options: ['value1', 'value2']\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: { param1: 'value1', param2: 'value2' }\n   *   }\n   * );\n   *\n   * @method FfmpegCommand#audioFilters\n   * @aliases withAudioFilter,withAudioFilters,audioFilter\n   * @category Audio\n   *\n   * @param {...String|String[]|Object[]} filters audio filter strings, string array or\n   *   filter specification array, each with the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|String[]|Object} [filters.options] filter option string, array, or object\n   * @return FfmpegCommand\n   */\n  proto.withAudioFilter =\n  proto.withAudioFilters =\n  proto.audioFilter =\n  proto.audioFilters = function(filters) {\n    if (arguments.length > 1) {\n      filters = [].slice.call(arguments);\n    }\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    this._currentOutput.audioFilters(utils.makeFilterStrings(filters));\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9hdWRpby5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxpRUFBVTs7O0FBRzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL29wdGlvbnMvYXVkaW8uanM/M2UyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5cbi8qXG4gKiEgQXVkaW8tcmVsYXRlZCBtZXRob2RzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogRGlzYWJsZSBhdWRpbyBpbiB0aGUgb3V0cHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNub0F1ZGlvXG4gICAqIEBjYXRlZ29yeSBBdWRpb1xuICAgKiBAYWxpYXNlcyB3aXRoTm9BdWRpb1xuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhOb0F1ZGlvID1cbiAgcHJvdG8ubm9BdWRpbyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuYXVkaW8uY2xlYXIoKTtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvRmlsdGVycy5jbGVhcigpO1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuYXVkaW8oJy1hbicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSBhdWRpbyBjb2RlY1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXVkaW9Db2RlY1xuICAgKiBAY2F0ZWdvcnkgQXVkaW9cbiAgICogQGFsaWFzZXMgd2l0aEF1ZGlvQ29kZWNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjIGF1ZGlvIGNvZGVjIG5hbWVcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoQXVkaW9Db2RlYyA9XG4gIHByb3RvLmF1ZGlvQ29kZWMgPSBmdW5jdGlvbihjb2RlYykge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuYXVkaW8oJy1hY29kZWMnLCBjb2RlYyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGF1ZGlvIGJpdHJhdGVcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2F1ZGlvQml0cmF0ZVxuICAgKiBAY2F0ZWdvcnkgQXVkaW9cbiAgICogQGFsaWFzZXMgd2l0aEF1ZGlvQml0cmF0ZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IGJpdHJhdGUgYXVkaW8gYml0cmF0ZSBpbiBrYnBzICh3aXRoIGFuIG9wdGlvbmFsICdrJyBzdWZmaXgpXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aEF1ZGlvQml0cmF0ZSA9XG4gIHByb3RvLmF1ZGlvQml0cmF0ZSA9IGZ1bmN0aW9uKGJpdHJhdGUpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvKCctYjphJywgKCcnICsgYml0cmF0ZSkucmVwbGFjZSgvaz8kLywgJ2snKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSBhdWRpbyBjaGFubmVsIGNvdW50XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdWRpb0NoYW5uZWxzXG4gICAqIEBjYXRlZ29yeSBBdWRpb1xuICAgKiBAYWxpYXNlcyB3aXRoQXVkaW9DaGFubmVsc1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gY2hhbm5lbHMgY2hhbm5lbCBjb3VudFxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhBdWRpb0NoYW5uZWxzID1cbiAgcHJvdG8uYXVkaW9DaGFubmVscyA9IGZ1bmN0aW9uKGNoYW5uZWxzKSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5hdWRpbygnLWFjJywgY2hhbm5lbHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYXVkaW8gZnJlcXVlbmN5XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdWRpb0ZyZXF1ZW5jeVxuICAgKiBAY2F0ZWdvcnkgQXVkaW9cbiAgICogQGFsaWFzZXMgd2l0aEF1ZGlvRnJlcXVlbmN5XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcmVxIGF1ZGlvIGZyZXF1ZW5jeSBpbiBIelxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhBdWRpb0ZyZXF1ZW5jeSA9XG4gIHByb3RvLmF1ZGlvRnJlcXVlbmN5ID0gZnVuY3Rpb24oZnJlcSkge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuYXVkaW8oJy1hcicsIGZyZXEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYXVkaW8gcXVhbGl0eVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXVkaW9RdWFsaXR5XG4gICAqIEBjYXRlZ29yeSBBdWRpb1xuICAgKiBAYWxpYXNlcyB3aXRoQXVkaW9RdWFsaXR5XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IGF1ZGlvIHF1YWxpdHkgZmFjdG9yXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aEF1ZGlvUXVhbGl0eSA9XG4gIHByb3RvLmF1ZGlvUXVhbGl0eSA9IGZ1bmN0aW9uKHF1YWxpdHkpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvKCctYXEnLCBxdWFsaXR5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGN1c3RvbSBhdWRpbyBmaWx0ZXIocylcbiAgICpcbiAgICogQ2FuIGJlIGNhbGxlZCBib3RoIHdpdGggb25lIG9yIG1hbnkgZmlsdGVycywgb3IgYSBmaWx0ZXIgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQuYXVkaW9GaWx0ZXJzKCdmaWx0ZXIxJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQuYXVkaW9GaWx0ZXJzKCdmaWx0ZXIxJywgJ2ZpbHRlcjI9cGFyYW0xPXZhbHVlMTpwYXJhbTI9dmFsdWUyJyk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQuYXVkaW9GaWx0ZXJzKFsnZmlsdGVyMScsICdmaWx0ZXIyJ10pO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLmF1ZGlvRmlsdGVycyhbXG4gICAqICAge1xuICAgKiAgICAgZmlsdGVyOiAnZmlsdGVyMSdcbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjInLFxuICAgKiAgICAgb3B0aW9uczogJ3BhcmFtPXZhbHVlOnBhcmFtPXZhbHVlJ1xuICAgKiAgIH1cbiAgICogXSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQuYXVkaW9GaWx0ZXJzKFxuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjEnLFxuICAgKiAgICAgb3B0aW9uczogWyd2YWx1ZTEnLCAndmFsdWUyJ11cbiAgICogICB9LFxuICAgKiAgIHtcbiAgICogICAgIGZpbHRlcjogJ2ZpbHRlcjInLFxuICAgKiAgICAgb3B0aW9uczogeyBwYXJhbTE6ICd2YWx1ZTEnLCBwYXJhbTI6ICd2YWx1ZTInIH1cbiAgICogICB9XG4gICAqICk7XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNhdWRpb0ZpbHRlcnNcbiAgICogQGFsaWFzZXMgd2l0aEF1ZGlvRmlsdGVyLHdpdGhBdWRpb0ZpbHRlcnMsYXVkaW9GaWx0ZXJcbiAgICogQGNhdGVnb3J5IEF1ZGlvXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfFN0cmluZ1tdfE9iamVjdFtdfSBmaWx0ZXJzIGF1ZGlvIGZpbHRlciBzdHJpbmdzLCBzdHJpbmcgYXJyYXkgb3JcbiAgICogICBmaWx0ZXIgc3BlY2lmaWNhdGlvbiBhcnJheSwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlcnMuZmlsdGVyIGZpbHRlciBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfE9iamVjdH0gW2ZpbHRlcnMub3B0aW9uc10gZmlsdGVyIG9wdGlvbiBzdHJpbmcsIGFycmF5LCBvciBvYmplY3RcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoQXVkaW9GaWx0ZXIgPVxuICBwcm90by53aXRoQXVkaW9GaWx0ZXJzID1cbiAgcHJvdG8uYXVkaW9GaWx0ZXIgPVxuICBwcm90by5hdWRpb0ZpbHRlcnMgPSBmdW5jdGlvbihmaWx0ZXJzKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBmaWx0ZXJzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShmaWx0ZXJzKSkge1xuICAgICAgZmlsdGVycyA9IFtmaWx0ZXJzXTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LmF1ZGlvRmlsdGVycyh1dGlscy5tYWtlRmlsdGVyU3RyaW5ncyhmaWx0ZXJzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/audio.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/custom.js":
/*!**********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/custom.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Custom options methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add custom input option(s)\n   *\n   * When passing a single string or an array, each string containing two\n   * words is split (eg. inputOptions('-option value') is supported) for\n   * compatibility reasons.  This is not the case when passing more than\n   * one argument.\n   *\n   * @example\n   * command.inputOptions('option1');\n   *\n   * @example\n   * command.inputOptions('option1', 'option2');\n   *\n   * @example\n   * command.inputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#inputOptions\n   * @category Custom options\n   * @aliases addInputOption,addInputOptions,withInputOption,withInputOptions,inputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addInputOption =\n  proto.addInputOptions =\n  proto.withInputOption =\n  proto.withInputOptions =\n  proto.inputOption =\n  proto.inputOptions = function(options) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentInput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Add custom output option(s)\n   *\n   * @example\n   * command.outputOptions('option1');\n   *\n   * @example\n   * command.outputOptions('option1', 'option2');\n   *\n   * @example\n   * command.outputOptions(['option1', 'option2']);\n   *\n   * @method FfmpegCommand#outputOptions\n   * @category Custom options\n   * @aliases addOutputOption,addOutputOptions,addOption,addOptions,withOutputOption,withOutputOptions,withOption,withOptions,outputOption\n   *\n   * @param {...String} options option string(s) or string array\n   * @return FfmpegCommand\n   */\n  proto.addOutputOption =\n  proto.addOutputOptions =\n  proto.addOption =\n  proto.addOptions =\n  proto.withOutputOption =\n  proto.withOutputOptions =\n  proto.withOption =\n  proto.withOptions =\n  proto.outputOption =\n  proto.outputOptions = function(options) {\n    var doSplit = true;\n\n    if (arguments.length > 1) {\n      options = [].slice.call(arguments);\n      doSplit = false;\n    }\n\n    if (!Array.isArray(options)) {\n      options = [options];\n    }\n\n    this._currentOutput.options(options.reduce(function(options, option) {\n      var split = String(option).split(' ');\n\n      if (doSplit && split.length === 2) {\n        options.push(split[0], split[1]);\n      } else {\n        options.push(option);\n      }\n\n      return options;\n    }, []));\n    return this;\n  };\n\n\n  /**\n   * Specify a complex filtergraph\n   *\n   * Calling this method will override any previously set filtergraph, but you can set\n   * as many filters as needed in one call.\n   *\n   * @example <caption>Overlay an image over a video (using a filtergraph string)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter('[0:v][1:v]overlay[out]', ['out']);\n   *\n   * @example <caption>Overlay an image over a video (using a filter array)</caption>\n   *   ffmpeg()\n   *     .input('video.avi')\n   *     .input('image.png')\n   *     .complexFilter([{\n   *       filter: 'overlay',\n   *       inputs: ['0:v', '1:v'],\n   *       outputs: ['out']\n   *     }], ['out']);\n   *\n   * @example <caption>Split video into RGB channels and output a 3x1 video with channels side to side</caption>\n   *  ffmpeg()\n   *    .input('video.avi')\n   *    .complexFilter([\n   *      // Duplicate video stream 3 times into streams a, b, and c\n   *      { filter: 'split', options: '3', outputs: ['a', 'b', 'c'] },\n   *\n   *      // Create stream 'red' by cancelling green and blue channels from stream 'a'\n   *      { filter: 'lutrgb', options: { g: 0, b: 0 }, inputs: 'a', outputs: 'red' },\n   *\n   *      // Create stream 'green' by cancelling red and blue channels from stream 'b'\n   *      { filter: 'lutrgb', options: { r: 0, b: 0 }, inputs: 'b', outputs: 'green' },\n   *\n   *      // Create stream 'blue' by cancelling red and green channels from stream 'c'\n   *      { filter: 'lutrgb', options: { r: 0, g: 0 }, inputs: 'c', outputs: 'blue' },\n   *\n   *      // Pad stream 'red' to 3x width, keeping the video on the left, and name output 'padded'\n   *      { filter: 'pad', options: { w: 'iw*3', h: 'ih' }, inputs: 'red', outputs: 'padded' },\n   *\n   *      // Overlay 'green' onto 'padded', moving it to the center, and name output 'redgreen'\n   *      { filter: 'overlay', options: { x: 'w', y: 0 }, inputs: ['padded', 'green'], outputs: 'redgreen'},\n   *\n   *      // Overlay 'blue' onto 'redgreen', moving it to the right\n   *      { filter: 'overlay', options: { x: '2*w', y: 0 }, inputs: ['redgreen', 'blue']},\n   *    ]);\n   *\n   * @method FfmpegCommand#complexFilter\n   * @category Custom options\n   * @aliases filterGraph\n   *\n   * @param {String|Array} spec filtergraph string or array of filter specification\n   *   objects, each having the following properties:\n   * @param {String} spec.filter filter name\n   * @param {String|Array} [spec.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [spec.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [spec.options] filter options, can be omitted to not set any options\n   * @param {Array} [map] (array of) stream specifier(s) from the graph to include in\n   *   ffmpeg output, defaults to ffmpeg automatically choosing the first matching streams.\n   * @return FfmpegCommand\n   */\n  proto.filterGraph =\n  proto.complexFilter = function(spec, map) {\n    this._complexFilters.clear();\n\n    if (!Array.isArray(spec)) {\n      spec = [spec];\n    }\n\n    this._complexFilters('-filter_complex', utils.makeFilterStrings(spec).join(';'));\n\n    if (Array.isArray(map)) {\n      var self = this;\n      map.forEach(function(streamSpec) {\n        self._complexFilters('-map', streamSpec.replace(utils.streamRegexp, '[$1]'));\n      });\n    } else if (typeof map === 'string') {\n      this._complexFilters('-map', map.replace(utils.streamRegexp, '[$1]'));\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9jdXN0b20uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUVBQVU7OztBQUc5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBeUQ7QUFDckU7QUFDQTtBQUNBLFlBQVksNkJBQTZCLFlBQVksK0JBQStCO0FBQ3BGO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QixZQUFZLGlDQUFpQztBQUN0RjtBQUNBO0FBQ0EsWUFBWSw2QkFBNkIsWUFBWSxnQ0FBZ0M7QUFDckY7QUFDQTtBQUNBLFlBQVksMEJBQTBCLG9CQUFvQixvQ0FBb0M7QUFDOUY7QUFDQTtBQUNBLFlBQVksOEJBQThCLGNBQWMsbURBQW1EO0FBQzNHO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QixnQkFBZ0IsK0JBQStCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpRkFBaUY7O0FBRWpGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9vcHRpb25zL2N1c3RvbS5qcz9mZjkyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cblxuLypcbiAqISBDdXN0b20gb3B0aW9ucyBtZXRob2RzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogQWRkIGN1c3RvbSBpbnB1dCBvcHRpb24ocylcbiAgICpcbiAgICogV2hlbiBwYXNzaW5nIGEgc2luZ2xlIHN0cmluZyBvciBhbiBhcnJheSwgZWFjaCBzdHJpbmcgY29udGFpbmluZyB0d29cbiAgICogd29yZHMgaXMgc3BsaXQgKGVnLiBpbnB1dE9wdGlvbnMoJy1vcHRpb24gdmFsdWUnKSBpcyBzdXBwb3J0ZWQpIGZvclxuICAgKiBjb21wYXRpYmlsaXR5IHJlYXNvbnMuICBUaGlzIGlzIG5vdCB0aGUgY2FzZSB3aGVuIHBhc3NpbmcgbW9yZSB0aGFuXG4gICAqIG9uZSBhcmd1bWVudC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5pbnB1dE9wdGlvbnMoJ29wdGlvbjEnKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5pbnB1dE9wdGlvbnMoJ29wdGlvbjEnLCAnb3B0aW9uMicpO1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLmlucHV0T3B0aW9ucyhbJ29wdGlvbjEnLCAnb3B0aW9uMiddKTtcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2lucHV0T3B0aW9uc1xuICAgKiBAY2F0ZWdvcnkgQ3VzdG9tIG9wdGlvbnNcbiAgICogQGFsaWFzZXMgYWRkSW5wdXRPcHRpb24sYWRkSW5wdXRPcHRpb25zLHdpdGhJbnB1dE9wdGlvbix3aXRoSW5wdXRPcHRpb25zLGlucHV0T3B0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7Li4uU3RyaW5nfSBvcHRpb25zIG9wdGlvbiBzdHJpbmcocykgb3Igc3RyaW5nIGFycmF5XG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8uYWRkSW5wdXRPcHRpb24gPVxuICBwcm90by5hZGRJbnB1dE9wdGlvbnMgPVxuICBwcm90by53aXRoSW5wdXRPcHRpb24gPVxuICBwcm90by53aXRoSW5wdXRPcHRpb25zID1cbiAgcHJvdG8uaW5wdXRPcHRpb24gPVxuICBwcm90by5pbnB1dE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50SW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgdmFyIGRvU3BsaXQgPSB0cnVlO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBvcHRpb25zID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZG9TcGxpdCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgb3B0aW9ucyA9IFtvcHRpb25zXTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50SW5wdXQub3B0aW9ucyhvcHRpb25zLnJlZHVjZShmdW5jdGlvbihvcHRpb25zLCBvcHRpb24pIHtcbiAgICAgIHZhciBzcGxpdCA9IFN0cmluZyhvcHRpb24pLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChkb1NwbGl0ICYmIHNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICBvcHRpb25zLnB1c2goc3BsaXRbMF0sIHNwbGl0WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LCBbXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEFkZCBjdXN0b20gb3V0cHV0IG9wdGlvbihzKVxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBjb21tYW5kLm91dHB1dE9wdGlvbnMoJ29wdGlvbjEnKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5vdXRwdXRPcHRpb25zKCdvcHRpb24xJywgJ29wdGlvbjInKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC5vdXRwdXRPcHRpb25zKFsnb3B0aW9uMScsICdvcHRpb24yJ10pO1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjb3V0cHV0T3B0aW9uc1xuICAgKiBAY2F0ZWdvcnkgQ3VzdG9tIG9wdGlvbnNcbiAgICogQGFsaWFzZXMgYWRkT3V0cHV0T3B0aW9uLGFkZE91dHB1dE9wdGlvbnMsYWRkT3B0aW9uLGFkZE9wdGlvbnMsd2l0aE91dHB1dE9wdGlvbix3aXRoT3V0cHV0T3B0aW9ucyx3aXRoT3B0aW9uLHdpdGhPcHRpb25zLG91dHB1dE9wdGlvblxuICAgKlxuICAgKiBAcGFyYW0gey4uLlN0cmluZ30gb3B0aW9ucyBvcHRpb24gc3RyaW5nKHMpIG9yIHN0cmluZyBhcnJheVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmFkZE91dHB1dE9wdGlvbiA9XG4gIHByb3RvLmFkZE91dHB1dE9wdGlvbnMgPVxuICBwcm90by5hZGRPcHRpb24gPVxuICBwcm90by5hZGRPcHRpb25zID1cbiAgcHJvdG8ud2l0aE91dHB1dE9wdGlvbiA9XG4gIHByb3RvLndpdGhPdXRwdXRPcHRpb25zID1cbiAgcHJvdG8ud2l0aE9wdGlvbiA9XG4gIHByb3RvLndpdGhPcHRpb25zID1cbiAgcHJvdG8ub3V0cHV0T3B0aW9uID1cbiAgcHJvdG8ub3V0cHV0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgZG9TcGxpdCA9IHRydWU7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIG9wdGlvbnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBkb1NwbGl0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgICBvcHRpb25zID0gW29wdGlvbnNdO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQub3B0aW9ucyhvcHRpb25zLnJlZHVjZShmdW5jdGlvbihvcHRpb25zLCBvcHRpb24pIHtcbiAgICAgIHZhciBzcGxpdCA9IFN0cmluZyhvcHRpb24pLnNwbGl0KCcgJyk7XG5cbiAgICAgIGlmIChkb1NwbGl0ICYmIHNwbGl0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICBvcHRpb25zLnB1c2goc3BsaXRbMF0sIHNwbGl0WzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMucHVzaChvcHRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9LCBbXSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBjb21wbGV4IGZpbHRlcmdyYXBoXG4gICAqXG4gICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBvdmVycmlkZSBhbnkgcHJldmlvdXNseSBzZXQgZmlsdGVyZ3JhcGgsIGJ1dCB5b3UgY2FuIHNldFxuICAgKiBhcyBtYW55IGZpbHRlcnMgYXMgbmVlZGVkIGluIG9uZSBjYWxsLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5PdmVybGF5IGFuIGltYWdlIG92ZXIgYSB2aWRlbyAodXNpbmcgYSBmaWx0ZXJncmFwaCBzdHJpbmcpPC9jYXB0aW9uPlxuICAgKiAgIGZmbXBlZygpXG4gICAqICAgICAuaW5wdXQoJ3ZpZGVvLmF2aScpXG4gICAqICAgICAuaW5wdXQoJ2ltYWdlLnBuZycpXG4gICAqICAgICAuY29tcGxleEZpbHRlcignWzA6dl1bMTp2XW92ZXJsYXlbb3V0XScsIFsnb3V0J10pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5PdmVybGF5IGFuIGltYWdlIG92ZXIgYSB2aWRlbyAodXNpbmcgYSBmaWx0ZXIgYXJyYXkpPC9jYXB0aW9uPlxuICAgKiAgIGZmbXBlZygpXG4gICAqICAgICAuaW5wdXQoJ3ZpZGVvLmF2aScpXG4gICAqICAgICAuaW5wdXQoJ2ltYWdlLnBuZycpXG4gICAqICAgICAuY29tcGxleEZpbHRlcihbe1xuICAgKiAgICAgICBmaWx0ZXI6ICdvdmVybGF5JyxcbiAgICogICAgICAgaW5wdXRzOiBbJzA6dicsICcxOnYnXSxcbiAgICogICAgICAgb3V0cHV0czogWydvdXQnXVxuICAgKiAgICAgfV0sIFsnb3V0J10pO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TcGxpdCB2aWRlbyBpbnRvIFJHQiBjaGFubmVscyBhbmQgb3V0cHV0IGEgM3gxIHZpZGVvIHdpdGggY2hhbm5lbHMgc2lkZSB0byBzaWRlPC9jYXB0aW9uPlxuICAgKiAgZmZtcGVnKClcbiAgICogICAgLmlucHV0KCd2aWRlby5hdmknKVxuICAgKiAgICAuY29tcGxleEZpbHRlcihbXG4gICAqICAgICAgLy8gRHVwbGljYXRlIHZpZGVvIHN0cmVhbSAzIHRpbWVzIGludG8gc3RyZWFtcyBhLCBiLCBhbmQgY1xuICAgKiAgICAgIHsgZmlsdGVyOiAnc3BsaXQnLCBvcHRpb25zOiAnMycsIG91dHB1dHM6IFsnYScsICdiJywgJ2MnXSB9LFxuICAgKlxuICAgKiAgICAgIC8vIENyZWF0ZSBzdHJlYW0gJ3JlZCcgYnkgY2FuY2VsbGluZyBncmVlbiBhbmQgYmx1ZSBjaGFubmVscyBmcm9tIHN0cmVhbSAnYSdcbiAgICogICAgICB7IGZpbHRlcjogJ2x1dHJnYicsIG9wdGlvbnM6IHsgZzogMCwgYjogMCB9LCBpbnB1dHM6ICdhJywgb3V0cHV0czogJ3JlZCcgfSxcbiAgICpcbiAgICogICAgICAvLyBDcmVhdGUgc3RyZWFtICdncmVlbicgYnkgY2FuY2VsbGluZyByZWQgYW5kIGJsdWUgY2hhbm5lbHMgZnJvbSBzdHJlYW0gJ2InXG4gICAqICAgICAgeyBmaWx0ZXI6ICdsdXRyZ2InLCBvcHRpb25zOiB7IHI6IDAsIGI6IDAgfSwgaW5wdXRzOiAnYicsIG91dHB1dHM6ICdncmVlbicgfSxcbiAgICpcbiAgICogICAgICAvLyBDcmVhdGUgc3RyZWFtICdibHVlJyBieSBjYW5jZWxsaW5nIHJlZCBhbmQgZ3JlZW4gY2hhbm5lbHMgZnJvbSBzdHJlYW0gJ2MnXG4gICAqICAgICAgeyBmaWx0ZXI6ICdsdXRyZ2InLCBvcHRpb25zOiB7IHI6IDAsIGc6IDAgfSwgaW5wdXRzOiAnYycsIG91dHB1dHM6ICdibHVlJyB9LFxuICAgKlxuICAgKiAgICAgIC8vIFBhZCBzdHJlYW0gJ3JlZCcgdG8gM3ggd2lkdGgsIGtlZXBpbmcgdGhlIHZpZGVvIG9uIHRoZSBsZWZ0LCBhbmQgbmFtZSBvdXRwdXQgJ3BhZGRlZCdcbiAgICogICAgICB7IGZpbHRlcjogJ3BhZCcsIG9wdGlvbnM6IHsgdzogJ2l3KjMnLCBoOiAnaWgnIH0sIGlucHV0czogJ3JlZCcsIG91dHB1dHM6ICdwYWRkZWQnIH0sXG4gICAqXG4gICAqICAgICAgLy8gT3ZlcmxheSAnZ3JlZW4nIG9udG8gJ3BhZGRlZCcsIG1vdmluZyBpdCB0byB0aGUgY2VudGVyLCBhbmQgbmFtZSBvdXRwdXQgJ3JlZGdyZWVuJ1xuICAgKiAgICAgIHsgZmlsdGVyOiAnb3ZlcmxheScsIG9wdGlvbnM6IHsgeDogJ3cnLCB5OiAwIH0sIGlucHV0czogWydwYWRkZWQnLCAnZ3JlZW4nXSwgb3V0cHV0czogJ3JlZGdyZWVuJ30sXG4gICAqXG4gICAqICAgICAgLy8gT3ZlcmxheSAnYmx1ZScgb250byAncmVkZ3JlZW4nLCBtb3ZpbmcgaXQgdG8gdGhlIHJpZ2h0XG4gICAqICAgICAgeyBmaWx0ZXI6ICdvdmVybGF5Jywgb3B0aW9uczogeyB4OiAnMip3JywgeTogMCB9LCBpbnB1dHM6IFsncmVkZ3JlZW4nLCAnYmx1ZSddfSxcbiAgICogICAgXSk7XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNjb21wbGV4RmlsdGVyXG4gICAqIEBjYXRlZ29yeSBDdXN0b20gb3B0aW9uc1xuICAgKiBAYWxpYXNlcyBmaWx0ZXJHcmFwaFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gc3BlYyBmaWx0ZXJncmFwaCBzdHJpbmcgb3IgYXJyYXkgb2YgZmlsdGVyIHNwZWNpZmljYXRpb25cbiAgICogICBvYmplY3RzLCBlYWNoIGhhdmluZyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzcGVjLmZpbHRlciBmaWx0ZXIgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3NwZWMuaW5wdXRzXSAoYXJyYXkgb2YpIGlucHV0IHN0cmVhbSBzcGVjaWZpZXIocykgZm9yIHRoZSBmaWx0ZXIsXG4gICAqICAgZGVmYXVsdHMgdG8gZmZtcGVnIGF1dG9tYXRpY2FsbHkgY2hvb3NpbmcgdGhlIGZpcnN0IHVudXNlZCBtYXRjaGluZyBzdHJlYW1zXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbc3BlYy5vdXRwdXRzXSAoYXJyYXkgb2YpIG91dHB1dCBzdHJlYW0gc3BlY2lmaWVyKHMpIGZvciB0aGUgZmlsdGVyLFxuICAgKiAgIGRlZmF1bHRzIHRvIGZmbXBlZyBhdXRvbWF0aWNhbGx5IGFzc2lnbmluZyB0aGUgb3V0cHV0IHRvIHRoZSBvdXRwdXQgZmlsZVxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd8QXJyYXl9IFtzcGVjLm9wdGlvbnNdIGZpbHRlciBvcHRpb25zLCBjYW4gYmUgb21pdHRlZCB0byBub3Qgc2V0IGFueSBvcHRpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl9IFttYXBdIChhcnJheSBvZikgc3RyZWFtIHNwZWNpZmllcihzKSBmcm9tIHRoZSBncmFwaCB0byBpbmNsdWRlIGluXG4gICAqICAgZmZtcGVnIG91dHB1dCwgZGVmYXVsdHMgdG8gZmZtcGVnIGF1dG9tYXRpY2FsbHkgY2hvb3NpbmcgdGhlIGZpcnN0IG1hdGNoaW5nIHN0cmVhbXMuXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8uZmlsdGVyR3JhcGggPVxuICBwcm90by5jb21wbGV4RmlsdGVyID0gZnVuY3Rpb24oc3BlYywgbWFwKSB7XG4gICAgdGhpcy5fY29tcGxleEZpbHRlcnMuY2xlYXIoKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShzcGVjKSkge1xuICAgICAgc3BlYyA9IFtzcGVjXTtcbiAgICB9XG5cbiAgICB0aGlzLl9jb21wbGV4RmlsdGVycygnLWZpbHRlcl9jb21wbGV4JywgdXRpbHMubWFrZUZpbHRlclN0cmluZ3Moc3BlYykuam9pbignOycpKTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KG1hcCkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHN0cmVhbVNwZWMpIHtcbiAgICAgICAgc2VsZi5fY29tcGxleEZpbHRlcnMoJy1tYXAnLCBzdHJlYW1TcGVjLnJlcGxhY2UodXRpbHMuc3RyZWFtUmVnZXhwLCAnWyQxXScpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbXBsZXhGaWx0ZXJzKCctbWFwJywgbWFwLnJlcGxhY2UodXRpbHMuc3RyZWFtUmVnZXhwLCAnWyQxXScpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/custom.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/inputs.js":
/*!**********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/inputs.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n/*\n *! Input-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add an input to command\n   *\n   * Also switches \"current input\", that is the input that will be affected\n   * by subsequent input-related methods.\n   *\n   * Note: only one stream input is supported for now.\n   *\n   * @method FfmpegCommand#input\n   * @category Input\n   * @aliases mergeAdd,addInput\n   *\n   * @param {String|Readable} source input file path or readable stream\n   * @return FfmpegCommand\n   */\n  proto.mergeAdd =\n  proto.addInput =\n  proto.input = function(source) {\n    var isFile = false;\n    var isStream = false;\n\n    if (typeof source !== 'string') {\n      if (!('readable' in source) || !(source.readable)) {\n        throw new Error('Invalid input');\n      }\n\n      var hasInputStream = this._inputs.some(function(input) {\n        return input.isStream;\n      });\n\n      if (hasInputStream) {\n        throw new Error('Only one input stream is supported');\n      }\n\n      isStream = true;\n      source.pause();\n    } else {\n      var protocol = source.match(/^([a-z]{2,}):/i);\n      isFile = !protocol || protocol[0] === 'file';\n    }\n\n    this._inputs.push(this._currentInput = {\n      source: source,\n      isFile: isFile,\n      isStream: isStream,\n      options: utils.args()\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Specify input format for the last specified input\n   *\n   * @method FfmpegCommand#inputFormat\n   * @category Input\n   * @aliases withInputFormat,fromFormat\n   *\n   * @param {String} format input format\n   * @return FfmpegCommand\n   */\n  proto.withInputFormat =\n  proto.inputFormat =\n  proto.fromFormat = function(format) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-f', format);\n    return this;\n  };\n\n\n  /**\n   * Specify input FPS for the last specified input\n   * (only valid for raw video formats)\n   *\n   * @method FfmpegCommand#inputFps\n   * @category Input\n   * @aliases withInputFps,withInputFPS,withFpsInput,withFPSInput,inputFPS,inputFps,fpsInput\n   *\n   * @param {Number} fps input FPS\n   * @return FfmpegCommand\n   */\n  proto.withInputFps =\n  proto.withInputFPS =\n  proto.withFpsInput =\n  proto.withFPSInput =\n  proto.inputFPS =\n  proto.inputFps =\n  proto.fpsInput =\n  proto.FPSInput = function(fps) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-r', fps);\n    return this;\n  };\n\n\n  /**\n   * Use native framerate for the last specified input\n   *\n   * @method FfmpegCommand#native\n   * @category Input\n   * @aliases nativeFramerate,withNativeFramerate\n   *\n   * @return FfmmegCommand\n   */\n  proto.nativeFramerate =\n  proto.withNativeFramerate =\n  proto.native = function() {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-re');\n    return this;\n  };\n\n\n  /**\n   * Specify input seek time for the last specified input\n   *\n   * @method FfmpegCommand#seekInput\n   * @category Input\n   * @aliases setStartTime,seekTo\n   *\n   * @param {String|Number} seek seek time in seconds or as a '[hh:[mm:]]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.setStartTime =\n  proto.seekInput = function(seek) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-ss', seek);\n\n    return this;\n  };\n\n\n  /**\n   * Loop over the last specified input\n   *\n   * @method FfmpegCommand#loop\n   * @category Input\n   *\n   * @param {String|Number} [duration] loop duration in seconds or as a '[[hh:]mm:]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.loop = function(duration) {\n    if (!this._currentInput) {\n      throw new Error('No input specified');\n    }\n\n    this._currentInput.options('-loop', '1');\n\n    if (typeof duration !== 'undefined') {\n      this.duration(duration);\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9pbnB1dHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUVBQVU7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJDQUEyQyxHQUFHO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9pbnB1dHMuanM/ZjdkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKlxuICohIElucHV0LXJlbGF0ZWQgbWV0aG9kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLyoqXG4gICAqIEFkZCBhbiBpbnB1dCB0byBjb21tYW5kXG4gICAqXG4gICAqIEFsc28gc3dpdGNoZXMgXCJjdXJyZW50IGlucHV0XCIsIHRoYXQgaXMgdGhlIGlucHV0IHRoYXQgd2lsbCBiZSBhZmZlY3RlZFxuICAgKiBieSBzdWJzZXF1ZW50IGlucHV0LXJlbGF0ZWQgbWV0aG9kcy5cbiAgICpcbiAgICogTm90ZTogb25seSBvbmUgc3RyZWFtIGlucHV0IGlzIHN1cHBvcnRlZCBmb3Igbm93LlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjaW5wdXRcbiAgICogQGNhdGVnb3J5IElucHV0XG4gICAqIEBhbGlhc2VzIG1lcmdlQWRkLGFkZElucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFJlYWRhYmxlfSBzb3VyY2UgaW5wdXQgZmlsZSBwYXRoIG9yIHJlYWRhYmxlIHN0cmVhbVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLm1lcmdlQWRkID1cbiAgcHJvdG8uYWRkSW5wdXQgPVxuICBwcm90by5pbnB1dCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgIHZhciBpc0ZpbGUgPSBmYWxzZTtcbiAgICB2YXIgaXNTdHJlYW0gPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKCEoJ3JlYWRhYmxlJyBpbiBzb3VyY2UpIHx8ICEoc291cmNlLnJlYWRhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0lucHV0U3RyZWFtID0gdGhpcy5faW5wdXRzLnNvbWUoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0LmlzU3RyZWFtO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChoYXNJbnB1dFN0cmVhbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgb25lIGlucHV0IHN0cmVhbSBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cblxuICAgICAgaXNTdHJlYW0gPSB0cnVlO1xuICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHNvdXJjZS5tYXRjaCgvXihbYS16XXsyLH0pOi9pKTtcbiAgICAgIGlzRmlsZSA9ICFwcm90b2NvbCB8fCBwcm90b2NvbFswXSA9PT0gJ2ZpbGUnO1xuICAgIH1cblxuICAgIHRoaXMuX2lucHV0cy5wdXNoKHRoaXMuX2N1cnJlbnRJbnB1dCA9IHtcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgaXNGaWxlOiBpc0ZpbGUsXG4gICAgICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gICAgICBvcHRpb25zOiB1dGlscy5hcmdzKClcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgaW5wdXQgZm9ybWF0IGZvciB0aGUgbGFzdCBzcGVjaWZpZWQgaW5wdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2lucHV0Rm9ybWF0XG4gICAqIEBjYXRlZ29yeSBJbnB1dFxuICAgKiBAYWxpYXNlcyB3aXRoSW5wdXRGb3JtYXQsZnJvbUZvcm1hdFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9ybWF0IGlucHV0IGZvcm1hdFxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhJbnB1dEZvcm1hdCA9XG4gIHByb3RvLmlucHV0Rm9ybWF0ID1cbiAgcHJvdG8uZnJvbUZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdCkge1xuICAgIGlmICghdGhpcy5fY3VycmVudElucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRJbnB1dC5vcHRpb25zKCctZicsIGZvcm1hdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSBpbnB1dCBGUFMgZm9yIHRoZSBsYXN0IHNwZWNpZmllZCBpbnB1dFxuICAgKiAob25seSB2YWxpZCBmb3IgcmF3IHZpZGVvIGZvcm1hdHMpXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNpbnB1dEZwc1xuICAgKiBAY2F0ZWdvcnkgSW5wdXRcbiAgICogQGFsaWFzZXMgd2l0aElucHV0RnBzLHdpdGhJbnB1dEZQUyx3aXRoRnBzSW5wdXQsd2l0aEZQU0lucHV0LGlucHV0RlBTLGlucHV0RnBzLGZwc0lucHV0XG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcHMgaW5wdXQgRlBTXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aElucHV0RnBzID1cbiAgcHJvdG8ud2l0aElucHV0RlBTID1cbiAgcHJvdG8ud2l0aEZwc0lucHV0ID1cbiAgcHJvdG8ud2l0aEZQU0lucHV0ID1cbiAgcHJvdG8uaW5wdXRGUFMgPVxuICBwcm90by5pbnB1dEZwcyA9XG4gIHByb3RvLmZwc0lucHV0ID1cbiAgcHJvdG8uRlBTSW5wdXQgPSBmdW5jdGlvbihmcHMpIHtcbiAgICBpZiAoIXRoaXMuX2N1cnJlbnRJbnB1dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnB1dCBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jdXJyZW50SW5wdXQub3B0aW9ucygnLXInLCBmcHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFVzZSBuYXRpdmUgZnJhbWVyYXRlIGZvciB0aGUgbGFzdCBzcGVjaWZpZWQgaW5wdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI25hdGl2ZVxuICAgKiBAY2F0ZWdvcnkgSW5wdXRcbiAgICogQGFsaWFzZXMgbmF0aXZlRnJhbWVyYXRlLHdpdGhOYXRpdmVGcmFtZXJhdGVcbiAgICpcbiAgICogQHJldHVybiBGZm1tZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5uYXRpdmVGcmFtZXJhdGUgPVxuICBwcm90by53aXRoTmF0aXZlRnJhbWVyYXRlID1cbiAgcHJvdG8ubmF0aXZlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50SW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudElucHV0Lm9wdGlvbnMoJy1yZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgaW5wdXQgc2VlayB0aW1lIGZvciB0aGUgbGFzdCBzcGVjaWZpZWQgaW5wdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NlZWtJbnB1dFxuICAgKiBAY2F0ZWdvcnkgSW5wdXRcbiAgICogQGFsaWFzZXMgc2V0U3RhcnRUaW1lLHNlZWtUb1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNlZWsgc2VlayB0aW1lIGluIHNlY29uZHMgb3IgYXMgYSAnW2hoOlttbTpdXXNzWy54eHhdJyBzdHJpbmdcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5zZXRTdGFydFRpbWUgPVxuICBwcm90by5zZWVrSW5wdXQgPSBmdW5jdGlvbihzZWVrKSB7XG4gICAgaWYgKCF0aGlzLl9jdXJyZW50SW5wdXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQgc3BlY2lmaWVkJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudElucHV0Lm9wdGlvbnMoJy1zcycsIHNlZWspO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogTG9vcCBvdmVyIHRoZSBsYXN0IHNwZWNpZmllZCBpbnB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjbG9vcFxuICAgKiBAY2F0ZWdvcnkgSW5wdXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbZHVyYXRpb25dIGxvb3AgZHVyYXRpb24gaW4gc2Vjb25kcyBvciBhcyBhICdbW2hoOl1tbTpdc3NbLnh4eF0nIHN0cmluZ1xuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmxvb3AgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIGlmICghdGhpcy5fY3VycmVudElucHV0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGlucHV0IHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRJbnB1dC5vcHRpb25zKCctbG9vcCcsICcxJyk7XG5cbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5kdXJhdGlvbihkdXJhdGlvbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/inputs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/misc.js":
/*!********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/misc.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar path = __webpack_require__(/*! path */ \"path\");\n\n/*\n *! Miscellaneous methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Use preset\n   *\n   * @method FfmpegCommand#preset\n   * @category Miscellaneous\n   * @aliases usingPreset\n   *\n   * @param {String|Function} preset preset name or preset function\n   */\n  proto.usingPreset =\n  proto.preset = function(preset) {\n    if (typeof preset === 'function') {\n      preset(this);\n    } else {\n      try {\n        var modulePath = path.join(this.options.presets, preset);\n        var module = __webpack_require__(\"(rsc)/./node_modules/fluent-ffmpeg/lib/options sync recursive\")(modulePath);\n\n        if (typeof module.load === 'function') {\n          module.load(this);\n        } else {\n          throw new Error('preset ' + modulePath + ' has no load() function');\n        }\n      } catch (err) {\n        throw new Error('preset ' + modulePath + ' could not be loaded: ' + err.message);\n      }\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9taXNjLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQixxRkFBUSxVQUFVLENBQUM7O0FBRXhDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL29wdGlvbnMvbWlzYy5qcz9jMTdmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG4vKlxuICohIE1pc2NlbGxhbmVvdXMgbWV0aG9kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocHJvdG8pIHtcbiAgLyoqXG4gICAqIFVzZSBwcmVzZXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3ByZXNldFxuICAgKiBAY2F0ZWdvcnkgTWlzY2VsbGFuZW91c1xuICAgKiBAYWxpYXNlcyB1c2luZ1ByZXNldFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcHJlc2V0IHByZXNldCBuYW1lIG9yIHByZXNldCBmdW5jdGlvblxuICAgKi9cbiAgcHJvdG8udXNpbmdQcmVzZXQgPVxuICBwcm90by5wcmVzZXQgPSBmdW5jdGlvbihwcmVzZXQpIHtcbiAgICBpZiAodHlwZW9mIHByZXNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJlc2V0KHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgbW9kdWxlUGF0aCA9IHBhdGguam9pbih0aGlzLm9wdGlvbnMucHJlc2V0cywgcHJlc2V0KTtcbiAgICAgICAgdmFyIG1vZHVsZSA9IHJlcXVpcmUobW9kdWxlUGF0aCk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG1vZHVsZS5sb2FkKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJlc2V0ICcgKyBtb2R1bGVQYXRoICsgJyBoYXMgbm8gbG9hZCgpIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXNldCAnICsgbW9kdWxlUGF0aCArICcgY291bGQgbm90IGJlIGxvYWRlZDogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/misc.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/output.js":
/*!**********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/output.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Output-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Add output\n   *\n   * @method FfmpegCommand#output\n   * @category Output\n   * @aliases addOutput\n   *\n   * @param {String|Writable} target target file path or writable stream\n   * @param {Object} [pipeopts={}] pipe options (only applies to streams)\n   * @return FfmpegCommand\n   */\n  proto.addOutput =\n  proto.output = function(target, pipeopts) {\n    var isFile = false;\n\n    if (!target && this._currentOutput) {\n      // No target is only allowed when called from constructor\n      throw new Error('Invalid output');\n    }\n\n    if (target && typeof target !== 'string') {\n      if (!('writable' in target) || !(target.writable)) {\n        throw new Error('Invalid output');\n      }\n    } else if (typeof target === 'string') {\n      var protocol = target.match(/^([a-z]{2,}):/i);\n      isFile = !protocol || protocol[0] === 'file';\n    }\n\n    if (target && !('target' in this._currentOutput)) {\n      // For backwards compatibility, set target for first output\n      this._currentOutput.target = target;\n      this._currentOutput.isFile = isFile;\n      this._currentOutput.pipeopts = pipeopts || {};\n    } else {\n      if (target && typeof target !== 'string') {\n        var hasOutputStream = this._outputs.some(function(output) {\n          return typeof output.target !== 'string';\n        });\n\n        if (hasOutputStream) {\n          throw new Error('Only one output stream is supported');\n        }\n      }\n\n      this._outputs.push(this._currentOutput = {\n        target: target,\n        isFile: isFile,\n        flags: {},\n        pipeopts: pipeopts || {}\n      });\n\n      var self = this;\n      ['audio', 'audioFilters', 'video', 'videoFilters', 'sizeFilters', 'options'].forEach(function(key) {\n        self._currentOutput[key] = utils.args();\n      });\n\n      if (!target) {\n        // Call from constructor: remove target key\n        delete this._currentOutput.target;\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Specify output seek time\n   *\n   * @method FfmpegCommand#seek\n   * @category Input\n   * @aliases seekOutput\n   *\n   * @param {String|Number} seek seek time in seconds or as a '[hh:[mm:]]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.seekOutput =\n  proto.seek = function(seek) {\n    this._currentOutput.options('-ss', seek);\n    return this;\n  };\n\n\n  /**\n   * Set output duration\n   *\n   * @method FfmpegCommand#duration\n   * @category Output\n   * @aliases withDuration,setDuration\n   *\n   * @param {String|Number} duration duration in seconds or as a '[[hh:]mm:]ss[.xxx]' string\n   * @return FfmpegCommand\n   */\n  proto.withDuration =\n  proto.setDuration =\n  proto.duration = function(duration) {\n    this._currentOutput.options('-t', duration);\n    return this;\n  };\n\n\n  /**\n   * Set output format\n   *\n   * @method FfmpegCommand#format\n   * @category Output\n   * @aliases toFormat,withOutputFormat,outputFormat\n   *\n   * @param {String} format output format name\n   * @return FfmpegCommand\n   */\n  proto.toFormat =\n  proto.withOutputFormat =\n  proto.outputFormat =\n  proto.format = function(format) {\n    this._currentOutput.options('-f', format);\n    return this;\n  };\n\n\n  /**\n   * Add stream mapping to output\n   *\n   * @method FfmpegCommand#map\n   * @category Output\n   *\n   * @param {String} spec stream specification string, with optional square brackets\n   * @return FfmpegCommand\n   */\n  proto.map = function(spec) {\n    this._currentOutput.options('-map', spec.replace(utils.streamRegexp, '[$1]'));\n    return this;\n  };\n\n\n  /**\n   * Run flvtool2/flvmeta on output\n   *\n   * @method FfmpegCommand#flvmeta\n   * @category Output\n   * @aliases updateFlvMetadata\n   *\n   * @return FfmpegCommand\n   */\n  proto.updateFlvMetadata =\n  proto.flvmeta = function() {\n    this._currentOutput.flags.flvmeta = true;\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy9vdXRwdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUVBQVU7OztBQUc5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUSxZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL29wdGlvbnMvb3V0cHV0LmpzPzFiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLypqc2hpbnQgbm9kZTp0cnVlKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuXG4vKlxuICohIE91dHB1dC1yZWxhdGVkIG1ldGhvZHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8qKlxuICAgKiBBZGQgb3V0cHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNvdXRwdXRcbiAgICogQGNhdGVnb3J5IE91dHB1dFxuICAgKiBAYWxpYXNlcyBhZGRPdXRwdXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8V3JpdGFibGV9IHRhcmdldCB0YXJnZXQgZmlsZSBwYXRoIG9yIHdyaXRhYmxlIHN0cmVhbVxuICAgKiBAcGFyYW0ge09iamVjdH0gW3BpcGVvcHRzPXt9XSBwaXBlIG9wdGlvbnMgKG9ubHkgYXBwbGllcyB0byBzdHJlYW1zKVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmFkZE91dHB1dCA9XG4gIHByb3RvLm91dHB1dCA9IGZ1bmN0aW9uKHRhcmdldCwgcGlwZW9wdHMpIHtcbiAgICB2YXIgaXNGaWxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXRhcmdldCAmJiB0aGlzLl9jdXJyZW50T3V0cHV0KSB7XG4gICAgICAvLyBObyB0YXJnZXQgaXMgb25seSBhbGxvd2VkIHdoZW4gY2FsbGVkIGZyb20gY29uc3RydWN0b3JcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvdXRwdXQnKTtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoISgnd3JpdGFibGUnIGluIHRhcmdldCkgfHwgISh0YXJnZXQud3JpdGFibGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvdXRwdXQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB0YXJnZXQubWF0Y2goL14oW2Etel17Mix9KTovaSk7XG4gICAgICBpc0ZpbGUgPSAhcHJvdG9jb2wgfHwgcHJvdG9jb2xbMF0gPT09ICdmaWxlJztcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0ICYmICEoJ3RhcmdldCcgaW4gdGhpcy5fY3VycmVudE91dHB1dCkpIHtcbiAgICAgIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgc2V0IHRhcmdldCBmb3IgZmlyc3Qgb3V0cHV0XG4gICAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnRhcmdldCA9IHRhcmdldDtcbiAgICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuaXNGaWxlID0gaXNGaWxlO1xuICAgICAgdGhpcy5fY3VycmVudE91dHB1dC5waXBlb3B0cyA9IHBpcGVvcHRzIHx8IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBoYXNPdXRwdXRTdHJlYW0gPSB0aGlzLl9vdXRwdXRzLnNvbWUoZnVuY3Rpb24ob3V0cHV0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQudGFyZ2V0ICE9PSAnc3RyaW5nJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc091dHB1dFN0cmVhbSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBvbmUgb3V0cHV0IHN0cmVhbSBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9vdXRwdXRzLnB1c2godGhpcy5fY3VycmVudE91dHB1dCA9IHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgIGlzRmlsZTogaXNGaWxlLFxuICAgICAgICBmbGFnczoge30sXG4gICAgICAgIHBpcGVvcHRzOiBwaXBlb3B0cyB8fCB7fVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIFsnYXVkaW8nLCAnYXVkaW9GaWx0ZXJzJywgJ3ZpZGVvJywgJ3ZpZGVvRmlsdGVycycsICdzaXplRmlsdGVycycsICdvcHRpb25zJ10uZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgc2VsZi5fY3VycmVudE91dHB1dFtrZXldID0gdXRpbHMuYXJncygpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIC8vIENhbGwgZnJvbSBjb25zdHJ1Y3RvcjogcmVtb3ZlIHRhcmdldCBrZXlcbiAgICAgICAgZGVsZXRlIHRoaXMuX2N1cnJlbnRPdXRwdXQudGFyZ2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgb3V0cHV0IHNlZWsgdGltZVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjc2Vla1xuICAgKiBAY2F0ZWdvcnkgSW5wdXRcbiAgICogQGFsaWFzZXMgc2Vla091dHB1dFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHNlZWsgc2VlayB0aW1lIGluIHNlY29uZHMgb3IgYXMgYSAnW2hoOlttbTpdXXNzWy54eHhdJyBzdHJpbmdcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5zZWVrT3V0cHV0ID1cbiAgcHJvdG8uc2VlayA9IGZ1bmN0aW9uKHNlZWspIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0Lm9wdGlvbnMoJy1zcycsIHNlZWspO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCBvdXRwdXQgZHVyYXRpb25cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2R1cmF0aW9uXG4gICAqIEBjYXRlZ29yeSBPdXRwdXRcbiAgICogQGFsaWFzZXMgd2l0aER1cmF0aW9uLHNldER1cmF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gZHVyYXRpb24gZHVyYXRpb24gaW4gc2Vjb25kcyBvciBhcyBhICdbW2hoOl1tbTpdc3NbLnh4eF0nIHN0cmluZ1xuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhEdXJhdGlvbiA9XG4gIHByb3RvLnNldER1cmF0aW9uID1cbiAgcHJvdG8uZHVyYXRpb24gPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQub3B0aW9ucygnLXQnLCBkdXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU2V0IG91dHB1dCBmb3JtYXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2Zvcm1hdFxuICAgKiBAY2F0ZWdvcnkgT3V0cHV0XG4gICAqIEBhbGlhc2VzIHRvRm9ybWF0LHdpdGhPdXRwdXRGb3JtYXQsb3V0cHV0Rm9ybWF0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb3JtYXQgb3V0cHV0IGZvcm1hdCBuYW1lXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8udG9Gb3JtYXQgPVxuICBwcm90by53aXRoT3V0cHV0Rm9ybWF0ID1cbiAgcHJvdG8ub3V0cHV0Rm9ybWF0ID1cbiAgcHJvdG8uZm9ybWF0ID0gZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5vcHRpb25zKCctZicsIGZvcm1hdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQWRkIHN0cmVhbSBtYXBwaW5nIHRvIG91dHB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjbWFwXG4gICAqIEBjYXRlZ29yeSBPdXRwdXRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNwZWMgc3RyZWFtIHNwZWNpZmljYXRpb24gc3RyaW5nLCB3aXRoIG9wdGlvbmFsIHNxdWFyZSBicmFja2V0c1xuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLm1hcCA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0Lm9wdGlvbnMoJy1tYXAnLCBzcGVjLnJlcGxhY2UodXRpbHMuc3RyZWFtUmVnZXhwLCAnWyQxXScpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBSdW4gZmx2dG9vbDIvZmx2bWV0YSBvbiBvdXRwdXRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2Zsdm1ldGFcbiAgICogQGNhdGVnb3J5IE91dHB1dFxuICAgKiBAYWxpYXNlcyB1cGRhdGVGbHZNZXRhZGF0YVxuICAgKlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnVwZGF0ZUZsdk1ldGFkYXRhID1cbiAgcHJvdG8uZmx2bWV0YSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuZmxhZ3MuZmx2bWV0YSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/output.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/video.js":
/*!*********************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/video.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar utils = __webpack_require__(/*! ../utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n *! Video-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Disable video in the output\n   *\n   * @method FfmpegCommand#noVideo\n   * @category Video\n   * @aliases withNoVideo\n   *\n   * @return FfmpegCommand\n   */\n  proto.withNoVideo =\n  proto.noVideo = function() {\n    this._currentOutput.video.clear();\n    this._currentOutput.videoFilters.clear();\n    this._currentOutput.video('-vn');\n\n    return this;\n  };\n\n\n  /**\n   * Specify video codec\n   *\n   * @method FfmpegCommand#videoCodec\n   * @category Video\n   * @aliases withVideoCodec\n   *\n   * @param {String} codec video codec name\n   * @return FfmpegCommand\n   */\n  proto.withVideoCodec =\n  proto.videoCodec = function(codec) {\n    this._currentOutput.video('-vcodec', codec);\n    return this;\n  };\n\n\n  /**\n   * Specify video bitrate\n   *\n   * @method FfmpegCommand#videoBitrate\n   * @category Video\n   * @aliases withVideoBitrate\n   *\n   * @param {String|Number} bitrate video bitrate in kbps (with an optional 'k' suffix)\n   * @param {Boolean} [constant=false] enforce constant bitrate\n   * @return FfmpegCommand\n   */\n  proto.withVideoBitrate =\n  proto.videoBitrate = function(bitrate, constant) {\n    bitrate = ('' + bitrate).replace(/k?$/, 'k');\n\n    this._currentOutput.video('-b:v', bitrate);\n    if (constant) {\n      this._currentOutput.video(\n        '-maxrate', bitrate,\n        '-minrate', bitrate,\n        '-bufsize', '3M'\n      );\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Specify custom video filter(s)\n   *\n   * Can be called both with one or many filters, or a filter array.\n   *\n   * @example\n   * command.videoFilters('filter1');\n   *\n   * @example\n   * command.videoFilters('filter1', 'filter2=param1=value1:param2=value2');\n   *\n   * @example\n   * command.videoFilters(['filter1', 'filter2']);\n   *\n   * @example\n   * command.videoFilters([\n   *   {\n   *     filter: 'filter1'\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: 'param=value:param=value'\n   *   }\n   * ]);\n   *\n   * @example\n   * command.videoFilters(\n   *   {\n   *     filter: 'filter1',\n   *     options: ['value1', 'value2']\n   *   },\n   *   {\n   *     filter: 'filter2',\n   *     options: { param1: 'value1', param2: 'value2' }\n   *   }\n   * );\n   *\n   * @method FfmpegCommand#videoFilters\n   * @category Video\n   * @aliases withVideoFilter,withVideoFilters,videoFilter\n   *\n   * @param {...String|String[]|Object[]} filters video filter strings, string array or\n   *   filter specification array, each with the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|String[]|Object} [filters.options] filter option string, array, or object\n   * @return FfmpegCommand\n   */\n  proto.withVideoFilter =\n  proto.withVideoFilters =\n  proto.videoFilter =\n  proto.videoFilters = function(filters) {\n    if (arguments.length > 1) {\n      filters = [].slice.call(arguments);\n    }\n\n    if (!Array.isArray(filters)) {\n      filters = [filters];\n    }\n\n    this._currentOutput.videoFilters(utils.makeFilterStrings(filters));\n\n    return this;\n  };\n\n\n  /**\n   * Specify output FPS\n   *\n   * @method FfmpegCommand#fps\n   * @category Video\n   * @aliases withOutputFps,withOutputFPS,withFpsOutput,withFPSOutput,withFps,withFPS,outputFPS,outputFps,fpsOutput,FPSOutput,FPS\n   *\n   * @param {Number} fps output FPS\n   * @return FfmpegCommand\n   */\n  proto.withOutputFps =\n  proto.withOutputFPS =\n  proto.withFpsOutput =\n  proto.withFPSOutput =\n  proto.withFps =\n  proto.withFPS =\n  proto.outputFPS =\n  proto.outputFps =\n  proto.fpsOutput =\n  proto.FPSOutput =\n  proto.fps =\n  proto.FPS = function(fps) {\n    this._currentOutput.video('-r', fps);\n    return this;\n  };\n\n\n  /**\n   * Only transcode a certain number of frames\n   *\n   * @method FfmpegCommand#frames\n   * @category Video\n   * @aliases takeFrames,withFrames\n   *\n   * @param {Number} frames frame count\n   * @return FfmpegCommand\n   */\n  proto.takeFrames =\n  proto.withFrames =\n  proto.frames = function(frames) {\n    this._currentOutput.video('-vframes', frames);\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy92aWRlby5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFlBQVksbUJBQU8sQ0FBQyxpRUFBVTs7O0FBRzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL29wdGlvbnMvdmlkZW8uanM/ZDZkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5cbi8qXG4gKiEgVmlkZW8tcmVsYXRlZCBtZXRob2RzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogRGlzYWJsZSB2aWRlbyBpbiB0aGUgb3V0cHV0XG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNub1ZpZGVvXG4gICAqIEBjYXRlZ29yeSBWaWRlb1xuICAgKiBAYWxpYXNlcyB3aXRoTm9WaWRlb1xuICAgKlxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhOb1ZpZGVvID1cbiAgcHJvdG8ubm9WaWRlbyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQudmlkZW8uY2xlYXIoKTtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvRmlsdGVycy5jbGVhcigpO1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQudmlkZW8oJy12bicpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSB2aWRlbyBjb2RlY1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjdmlkZW9Db2RlY1xuICAgKiBAY2F0ZWdvcnkgVmlkZW9cbiAgICogQGFsaWFzZXMgd2l0aFZpZGVvQ29kZWNcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjIHZpZGVvIGNvZGVjIG5hbWVcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoVmlkZW9Db2RlYyA9XG4gIHByb3RvLnZpZGVvQ29kZWMgPSBmdW5jdGlvbihjb2RlYykge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQudmlkZW8oJy12Y29kZWMnLCBjb2RlYyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU3BlY2lmeSB2aWRlbyBiaXRyYXRlXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCN2aWRlb0JpdHJhdGVcbiAgICogQGNhdGVnb3J5IFZpZGVvXG4gICAqIEBhbGlhc2VzIHdpdGhWaWRlb0JpdHJhdGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBiaXRyYXRlIHZpZGVvIGJpdHJhdGUgaW4ga2JwcyAod2l0aCBhbiBvcHRpb25hbCAnaycgc3VmZml4KVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25zdGFudD1mYWxzZV0gZW5mb3JjZSBjb25zdGFudCBiaXRyYXRlXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ud2l0aFZpZGVvQml0cmF0ZSA9XG4gIHByb3RvLnZpZGVvQml0cmF0ZSA9IGZ1bmN0aW9uKGJpdHJhdGUsIGNvbnN0YW50KSB7XG4gICAgYml0cmF0ZSA9ICgnJyArIGJpdHJhdGUpLnJlcGxhY2UoL2s/JC8sICdrJyk7XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvKCctYjp2JywgYml0cmF0ZSk7XG4gICAgaWYgKGNvbnN0YW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnZpZGVvKFxuICAgICAgICAnLW1heHJhdGUnLCBiaXRyYXRlLFxuICAgICAgICAnLW1pbnJhdGUnLCBiaXRyYXRlLFxuICAgICAgICAnLWJ1ZnNpemUnLCAnM00nXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgY3VzdG9tIHZpZGVvIGZpbHRlcihzKVxuICAgKlxuICAgKiBDYW4gYmUgY2FsbGVkIGJvdGggd2l0aCBvbmUgb3IgbWFueSBmaWx0ZXJzLCBvciBhIGZpbHRlciBhcnJheS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC52aWRlb0ZpbHRlcnMoJ2ZpbHRlcjEnKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC52aWRlb0ZpbHRlcnMoJ2ZpbHRlcjEnLCAnZmlsdGVyMj1wYXJhbTE9dmFsdWUxOnBhcmFtMj12YWx1ZTInKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC52aWRlb0ZpbHRlcnMoWydmaWx0ZXIxJywgJ2ZpbHRlcjInXSk7XG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbW1hbmQudmlkZW9GaWx0ZXJzKFtcbiAgICogICB7XG4gICAqICAgICBmaWx0ZXI6ICdmaWx0ZXIxJ1xuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgZmlsdGVyOiAnZmlsdGVyMicsXG4gICAqICAgICBvcHRpb25zOiAncGFyYW09dmFsdWU6cGFyYW09dmFsdWUnXG4gICAqICAgfVxuICAgKiBdKTtcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29tbWFuZC52aWRlb0ZpbHRlcnMoXG4gICAqICAge1xuICAgKiAgICAgZmlsdGVyOiAnZmlsdGVyMScsXG4gICAqICAgICBvcHRpb25zOiBbJ3ZhbHVlMScsICd2YWx1ZTInXVxuICAgKiAgIH0sXG4gICAqICAge1xuICAgKiAgICAgZmlsdGVyOiAnZmlsdGVyMicsXG4gICAqICAgICBvcHRpb25zOiB7IHBhcmFtMTogJ3ZhbHVlMScsIHBhcmFtMjogJ3ZhbHVlMicgfVxuICAgKiAgIH1cbiAgICogKTtcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3ZpZGVvRmlsdGVyc1xuICAgKiBAY2F0ZWdvcnkgVmlkZW9cbiAgICogQGFsaWFzZXMgd2l0aFZpZGVvRmlsdGVyLHdpdGhWaWRlb0ZpbHRlcnMsdmlkZW9GaWx0ZXJcbiAgICpcbiAgICogQHBhcmFtIHsuLi5TdHJpbmd8U3RyaW5nW118T2JqZWN0W119IGZpbHRlcnMgdmlkZW8gZmlsdGVyIHN0cmluZ3MsIHN0cmluZyBhcnJheSBvclxuICAgKiAgIGZpbHRlciBzcGVjaWZpY2F0aW9uIGFycmF5LCBlYWNoIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsdGVycy5maWx0ZXIgZmlsdGVyIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd8U3RyaW5nW118T2JqZWN0fSBbZmlsdGVycy5vcHRpb25zXSBmaWx0ZXIgb3B0aW9uIHN0cmluZywgYXJyYXksIG9yIG9iamVjdFxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhWaWRlb0ZpbHRlciA9XG4gIHByb3RvLndpdGhWaWRlb0ZpbHRlcnMgPVxuICBwcm90by52aWRlb0ZpbHRlciA9XG4gIHByb3RvLnZpZGVvRmlsdGVycyA9IGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZpbHRlcnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpbHRlcnMpKSB7XG4gICAgICBmaWx0ZXJzID0gW2ZpbHRlcnNdO1xuICAgIH1cblxuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQudmlkZW9GaWx0ZXJzKHV0aWxzLm1ha2VGaWx0ZXJTdHJpbmdzKGZpbHRlcnMpKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgb3V0cHV0IEZQU1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjZnBzXG4gICAqIEBjYXRlZ29yeSBWaWRlb1xuICAgKiBAYWxpYXNlcyB3aXRoT3V0cHV0RnBzLHdpdGhPdXRwdXRGUFMsd2l0aEZwc091dHB1dCx3aXRoRlBTT3V0cHV0LHdpdGhGcHMsd2l0aEZQUyxvdXRwdXRGUFMsb3V0cHV0RnBzLGZwc091dHB1dCxGUFNPdXRwdXQsRlBTXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBmcHMgb3V0cHV0IEZQU1xuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhPdXRwdXRGcHMgPVxuICBwcm90by53aXRoT3V0cHV0RlBTID1cbiAgcHJvdG8ud2l0aEZwc091dHB1dCA9XG4gIHByb3RvLndpdGhGUFNPdXRwdXQgPVxuICBwcm90by53aXRoRnBzID1cbiAgcHJvdG8ud2l0aEZQUyA9XG4gIHByb3RvLm91dHB1dEZQUyA9XG4gIHByb3RvLm91dHB1dEZwcyA9XG4gIHByb3RvLmZwc091dHB1dCA9XG4gIHByb3RvLkZQU091dHB1dCA9XG4gIHByb3RvLmZwcyA9XG4gIHByb3RvLkZQUyA9IGZ1bmN0aW9uKGZwcykge1xuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQudmlkZW8oJy1yJywgZnBzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBPbmx5IHRyYW5zY29kZSBhIGNlcnRhaW4gbnVtYmVyIG9mIGZyYW1lc1xuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjZnJhbWVzXG4gICAqIEBjYXRlZ29yeSBWaWRlb1xuICAgKiBAYWxpYXNlcyB0YWtlRnJhbWVzLHdpdGhGcmFtZXNcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZyYW1lcyBmcmFtZSBjb3VudFxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnRha2VGcmFtZXMgPVxuICBwcm90by53aXRoRnJhbWVzID1cbiAgcHJvdG8uZnJhbWVzID0gZnVuY3Rpb24oZnJhbWVzKSB7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC52aWRlbygnLXZmcmFtZXMnLCBmcmFtZXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/video.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options/videosize.js":
/*!*************************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/videosize.js ***!
  \*************************************************************/
/***/ ((module) => {

"use strict";
eval("/*jshint node:true*/\n\n\n/*\n *! Size helpers\n */\n\n\n/**\n * Return filters to pad video to width*height,\n *\n * @param {Number} width output width\n * @param {Number} height output height\n * @param {Number} aspect video aspect ratio (without padding)\n * @param {Number} color padding color\n * @return scale/pad filters\n * @private\n */\nfunction getScalePadFilters(width, height, aspect, color) {\n  /*\n    let a be the input aspect ratio, A be the requested aspect ratio\n\n    if a > A, padding is done on top and bottom\n    if a < A, padding is done on left and right\n   */\n\n  return [\n    /*\n      In both cases, we first have to scale the input to match the requested size.\n      When using computed width/height, we truncate them to multiples of 2\n     */\n    {\n      filter: 'scale',\n      options: {\n        w: 'if(gt(a,' + aspect + '),' + width + ',trunc(' + height + '*a/2)*2)',\n        h: 'if(lt(a,' + aspect + '),' + height + ',trunc(' + width + '/a/2)*2)'\n      }\n    },\n\n    /*\n      Then we pad the scaled input to match the target size\n      (here iw and ih refer to the padding input, i.e the scaled output)\n     */\n\n    {\n      filter: 'pad',\n      options: {\n        w: width,\n        h: height,\n        x: 'if(gt(a,' + aspect + '),0,(' + width + '-iw)/2)',\n        y: 'if(lt(a,' + aspect + '),0,(' + height + '-ih)/2)',\n        color: color\n      }\n    }\n  ];\n}\n\n\n/**\n * Recompute size filters\n *\n * @param {Object} output\n * @param {String} key newly-added parameter name ('size', 'aspect' or 'pad')\n * @param {String} value newly-added parameter value\n * @return filter string array\n * @private\n */\nfunction createSizeFilters(output, key, value) {\n  // Store parameters\n  var data = output.sizeData = output.sizeData || {};\n  data[key] = value;\n\n  if (!('size' in data)) {\n    // No size requested, keep original size\n    return [];\n  }\n\n  // Try to match the different size string formats\n  var fixedSize = data.size.match(/([0-9]+)x([0-9]+)/);\n  var fixedWidth = data.size.match(/([0-9]+)x\\?/);\n  var fixedHeight = data.size.match(/\\?x([0-9]+)/);\n  var percentRatio = data.size.match(/\\b([0-9]{1,3})%/);\n  var width, height, aspect;\n\n  if (percentRatio) {\n    var ratio = Number(percentRatio[1]) / 100;\n    return [{\n      filter: 'scale',\n      options: {\n        w: 'trunc(iw*' + ratio + '/2)*2',\n        h: 'trunc(ih*' + ratio + '/2)*2'\n      }\n    }];\n  } else if (fixedSize) {\n    // Round target size to multiples of 2\n    width = Math.round(Number(fixedSize[1]) / 2) * 2;\n    height = Math.round(Number(fixedSize[2]) / 2) * 2;\n\n    aspect = width / height;\n\n    if (data.pad) {\n      return getScalePadFilters(width, height, aspect, data.pad);\n    } else {\n      // No autopad requested, rescale to target size\n      return [{ filter: 'scale', options: { w: width, h: height }}];\n    }\n  } else if (fixedWidth || fixedHeight) {\n    if ('aspect' in data) {\n      // Specified aspect ratio\n      width = fixedWidth ? fixedWidth[1] : Math.round(Number(fixedHeight[1]) * data.aspect);\n      height = fixedHeight ? fixedHeight[1] : Math.round(Number(fixedWidth[1]) / data.aspect);\n\n      // Round to multiples of 2\n      width = Math.round(width / 2) * 2;\n      height = Math.round(height / 2) * 2;\n\n      if (data.pad) {\n        return getScalePadFilters(width, height, data.aspect, data.pad);\n      } else {\n        // No autopad requested, rescale to target size\n        return [{ filter: 'scale', options: { w: width, h: height }}];\n      }\n    } else {\n      // Keep input aspect ratio\n\n      if (fixedWidth) {\n        return [{\n          filter: 'scale',\n          options: {\n            w: Math.round(Number(fixedWidth[1]) / 2) * 2,\n            h: 'trunc(ow/a/2)*2'\n          }\n        }];\n      } else {\n        return [{\n          filter: 'scale',\n          options: {\n            w: 'trunc(oh*a/2)*2',\n            h: Math.round(Number(fixedHeight[1]) / 2) * 2\n          }\n        }];\n      }\n    }\n  } else {\n    throw new Error('Invalid size specified: ' + data.size);\n  }\n}\n\n\n/*\n *! Video size-related methods\n */\n\nmodule.exports = function(proto) {\n  /**\n   * Keep display aspect ratio\n   *\n   * This method is useful when converting an input with non-square pixels to an output format\n   * that does not support non-square pixels.  It rescales the input so that the display aspect\n   * ratio is the same.\n   *\n   * @method FfmpegCommand#keepDAR\n   * @category Video size\n   * @aliases keepPixelAspect,keepDisplayAspect,keepDisplayAspectRatio\n   *\n   * @return FfmpegCommand\n   */\n  proto.keepPixelAspect = // Only for compatibility, this is not about keeping _pixel_ aspect ratio\n  proto.keepDisplayAspect =\n  proto.keepDisplayAspectRatio =\n  proto.keepDAR = function() {\n    return this.videoFilters([\n      {\n        filter: 'scale',\n        options: {\n          w: 'if(gt(sar,1),iw*sar,iw)',\n          h: 'if(lt(sar,1),ih/sar,ih)'\n        }\n      },\n      {\n        filter: 'setsar',\n        options: '1'\n      }\n    ]);\n  };\n\n\n  /**\n   * Set output size\n   *\n   * The 'size' parameter can have one of 4 forms:\n   * - 'X%': rescale to xx % of the original size\n   * - 'WxH': specify width and height\n   * - 'Wx?': specify width and compute height from input aspect ratio\n   * - '?xH': specify height and compute width from input aspect ratio\n   *\n   * Note: both dimensions will be truncated to multiples of 2.\n   *\n   * @method FfmpegCommand#size\n   * @category Video size\n   * @aliases withSize,setSize\n   *\n   * @param {String} size size string, eg. '33%', '320x240', '320x?', '?x240'\n   * @return FfmpegCommand\n   */\n  proto.withSize =\n  proto.setSize =\n  proto.size = function(size) {\n    var filters = createSizeFilters(this._currentOutput, 'size', size);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Set output aspect ratio\n   *\n   * @method FfmpegCommand#aspect\n   * @category Video size\n   * @aliases withAspect,withAspectRatio,setAspect,setAspectRatio,aspectRatio\n   *\n   * @param {String|Number} aspect aspect ratio (number or 'X:Y' string)\n   * @return FfmpegCommand\n   */\n  proto.withAspect =\n  proto.withAspectRatio =\n  proto.setAspect =\n  proto.setAspectRatio =\n  proto.aspect =\n  proto.aspectRatio = function(aspect) {\n    var a = Number(aspect);\n    if (isNaN(a)) {\n      var match = aspect.match(/^(\\d+):(\\d+)$/);\n      if (match) {\n        a = Number(match[1]) / Number(match[2]);\n      } else {\n        throw new Error('Invalid aspect ratio: ' + aspect);\n      }\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'aspect', a);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n\n\n  /**\n   * Enable auto-padding the output\n   *\n   * @method FfmpegCommand#autopad\n   * @category Video size\n   * @aliases applyAutopadding,applyAutoPadding,applyAutopad,applyAutoPad,withAutopadding,withAutoPadding,withAutopad,withAutoPad,autoPad\n   *\n   * @param {Boolean} [pad=true] enable/disable auto-padding\n   * @param {String} [color='black'] pad color\n   */\n  proto.applyAutopadding =\n  proto.applyAutoPadding =\n  proto.applyAutopad =\n  proto.applyAutoPad =\n  proto.withAutopadding =\n  proto.withAutoPadding =\n  proto.withAutopad =\n  proto.withAutoPad =\n  proto.autoPad =\n  proto.autopad = function(pad, color) {\n    // Allow autopad(color)\n    if (typeof pad === 'string') {\n      color = pad;\n      pad = true;\n    }\n\n    // Allow autopad() and autopad(undefined, color)\n    if (typeof pad === 'undefined') {\n      pad = true;\n    }\n\n    var filters = createSizeFilters(this._currentOutput, 'pad', pad ? color || 'black' : false);\n\n    this._currentOutput.sizeFilters.clear();\n    this._currentOutput.sizeFilters(filters);\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvb3B0aW9ucy92aWRlb3NpemUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsSUFBSTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdCQUFnQiw0QkFBNEIsc0JBQXNCO0FBQ2xFO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esa0JBQWtCLDRCQUE0QixzQkFBc0I7QUFDcEU7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9vcHRpb25zL3ZpZGVvc2l6ZS5qcz81ZDI2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbi8qXG4gKiEgU2l6ZSBoZWxwZXJzXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiBmaWx0ZXJzIHRvIHBhZCB2aWRlbyB0byB3aWR0aCpoZWlnaHQsXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIG91dHB1dCB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCBvdXRwdXQgaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0gYXNwZWN0IHZpZGVvIGFzcGVjdCByYXRpbyAod2l0aG91dCBwYWRkaW5nKVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbG9yIHBhZGRpbmcgY29sb3JcbiAqIEByZXR1cm4gc2NhbGUvcGFkIGZpbHRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlUGFkRmlsdGVycyh3aWR0aCwgaGVpZ2h0LCBhc3BlY3QsIGNvbG9yKSB7XG4gIC8qXG4gICAgbGV0IGEgYmUgdGhlIGlucHV0IGFzcGVjdCByYXRpbywgQSBiZSB0aGUgcmVxdWVzdGVkIGFzcGVjdCByYXRpb1xuXG4gICAgaWYgYSA+IEEsIHBhZGRpbmcgaXMgZG9uZSBvbiB0b3AgYW5kIGJvdHRvbVxuICAgIGlmIGEgPCBBLCBwYWRkaW5nIGlzIGRvbmUgb24gbGVmdCBhbmQgcmlnaHRcbiAgICovXG5cbiAgcmV0dXJuIFtcbiAgICAvKlxuICAgICAgSW4gYm90aCBjYXNlcywgd2UgZmlyc3QgaGF2ZSB0byBzY2FsZSB0aGUgaW5wdXQgdG8gbWF0Y2ggdGhlIHJlcXVlc3RlZCBzaXplLlxuICAgICAgV2hlbiB1c2luZyBjb21wdXRlZCB3aWR0aC9oZWlnaHQsIHdlIHRydW5jYXRlIHRoZW0gdG8gbXVsdGlwbGVzIG9mIDJcbiAgICAgKi9cbiAgICB7XG4gICAgICBmaWx0ZXI6ICdzY2FsZScsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHc6ICdpZihndChhLCcgKyBhc3BlY3QgKyAnKSwnICsgd2lkdGggKyAnLHRydW5jKCcgKyBoZWlnaHQgKyAnKmEvMikqMiknLFxuICAgICAgICBoOiAnaWYobHQoYSwnICsgYXNwZWN0ICsgJyksJyArIGhlaWdodCArICcsdHJ1bmMoJyArIHdpZHRoICsgJy9hLzIpKjIpJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKlxuICAgICAgVGhlbiB3ZSBwYWQgdGhlIHNjYWxlZCBpbnB1dCB0byBtYXRjaCB0aGUgdGFyZ2V0IHNpemVcbiAgICAgIChoZXJlIGl3IGFuZCBpaCByZWZlciB0byB0aGUgcGFkZGluZyBpbnB1dCwgaS5lIHRoZSBzY2FsZWQgb3V0cHV0KVxuICAgICAqL1xuXG4gICAge1xuICAgICAgZmlsdGVyOiAncGFkJyxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIGg6IGhlaWdodCxcbiAgICAgICAgeDogJ2lmKGd0KGEsJyArIGFzcGVjdCArICcpLDAsKCcgKyB3aWR0aCArICctaXcpLzIpJyxcbiAgICAgICAgeTogJ2lmKGx0KGEsJyArIGFzcGVjdCArICcpLDAsKCcgKyBoZWlnaHQgKyAnLWloKS8yKScsXG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgfVxuICAgIH1cbiAgXTtcbn1cblxuXG4vKipcbiAqIFJlY29tcHV0ZSBzaXplIGZpbHRlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3V0cHV0XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5IG5ld2x5LWFkZGVkIHBhcmFtZXRlciBuYW1lICgnc2l6ZScsICdhc3BlY3QnIG9yICdwYWQnKVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIG5ld2x5LWFkZGVkIHBhcmFtZXRlciB2YWx1ZVxuICogQHJldHVybiBmaWx0ZXIgc3RyaW5nIGFycmF5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVTaXplRmlsdGVycyhvdXRwdXQsIGtleSwgdmFsdWUpIHtcbiAgLy8gU3RvcmUgcGFyYW1ldGVyc1xuICB2YXIgZGF0YSA9IG91dHB1dC5zaXplRGF0YSA9IG91dHB1dC5zaXplRGF0YSB8fCB7fTtcbiAgZGF0YVtrZXldID0gdmFsdWU7XG5cbiAgaWYgKCEoJ3NpemUnIGluIGRhdGEpKSB7XG4gICAgLy8gTm8gc2l6ZSByZXF1ZXN0ZWQsIGtlZXAgb3JpZ2luYWwgc2l6ZVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vIFRyeSB0byBtYXRjaCB0aGUgZGlmZmVyZW50IHNpemUgc3RyaW5nIGZvcm1hdHNcbiAgdmFyIGZpeGVkU2l6ZSA9IGRhdGEuc2l6ZS5tYXRjaCgvKFswLTldKyl4KFswLTldKykvKTtcbiAgdmFyIGZpeGVkV2lkdGggPSBkYXRhLnNpemUubWF0Y2goLyhbMC05XSspeFxcPy8pO1xuICB2YXIgZml4ZWRIZWlnaHQgPSBkYXRhLnNpemUubWF0Y2goL1xcP3goWzAtOV0rKS8pO1xuICB2YXIgcGVyY2VudFJhdGlvID0gZGF0YS5zaXplLm1hdGNoKC9cXGIoWzAtOV17MSwzfSklLyk7XG4gIHZhciB3aWR0aCwgaGVpZ2h0LCBhc3BlY3Q7XG5cbiAgaWYgKHBlcmNlbnRSYXRpbykge1xuICAgIHZhciByYXRpbyA9IE51bWJlcihwZXJjZW50UmF0aW9bMV0pIC8gMTAwO1xuICAgIHJldHVybiBbe1xuICAgICAgZmlsdGVyOiAnc2NhbGUnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICB3OiAndHJ1bmMoaXcqJyArIHJhdGlvICsgJy8yKSoyJyxcbiAgICAgICAgaDogJ3RydW5jKGloKicgKyByYXRpbyArICcvMikqMidcbiAgICAgIH1cbiAgICB9XTtcbiAgfSBlbHNlIGlmIChmaXhlZFNpemUpIHtcbiAgICAvLyBSb3VuZCB0YXJnZXQgc2l6ZSB0byBtdWx0aXBsZXMgb2YgMlxuICAgIHdpZHRoID0gTWF0aC5yb3VuZChOdW1iZXIoZml4ZWRTaXplWzFdKSAvIDIpICogMjtcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKE51bWJlcihmaXhlZFNpemVbMl0pIC8gMikgKiAyO1xuXG4gICAgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG5cbiAgICBpZiAoZGF0YS5wYWQpIHtcbiAgICAgIHJldHVybiBnZXRTY2FsZVBhZEZpbHRlcnMod2lkdGgsIGhlaWdodCwgYXNwZWN0LCBkYXRhLnBhZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGF1dG9wYWQgcmVxdWVzdGVkLCByZXNjYWxlIHRvIHRhcmdldCBzaXplXG4gICAgICByZXR1cm4gW3sgZmlsdGVyOiAnc2NhbGUnLCBvcHRpb25zOiB7IHc6IHdpZHRoLCBoOiBoZWlnaHQgfX1dO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmaXhlZFdpZHRoIHx8IGZpeGVkSGVpZ2h0KSB7XG4gICAgaWYgKCdhc3BlY3QnIGluIGRhdGEpIHtcbiAgICAgIC8vIFNwZWNpZmllZCBhc3BlY3QgcmF0aW9cbiAgICAgIHdpZHRoID0gZml4ZWRXaWR0aCA/IGZpeGVkV2lkdGhbMV0gOiBNYXRoLnJvdW5kKE51bWJlcihmaXhlZEhlaWdodFsxXSkgKiBkYXRhLmFzcGVjdCk7XG4gICAgICBoZWlnaHQgPSBmaXhlZEhlaWdodCA/IGZpeGVkSGVpZ2h0WzFdIDogTWF0aC5yb3VuZChOdW1iZXIoZml4ZWRXaWR0aFsxXSkgLyBkYXRhLmFzcGVjdCk7XG5cbiAgICAgIC8vIFJvdW5kIHRvIG11bHRpcGxlcyBvZiAyXG4gICAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGggLyAyKSAqIDI7XG4gICAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAvIDIpICogMjtcblxuICAgICAgaWYgKGRhdGEucGFkKSB7XG4gICAgICAgIHJldHVybiBnZXRTY2FsZVBhZEZpbHRlcnMod2lkdGgsIGhlaWdodCwgZGF0YS5hc3BlY3QsIGRhdGEucGFkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGF1dG9wYWQgcmVxdWVzdGVkLCByZXNjYWxlIHRvIHRhcmdldCBzaXplXG4gICAgICAgIHJldHVybiBbeyBmaWx0ZXI6ICdzY2FsZScsIG9wdGlvbnM6IHsgdzogd2lkdGgsIGg6IGhlaWdodCB9fV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgaW5wdXQgYXNwZWN0IHJhdGlvXG5cbiAgICAgIGlmIChmaXhlZFdpZHRoKSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIGZpbHRlcjogJ3NjYWxlJyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB3OiBNYXRoLnJvdW5kKE51bWJlcihmaXhlZFdpZHRoWzFdKSAvIDIpICogMixcbiAgICAgICAgICAgIGg6ICd0cnVuYyhvdy9hLzIpKjInXG4gICAgICAgICAgfVxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbe1xuICAgICAgICAgIGZpbHRlcjogJ3NjYWxlJyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB3OiAndHJ1bmMob2gqYS8yKSoyJyxcbiAgICAgICAgICAgIGg6IE1hdGgucm91bmQoTnVtYmVyKGZpeGVkSGVpZ2h0WzFdKSAvIDIpICogMlxuICAgICAgICAgIH1cbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaXplIHNwZWNpZmllZDogJyArIGRhdGEuc2l6ZSk7XG4gIH1cbn1cblxuXG4vKlxuICohIFZpZGVvIHNpemUtcmVsYXRlZCBtZXRob2RzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwcm90bykge1xuICAvKipcbiAgICogS2VlcCBkaXNwbGF5IGFzcGVjdCByYXRpb1xuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VmdWwgd2hlbiBjb252ZXJ0aW5nIGFuIGlucHV0IHdpdGggbm9uLXNxdWFyZSBwaXhlbHMgdG8gYW4gb3V0cHV0IGZvcm1hdFxuICAgKiB0aGF0IGRvZXMgbm90IHN1cHBvcnQgbm9uLXNxdWFyZSBwaXhlbHMuICBJdCByZXNjYWxlcyB0aGUgaW5wdXQgc28gdGhhdCB0aGUgZGlzcGxheSBhc3BlY3RcbiAgICogcmF0aW8gaXMgdGhlIHNhbWUuXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNrZWVwREFSXG4gICAqIEBjYXRlZ29yeSBWaWRlbyBzaXplXG4gICAqIEBhbGlhc2VzIGtlZXBQaXhlbEFzcGVjdCxrZWVwRGlzcGxheUFzcGVjdCxrZWVwRGlzcGxheUFzcGVjdFJhdGlvXG4gICAqXG4gICAqIEByZXR1cm4gRmZtcGVnQ29tbWFuZFxuICAgKi9cbiAgcHJvdG8ua2VlcFBpeGVsQXNwZWN0ID0gLy8gT25seSBmb3IgY29tcGF0aWJpbGl0eSwgdGhpcyBpcyBub3QgYWJvdXQga2VlcGluZyBfcGl4ZWxfIGFzcGVjdCByYXRpb1xuICBwcm90by5rZWVwRGlzcGxheUFzcGVjdCA9XG4gIHByb3RvLmtlZXBEaXNwbGF5QXNwZWN0UmF0aW8gPVxuICBwcm90by5rZWVwREFSID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmlkZW9GaWx0ZXJzKFtcbiAgICAgIHtcbiAgICAgICAgZmlsdGVyOiAnc2NhbGUnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgdzogJ2lmKGd0KHNhciwxKSxpdypzYXIsaXcpJyxcbiAgICAgICAgICBoOiAnaWYobHQoc2FyLDEpLGloL3NhcixpaCknXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGZpbHRlcjogJ3NldHNhcicsXG4gICAgICAgIG9wdGlvbnM6ICcxJ1xuICAgICAgfVxuICAgIF0pO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFNldCBvdXRwdXQgc2l6ZVxuICAgKlxuICAgKiBUaGUgJ3NpemUnIHBhcmFtZXRlciBjYW4gaGF2ZSBvbmUgb2YgNCBmb3JtczpcbiAgICogLSAnWCUnOiByZXNjYWxlIHRvIHh4ICUgb2YgdGhlIG9yaWdpbmFsIHNpemVcbiAgICogLSAnV3hIJzogc3BlY2lmeSB3aWR0aCBhbmQgaGVpZ2h0XG4gICAqIC0gJ1d4Pyc6IHNwZWNpZnkgd2lkdGggYW5kIGNvbXB1dGUgaGVpZ2h0IGZyb20gaW5wdXQgYXNwZWN0IHJhdGlvXG4gICAqIC0gJz94SCc6IHNwZWNpZnkgaGVpZ2h0IGFuZCBjb21wdXRlIHdpZHRoIGZyb20gaW5wdXQgYXNwZWN0IHJhdGlvXG4gICAqXG4gICAqIE5vdGU6IGJvdGggZGltZW5zaW9ucyB3aWxsIGJlIHRydW5jYXRlZCB0byBtdWx0aXBsZXMgb2YgMi5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3NpemVcbiAgICogQGNhdGVnb3J5IFZpZGVvIHNpemVcbiAgICogQGFsaWFzZXMgd2l0aFNpemUsc2V0U2l6ZVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2l6ZSBzaXplIHN0cmluZywgZWcuICczMyUnLCAnMzIweDI0MCcsICczMjB4PycsICc/eDI0MCdcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by53aXRoU2l6ZSA9XG4gIHByb3RvLnNldFNpemUgPVxuICBwcm90by5zaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBmaWx0ZXJzID0gY3JlYXRlU2l6ZUZpbHRlcnModGhpcy5fY3VycmVudE91dHB1dCwgJ3NpemUnLCBzaXplKTtcblxuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuc2l6ZUZpbHRlcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVGaWx0ZXJzKGZpbHRlcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogU2V0IG91dHB1dCBhc3BlY3QgcmF0aW9cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI2FzcGVjdFxuICAgKiBAY2F0ZWdvcnkgVmlkZW8gc2l6ZVxuICAgKiBAYWxpYXNlcyB3aXRoQXNwZWN0LHdpdGhBc3BlY3RSYXRpbyxzZXRBc3BlY3Qsc2V0QXNwZWN0UmF0aW8sYXNwZWN0UmF0aW9cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBhc3BlY3QgYXNwZWN0IHJhdGlvIChudW1iZXIgb3IgJ1g6WScgc3RyaW5nKVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLndpdGhBc3BlY3QgPVxuICBwcm90by53aXRoQXNwZWN0UmF0aW8gPVxuICBwcm90by5zZXRBc3BlY3QgPVxuICBwcm90by5zZXRBc3BlY3RSYXRpbyA9XG4gIHByb3RvLmFzcGVjdCA9XG4gIHByb3RvLmFzcGVjdFJhdGlvID0gZnVuY3Rpb24oYXNwZWN0KSB7XG4gICAgdmFyIGEgPSBOdW1iZXIoYXNwZWN0KTtcbiAgICBpZiAoaXNOYU4oYSkpIHtcbiAgICAgIHZhciBtYXRjaCA9IGFzcGVjdC5tYXRjaCgvXihcXGQrKTooXFxkKykkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgYSA9IE51bWJlcihtYXRjaFsxXSkgLyBOdW1iZXIobWF0Y2hbMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFzcGVjdCByYXRpbzogJyArIGFzcGVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlcnMgPSBjcmVhdGVTaXplRmlsdGVycyh0aGlzLl9jdXJyZW50T3V0cHV0LCAnYXNwZWN0JywgYSk7XG5cbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVGaWx0ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy5fY3VycmVudE91dHB1dC5zaXplRmlsdGVycyhmaWx0ZXJzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBhdXRvLXBhZGRpbmcgdGhlIG91dHB1dFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjYXV0b3BhZFxuICAgKiBAY2F0ZWdvcnkgVmlkZW8gc2l6ZVxuICAgKiBAYWxpYXNlcyBhcHBseUF1dG9wYWRkaW5nLGFwcGx5QXV0b1BhZGRpbmcsYXBwbHlBdXRvcGFkLGFwcGx5QXV0b1BhZCx3aXRoQXV0b3BhZGRpbmcsd2l0aEF1dG9QYWRkaW5nLHdpdGhBdXRvcGFkLHdpdGhBdXRvUGFkLGF1dG9QYWRcbiAgICpcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFkPXRydWVdIGVuYWJsZS9kaXNhYmxlIGF1dG8tcGFkZGluZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbG9yPSdibGFjayddIHBhZCBjb2xvclxuICAgKi9cbiAgcHJvdG8uYXBwbHlBdXRvcGFkZGluZyA9XG4gIHByb3RvLmFwcGx5QXV0b1BhZGRpbmcgPVxuICBwcm90by5hcHBseUF1dG9wYWQgPVxuICBwcm90by5hcHBseUF1dG9QYWQgPVxuICBwcm90by53aXRoQXV0b3BhZGRpbmcgPVxuICBwcm90by53aXRoQXV0b1BhZGRpbmcgPVxuICBwcm90by53aXRoQXV0b3BhZCA9XG4gIHByb3RvLndpdGhBdXRvUGFkID1cbiAgcHJvdG8uYXV0b1BhZCA9XG4gIHByb3RvLmF1dG9wYWQgPSBmdW5jdGlvbihwYWQsIGNvbG9yKSB7XG4gICAgLy8gQWxsb3cgYXV0b3BhZChjb2xvcilcbiAgICBpZiAodHlwZW9mIHBhZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbG9yID0gcGFkO1xuICAgICAgcGFkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBbGxvdyBhdXRvcGFkKCkgYW5kIGF1dG9wYWQodW5kZWZpbmVkLCBjb2xvcilcbiAgICBpZiAodHlwZW9mIHBhZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHBhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGZpbHRlcnMgPSBjcmVhdGVTaXplRmlsdGVycyh0aGlzLl9jdXJyZW50T3V0cHV0LCAncGFkJywgcGFkID8gY29sb3IgfHwgJ2JsYWNrJyA6IGZhbHNlKTtcblxuICAgIHRoaXMuX2N1cnJlbnRPdXRwdXQuc2l6ZUZpbHRlcnMuY2xlYXIoKTtcbiAgICB0aGlzLl9jdXJyZW50T3V0cHV0LnNpemVGaWx0ZXJzKGZpbHRlcnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/options/videosize.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/processor.js":
/*!*****************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/processor.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar spawn = (__webpack_require__(/*! child_process */ \"child_process\").spawn);\nvar path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/lib/async.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n/*\n *! Processor methods\n */\n\n\n/**\n * Run ffprobe asynchronously and store data in command\n *\n * @param {FfmpegCommand} command\n * @private\n */\nfunction runFfprobe(command) {\n  const inputProbeIndex = 0;\n  if (command._inputs[inputProbeIndex].isStream) {\n    // Don't probe input streams as this will consume them\n    return;\n  }\n  command.ffprobe(inputProbeIndex, function(err, data) {\n    command._ffprobeData = data;\n  });\n}\n\n\nmodule.exports = function(proto) {\n  /**\n   * Emitted just after ffmpeg has been spawned.\n   *\n   * @event FfmpegCommand#start\n   * @param {String} command ffmpeg command line\n   */\n\n  /**\n   * Emitted when ffmpeg reports progress information\n   *\n   * @event FfmpegCommand#progress\n   * @param {Object} progress progress object\n   * @param {Number} progress.frames number of frames transcoded\n   * @param {Number} progress.currentFps current processing speed in frames per second\n   * @param {Number} progress.currentKbps current output generation speed in kilobytes per second\n   * @param {Number} progress.targetSize current output file size\n   * @param {String} progress.timemark current video timemark\n   * @param {Number} [progress.percent] processing progress (may not be available depending on input)\n   */\n\n  /**\n   * Emitted when ffmpeg outputs to stderr\n   *\n   * @event FfmpegCommand#stderr\n   * @param {String} line stderr output line\n   */\n\n  /**\n   * Emitted when ffmpeg reports input codec data\n   *\n   * @event FfmpegCommand#codecData\n   * @param {Object} codecData codec data object\n   * @param {String} codecData.format input format name\n   * @param {String} codecData.audio input audio codec name\n   * @param {String} codecData.audio_details input audio codec parameters\n   * @param {String} codecData.video input video codec name\n   * @param {String} codecData.video_details input video codec parameters\n   */\n\n  /**\n   * Emitted when an error happens when preparing or running a command\n   *\n   * @event FfmpegCommand#error\n   * @param {Error} error error object, with optional properties 'inputStreamError' / 'outputStreamError' for errors on their respective streams\n   * @param {String|null} stdout ffmpeg stdout, unless outputting to a stream\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n  /**\n   * Emitted when a command finishes processing\n   *\n   * @event FfmpegCommand#end\n   * @param {Array|String|null} [filenames|stdout] generated filenames when taking screenshots, ffmpeg stdout when not outputting to a stream, null otherwise\n   * @param {String|null} stderr ffmpeg stderr\n   */\n\n\n  /**\n   * Spawn an ffmpeg process\n   *\n   * The 'options' argument may contain the following keys:\n   * - 'niceness': specify process niceness, ignored on Windows (default: 0)\n   * - `cwd`: change working directory\n   * - 'captureStdout': capture stdout and pass it to 'endCB' as its 2nd argument (default: false)\n   * - 'stdoutLines': override command limit (default: use command limit)\n   *\n   * The 'processCB' callback, if present, is called as soon as the process is created and\n   * receives a nodejs ChildProcess object.  It may not be called at all if an error happens\n   * before spawning the process.\n   *\n   * The 'endCB' callback is called either when an error occurs or when the ffmpeg process finishes.\n   *\n   * @method FfmpegCommand#_spawnFfmpeg\n   * @param {Array} args ffmpeg command line argument list\n   * @param {Object} [options] spawn options (see above)\n   * @param {Function} [processCB] callback called with process object and stdout/stderr ring buffers when process has been created\n   * @param {Function} endCB callback called with error (if applicable) and stdout/stderr ring buffers when process finished\n   * @private\n   */\n  proto._spawnFfmpeg = function(args, options, processCB, endCB) {\n    // Enable omitting options\n    if (typeof options === 'function') {\n      endCB = processCB;\n      processCB = options;\n      options = {};\n    }\n\n    // Enable omitting processCB\n    if (typeof endCB === 'undefined') {\n      endCB = processCB;\n      processCB = function() {};\n    }\n\n    var maxLines = 'stdoutLines' in options ? options.stdoutLines : this.options.stdoutLines;\n\n    // Find ffmpeg\n    this._getFfmpegPath(function(err, command) {\n      if (err) {\n        return endCB(err);\n      } else if (!command || command.length === 0) {\n        return endCB(new Error('Cannot find ffmpeg'));\n      }\n\n      // Apply niceness\n      if (options.niceness && options.niceness !== 0 && !utils.isWindows) {\n        args.unshift('-n', options.niceness, command);\n        command = 'nice';\n      }\n\n      var stdoutRing = utils.linesRing(maxLines);\n      var stdoutClosed = false;\n\n      var stderrRing = utils.linesRing(maxLines);\n      var stderrClosed = false;\n\n      // Spawn process\n      var ffmpegProc = spawn(command, args, options);\n\n      if (ffmpegProc.stderr) {\n        ffmpegProc.stderr.setEncoding('utf8');\n      }\n\n      ffmpegProc.on('error', function(err) {\n        endCB(err);\n      });\n\n      // Ensure we wait for captured streams to end before calling endCB\n      var exitError = null;\n      function handleExit(err) {\n        if (err) {\n          exitError = err;\n        }\n\n        if (processExited && (stdoutClosed || !options.captureStdout) && stderrClosed) {\n          endCB(exitError, stdoutRing, stderrRing);\n        }\n      }\n\n      // Handle process exit\n      var processExited = false;\n      ffmpegProc.on('exit', function(code, signal) {\n        processExited = true;\n\n        if (signal) {\n          handleExit(new Error('ffmpeg was killed with signal ' + signal));\n        } else if (code) {\n          handleExit(new Error('ffmpeg exited with code ' + code));\n        } else {\n          handleExit();\n        }\n      });\n\n      // Capture stdout if specified\n      if (options.captureStdout) {\n        ffmpegProc.stdout.on('data', function(data) {\n          stdoutRing.append(data);\n        });\n\n        ffmpegProc.stdout.on('close', function() {\n          stdoutRing.close();\n          stdoutClosed = true;\n          handleExit();\n        });\n      }\n\n      // Capture stderr if specified\n      ffmpegProc.stderr.on('data', function(data) {\n        stderrRing.append(data);\n      });\n\n      ffmpegProc.stderr.on('close', function() {\n        stderrRing.close();\n        stderrClosed = true;\n        handleExit();\n      });\n\n      // Call process callback\n      processCB(ffmpegProc, stdoutRing, stderrRing);\n    });\n  };\n\n\n  /**\n   * Build the argument list for an ffmpeg command\n   *\n   * @method FfmpegCommand#_getArguments\n   * @return argument list\n   * @private\n   */\n  proto._getArguments = function() {\n    var complexFilters = this._complexFilters.get();\n\n    var fileOutput = this._outputs.some(function(output) {\n      return output.isFile;\n    });\n\n    return [].concat(\n        // Inputs and input options\n        this._inputs.reduce(function(args, input) {\n          var source = (typeof input.source === 'string') ? input.source : 'pipe:0';\n\n          // For each input, add input options, then '-i <source>'\n          return args.concat(\n            input.options.get(),\n            ['-i', source]\n          );\n        }, []),\n\n        // Global options\n        this._global.get(),\n\n        // Overwrite if we have file outputs\n        fileOutput ? ['-y'] : [],\n\n        // Complex filters\n        complexFilters,\n\n        // Outputs, filters and output options\n        this._outputs.reduce(function(args, output) {\n          var sizeFilters = utils.makeFilterStrings(output.sizeFilters.get());\n          var audioFilters = output.audioFilters.get();\n          var videoFilters = output.videoFilters.get().concat(sizeFilters);\n          var outputArg;\n\n          if (!output.target) {\n            outputArg = [];\n          } else if (typeof output.target === 'string') {\n            outputArg = [output.target];\n          } else {\n            outputArg = ['pipe:1'];\n          }\n\n          return args.concat(\n            output.audio.get(),\n            audioFilters.length ? ['-filter:a', audioFilters.join(',')] : [],\n            output.video.get(),\n            videoFilters.length ? ['-filter:v', videoFilters.join(',')] : [],\n            output.options.get(),\n            outputArg\n          );\n        }, [])\n      );\n  };\n\n\n  /**\n   * Prepare execution of an ffmpeg command\n   *\n   * Checks prerequisites for the execution of the command (codec/format availability, flvtool...),\n   * then builds the argument list for ffmpeg and pass them to 'callback'.\n   *\n   * @method FfmpegCommand#_prepare\n   * @param {Function} callback callback with signature (err, args)\n   * @param {Boolean} [readMetadata=false] read metadata before processing\n   * @private\n   */\n  proto._prepare = function(callback, readMetadata) {\n    var self = this;\n\n    async.waterfall([\n      // Check codecs and formats\n      function(cb) {\n        self._checkCapabilities(cb);\n      },\n\n      // Read metadata if required\n      function(cb) {\n        if (!readMetadata) {\n          return cb();\n        }\n\n        self.ffprobe(0, function(err, data) {\n          if (!err) {\n            self._ffprobeData = data;\n          }\n\n          cb();\n        });\n      },\n\n      // Check for flvtool2/flvmeta if necessary\n      function(cb) {\n        var flvmeta = self._outputs.some(function(output) {\n          // Remove flvmeta flag on non-file output\n          if (output.flags.flvmeta && !output.isFile) {\n            self.logger.warn('Updating flv metadata is only supported for files');\n            output.flags.flvmeta = false;\n          }\n\n          return output.flags.flvmeta;\n        });\n\n        if (flvmeta) {\n          self._getFlvtoolPath(function(err) {\n            cb(err);\n          });\n        } else {\n          cb();\n        }\n      },\n\n      // Build argument list\n      function(cb) {\n        var args;\n        try {\n          args = self._getArguments();\n        } catch(e) {\n          return cb(e);\n        }\n\n        cb(null, args);\n      },\n\n      // Add \"-strict experimental\" option where needed\n      function(args, cb) {\n        self.availableEncoders(function(err, encoders) {\n          for (var i = 0; i < args.length; i++) {\n            if (args[i] === '-acodec' || args[i] === '-vcodec') {\n              i++;\n\n              if ((args[i] in encoders) && encoders[args[i]].experimental) {\n                args.splice(i + 1, 0, '-strict', 'experimental');\n                i += 2;\n              }\n            }\n          }\n\n          cb(null, args);\n        });\n      }\n    ], callback);\n\n    if (!readMetadata) {\n      // Read metadata as soon as 'progress' listeners are added\n\n      if (this.listeners('progress').length > 0) {\n        // Read metadata in parallel\n        runFfprobe(this);\n      } else {\n        // Read metadata as soon as the first 'progress' listener is added\n        this.once('newListener', function(event) {\n          if (event === 'progress') {\n            runFfprobe(this);\n          }\n        });\n      }\n    }\n  };\n\n\n  /**\n   * Run ffmpeg command\n   *\n   * @method FfmpegCommand#run\n   * @category Processing\n   * @aliases exec,execute\n   */\n  proto.exec =\n  proto.execute =\n  proto.run = function() {\n    var self = this;\n\n    // Check if at least one output is present\n    var outputPresent = this._outputs.some(function(output) {\n      return 'target' in output;\n    });\n\n    if (!outputPresent) {\n      throw new Error('No output specified');\n    }\n\n    // Get output stream if any\n    var outputStream = this._outputs.filter(function(output) {\n      return typeof output.target !== 'string';\n    })[0];\n\n    // Get input stream if any\n    var inputStream = this._inputs.filter(function(input) {\n      return typeof input.source !== 'string';\n    })[0];\n\n    // Ensure we send 'end' or 'error' only once\n    var ended = false;\n    function emitEnd(err, stdout, stderr) {\n      if (!ended) {\n        ended = true;\n\n        if (err) {\n          self.emit('error', err, stdout, stderr);\n        } else {\n          self.emit('end', stdout, stderr);\n        }\n      }\n    }\n\n    self._prepare(function(err, args) {\n      if (err) {\n        return emitEnd(err);\n      }\n\n      // Run ffmpeg\n      self._spawnFfmpeg(\n        args,\n        {\n          captureStdout: !outputStream,\n          niceness: self.options.niceness,\n          cwd: self.options.cwd,\n          windowsHide: true\n        }, \n\n        function processCB(ffmpegProc, stdoutRing, stderrRing) {\n          self.ffmpegProc = ffmpegProc;\n          self.emit('start', 'ffmpeg ' + args.join(' '));\n\n          // Pipe input stream if any\n          if (inputStream) {\n            inputStream.source.on('error', function(err) {\n              var reportingErr = new Error('Input stream error: ' + err.message);\n              reportingErr.inputStreamError = err;\n              emitEnd(reportingErr);\n              ffmpegProc.kill();\n            });\n\n            inputStream.source.resume();\n            inputStream.source.pipe(ffmpegProc.stdin);\n\n            // Set stdin error handler on ffmpeg (prevents nodejs catching the error, but\n            // ffmpeg will fail anyway, so no need to actually handle anything)\n            ffmpegProc.stdin.on('error', function() {});\n          }\n\n          // Setup timeout if requested\n          if (self.options.timeout) {\n            self.processTimer = setTimeout(function() {\n              var msg = 'process ran into a timeout (' + self.options.timeout + 's)';\n\n              emitEnd(new Error(msg), stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill();\n            }, self.options.timeout * 1000);\n          }\n\n\n          if (outputStream) {\n            // Pipe ffmpeg stdout to output stream\n            ffmpegProc.stdout.pipe(outputStream.target, outputStream.pipeopts);\n\n            // Handle output stream events\n            outputStream.target.on('close', function() {\n              self.logger.debug('Output stream closed, scheduling kill for ffmpeg process');\n\n              // Don't kill process yet, to give a chance to ffmpeg to\n              // terminate successfully first  This is necessary because\n              // under load, the process 'exit' event sometimes happens\n              // after the output stream 'close' event.\n              setTimeout(function() {\n                emitEnd(new Error('Output stream closed'));\n                ffmpegProc.kill();\n              }, 20);\n            });\n\n            outputStream.target.on('error', function(err) {\n              self.logger.debug('Output stream error, killing ffmpeg process');\n              var reportingErr = new Error('Output stream error: ' + err.message);\n              reportingErr.outputStreamError = err;\n              emitEnd(reportingErr, stdoutRing.get(), stderrRing.get());\n              ffmpegProc.kill('SIGKILL');\n            });\n          }\n\n          // Setup stderr handling\n          if (stderrRing) {\n\n            // 'stderr' event\n            if (self.listeners('stderr').length) {\n              stderrRing.callback(function(line) {\n                self.emit('stderr', line);\n              });\n            }\n\n            // 'codecData' event\n            if (self.listeners('codecData').length) {\n              var codecDataSent = false;\n              var codecObject = {};\n\n              stderrRing.callback(function(line) {\n                if (!codecDataSent)\n                  codecDataSent = utils.extractCodecData(self, line, codecObject);\n              });\n            }\n\n            // 'progress' event\n            if (self.listeners('progress').length) {\n              stderrRing.callback(function(line) {\n                utils.extractProgress(self, line);\n              });\n            }\n          }\n        },\n\n        function endCB(err, stdoutRing, stderrRing) {\n          clearTimeout(self.processTimer);\n          delete self.ffmpegProc;\n\n          if (err) {\n            if (err.message.match(/ffmpeg exited with code/)) {\n              // Add ffmpeg error message\n              err.message += ': ' + utils.extractError(stderrRing.get());\n            }\n\n            emitEnd(err, stdoutRing.get(), stderrRing.get());\n          } else {\n            // Find out which outputs need flv metadata\n            var flvmeta = self._outputs.filter(function(output) {\n              return output.flags.flvmeta;\n            });\n\n            if (flvmeta.length) {\n              self._getFlvtoolPath(function(err, flvtool) {\n                if (err) {\n                  return emitEnd(err);\n                }\n\n                async.each(\n                  flvmeta,\n                  function(output, cb) {\n                    spawn(flvtool, ['-U', output.target], {windowsHide: true})\n                      .on('error', function(err) {\n                        cb(new Error('Error running ' + flvtool + ' on ' + output.target + ': ' + err.message));\n                      })\n                      .on('exit', function(code, signal) {\n                        if (code !== 0 || signal) {\n                          cb(\n                            new Error(flvtool + ' ' +\n                              (signal ? 'received signal ' + signal\n                                      : 'exited with code ' + code)) +\n                              ' when running on ' + output.target\n                          );\n                        } else {\n                          cb();\n                        }\n                      });\n                  },\n                  function(err) {\n                    if (err) {\n                      emitEnd(err);\n                    } else {\n                      emitEnd(null, stdoutRing.get(), stderrRing.get());\n                    }\n                  }\n                );\n              });\n            } else {\n              emitEnd(null, stdoutRing.get(), stderrRing.get());\n            }\n          }\n        }\n      );\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Renice current and/or future ffmpeg processes\n   *\n   * Ignored on Windows platforms.\n   *\n   * @method FfmpegCommand#renice\n   * @category Processing\n   *\n   * @param {Number} [niceness=0] niceness value between -20 (highest priority) and 20 (lowest priority)\n   * @return FfmpegCommand\n   */\n  proto.renice = function(niceness) {\n    if (!utils.isWindows) {\n      niceness = niceness || 0;\n\n      if (niceness < -20 || niceness > 20) {\n        this.logger.warn('Invalid niceness value: ' + niceness + ', must be between -20 and 20');\n      }\n\n      niceness = Math.min(20, Math.max(-20, niceness));\n      this.options.niceness = niceness;\n\n      if (this.ffmpegProc) {\n        var logger = this.logger;\n        var pid = this.ffmpegProc.pid;\n        var renice = spawn('renice', [niceness, '-p', pid], {windowsHide: true});\n\n        renice.on('error', function(err) {\n          logger.warn('could not renice process ' + pid + ': ' + err.message);\n        });\n\n        renice.on('exit', function(code, signal) {\n          if (signal) {\n            logger.warn('could not renice process ' + pid + ': renice was killed by signal ' + signal);\n          } else if (code) {\n            logger.warn('could not renice process ' + pid + ': renice exited with ' + code);\n          } else {\n            logger.info('successfully reniced process ' + pid + ' to ' + niceness + ' niceness');\n          }\n        });\n      }\n    }\n\n    return this;\n  };\n\n\n  /**\n   * Kill current ffmpeg process, if any\n   *\n   * @method FfmpegCommand#kill\n   * @category Processing\n   *\n   * @param {String} [signal=SIGKILL] signal name\n   * @return FfmpegCommand\n   */\n  proto.kill = function(signal) {\n    if (!this.ffmpegProc) {\n      this.logger.warn('No running ffmpeg process, cannot send signal');\n    } else {\n      this.ffmpegProc.kill(signal || 'SIGKILL');\n    }\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvcHJvY2Vzc29yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ2E7O0FBRWIsWUFBWSxpRUFBOEI7QUFDMUMsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7O0FBRTdCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsYUFBYTtBQUMxQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGtCQUFrQjtBQUM3RTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjs7QUFFL0U7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi9wcm9jZXNzb3IuanM/MTJkMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3Bhd24gPSByZXF1aXJlKCdjaGlsZF9wcm9jZXNzJykuc3Bhd247XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG52YXIgYXN5bmMgPSByZXF1aXJlKCdhc3luYycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKlxuICohIFByb2Nlc3NvciBtZXRob2RzXG4gKi9cblxuXG4vKipcbiAqIFJ1biBmZnByb2JlIGFzeW5jaHJvbm91c2x5IGFuZCBzdG9yZSBkYXRhIGluIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge0ZmbXBlZ0NvbW1hbmR9IGNvbW1hbmRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkZmcHJvYmUoY29tbWFuZCkge1xuICBjb25zdCBpbnB1dFByb2JlSW5kZXggPSAwO1xuICBpZiAoY29tbWFuZC5faW5wdXRzW2lucHV0UHJvYmVJbmRleF0uaXNTdHJlYW0pIHtcbiAgICAvLyBEb24ndCBwcm9iZSBpbnB1dCBzdHJlYW1zIGFzIHRoaXMgd2lsbCBjb25zdW1lIHRoZW1cbiAgICByZXR1cm47XG4gIH1cbiAgY29tbWFuZC5mZnByb2JlKGlucHV0UHJvYmVJbmRleCwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG4gICAgY29tbWFuZC5fZmZwcm9iZURhdGEgPSBkYXRhO1xuICB9KTtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gIC8qKlxuICAgKiBFbWl0dGVkIGp1c3QgYWZ0ZXIgZmZtcGVnIGhhcyBiZWVuIHNwYXduZWQuXG4gICAqXG4gICAqIEBldmVudCBGZm1wZWdDb21tYW5kI3N0YXJ0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIGZmbXBlZyBjb21tYW5kIGxpbmVcbiAgICovXG5cbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiBmZm1wZWcgcmVwb3J0cyBwcm9ncmVzcyBpbmZvcm1hdGlvblxuICAgKlxuICAgKiBAZXZlbnQgRmZtcGVnQ29tbWFuZCNwcm9ncmVzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvZ3Jlc3MgcHJvZ3Jlc3Mgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcy5mcmFtZXMgbnVtYmVyIG9mIGZyYW1lcyB0cmFuc2NvZGVkXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwcm9ncmVzcy5jdXJyZW50RnBzIGN1cnJlbnQgcHJvY2Vzc2luZyBzcGVlZCBpbiBmcmFtZXMgcGVyIHNlY29uZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MuY3VycmVudEticHMgY3VycmVudCBvdXRwdXQgZ2VuZXJhdGlvbiBzcGVlZCBpbiBraWxvYnl0ZXMgcGVyIHNlY29uZFxuICAgKiBAcGFyYW0ge051bWJlcn0gcHJvZ3Jlc3MudGFyZ2V0U2l6ZSBjdXJyZW50IG91dHB1dCBmaWxlIHNpemVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb2dyZXNzLnRpbWVtYXJrIGN1cnJlbnQgdmlkZW8gdGltZW1hcmtcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtwcm9ncmVzcy5wZXJjZW50XSBwcm9jZXNzaW5nIHByb2dyZXNzIChtYXkgbm90IGJlIGF2YWlsYWJsZSBkZXBlbmRpbmcgb24gaW5wdXQpXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gZmZtcGVnIG91dHB1dHMgdG8gc3RkZXJyXG4gICAqXG4gICAqIEBldmVudCBGZm1wZWdDb21tYW5kI3N0ZGVyclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZSBzdGRlcnIgb3V0cHV0IGxpbmVcbiAgICovXG5cbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiBmZm1wZWcgcmVwb3J0cyBpbnB1dCBjb2RlYyBkYXRhXG4gICAqXG4gICAqIEBldmVudCBGZm1wZWdDb21tYW5kI2NvZGVjRGF0YVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29kZWNEYXRhIGNvZGVjIGRhdGEgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlY0RhdGEuZm9ybWF0IGlucHV0IGZvcm1hdCBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlY0RhdGEuYXVkaW8gaW5wdXQgYXVkaW8gY29kZWMgbmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZWNEYXRhLmF1ZGlvX2RldGFpbHMgaW5wdXQgYXVkaW8gY29kZWMgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZWNEYXRhLnZpZGVvIGlucHV0IHZpZGVvIGNvZGVjIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVjRGF0YS52aWRlb19kZXRhaWxzIGlucHV0IHZpZGVvIGNvZGVjIHBhcmFtZXRlcnNcbiAgICovXG5cbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiBhbiBlcnJvciBoYXBwZW5zIHdoZW4gcHJlcGFyaW5nIG9yIHJ1bm5pbmcgYSBjb21tYW5kXG4gICAqXG4gICAqIEBldmVudCBGZm1wZWdDb21tYW5kI2Vycm9yXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIGVycm9yIG9iamVjdCwgd2l0aCBvcHRpb25hbCBwcm9wZXJ0aWVzICdpbnB1dFN0cmVhbUVycm9yJyAvICdvdXRwdXRTdHJlYW1FcnJvcicgZm9yIGVycm9ycyBvbiB0aGVpciByZXNwZWN0aXZlIHN0cmVhbXNcbiAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gc3Rkb3V0IGZmbXBlZyBzdGRvdXQsIHVubGVzcyBvdXRwdXR0aW5nIHRvIGEgc3RyZWFtXG4gICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHN0ZGVyciBmZm1wZWcgc3RkZXJyXG4gICAqL1xuXG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gYSBjb21tYW5kIGZpbmlzaGVzIHByb2Nlc3NpbmdcbiAgICpcbiAgICogQGV2ZW50IEZmbXBlZ0NvbW1hbmQjZW5kXG4gICAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfG51bGx9IFtmaWxlbmFtZXN8c3Rkb3V0XSBnZW5lcmF0ZWQgZmlsZW5hbWVzIHdoZW4gdGFraW5nIHNjcmVlbnNob3RzLCBmZm1wZWcgc3Rkb3V0IHdoZW4gbm90IG91dHB1dHRpbmcgdG8gYSBzdHJlYW0sIG51bGwgb3RoZXJ3aXNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfG51bGx9IHN0ZGVyciBmZm1wZWcgc3RkZXJyXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFNwYXduIGFuIGZmbXBlZyBwcm9jZXNzXG4gICAqXG4gICAqIFRoZSAnb3B0aW9ucycgYXJndW1lbnQgbWF5IGNvbnRhaW4gdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAtICduaWNlbmVzcyc6IHNwZWNpZnkgcHJvY2VzcyBuaWNlbmVzcywgaWdub3JlZCBvbiBXaW5kb3dzIChkZWZhdWx0OiAwKVxuICAgKiAtIGBjd2RgOiBjaGFuZ2Ugd29ya2luZyBkaXJlY3RvcnlcbiAgICogLSAnY2FwdHVyZVN0ZG91dCc6IGNhcHR1cmUgc3Rkb3V0IGFuZCBwYXNzIGl0IHRvICdlbmRDQicgYXMgaXRzIDJuZCBhcmd1bWVudCAoZGVmYXVsdDogZmFsc2UpXG4gICAqIC0gJ3N0ZG91dExpbmVzJzogb3ZlcnJpZGUgY29tbWFuZCBsaW1pdCAoZGVmYXVsdDogdXNlIGNvbW1hbmQgbGltaXQpXG4gICAqXG4gICAqIFRoZSAncHJvY2Vzc0NCJyBjYWxsYmFjaywgaWYgcHJlc2VudCwgaXMgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHByb2Nlc3MgaXMgY3JlYXRlZCBhbmRcbiAgICogcmVjZWl2ZXMgYSBub2RlanMgQ2hpbGRQcm9jZXNzIG9iamVjdC4gIEl0IG1heSBub3QgYmUgY2FsbGVkIGF0IGFsbCBpZiBhbiBlcnJvciBoYXBwZW5zXG4gICAqIGJlZm9yZSBzcGF3bmluZyB0aGUgcHJvY2Vzcy5cbiAgICpcbiAgICogVGhlICdlbmRDQicgY2FsbGJhY2sgaXMgY2FsbGVkIGVpdGhlciB3aGVuIGFuIGVycm9yIG9jY3VycyBvciB3aGVuIHRoZSBmZm1wZWcgcHJvY2VzcyBmaW5pc2hlcy5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19zcGF3bkZmbXBlZ1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIGZmbXBlZyBjb21tYW5kIGxpbmUgYXJndW1lbnQgbGlzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIHNwYXduIG9wdGlvbnMgKHNlZSBhYm92ZSlcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb2Nlc3NDQl0gY2FsbGJhY2sgY2FsbGVkIHdpdGggcHJvY2VzcyBvYmplY3QgYW5kIHN0ZG91dC9zdGRlcnIgcmluZyBidWZmZXJzIHdoZW4gcHJvY2VzcyBoYXMgYmVlbiBjcmVhdGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZENCIGNhbGxiYWNrIGNhbGxlZCB3aXRoIGVycm9yIChpZiBhcHBsaWNhYmxlKSBhbmQgc3Rkb3V0L3N0ZGVyciByaW5nIGJ1ZmZlcnMgd2hlbiBwcm9jZXNzIGZpbmlzaGVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90by5fc3Bhd25GZm1wZWcgPSBmdW5jdGlvbihhcmdzLCBvcHRpb25zLCBwcm9jZXNzQ0IsIGVuZENCKSB7XG4gICAgLy8gRW5hYmxlIG9taXR0aW5nIG9wdGlvbnNcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVuZENCID0gcHJvY2Vzc0NCO1xuICAgICAgcHJvY2Vzc0NCID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgb21pdHRpbmcgcHJvY2Vzc0NCXG4gICAgaWYgKHR5cGVvZiBlbmRDQiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVuZENCID0gcHJvY2Vzc0NCO1xuICAgICAgcHJvY2Vzc0NCID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG5cbiAgICB2YXIgbWF4TGluZXMgPSAnc3Rkb3V0TGluZXMnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0ZG91dExpbmVzIDogdGhpcy5vcHRpb25zLnN0ZG91dExpbmVzO1xuXG4gICAgLy8gRmluZCBmZm1wZWdcbiAgICB0aGlzLl9nZXRGZm1wZWdQYXRoKGZ1bmN0aW9uKGVyciwgY29tbWFuZCkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gZW5kQ0IoZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIWNvbW1hbmQgfHwgY29tbWFuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGVuZENCKG5ldyBFcnJvcignQ2Fubm90IGZpbmQgZmZtcGVnJykpO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBuaWNlbmVzc1xuICAgICAgaWYgKG9wdGlvbnMubmljZW5lc3MgJiYgb3B0aW9ucy5uaWNlbmVzcyAhPT0gMCAmJiAhdXRpbHMuaXNXaW5kb3dzKSB7XG4gICAgICAgIGFyZ3MudW5zaGlmdCgnLW4nLCBvcHRpb25zLm5pY2VuZXNzLCBjb21tYW5kKTtcbiAgICAgICAgY29tbWFuZCA9ICduaWNlJztcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZG91dFJpbmcgPSB1dGlscy5saW5lc1JpbmcobWF4TGluZXMpO1xuICAgICAgdmFyIHN0ZG91dENsb3NlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgc3RkZXJyUmluZyA9IHV0aWxzLmxpbmVzUmluZyhtYXhMaW5lcyk7XG4gICAgICB2YXIgc3RkZXJyQ2xvc2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIFNwYXduIHByb2Nlc3NcbiAgICAgIHZhciBmZm1wZWdQcm9jID0gc3Bhd24oY29tbWFuZCwgYXJncywgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChmZm1wZWdQcm9jLnN0ZGVycikge1xuICAgICAgICBmZm1wZWdQcm9jLnN0ZGVyci5zZXRFbmNvZGluZygndXRmOCcpO1xuICAgICAgfVxuXG4gICAgICBmZm1wZWdQcm9jLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICBlbmRDQihlcnIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSB3YWl0IGZvciBjYXB0dXJlZCBzdHJlYW1zIHRvIGVuZCBiZWZvcmUgY2FsbGluZyBlbmRDQlxuICAgICAgdmFyIGV4aXRFcnJvciA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBoYW5kbGVFeGl0KGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZXhpdEVycm9yID0gZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3NFeGl0ZWQgJiYgKHN0ZG91dENsb3NlZCB8fCAhb3B0aW9ucy5jYXB0dXJlU3Rkb3V0KSAmJiBzdGRlcnJDbG9zZWQpIHtcbiAgICAgICAgICBlbmRDQihleGl0RXJyb3IsIHN0ZG91dFJpbmcsIHN0ZGVyclJpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBwcm9jZXNzIGV4aXRcbiAgICAgIHZhciBwcm9jZXNzRXhpdGVkID0gZmFsc2U7XG4gICAgICBmZm1wZWdQcm9jLm9uKCdleGl0JywgZnVuY3Rpb24oY29kZSwgc2lnbmFsKSB7XG4gICAgICAgIHByb2Nlc3NFeGl0ZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzaWduYWwpIHtcbiAgICAgICAgICBoYW5kbGVFeGl0KG5ldyBFcnJvcignZmZtcGVnIHdhcyBraWxsZWQgd2l0aCBzaWduYWwgJyArIHNpZ25hbCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUpIHtcbiAgICAgICAgICBoYW5kbGVFeGl0KG5ldyBFcnJvcignZmZtcGVnIGV4aXRlZCB3aXRoIGNvZGUgJyArIGNvZGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoYW5kbGVFeGl0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYXB0dXJlIHN0ZG91dCBpZiBzcGVjaWZpZWRcbiAgICAgIGlmIChvcHRpb25zLmNhcHR1cmVTdGRvdXQpIHtcbiAgICAgICAgZmZtcGVnUHJvYy5zdGRvdXQub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgc3Rkb3V0UmluZy5hcHBlbmQoZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZmbXBlZ1Byb2Muc3Rkb3V0Lm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHN0ZG91dFJpbmcuY2xvc2UoKTtcbiAgICAgICAgICBzdGRvdXRDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgIGhhbmRsZUV4aXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhcHR1cmUgc3RkZXJyIGlmIHNwZWNpZmllZFxuICAgICAgZmZtcGVnUHJvYy5zdGRlcnIub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHN0ZGVyclJpbmcuYXBwZW5kKGRhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGZmbXBlZ1Byb2Muc3RkZXJyLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBzdGRlcnJSaW5nLmNsb3NlKCk7XG4gICAgICAgIHN0ZGVyckNsb3NlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZUV4aXQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYWxsIHByb2Nlc3MgY2FsbGJhY2tcbiAgICAgIHByb2Nlc3NDQihmZm1wZWdQcm9jLCBzdGRvdXRSaW5nLCBzdGRlcnJSaW5nKTtcbiAgICB9KTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBCdWlsZCB0aGUgYXJndW1lbnQgbGlzdCBmb3IgYW4gZmZtcGVnIGNvbW1hbmRcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19nZXRBcmd1bWVudHNcbiAgICogQHJldHVybiBhcmd1bWVudCBsaXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcm90by5fZ2V0QXJndW1lbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbXBsZXhGaWx0ZXJzID0gdGhpcy5fY29tcGxleEZpbHRlcnMuZ2V0KCk7XG5cbiAgICB2YXIgZmlsZU91dHB1dCA9IHRoaXMuX291dHB1dHMuc29tZShmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiBvdXRwdXQuaXNGaWxlO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtdLmNvbmNhdChcbiAgICAgICAgLy8gSW5wdXRzIGFuZCBpbnB1dCBvcHRpb25zXG4gICAgICAgIHRoaXMuX2lucHV0cy5yZWR1Y2UoZnVuY3Rpb24oYXJncywgaW5wdXQpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gKHR5cGVvZiBpbnB1dC5zb3VyY2UgPT09ICdzdHJpbmcnKSA/IGlucHV0LnNvdXJjZSA6ICdwaXBlOjAnO1xuXG4gICAgICAgICAgLy8gRm9yIGVhY2ggaW5wdXQsIGFkZCBpbnB1dCBvcHRpb25zLCB0aGVuICctaSA8c291cmNlPidcbiAgICAgICAgICByZXR1cm4gYXJncy5jb25jYXQoXG4gICAgICAgICAgICBpbnB1dC5vcHRpb25zLmdldCgpLFxuICAgICAgICAgICAgWyctaScsIHNvdXJjZV1cbiAgICAgICAgICApO1xuICAgICAgICB9LCBbXSksXG5cbiAgICAgICAgLy8gR2xvYmFsIG9wdGlvbnNcbiAgICAgICAgdGhpcy5fZ2xvYmFsLmdldCgpLFxuXG4gICAgICAgIC8vIE92ZXJ3cml0ZSBpZiB3ZSBoYXZlIGZpbGUgb3V0cHV0c1xuICAgICAgICBmaWxlT3V0cHV0ID8gWycteSddIDogW10sXG5cbiAgICAgICAgLy8gQ29tcGxleCBmaWx0ZXJzXG4gICAgICAgIGNvbXBsZXhGaWx0ZXJzLFxuXG4gICAgICAgIC8vIE91dHB1dHMsIGZpbHRlcnMgYW5kIG91dHB1dCBvcHRpb25zXG4gICAgICAgIHRoaXMuX291dHB1dHMucmVkdWNlKGZ1bmN0aW9uKGFyZ3MsIG91dHB1dCkge1xuICAgICAgICAgIHZhciBzaXplRmlsdGVycyA9IHV0aWxzLm1ha2VGaWx0ZXJTdHJpbmdzKG91dHB1dC5zaXplRmlsdGVycy5nZXQoKSk7XG4gICAgICAgICAgdmFyIGF1ZGlvRmlsdGVycyA9IG91dHB1dC5hdWRpb0ZpbHRlcnMuZ2V0KCk7XG4gICAgICAgICAgdmFyIHZpZGVvRmlsdGVycyA9IG91dHB1dC52aWRlb0ZpbHRlcnMuZ2V0KCkuY29uY2F0KHNpemVGaWx0ZXJzKTtcbiAgICAgICAgICB2YXIgb3V0cHV0QXJnO1xuXG4gICAgICAgICAgaWYgKCFvdXRwdXQudGFyZ2V0KSB7XG4gICAgICAgICAgICBvdXRwdXRBcmcgPSBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvdXRwdXQudGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgb3V0cHV0QXJnID0gW291dHB1dC50YXJnZXRdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRBcmcgPSBbJ3BpcGU6MSddO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBhcmdzLmNvbmNhdChcbiAgICAgICAgICAgIG91dHB1dC5hdWRpby5nZXQoKSxcbiAgICAgICAgICAgIGF1ZGlvRmlsdGVycy5sZW5ndGggPyBbJy1maWx0ZXI6YScsIGF1ZGlvRmlsdGVycy5qb2luKCcsJyldIDogW10sXG4gICAgICAgICAgICBvdXRwdXQudmlkZW8uZ2V0KCksXG4gICAgICAgICAgICB2aWRlb0ZpbHRlcnMubGVuZ3RoID8gWyctZmlsdGVyOnYnLCB2aWRlb0ZpbHRlcnMuam9pbignLCcpXSA6IFtdLFxuICAgICAgICAgICAgb3V0cHV0Lm9wdGlvbnMuZ2V0KCksXG4gICAgICAgICAgICBvdXRwdXRBcmdcbiAgICAgICAgICApO1xuICAgICAgICB9LCBbXSlcbiAgICAgICk7XG4gIH07XG5cblxuICAvKipcbiAgICogUHJlcGFyZSBleGVjdXRpb24gb2YgYW4gZmZtcGVnIGNvbW1hbmRcbiAgICpcbiAgICogQ2hlY2tzIHByZXJlcXVpc2l0ZXMgZm9yIHRoZSBleGVjdXRpb24gb2YgdGhlIGNvbW1hbmQgKGNvZGVjL2Zvcm1hdCBhdmFpbGFiaWxpdHksIGZsdnRvb2wuLi4pLFxuICAgKiB0aGVuIGJ1aWxkcyB0aGUgYXJndW1lbnQgbGlzdCBmb3IgZmZtcGVnIGFuZCBwYXNzIHRoZW0gdG8gJ2NhbGxiYWNrJy5cbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI19wcmVwYXJlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIHdpdGggc2lnbmF0dXJlIChlcnIsIGFyZ3MpXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlYWRNZXRhZGF0YT1mYWxzZV0gcmVhZCBtZXRhZGF0YSBiZWZvcmUgcHJvY2Vzc2luZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJvdG8uX3ByZXBhcmUgPSBmdW5jdGlvbihjYWxsYmFjaywgcmVhZE1ldGFkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgYXN5bmMud2F0ZXJmYWxsKFtcbiAgICAgIC8vIENoZWNrIGNvZGVjcyBhbmQgZm9ybWF0c1xuICAgICAgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgc2VsZi5fY2hlY2tDYXBhYmlsaXRpZXMoY2IpO1xuICAgICAgfSxcblxuICAgICAgLy8gUmVhZCBtZXRhZGF0YSBpZiByZXF1aXJlZFxuICAgICAgZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgaWYgKCFyZWFkTWV0YWRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGYuZmZwcm9iZSgwLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgc2VsZi5fZmZwcm9iZURhdGEgPSBkYXRhO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgLy8gQ2hlY2sgZm9yIGZsdnRvb2wyL2Zsdm1ldGEgaWYgbmVjZXNzYXJ5XG4gICAgICBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmx2bWV0YSA9IHNlbGYuX291dHB1dHMuc29tZShmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgZmx2bWV0YSBmbGFnIG9uIG5vbi1maWxlIG91dHB1dFxuICAgICAgICAgIGlmIChvdXRwdXQuZmxhZ3MuZmx2bWV0YSAmJiAhb3V0cHV0LmlzRmlsZSkge1xuICAgICAgICAgICAgc2VsZi5sb2dnZXIud2FybignVXBkYXRpbmcgZmx2IG1ldGFkYXRhIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBmaWxlcycpO1xuICAgICAgICAgICAgb3V0cHV0LmZsYWdzLmZsdm1ldGEgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gb3V0cHV0LmZsYWdzLmZsdm1ldGE7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmbHZtZXRhKSB7XG4gICAgICAgICAgc2VsZi5fZ2V0Rmx2dG9vbFBhdGgoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8vIEJ1aWxkIGFyZ3VtZW50IGxpc3RcbiAgICAgIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgIHZhciBhcmdzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGFyZ3MgPSBzZWxmLl9nZXRBcmd1bWVudHMoKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IobnVsbCwgYXJncyk7XG4gICAgICB9LFxuXG4gICAgICAvLyBBZGQgXCItc3RyaWN0IGV4cGVyaW1lbnRhbFwiIG9wdGlvbiB3aGVyZSBuZWVkZWRcbiAgICAgIGZ1bmN0aW9uKGFyZ3MsIGNiKSB7XG4gICAgICAgIHNlbGYuYXZhaWxhYmxlRW5jb2RlcnMoZnVuY3Rpb24oZXJyLCBlbmNvZGVycykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFyZ3NbaV0gPT09ICctYWNvZGVjJyB8fCBhcmdzW2ldID09PSAnLXZjb2RlYycpIHtcbiAgICAgICAgICAgICAgaSsrO1xuXG4gICAgICAgICAgICAgIGlmICgoYXJnc1tpXSBpbiBlbmNvZGVycykgJiYgZW5jb2RlcnNbYXJnc1tpXV0uZXhwZXJpbWVudGFsKSB7XG4gICAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaSArIDEsIDAsICctc3RyaWN0JywgJ2V4cGVyaW1lbnRhbCcpO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNiKG51bGwsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBdLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoIXJlYWRNZXRhZGF0YSkge1xuICAgICAgLy8gUmVhZCBtZXRhZGF0YSBhcyBzb29uIGFzICdwcm9ncmVzcycgbGlzdGVuZXJzIGFyZSBhZGRlZFxuXG4gICAgICBpZiAodGhpcy5saXN0ZW5lcnMoJ3Byb2dyZXNzJykubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBSZWFkIG1ldGFkYXRhIGluIHBhcmFsbGVsXG4gICAgICAgIHJ1bkZmcHJvYmUodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWFkIG1ldGFkYXRhIGFzIHNvb24gYXMgdGhlIGZpcnN0ICdwcm9ncmVzcycgbGlzdGVuZXIgaXMgYWRkZWRcbiAgICAgICAgdGhpcy5vbmNlKCduZXdMaXN0ZW5lcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKGV2ZW50ID09PSAncHJvZ3Jlc3MnKSB7XG4gICAgICAgICAgICBydW5GZnByb2JlKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJ1biBmZm1wZWcgY29tbWFuZFxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjcnVuXG4gICAqIEBjYXRlZ29yeSBQcm9jZXNzaW5nXG4gICAqIEBhbGlhc2VzIGV4ZWMsZXhlY3V0ZVxuICAgKi9cbiAgcHJvdG8uZXhlYyA9XG4gIHByb3RvLmV4ZWN1dGUgPVxuICBwcm90by5ydW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDaGVjayBpZiBhdCBsZWFzdCBvbmUgb3V0cHV0IGlzIHByZXNlbnRcbiAgICB2YXIgb3V0cHV0UHJlc2VudCA9IHRoaXMuX291dHB1dHMuc29tZShmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiAndGFyZ2V0JyBpbiBvdXRwdXQ7XG4gICAgfSk7XG5cbiAgICBpZiAoIW91dHB1dFByZXNlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gb3V0cHV0IHNwZWNpZmllZCcpO1xuICAgIH1cblxuICAgIC8vIEdldCBvdXRwdXQgc3RyZWFtIGlmIGFueVxuICAgIHZhciBvdXRwdXRTdHJlYW0gPSB0aGlzLl9vdXRwdXRzLmZpbHRlcihmdW5jdGlvbihvdXRwdXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb3V0cHV0LnRhcmdldCAhPT0gJ3N0cmluZyc7XG4gICAgfSlbMF07XG5cbiAgICAvLyBHZXQgaW5wdXQgc3RyZWFtIGlmIGFueVxuICAgIHZhciBpbnB1dFN0cmVhbSA9IHRoaXMuX2lucHV0cy5maWx0ZXIoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQuc291cmNlICE9PSAnc3RyaW5nJztcbiAgICB9KVswXTtcblxuICAgIC8vIEVuc3VyZSB3ZSBzZW5kICdlbmQnIG9yICdlcnJvcicgb25seSBvbmNlXG4gICAgdmFyIGVuZGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gZW1pdEVuZChlcnIsIHN0ZG91dCwgc3RkZXJyKSB7XG4gICAgICBpZiAoIWVuZGVkKSB7XG4gICAgICAgIGVuZGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVyciwgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuZW1pdCgnZW5kJywgc3Rkb3V0LCBzdGRlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5fcHJlcGFyZShmdW5jdGlvbihlcnIsIGFyZ3MpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGVtaXRFbmQoZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gUnVuIGZmbXBlZ1xuICAgICAgc2VsZi5fc3Bhd25GZm1wZWcoXG4gICAgICAgIGFyZ3MsXG4gICAgICAgIHtcbiAgICAgICAgICBjYXB0dXJlU3Rkb3V0OiAhb3V0cHV0U3RyZWFtLFxuICAgICAgICAgIG5pY2VuZXNzOiBzZWxmLm9wdGlvbnMubmljZW5lc3MsXG4gICAgICAgICAgY3dkOiBzZWxmLm9wdGlvbnMuY3dkLFxuICAgICAgICAgIHdpbmRvd3NIaWRlOiB0cnVlXG4gICAgICAgIH0sIFxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NDQihmZm1wZWdQcm9jLCBzdGRvdXRSaW5nLCBzdGRlcnJSaW5nKSB7XG4gICAgICAgICAgc2VsZi5mZm1wZWdQcm9jID0gZmZtcGVnUHJvYztcbiAgICAgICAgICBzZWxmLmVtaXQoJ3N0YXJ0JywgJ2ZmbXBlZyAnICsgYXJncy5qb2luKCcgJykpO1xuXG4gICAgICAgICAgLy8gUGlwZSBpbnB1dCBzdHJlYW0gaWYgYW55XG4gICAgICAgICAgaWYgKGlucHV0U3RyZWFtKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmVhbS5zb3VyY2Uub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIHZhciByZXBvcnRpbmdFcnIgPSBuZXcgRXJyb3IoJ0lucHV0IHN0cmVhbSBlcnJvcjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgcmVwb3J0aW5nRXJyLmlucHV0U3RyZWFtRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgIGVtaXRFbmQocmVwb3J0aW5nRXJyKTtcbiAgICAgICAgICAgICAgZmZtcGVnUHJvYy5raWxsKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc291cmNlLnJlc3VtZSgpO1xuICAgICAgICAgICAgaW5wdXRTdHJlYW0uc291cmNlLnBpcGUoZmZtcGVnUHJvYy5zdGRpbik7XG5cbiAgICAgICAgICAgIC8vIFNldCBzdGRpbiBlcnJvciBoYW5kbGVyIG9uIGZmbXBlZyAocHJldmVudHMgbm9kZWpzIGNhdGNoaW5nIHRoZSBlcnJvciwgYnV0XG4gICAgICAgICAgICAvLyBmZm1wZWcgd2lsbCBmYWlsIGFueXdheSwgc28gbm8gbmVlZCB0byBhY3R1YWxseSBoYW5kbGUgYW55dGhpbmcpXG4gICAgICAgICAgICBmZm1wZWdQcm9jLnN0ZGluLm9uKCdlcnJvcicsIGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldHVwIHRpbWVvdXQgaWYgcmVxdWVzdGVkXG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBtc2cgPSAncHJvY2VzcyByYW4gaW50byBhIHRpbWVvdXQgKCcgKyBzZWxmLm9wdGlvbnMudGltZW91dCArICdzKSc7XG5cbiAgICAgICAgICAgICAgZW1pdEVuZChuZXcgRXJyb3IobXNnKSwgc3Rkb3V0UmluZy5nZXQoKSwgc3RkZXJyUmluZy5nZXQoKSk7XG4gICAgICAgICAgICAgIGZmbXBlZ1Byb2Mua2lsbCgpO1xuICAgICAgICAgICAgfSwgc2VsZi5vcHRpb25zLnRpbWVvdXQgKiAxMDAwKTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIGlmIChvdXRwdXRTdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIFBpcGUgZmZtcGVnIHN0ZG91dCB0byBvdXRwdXQgc3RyZWFtXG4gICAgICAgICAgICBmZm1wZWdQcm9jLnN0ZG91dC5waXBlKG91dHB1dFN0cmVhbS50YXJnZXQsIG91dHB1dFN0cmVhbS5waXBlb3B0cyk7XG5cbiAgICAgICAgICAgIC8vIEhhbmRsZSBvdXRwdXQgc3RyZWFtIGV2ZW50c1xuICAgICAgICAgICAgb3V0cHV0U3RyZWFtLnRhcmdldC5vbignY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2VsZi5sb2dnZXIuZGVidWcoJ091dHB1dCBzdHJlYW0gY2xvc2VkLCBzY2hlZHVsaW5nIGtpbGwgZm9yIGZmbXBlZyBwcm9jZXNzJyk7XG5cbiAgICAgICAgICAgICAgLy8gRG9uJ3Qga2lsbCBwcm9jZXNzIHlldCwgdG8gZ2l2ZSBhIGNoYW5jZSB0byBmZm1wZWcgdG9cbiAgICAgICAgICAgICAgLy8gdGVybWluYXRlIHN1Y2Nlc3NmdWxseSBmaXJzdCAgVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZVxuICAgICAgICAgICAgICAvLyB1bmRlciBsb2FkLCB0aGUgcHJvY2VzcyAnZXhpdCcgZXZlbnQgc29tZXRpbWVzIGhhcHBlbnNcbiAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIG91dHB1dCBzdHJlYW0gJ2Nsb3NlJyBldmVudC5cbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBlbWl0RW5kKG5ldyBFcnJvcignT3V0cHV0IHN0cmVhbSBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgZmZtcGVnUHJvYy5raWxsKCk7XG4gICAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvdXRwdXRTdHJlYW0udGFyZ2V0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBzZWxmLmxvZ2dlci5kZWJ1ZygnT3V0cHV0IHN0cmVhbSBlcnJvciwga2lsbGluZyBmZm1wZWcgcHJvY2VzcycpO1xuICAgICAgICAgICAgICB2YXIgcmVwb3J0aW5nRXJyID0gbmV3IEVycm9yKCdPdXRwdXQgc3RyZWFtIGVycm9yOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICByZXBvcnRpbmdFcnIub3V0cHV0U3RyZWFtRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgIGVtaXRFbmQocmVwb3J0aW5nRXJyLCBzdGRvdXRSaW5nLmdldCgpLCBzdGRlcnJSaW5nLmdldCgpKTtcbiAgICAgICAgICAgICAgZmZtcGVnUHJvYy5raWxsKCdTSUdLSUxMJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXR1cCBzdGRlcnIgaGFuZGxpbmdcbiAgICAgICAgICBpZiAoc3RkZXJyUmluZykge1xuXG4gICAgICAgICAgICAvLyAnc3RkZXJyJyBldmVudFxuICAgICAgICAgICAgaWYgKHNlbGYubGlzdGVuZXJzKCdzdGRlcnInKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3RkZXJyUmluZy5jYWxsYmFjayhmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5lbWl0KCdzdGRlcnInLCBsaW5lKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICdjb2RlY0RhdGEnIGV2ZW50XG4gICAgICAgICAgICBpZiAoc2VsZi5saXN0ZW5lcnMoJ2NvZGVjRGF0YScpLmxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgY29kZWNEYXRhU2VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICB2YXIgY29kZWNPYmplY3QgPSB7fTtcblxuICAgICAgICAgICAgICBzdGRlcnJSaW5nLmNhbGxiYWNrKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvZGVjRGF0YVNlbnQpXG4gICAgICAgICAgICAgICAgICBjb2RlY0RhdGFTZW50ID0gdXRpbHMuZXh0cmFjdENvZGVjRGF0YShzZWxmLCBsaW5lLCBjb2RlY09iamVjdCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAncHJvZ3Jlc3MnIGV2ZW50XG4gICAgICAgICAgICBpZiAoc2VsZi5saXN0ZW5lcnMoJ3Byb2dyZXNzJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHN0ZGVyclJpbmcuY2FsbGJhY2soZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmV4dHJhY3RQcm9ncmVzcyhzZWxmLCBsaW5lKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uIGVuZENCKGVyciwgc3Rkb3V0UmluZywgc3RkZXJyUmluZykge1xuICAgICAgICAgIGNsZWFyVGltZW91dChzZWxmLnByb2Nlc3NUaW1lcik7XG4gICAgICAgICAgZGVsZXRlIHNlbGYuZmZtcGVnUHJvYztcblxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5tYXRjaCgvZmZtcGVnIGV4aXRlZCB3aXRoIGNvZGUvKSkge1xuICAgICAgICAgICAgICAvLyBBZGQgZmZtcGVnIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgKz0gJzogJyArIHV0aWxzLmV4dHJhY3RFcnJvcihzdGRlcnJSaW5nLmdldCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW1pdEVuZChlcnIsIHN0ZG91dFJpbmcuZ2V0KCksIHN0ZGVyclJpbmcuZ2V0KCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5kIG91dCB3aGljaCBvdXRwdXRzIG5lZWQgZmx2IG1ldGFkYXRhXG4gICAgICAgICAgICB2YXIgZmx2bWV0YSA9IHNlbGYuX291dHB1dHMuZmlsdGVyKGZ1bmN0aW9uKG91dHB1dCkge1xuICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0LmZsYWdzLmZsdm1ldGE7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGZsdm1ldGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHNlbGYuX2dldEZsdnRvb2xQYXRoKGZ1bmN0aW9uKGVyciwgZmx2dG9vbCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBlbWl0RW5kKGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYXN5bmMuZWFjaChcbiAgICAgICAgICAgICAgICAgIGZsdm1ldGEsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbihvdXRwdXQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwYXduKGZsdnRvb2wsIFsnLVUnLCBvdXRwdXQudGFyZ2V0XSwge3dpbmRvd3NIaWRlOiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgRXJyb3IoJ0Vycm9yIHJ1bm5pbmcgJyArIGZsdnRvb2wgKyAnIG9uICcgKyBvdXRwdXQudGFyZ2V0ICsgJzogJyArIGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAub24oJ2V4aXQnLCBmdW5jdGlvbihjb2RlLCBzaWduYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSAwIHx8IHNpZ25hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjYihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoZmx2dG9vbCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2lnbmFsID8gJ3JlY2VpdmVkIHNpZ25hbCAnICsgc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2V4aXRlZCB3aXRoIGNvZGUgJyArIGNvZGUpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdoZW4gcnVubmluZyBvbiAnICsgb3V0cHV0LnRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgIGVtaXRFbmQoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBlbWl0RW5kKG51bGwsIHN0ZG91dFJpbmcuZ2V0KCksIHN0ZGVyclJpbmcuZ2V0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbWl0RW5kKG51bGwsIHN0ZG91dFJpbmcuZ2V0KCksIHN0ZGVyclJpbmcuZ2V0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJlbmljZSBjdXJyZW50IGFuZC9vciBmdXR1cmUgZmZtcGVnIHByb2Nlc3Nlc1xuICAgKlxuICAgKiBJZ25vcmVkIG9uIFdpbmRvd3MgcGxhdGZvcm1zLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjcmVuaWNlXG4gICAqIEBjYXRlZ29yeSBQcm9jZXNzaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbmljZW5lc3M9MF0gbmljZW5lc3MgdmFsdWUgYmV0d2VlbiAtMjAgKGhpZ2hlc3QgcHJpb3JpdHkpIGFuZCAyMCAobG93ZXN0IHByaW9yaXR5KVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLnJlbmljZSA9IGZ1bmN0aW9uKG5pY2VuZXNzKSB7XG4gICAgaWYgKCF1dGlscy5pc1dpbmRvd3MpIHtcbiAgICAgIG5pY2VuZXNzID0gbmljZW5lc3MgfHwgMDtcblxuICAgICAgaWYgKG5pY2VuZXNzIDwgLTIwIHx8IG5pY2VuZXNzID4gMjApIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybignSW52YWxpZCBuaWNlbmVzcyB2YWx1ZTogJyArIG5pY2VuZXNzICsgJywgbXVzdCBiZSBiZXR3ZWVuIC0yMCBhbmQgMjAnKTtcbiAgICAgIH1cblxuICAgICAgbmljZW5lc3MgPSBNYXRoLm1pbigyMCwgTWF0aC5tYXgoLTIwLCBuaWNlbmVzcykpO1xuICAgICAgdGhpcy5vcHRpb25zLm5pY2VuZXNzID0gbmljZW5lc3M7XG5cbiAgICAgIGlmICh0aGlzLmZmbXBlZ1Byb2MpIHtcbiAgICAgICAgdmFyIGxvZ2dlciA9IHRoaXMubG9nZ2VyO1xuICAgICAgICB2YXIgcGlkID0gdGhpcy5mZm1wZWdQcm9jLnBpZDtcbiAgICAgICAgdmFyIHJlbmljZSA9IHNwYXduKCdyZW5pY2UnLCBbbmljZW5lc3MsICctcCcsIHBpZF0sIHt3aW5kb3dzSGlkZTogdHJ1ZX0pO1xuXG4gICAgICAgIHJlbmljZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICBsb2dnZXIud2FybignY291bGQgbm90IHJlbmljZSBwcm9jZXNzICcgKyBwaWQgKyAnOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZW5pY2Uub24oJ2V4aXQnLCBmdW5jdGlvbihjb2RlLCBzaWduYWwpIHtcbiAgICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY291bGQgbm90IHJlbmljZSBwcm9jZXNzICcgKyBwaWQgKyAnOiByZW5pY2Ugd2FzIGtpbGxlZCBieSBzaWduYWwgJyArIHNpZ25hbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybignY291bGQgbm90IHJlbmljZSBwcm9jZXNzICcgKyBwaWQgKyAnOiByZW5pY2UgZXhpdGVkIHdpdGggJyArIGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbygnc3VjY2Vzc2Z1bGx5IHJlbmljZWQgcHJvY2VzcyAnICsgcGlkICsgJyB0byAnICsgbmljZW5lc3MgKyAnIG5pY2VuZXNzJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBLaWxsIGN1cnJlbnQgZmZtcGVnIHByb2Nlc3MsIGlmIGFueVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQja2lsbFxuICAgKiBAY2F0ZWdvcnkgUHJvY2Vzc2luZ1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3NpZ25hbD1TSUdLSUxMXSBzaWduYWwgbmFtZVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLmtpbGwgPSBmdW5jdGlvbihzaWduYWwpIHtcbiAgICBpZiAoIXRoaXMuZmZtcGVnUHJvYykge1xuICAgICAgdGhpcy5sb2dnZXIud2FybignTm8gcnVubmluZyBmZm1wZWcgcHJvY2VzcywgY2Fubm90IHNlbmQgc2lnbmFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmZtcGVnUHJvYy5raWxsKHNpZ25hbCB8fCAnU0lHS0lMTCcpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/recipes.js":
/*!***************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/recipes.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nvar async = __webpack_require__(/*! async */ \"(rsc)/./node_modules/async/lib/async.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\");\n\n\n/*\n * Useful recipes for commands\n */\n\nmodule.exports = function recipes(proto) {\n  /**\n   * Execute ffmpeg command and save output to a file\n   *\n   * @method FfmpegCommand#save\n   * @category Processing\n   * @aliases saveToFile\n   *\n   * @param {String} output file path\n   * @return FfmpegCommand\n   */\n  proto.saveToFile =\n  proto.save = function(output) {\n    this.output(output).run();\n    return this;\n  };\n\n\n  /**\n   * Execute ffmpeg command and save output to a stream\n   *\n   * If 'stream' is not specified, a PassThrough stream is created and returned.\n   * 'options' will be used when piping ffmpeg output to the output stream\n   * (@see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options)\n   *\n   * @method FfmpegCommand#pipe\n   * @category Processing\n   * @aliases stream,writeToStream\n   *\n   * @param {stream.Writable} [stream] output stream\n   * @param {Object} [options={}] pipe options\n   * @return Output stream\n   */\n  proto.writeToStream =\n  proto.pipe =\n  proto.stream = function(stream, options) {\n    if (stream && !('writable' in stream)) {\n      options = stream;\n      stream = undefined;\n    }\n\n    if (!stream) {\n      if (process.version.match(/v0\\.8\\./)) {\n        throw new Error('PassThrough stream is not supported on node v0.8');\n      }\n\n      stream = new PassThrough();\n    }\n\n    this.output(stream, options).run();\n    return stream;\n  };\n\n\n  /**\n   * Generate images from a video\n   *\n   * Note: this method makes the command emit a 'filenames' event with an array of\n   * the generated image filenames.\n   *\n   * @method FfmpegCommand#screenshots\n   * @category Processing\n   * @aliases takeScreenshots,thumbnail,thumbnails,screenshot\n   *\n   * @param {Number|Object} [config=1] screenshot count or configuration object with\n   *   the following keys:\n   * @param {Number} [config.count] number of screenshots to take; using this option\n   *   takes screenshots at regular intervals (eg. count=4 would take screens at 20%, 40%,\n   *   60% and 80% of the video length).\n   * @param {String} [config.folder='.'] output folder\n   * @param {String} [config.filename='tn.png'] output filename pattern, may contain the following\n   *   tokens:\n   *   - '%s': offset in seconds\n   *   - '%w': screenshot width\n   *   - '%h': screenshot height\n   *   - '%r': screenshot resolution (same as '%wx%h')\n   *   - '%f': input filename\n   *   - '%b': input basename (filename w/o extension)\n   *   - '%i': index of screenshot in timemark array (can be zero-padded by using it like `%000i`)\n   * @param {Number[]|String[]} [config.timemarks] array of timemarks to take screenshots\n   *   at; each timemark may be a number of seconds, a '[[hh:]mm:]ss[.xxx]' string or a\n   *   'XX%' string.  Overrides 'count' if present.\n   * @param {Number[]|String[]} [config.timestamps] alias for 'timemarks'\n   * @param {Boolean} [config.fastSeek] use fast seek (less accurate)\n   * @param {String} [config.size] screenshot size, with the same syntax as {@link FfmpegCommand#size}\n   * @param {String} [folder] output folder (legacy alias for 'config.folder')\n   * @return FfmpegCommand\n   */\n  proto.takeScreenshots =\n  proto.thumbnail =\n  proto.thumbnails =\n  proto.screenshot =\n  proto.screenshots = function(config, folder) {\n    var self = this;\n    var source = this._currentInput.source;\n    config = config || { count: 1 };\n\n    // Accept a number of screenshots instead of a config object\n    if (typeof config === 'number') {\n      config = {\n        count: config\n      };\n    }\n\n    // Accept a second 'folder' parameter instead of config.folder\n    if (!('folder' in config)) {\n      config.folder = folder || '.';\n    }\n\n    // Accept 'timestamps' instead of 'timemarks'\n    if ('timestamps' in config) {\n      config.timemarks = config.timestamps;\n    }\n\n    // Compute timemarks from count if not present\n    if (!('timemarks' in config)) {\n      if (!config.count) {\n        throw new Error('Cannot take screenshots: neither a count nor a timemark list are specified');\n      }\n\n      var interval = 100 / (1 + config.count);\n      config.timemarks = [];\n      for (var i = 0; i < config.count; i++) {\n        config.timemarks.push((interval * (i + 1)) + '%');\n      }\n    }\n\n    // Parse size option\n    if ('size' in config) {\n      var fixedSize = config.size.match(/^(\\d+)x(\\d+)$/);\n      var fixedWidth = config.size.match(/^(\\d+)x\\?$/);\n      var fixedHeight = config.size.match(/^\\?x(\\d+)$/);\n      var percentSize = config.size.match(/^(\\d+)%$/);\n\n      if (!fixedSize && !fixedWidth && !fixedHeight && !percentSize) {\n        throw new Error('Invalid size parameter: ' + config.size);\n      }\n    }\n\n    // Metadata helper\n    var metadata;\n    function getMetadata(cb) {\n      if (metadata) {\n        cb(null, metadata);\n      } else {\n        self.ffprobe(function(err, meta) {\n          metadata = meta;\n          cb(err, meta);\n        });\n      }\n    }\n\n    async.waterfall([\n      // Compute percent timemarks if any\n      function computeTimemarks(next) {\n        if (config.timemarks.some(function(t) { return ('' + t).match(/^[\\d.]+%$/); })) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot compute screenshot timemarks with an input stream, please specify fixed timemarks'));\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              next(err);\n            } else {\n              // Select video stream with the highest resolution\n              var vstream = meta.streams.reduce(function(biggest, stream) {\n                if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                  return stream;\n                } else {\n                  return biggest;\n                }\n              }, { width: 0, height: 0 });\n\n              if (vstream.width === 0) {\n                return next(new Error('No video stream in input, cannot take screenshots'));\n              }\n\n              var duration = Number(vstream.duration);\n              if (isNaN(duration)) {\n                duration = Number(meta.format.duration);\n              }\n\n              if (isNaN(duration)) {\n                return next(new Error('Could not get input duration, please specify fixed timemarks'));\n              }\n\n              config.timemarks = config.timemarks.map(function(mark) {\n                if (('' + mark).match(/^([\\d.]+)%$/)) {\n                  return duration * parseFloat(mark) / 100;\n                } else {\n                  return mark;\n                }\n              });\n\n              next();\n            }\n          });\n        } else {\n          next();\n        }\n      },\n\n      // Turn all timemarks into numbers and sort them\n      function normalizeTimemarks(next) {\n        config.timemarks = config.timemarks.map(function(mark) {\n          return utils.timemarkToSeconds(mark);\n        }).sort(function(a, b) { return a - b; });\n\n        next();\n      },\n\n      // Add '_%i' to pattern when requesting multiple screenshots and no variable token is present\n      function fixPattern(next) {\n        var pattern = config.filename || 'tn.png';\n\n        if (pattern.indexOf('.') === -1) {\n          pattern += '.png';\n        }\n\n        if (config.timemarks.length > 1 && !pattern.match(/%(s|0*i)/)) {\n          var ext = path.extname(pattern);\n          pattern = path.join(path.dirname(pattern), path.basename(pattern, ext) + '_%i' + ext);\n        }\n\n        next(null, pattern);\n      },\n\n      // Replace filename tokens (%f, %b) in pattern\n      function replaceFilenameTokens(pattern, next) {\n        if (pattern.match(/%[bf]/)) {\n          if (typeof source !== 'string') {\n            return next(new Error('Cannot replace %f or %b when using an input stream'));\n          }\n\n          pattern = pattern\n            .replace(/%f/g, path.basename(source))\n            .replace(/%b/g, path.basename(source, path.extname(source)));\n        }\n\n        next(null, pattern);\n      },\n\n      // Compute size if needed\n      function getSize(pattern, next) {\n        if (pattern.match(/%[whr]/)) {\n          if (fixedSize) {\n            return next(null, pattern, fixedSize[1], fixedSize[2]);\n          }\n\n          getMetadata(function(err, meta) {\n            if (err) {\n              return next(new Error('Could not determine video resolution to replace %w, %h or %r'));\n            }\n\n            var vstream = meta.streams.reduce(function(biggest, stream) {\n              if (stream.codec_type === 'video' && stream.width * stream.height > biggest.width * biggest.height) {\n                return stream;\n              } else {\n                return biggest;\n              }\n            }, { width: 0, height: 0 });\n\n            if (vstream.width === 0) {\n              return next(new Error('No video stream in input, cannot replace %w, %h or %r'));\n            }\n\n            var width = vstream.width;\n            var height = vstream.height;\n\n            if (fixedWidth) {\n              height = height * Number(fixedWidth[1]) / width;\n              width = Number(fixedWidth[1]);\n            } else if (fixedHeight) {\n              width = width * Number(fixedHeight[1]) / height;\n              height = Number(fixedHeight[1]);\n            } else if (percentSize) {\n              width = width * Number(percentSize[1]) / 100;\n              height = height * Number(percentSize[1]) / 100;\n            }\n\n            next(null, pattern, Math.round(width / 2) * 2, Math.round(height / 2) * 2);\n          });\n        } else {\n          next(null, pattern, -1, -1);\n        }\n      },\n\n      // Replace size tokens (%w, %h, %r) in pattern\n      function replaceSizeTokens(pattern, width, height, next) {\n        pattern = pattern\n          .replace(/%r/g, '%wx%h')\n          .replace(/%w/g, width)\n          .replace(/%h/g, height);\n\n        next(null, pattern);\n      },\n\n      // Replace variable tokens in pattern (%s, %i) and generate filename list\n      function replaceVariableTokens(pattern, next) {\n        var filenames = config.timemarks.map(function(t, i) {\n          return pattern\n            .replace(/%s/g, utils.timemarkToSeconds(t))\n            .replace(/%(0*)i/g, function(match, padding) {\n              var idx = '' + (i + 1);\n              return padding.substr(0, Math.max(0, padding.length + 1 - idx.length)) + idx;\n            });\n        });\n\n        self.emit('filenames', filenames);\n        next(null, filenames);\n      },\n\n      // Create output directory\n      function createDirectory(filenames, next) {\n        fs.exists(config.folder, function(exists) {\n          if (!exists) {\n            fs.mkdir(config.folder, function(err) {\n              if (err) {\n                next(err);\n              } else {\n                next(null, filenames);\n              }\n            });\n          } else {\n            next(null, filenames);\n          }\n        });\n      }\n    ], function runCommand(err, filenames) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var count = config.timemarks.length;\n      var split;\n      var filters = [split = {\n        filter: 'split',\n        options: count,\n        outputs: []\n      }];\n\n      if ('size' in config) {\n        // Set size to generate size filters\n        self.size(config.size);\n\n        // Get size filters and chain them with 'sizeN' stream names\n        var sizeFilters =  self._currentOutput.sizeFilters.get().map(function(f, i) {\n          if (i > 0) {\n            f.inputs = 'size' + (i - 1);\n          }\n\n          f.outputs = 'size' + i;\n\n          return f;\n        });\n\n        // Input last size filter output into split filter\n        split.inputs = 'size' + (sizeFilters.length - 1);\n\n        // Add size filters in front of split filter\n        filters = sizeFilters.concat(filters);\n\n        // Remove size filters\n        self._currentOutput.sizeFilters.clear();\n      }\n\n      var first = 0;\n      for (var i = 0; i < count; i++) {\n        var stream = 'screen' + i;\n        split.outputs.push(stream);\n\n        if (i === 0) {\n          first = config.timemarks[i];\n          self.seekInput(first);\n        }\n\n        self.output(path.join(config.folder, filenames[i]))\n          .frames(1)\n          .map(stream);\n\n        if (i > 0) {\n          self.seek(config.timemarks[i] - first);\n        }\n      }\n\n      self.complexFilter(filters);\n      self.run();\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Merge (concatenate) inputs to a single file\n   *\n   * @method FfmpegCommand#concat\n   * @category Processing\n   * @aliases concatenate,mergeToFile\n   *\n   * @param {String|Writable} target output file or writable stream\n   * @param {Object} [options] pipe options (only used when outputting to a writable stream)\n   * @return FfmpegCommand\n   */\n  proto.mergeToFile =\n  proto.concatenate =\n  proto.concat = function(target, options) {\n    // Find out which streams are present in the first non-stream input\n    var fileInput = this._inputs.filter(function(input) {\n      return !input.isStream;\n    })[0];\n\n    var self = this;\n    this.ffprobe(this._inputs.indexOf(fileInput), function(err, data) {\n      if (err) {\n        return self.emit('error', err);\n      }\n\n      var hasAudioStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'audio';\n      });\n\n      var hasVideoStreams = data.streams.some(function(stream) {\n        return stream.codec_type === 'video';\n      });\n\n      // Setup concat filter and start processing\n      self.output(target, options)\n        .complexFilter({\n          filter: 'concat',\n          options: {\n            n: self._inputs.length,\n            v: hasVideoStreams ? 1 : 0,\n            a: hasAudioStreams ? 1 : 0\n          }\n        })\n        .run();\n    });\n\n    return this;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvcmVjaXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixrQkFBa0IseURBQTZCO0FBQy9DLFlBQVksbUJBQU8sQ0FBQyxzREFBTztBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0VBQVM7OztBQUc3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUSxXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxhQUFhLFFBQVEsOENBQThDO0FBQ25FO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxXQUFXO0FBQ1g7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRLHdEQUF3RDtBQUM3RSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHFDQUFxQztBQUNyRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxlQUFlLElBQUkscUJBQXFCOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0JBQXdCLGVBQWU7O0FBRWhEO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWEsSUFBSSxxQkFBcUI7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbGliL3JlY2lwZXMuanM/MDUzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmpzaGludCBub2RlOnRydWUqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaDtcbnZhciBhc3luYyA9IHJlcXVpcmUoJ2FzeW5jJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cblxuLypcbiAqIFVzZWZ1bCByZWNpcGVzIGZvciBjb21tYW5kc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVjaXBlcyhwcm90bykge1xuICAvKipcbiAgICogRXhlY3V0ZSBmZm1wZWcgY29tbWFuZCBhbmQgc2F2ZSBvdXRwdXQgdG8gYSBmaWxlXG4gICAqXG4gICAqIEBtZXRob2QgRmZtcGVnQ29tbWFuZCNzYXZlXG4gICAqIEBjYXRlZ29yeSBQcm9jZXNzaW5nXG4gICAqIEBhbGlhc2VzIHNhdmVUb0ZpbGVcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dCBmaWxlIHBhdGhcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by5zYXZlVG9GaWxlID1cbiAgcHJvdG8uc2F2ZSA9IGZ1bmN0aW9uKG91dHB1dCkge1xuICAgIHRoaXMub3V0cHV0KG91dHB1dCkucnVuKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogRXhlY3V0ZSBmZm1wZWcgY29tbWFuZCBhbmQgc2F2ZSBvdXRwdXQgdG8gYSBzdHJlYW1cbiAgICpcbiAgICogSWYgJ3N0cmVhbScgaXMgbm90IHNwZWNpZmllZCwgYSBQYXNzVGhyb3VnaCBzdHJlYW0gaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAqICdvcHRpb25zJyB3aWxsIGJlIHVzZWQgd2hlbiBwaXBpbmcgZmZtcGVnIG91dHB1dCB0byB0aGUgb3V0cHV0IHN0cmVhbVxuICAgKiAoQHNlZSBodHRwOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX3JlYWRhYmxlX3BpcGVfZGVzdGluYXRpb25fb3B0aW9ucylcbiAgICpcbiAgICogQG1ldGhvZCBGZm1wZWdDb21tYW5kI3BpcGVcbiAgICogQGNhdGVnb3J5IFByb2Nlc3NpbmdcbiAgICogQGFsaWFzZXMgc3RyZWFtLHdyaXRlVG9TdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJlYW0uV3JpdGFibGV9IFtzdHJlYW1dIG91dHB1dCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBwaXBlIG9wdGlvbnNcbiAgICogQHJldHVybiBPdXRwdXQgc3RyZWFtXG4gICAqL1xuICBwcm90by53cml0ZVRvU3RyZWFtID1cbiAgcHJvdG8ucGlwZSA9XG4gIHByb3RvLnN0cmVhbSA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0aW9ucykge1xuICAgIGlmIChzdHJlYW0gJiYgISgnd3JpdGFibGUnIGluIHN0cmVhbSkpIHtcbiAgICAgIG9wdGlvbnMgPSBzdHJlYW07XG4gICAgICBzdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFzdHJlYW0pIHtcbiAgICAgIGlmIChwcm9jZXNzLnZlcnNpb24ubWF0Y2goL3YwXFwuOFxcLi8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFzc1Rocm91Z2ggc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gbm9kZSB2MC44Jyk7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgIH1cblxuICAgIHRoaXMub3V0cHV0KHN0cmVhbSwgb3B0aW9ucykucnVuKCk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBpbWFnZXMgZnJvbSBhIHZpZGVvXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgbWV0aG9kIG1ha2VzIHRoZSBjb21tYW5kIGVtaXQgYSAnZmlsZW5hbWVzJyBldmVudCB3aXRoIGFuIGFycmF5IG9mXG4gICAqIHRoZSBnZW5lcmF0ZWQgaW1hZ2UgZmlsZW5hbWVzLlxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjc2NyZWVuc2hvdHNcbiAgICogQGNhdGVnb3J5IFByb2Nlc3NpbmdcbiAgICogQGFsaWFzZXMgdGFrZVNjcmVlbnNob3RzLHRodW1ibmFpbCx0aHVtYm5haWxzLHNjcmVlbnNob3RcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbY29uZmlnPTFdIHNjcmVlbnNob3QgY291bnQgb3IgY29uZmlndXJhdGlvbiBvYmplY3Qgd2l0aFxuICAgKiAgIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY291bnRdIG51bWJlciBvZiBzY3JlZW5zaG90cyB0byB0YWtlOyB1c2luZyB0aGlzIG9wdGlvblxuICAgKiAgIHRha2VzIHNjcmVlbnNob3RzIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIChlZy4gY291bnQ9NCB3b3VsZCB0YWtlIHNjcmVlbnMgYXQgMjAlLCA0MCUsXG4gICAqICAgNjAlIGFuZCA4MCUgb2YgdGhlIHZpZGVvIGxlbmd0aCkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbGRlcj0nLiddIG91dHB1dCBmb2xkZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsZW5hbWU9J3RuLnBuZyddIG91dHB1dCBmaWxlbmFtZSBwYXR0ZXJuLCBtYXkgY29udGFpbiB0aGUgZm9sbG93aW5nXG4gICAqICAgdG9rZW5zOlxuICAgKiAgIC0gJyVzJzogb2Zmc2V0IGluIHNlY29uZHNcbiAgICogICAtICcldyc6IHNjcmVlbnNob3Qgd2lkdGhcbiAgICogICAtICclaCc6IHNjcmVlbnNob3QgaGVpZ2h0XG4gICAqICAgLSAnJXInOiBzY3JlZW5zaG90IHJlc29sdXRpb24gKHNhbWUgYXMgJyV3eCVoJylcbiAgICogICAtICclZic6IGlucHV0IGZpbGVuYW1lXG4gICAqICAgLSAnJWInOiBpbnB1dCBiYXNlbmFtZSAoZmlsZW5hbWUgdy9vIGV4dGVuc2lvbilcbiAgICogICAtICclaSc6IGluZGV4IG9mIHNjcmVlbnNob3QgaW4gdGltZW1hcmsgYXJyYXkgKGNhbiBiZSB6ZXJvLXBhZGRlZCBieSB1c2luZyBpdCBsaWtlIGAlMDAwaWApXG4gICAqIEBwYXJhbSB7TnVtYmVyW118U3RyaW5nW119IFtjb25maWcudGltZW1hcmtzXSBhcnJheSBvZiB0aW1lbWFya3MgdG8gdGFrZSBzY3JlZW5zaG90c1xuICAgKiAgIGF0OyBlYWNoIHRpbWVtYXJrIG1heSBiZSBhIG51bWJlciBvZiBzZWNvbmRzLCBhICdbW2hoOl1tbTpdc3NbLnh4eF0nIHN0cmluZyBvciBhXG4gICAqICAgJ1hYJScgc3RyaW5nLiAgT3ZlcnJpZGVzICdjb3VudCcgaWYgcHJlc2VudC5cbiAgICogQHBhcmFtIHtOdW1iZXJbXXxTdHJpbmdbXX0gW2NvbmZpZy50aW1lc3RhbXBzXSBhbGlhcyBmb3IgJ3RpbWVtYXJrcydcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZhc3RTZWVrXSB1c2UgZmFzdCBzZWVrIChsZXNzIGFjY3VyYXRlKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaXplXSBzY3JlZW5zaG90IHNpemUsIHdpdGggdGhlIHNhbWUgc3ludGF4IGFzIHtAbGluayBGZm1wZWdDb21tYW5kI3NpemV9XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZm9sZGVyXSBvdXRwdXQgZm9sZGVyIChsZWdhY3kgYWxpYXMgZm9yICdjb25maWcuZm9sZGVyJylcbiAgICogQHJldHVybiBGZm1wZWdDb21tYW5kXG4gICAqL1xuICBwcm90by50YWtlU2NyZWVuc2hvdHMgPVxuICBwcm90by50aHVtYm5haWwgPVxuICBwcm90by50aHVtYm5haWxzID1cbiAgcHJvdG8uc2NyZWVuc2hvdCA9XG4gIHByb3RvLnNjcmVlbnNob3RzID0gZnVuY3Rpb24oY29uZmlnLCBmb2xkZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuX2N1cnJlbnRJbnB1dC5zb3VyY2U7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHsgY291bnQ6IDEgfTtcblxuICAgIC8vIEFjY2VwdCBhIG51bWJlciBvZiBzY3JlZW5zaG90cyBpbnN0ZWFkIG9mIGEgY29uZmlnIG9iamVjdFxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnID0ge1xuICAgICAgICBjb3VudDogY29uZmlnXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEFjY2VwdCBhIHNlY29uZCAnZm9sZGVyJyBwYXJhbWV0ZXIgaW5zdGVhZCBvZiBjb25maWcuZm9sZGVyXG4gICAgaWYgKCEoJ2ZvbGRlcicgaW4gY29uZmlnKSkge1xuICAgICAgY29uZmlnLmZvbGRlciA9IGZvbGRlciB8fCAnLic7XG4gICAgfVxuXG4gICAgLy8gQWNjZXB0ICd0aW1lc3RhbXBzJyBpbnN0ZWFkIG9mICd0aW1lbWFya3MnXG4gICAgaWYgKCd0aW1lc3RhbXBzJyBpbiBjb25maWcpIHtcbiAgICAgIGNvbmZpZy50aW1lbWFya3MgPSBjb25maWcudGltZXN0YW1wcztcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRpbWVtYXJrcyBmcm9tIGNvdW50IGlmIG5vdCBwcmVzZW50XG4gICAgaWYgKCEoJ3RpbWVtYXJrcycgaW4gY29uZmlnKSkge1xuICAgICAgaWYgKCFjb25maWcuY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdGFrZSBzY3JlZW5zaG90czogbmVpdGhlciBhIGNvdW50IG5vciBhIHRpbWVtYXJrIGxpc3QgYXJlIHNwZWNpZmllZCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW50ZXJ2YWwgPSAxMDAgLyAoMSArIGNvbmZpZy5jb3VudCk7XG4gICAgICBjb25maWcudGltZW1hcmtzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbmZpZy5jb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbmZpZy50aW1lbWFya3MucHVzaCgoaW50ZXJ2YWwgKiAoaSArIDEpKSArICclJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugc2l6ZSBvcHRpb25cbiAgICBpZiAoJ3NpemUnIGluIGNvbmZpZykge1xuICAgICAgdmFyIGZpeGVkU2l6ZSA9IGNvbmZpZy5zaXplLm1hdGNoKC9eKFxcZCspeChcXGQrKSQvKTtcbiAgICAgIHZhciBmaXhlZFdpZHRoID0gY29uZmlnLnNpemUubWF0Y2goL14oXFxkKyl4XFw/JC8pO1xuICAgICAgdmFyIGZpeGVkSGVpZ2h0ID0gY29uZmlnLnNpemUubWF0Y2goL15cXD94KFxcZCspJC8pO1xuICAgICAgdmFyIHBlcmNlbnRTaXplID0gY29uZmlnLnNpemUubWF0Y2goL14oXFxkKyklJC8pO1xuXG4gICAgICBpZiAoIWZpeGVkU2l6ZSAmJiAhZml4ZWRXaWR0aCAmJiAhZml4ZWRIZWlnaHQgJiYgIXBlcmNlbnRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaXplIHBhcmFtZXRlcjogJyArIGNvbmZpZy5zaXplKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNZXRhZGF0YSBoZWxwZXJcbiAgICB2YXIgbWV0YWRhdGE7XG4gICAgZnVuY3Rpb24gZ2V0TWV0YWRhdGEoY2IpIHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBjYihudWxsLCBtZXRhZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmZmcHJvYmUoZnVuY3Rpb24oZXJyLCBtZXRhKSB7XG4gICAgICAgICAgbWV0YWRhdGEgPSBtZXRhO1xuICAgICAgICAgIGNiKGVyciwgbWV0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jLndhdGVyZmFsbChbXG4gICAgICAvLyBDb21wdXRlIHBlcmNlbnQgdGltZW1hcmtzIGlmIGFueVxuICAgICAgZnVuY3Rpb24gY29tcHV0ZVRpbWVtYXJrcyhuZXh0KSB7XG4gICAgICAgIGlmIChjb25maWcudGltZW1hcmtzLnNvbWUoZnVuY3Rpb24odCkgeyByZXR1cm4gKCcnICsgdCkubWF0Y2goL15bXFxkLl0rJSQvKTsgfSkpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KG5ldyBFcnJvcignQ2Fubm90IGNvbXB1dGUgc2NyZWVuc2hvdCB0aW1lbWFya3Mgd2l0aCBhbiBpbnB1dCBzdHJlYW0sIHBsZWFzZSBzcGVjaWZ5IGZpeGVkIHRpbWVtYXJrcycpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRNZXRhZGF0YShmdW5jdGlvbihlcnIsIG1ldGEpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gU2VsZWN0IHZpZGVvIHN0cmVhbSB3aXRoIHRoZSBoaWdoZXN0IHJlc29sdXRpb25cbiAgICAgICAgICAgICAgdmFyIHZzdHJlYW0gPSBtZXRhLnN0cmVhbXMucmVkdWNlKGZ1bmN0aW9uKGJpZ2dlc3QsIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY29kZWNfdHlwZSA9PT0gJ3ZpZGVvJyAmJiBzdHJlYW0ud2lkdGggKiBzdHJlYW0uaGVpZ2h0ID4gYmlnZ2VzdC53aWR0aCAqIGJpZ2dlc3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYmlnZ2VzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcblxuICAgICAgICAgICAgICBpZiAodnN0cmVhbS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KG5ldyBFcnJvcignTm8gdmlkZW8gc3RyZWFtIGluIGlucHV0LCBjYW5ub3QgdGFrZSBzY3JlZW5zaG90cycpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBkdXJhdGlvbiA9IE51bWJlcih2c3RyZWFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgaWYgKGlzTmFOKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gTnVtYmVyKG1ldGEuZm9ybWF0LmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChpc05hTihkdXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgaW5wdXQgZHVyYXRpb24sIHBsZWFzZSBzcGVjaWZ5IGZpeGVkIHRpbWVtYXJrcycpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbmZpZy50aW1lbWFya3MgPSBjb25maWcudGltZW1hcmtzLm1hcChmdW5jdGlvbihtYXJrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgnJyArIG1hcmspLm1hdGNoKC9eKFtcXGQuXSspJSQvKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGR1cmF0aW9uICogcGFyc2VGbG9hdChtYXJrKSAvIDEwMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBUdXJuIGFsbCB0aW1lbWFya3MgaW50byBudW1iZXJzIGFuZCBzb3J0IHRoZW1cbiAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVRpbWVtYXJrcyhuZXh0KSB7XG4gICAgICAgIGNvbmZpZy50aW1lbWFya3MgPSBjb25maWcudGltZW1hcmtzLm1hcChmdW5jdGlvbihtYXJrKSB7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzLnRpbWVtYXJrVG9TZWNvbmRzKG1hcmspO1xuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9KTtcblxuICAgICAgICBuZXh0KCk7XG4gICAgICB9LFxuXG4gICAgICAvLyBBZGQgJ18laScgdG8gcGF0dGVybiB3aGVuIHJlcXVlc3RpbmcgbXVsdGlwbGUgc2NyZWVuc2hvdHMgYW5kIG5vIHZhcmlhYmxlIHRva2VuIGlzIHByZXNlbnRcbiAgICAgIGZ1bmN0aW9uIGZpeFBhdHRlcm4obmV4dCkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IGNvbmZpZy5maWxlbmFtZSB8fCAndG4ucG5nJztcblxuICAgICAgICBpZiAocGF0dGVybi5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgICAgICAgcGF0dGVybiArPSAnLnBuZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLnRpbWVtYXJrcy5sZW5ndGggPiAxICYmICFwYXR0ZXJuLm1hdGNoKC8lKHN8MCppKS8pKSB7XG4gICAgICAgICAgdmFyIGV4dCA9IHBhdGguZXh0bmFtZShwYXR0ZXJuKTtcbiAgICAgICAgICBwYXR0ZXJuID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShwYXR0ZXJuKSwgcGF0aC5iYXNlbmFtZShwYXR0ZXJuLCBleHQpICsgJ18laScgKyBleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChudWxsLCBwYXR0ZXJuKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIFJlcGxhY2UgZmlsZW5hbWUgdG9rZW5zICglZiwgJWIpIGluIHBhdHRlcm5cbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VGaWxlbmFtZVRva2VucyhwYXR0ZXJuLCBuZXh0KSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLm1hdGNoKC8lW2JmXS8pKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ0Nhbm5vdCByZXBsYWNlICVmIG9yICViIHdoZW4gdXNpbmcgYW4gaW5wdXQgc3RyZWFtJykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgICAgICAgICAucmVwbGFjZSgvJWYvZywgcGF0aC5iYXNlbmFtZShzb3VyY2UpKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyViL2csIHBhdGguYmFzZW5hbWUoc291cmNlLCBwYXRoLmV4dG5hbWUoc291cmNlKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dChudWxsLCBwYXR0ZXJuKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIENvbXB1dGUgc2l6ZSBpZiBuZWVkZWRcbiAgICAgIGZ1bmN0aW9uIGdldFNpemUocGF0dGVybiwgbmV4dCkge1xuICAgICAgICBpZiAocGF0dGVybi5tYXRjaCgvJVt3aHJdLykpIHtcbiAgICAgICAgICBpZiAoZml4ZWRTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dChudWxsLCBwYXR0ZXJuLCBmaXhlZFNpemVbMV0sIGZpeGVkU2l6ZVsyXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZ2V0TWV0YWRhdGEoZnVuY3Rpb24oZXJyLCBtZXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0KG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSB2aWRlbyByZXNvbHV0aW9uIHRvIHJlcGxhY2UgJXcsICVoIG9yICVyJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdnN0cmVhbSA9IG1ldGEuc3RyZWFtcy5yZWR1Y2UoZnVuY3Rpb24oYmlnZ2VzdCwgc3RyZWFtKSB7XG4gICAgICAgICAgICAgIGlmIChzdHJlYW0uY29kZWNfdHlwZSA9PT0gJ3ZpZGVvJyAmJiBzdHJlYW0ud2lkdGggKiBzdHJlYW0uaGVpZ2h0ID4gYmlnZ2VzdC53aWR0aCAqIGJpZ2dlc3QuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlnZ2VzdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuXG4gICAgICAgICAgICBpZiAodnN0cmVhbS53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dChuZXcgRXJyb3IoJ05vIHZpZGVvIHN0cmVhbSBpbiBpbnB1dCwgY2Fubm90IHJlcGxhY2UgJXcsICVoIG9yICVyJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB2c3RyZWFtLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHZzdHJlYW0uaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoZml4ZWRXaWR0aCkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKiBOdW1iZXIoZml4ZWRXaWR0aFsxXSkgLyB3aWR0aDtcbiAgICAgICAgICAgICAgd2lkdGggPSBOdW1iZXIoZml4ZWRXaWR0aFsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZpeGVkSGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHdpZHRoID0gd2lkdGggKiBOdW1iZXIoZml4ZWRIZWlnaHRbMV0pIC8gaGVpZ2h0O1xuICAgICAgICAgICAgICBoZWlnaHQgPSBOdW1iZXIoZml4ZWRIZWlnaHRbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwZXJjZW50U2l6ZSkge1xuICAgICAgICAgICAgICB3aWR0aCA9IHdpZHRoICogTnVtYmVyKHBlcmNlbnRTaXplWzFdKSAvIDEwMDtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0ICogTnVtYmVyKHBlcmNlbnRTaXplWzFdKSAvIDEwMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmV4dChudWxsLCBwYXR0ZXJuLCBNYXRoLnJvdW5kKHdpZHRoIC8gMikgKiAyLCBNYXRoLnJvdW5kKGhlaWdodCAvIDIpICogMik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dChudWxsLCBwYXR0ZXJuLCAtMSwgLTEpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvLyBSZXBsYWNlIHNpemUgdG9rZW5zICgldywgJWgsICVyKSBpbiBwYXR0ZXJuXG4gICAgICBmdW5jdGlvbiByZXBsYWNlU2l6ZVRva2VucyhwYXR0ZXJuLCB3aWR0aCwgaGVpZ2h0LCBuZXh0KSB7XG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuXG4gICAgICAgICAgLnJlcGxhY2UoLyVyL2csICcld3glaCcpXG4gICAgICAgICAgLnJlcGxhY2UoLyV3L2csIHdpZHRoKVxuICAgICAgICAgIC5yZXBsYWNlKC8laC9nLCBoZWlnaHQpO1xuXG4gICAgICAgIG5leHQobnVsbCwgcGF0dGVybik7XG4gICAgICB9LFxuXG4gICAgICAvLyBSZXBsYWNlIHZhcmlhYmxlIHRva2VucyBpbiBwYXR0ZXJuICglcywgJWkpIGFuZCBnZW5lcmF0ZSBmaWxlbmFtZSBsaXN0XG4gICAgICBmdW5jdGlvbiByZXBsYWNlVmFyaWFibGVUb2tlbnMocGF0dGVybiwgbmV4dCkge1xuICAgICAgICB2YXIgZmlsZW5hbWVzID0gY29uZmlnLnRpbWVtYXJrcy5tYXAoZnVuY3Rpb24odCwgaSkge1xuICAgICAgICAgIHJldHVybiBwYXR0ZXJuXG4gICAgICAgICAgICAucmVwbGFjZSgvJXMvZywgdXRpbHMudGltZW1hcmtUb1NlY29uZHModCkpXG4gICAgICAgICAgICAucmVwbGFjZSgvJSgwKilpL2csIGZ1bmN0aW9uKG1hdGNoLCBwYWRkaW5nKSB7XG4gICAgICAgICAgICAgIHZhciBpZHggPSAnJyArIChpICsgMSk7XG4gICAgICAgICAgICAgIHJldHVybiBwYWRkaW5nLnN1YnN0cigwLCBNYXRoLm1heCgwLCBwYWRkaW5nLmxlbmd0aCArIDEgLSBpZHgubGVuZ3RoKSkgKyBpZHg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VsZi5lbWl0KCdmaWxlbmFtZXMnLCBmaWxlbmFtZXMpO1xuICAgICAgICBuZXh0KG51bGwsIGZpbGVuYW1lcyk7XG4gICAgICB9LFxuXG4gICAgICAvLyBDcmVhdGUgb3V0cHV0IGRpcmVjdG9yeVxuICAgICAgZnVuY3Rpb24gY3JlYXRlRGlyZWN0b3J5KGZpbGVuYW1lcywgbmV4dCkge1xuICAgICAgICBmcy5leGlzdHMoY29uZmlnLmZvbGRlciwgZnVuY3Rpb24oZXhpc3RzKSB7XG4gICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIGZzLm1rZGlyKGNvbmZpZy5mb2xkZXIsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgbmV4dChlcnIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHQobnVsbCwgZmlsZW5hbWVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQobnVsbCwgZmlsZW5hbWVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIF0sIGZ1bmN0aW9uIHJ1bkNvbW1hbmQoZXJyLCBmaWxlbmFtZXMpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY291bnQgPSBjb25maWcudGltZW1hcmtzLmxlbmd0aDtcbiAgICAgIHZhciBzcGxpdDtcbiAgICAgIHZhciBmaWx0ZXJzID0gW3NwbGl0ID0ge1xuICAgICAgICBmaWx0ZXI6ICdzcGxpdCcsXG4gICAgICAgIG9wdGlvbnM6IGNvdW50LFxuICAgICAgICBvdXRwdXRzOiBbXVxuICAgICAgfV07XG5cbiAgICAgIGlmICgnc2l6ZScgaW4gY29uZmlnKSB7XG4gICAgICAgIC8vIFNldCBzaXplIHRvIGdlbmVyYXRlIHNpemUgZmlsdGVyc1xuICAgICAgICBzZWxmLnNpemUoY29uZmlnLnNpemUpO1xuXG4gICAgICAgIC8vIEdldCBzaXplIGZpbHRlcnMgYW5kIGNoYWluIHRoZW0gd2l0aCAnc2l6ZU4nIHN0cmVhbSBuYW1lc1xuICAgICAgICB2YXIgc2l6ZUZpbHRlcnMgPSAgc2VsZi5fY3VycmVudE91dHB1dC5zaXplRmlsdGVycy5nZXQoKS5tYXAoZnVuY3Rpb24oZiwgaSkge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZi5pbnB1dHMgPSAnc2l6ZScgKyAoaSAtIDEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGYub3V0cHV0cyA9ICdzaXplJyArIGk7XG5cbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5wdXQgbGFzdCBzaXplIGZpbHRlciBvdXRwdXQgaW50byBzcGxpdCBmaWx0ZXJcbiAgICAgICAgc3BsaXQuaW5wdXRzID0gJ3NpemUnICsgKHNpemVGaWx0ZXJzLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIC8vIEFkZCBzaXplIGZpbHRlcnMgaW4gZnJvbnQgb2Ygc3BsaXQgZmlsdGVyXG4gICAgICAgIGZpbHRlcnMgPSBzaXplRmlsdGVycy5jb25jYXQoZmlsdGVycyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHNpemUgZmlsdGVyc1xuICAgICAgICBzZWxmLl9jdXJyZW50T3V0cHV0LnNpemVGaWx0ZXJzLmNsZWFyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHN0cmVhbSA9ICdzY3JlZW4nICsgaTtcbiAgICAgICAgc3BsaXQub3V0cHV0cy5wdXNoKHN0cmVhbSk7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBmaXJzdCA9IGNvbmZpZy50aW1lbWFya3NbaV07XG4gICAgICAgICAgc2VsZi5zZWVrSW5wdXQoZmlyc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5vdXRwdXQocGF0aC5qb2luKGNvbmZpZy5mb2xkZXIsIGZpbGVuYW1lc1tpXSkpXG4gICAgICAgICAgLmZyYW1lcygxKVxuICAgICAgICAgIC5tYXAoc3RyZWFtKTtcblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBzZWxmLnNlZWsoY29uZmlnLnRpbWVtYXJrc1tpXSAtIGZpcnN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLmNvbXBsZXhGaWx0ZXIoZmlsdGVycyk7XG4gICAgICBzZWxmLnJ1bigpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cblxuICAvKipcbiAgICogTWVyZ2UgKGNvbmNhdGVuYXRlKSBpbnB1dHMgdG8gYSBzaW5nbGUgZmlsZVxuICAgKlxuICAgKiBAbWV0aG9kIEZmbXBlZ0NvbW1hbmQjY29uY2F0XG4gICAqIEBjYXRlZ29yeSBQcm9jZXNzaW5nXG4gICAqIEBhbGlhc2VzIGNvbmNhdGVuYXRlLG1lcmdlVG9GaWxlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfFdyaXRhYmxlfSB0YXJnZXQgb3V0cHV0IGZpbGUgb3Igd3JpdGFibGUgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gcGlwZSBvcHRpb25zIChvbmx5IHVzZWQgd2hlbiBvdXRwdXR0aW5nIHRvIGEgd3JpdGFibGUgc3RyZWFtKVxuICAgKiBAcmV0dXJuIEZmbXBlZ0NvbW1hbmRcbiAgICovXG4gIHByb3RvLm1lcmdlVG9GaWxlID1cbiAgcHJvdG8uY29uY2F0ZW5hdGUgPVxuICBwcm90by5jb25jYXQgPSBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAvLyBGaW5kIG91dCB3aGljaCBzdHJlYW1zIGFyZSBwcmVzZW50IGluIHRoZSBmaXJzdCBub24tc3RyZWFtIGlucHV0XG4gICAgdmFyIGZpbGVJbnB1dCA9IHRoaXMuX2lucHV0cy5maWx0ZXIoZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgIHJldHVybiAhaW5wdXQuaXNTdHJlYW07XG4gICAgfSlbMF07XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5mZnByb2JlKHRoaXMuX2lucHV0cy5pbmRleE9mKGZpbGVJbnB1dCksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNBdWRpb1N0cmVhbXMgPSBkYXRhLnN0cmVhbXMuc29tZShmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5jb2RlY190eXBlID09PSAnYXVkaW8nO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBoYXNWaWRlb1N0cmVhbXMgPSBkYXRhLnN0cmVhbXMuc29tZShmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5jb2RlY190eXBlID09PSAndmlkZW8nO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldHVwIGNvbmNhdCBmaWx0ZXIgYW5kIHN0YXJ0IHByb2Nlc3NpbmdcbiAgICAgIHNlbGYub3V0cHV0KHRhcmdldCwgb3B0aW9ucylcbiAgICAgICAgLmNvbXBsZXhGaWx0ZXIoe1xuICAgICAgICAgIGZpbHRlcjogJ2NvbmNhdCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgbjogc2VsZi5faW5wdXRzLmxlbmd0aCxcbiAgICAgICAgICAgIHY6IGhhc1ZpZGVvU3RyZWFtcyA/IDEgOiAwLFxuICAgICAgICAgICAgYTogaGFzQXVkaW9TdHJlYW1zID8gMSA6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5ydW4oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/recipes.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/utils.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*jshint node:true*/\n\n\nvar exec = (__webpack_require__(/*! child_process */ \"child_process\").exec);\nvar isWindows = (__webpack_require__(/*! os */ \"os\").platform)().match(/win(32|64)/);\nvar which = __webpack_require__(/*! which */ \"(rsc)/./node_modules/fluent-ffmpeg/node_modules/which/which.js\");\n\nvar nlRegexp = /\\r\\n|\\r|\\n/g;\nvar streamRegexp = /^\\[?(.*?)\\]?$/;\nvar filterEscapeRegexp = /[,]/;\nvar whichCache = {};\n\n/**\n * Parse progress line from ffmpeg stderr\n *\n * @param {String} line progress line\n * @return progress object\n * @private\n */\nfunction parseProgressLine(line) {\n  var progress = {};\n\n  // Remove all spaces after = and trim\n  line  = line.replace(/=\\s+/g, '=').trim();\n  var progressParts = line.split(' ');\n\n  // Split every progress part by \"=\" to get key and value\n  for(var i = 0; i < progressParts.length; i++) {\n    var progressSplit = progressParts[i].split('=', 2);\n    var key = progressSplit[0];\n    var value = progressSplit[1];\n\n    // This is not a progress line\n    if(typeof value === 'undefined')\n      return null;\n\n    progress[key] = value;\n  }\n\n  return progress;\n}\n\n\nvar utils = module.exports = {\n  isWindows: isWindows,\n  streamRegexp: streamRegexp,\n\n\n  /**\n   * Copy an object keys into another one\n   *\n   * @param {Object} source source object\n   * @param {Object} dest destination object\n   * @private\n   */\n  copy: function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n      dest[key] = source[key];\n    });\n  },\n\n\n  /**\n   * Create an argument list\n   *\n   * Returns a function that adds new arguments to the list.\n   * It also has the following methods:\n   * - clear() empties the argument list\n   * - get() returns the argument list\n   * - find(arg, count) finds 'arg' in the list and return the following 'count' items, or undefined if not found\n   * - remove(arg, count) remove 'arg' in the list as well as the following 'count' items\n   *\n   * @private\n   */\n  args: function() {\n    var list = [];\n\n    // Append argument(s) to the list\n    var argfunc = function() {\n      if (arguments.length === 1 && Array.isArray(arguments[0])) {\n        list = list.concat(arguments[0]);\n      } else {\n        list = list.concat([].slice.call(arguments));\n      }\n    };\n\n    // Clear argument list\n    argfunc.clear = function() {\n      list = [];\n    };\n\n    // Return argument list\n    argfunc.get = function() {\n      return list;\n    };\n\n    // Find argument 'arg' in list, and if found, return an array of the 'count' items that follow it\n    argfunc.find = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        return list.slice(index + 1, index + 1 + (count || 0));\n      }\n    };\n\n    // Find argument 'arg' in list, and if found, remove it as well as the 'count' items that follow it\n    argfunc.remove = function(arg, count) {\n      var index = list.indexOf(arg);\n      if (index !== -1) {\n        list.splice(index, (count || 0) + 1);\n      }\n    };\n\n    // Clone argument list\n    argfunc.clone = function() {\n      var cloned = utils.args();\n      cloned(list);\n      return cloned;\n    };\n\n    return argfunc;\n  },\n\n\n  /**\n   * Generate filter strings\n   *\n   * @param {String[]|Object[]} filters filter specifications. When using objects,\n   *   each must have the following properties:\n   * @param {String} filters.filter filter name\n   * @param {String|Array} [filters.inputs] (array of) input stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically choosing the first unused matching streams\n   * @param {String|Array} [filters.outputs] (array of) output stream specifier(s) for the filter,\n   *   defaults to ffmpeg automatically assigning the output to the output file\n   * @param {Object|String|Array} [filters.options] filter options, can be omitted to not set any options\n   * @return String[]\n   * @private\n   */\n  makeFilterStrings: function(filters) {\n    return filters.map(function(filterSpec) {\n      if (typeof filterSpec === 'string') {\n        return filterSpec;\n      }\n\n      var filterString = '';\n\n      // Filter string format is:\n      // [input1][input2]...filter[output1][output2]...\n      // The 'filter' part can optionaly have arguments:\n      //   filter=arg1:arg2:arg3\n      //   filter=arg1=v1:arg2=v2:arg3=v3\n\n      // Add inputs\n      if (Array.isArray(filterSpec.inputs)) {\n        filterString += filterSpec.inputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.inputs === 'string') {\n        filterString += filterSpec.inputs.replace(streamRegexp, '[$1]');\n      }\n\n      // Add filter\n      filterString += filterSpec.filter;\n\n      // Add options\n      if (filterSpec.options) {\n        if (typeof filterSpec.options === 'string' || typeof filterSpec.options === 'number') {\n          // Option string\n          filterString += '=' + filterSpec.options;\n        } else if (Array.isArray(filterSpec.options)) {\n          // Option array (unnamed options)\n          filterString += '=' + filterSpec.options.map(function(option) {\n            if (typeof option === 'string' && option.match(filterEscapeRegexp)) {\n              return '\\'' + option + '\\'';\n            } else {\n              return option;\n            }\n          }).join(':');\n        } else if (Object.keys(filterSpec.options).length) {\n          // Option object (named options)\n          filterString += '=' + Object.keys(filterSpec.options).map(function(option) {\n            var value = filterSpec.options[option];\n\n            if (typeof value === 'string' && value.match(filterEscapeRegexp)) {\n              value = '\\'' + value + '\\'';\n            }\n\n            return option + '=' + value;\n          }).join(':');\n        }\n      }\n\n      // Add outputs\n      if (Array.isArray(filterSpec.outputs)) {\n        filterString += filterSpec.outputs.map(function(streamSpec) {\n          return streamSpec.replace(streamRegexp, '[$1]');\n        }).join('');\n      } else if (typeof filterSpec.outputs === 'string') {\n        filterString += filterSpec.outputs.replace(streamRegexp, '[$1]');\n      }\n\n      return filterString;\n    });\n  },\n\n\n  /**\n   * Search for an executable\n   *\n   * Uses 'which' or 'where' depending on platform\n   *\n   * @param {String} name executable name\n   * @param {Function} callback callback with signature (err, path)\n   * @private\n   */\n  which: function(name, callback) {\n    if (name in whichCache) {\n      return callback(null, whichCache[name]);\n    }\n\n    which(name, function(err, result){\n      if (err) {\n        // Treat errors as not found\n        return callback(null, whichCache[name] = '');\n      }\n      callback(null, whichCache[name] = result);\n    });\n  },\n\n\n  /**\n   * Convert a [[hh:]mm:]ss[.xxx] timemark into seconds\n   *\n   * @param {String} timemark timemark string\n   * @return Number\n   * @private\n   */\n  timemarkToSeconds: function(timemark) {\n    if (typeof timemark === 'number') {\n      return timemark;\n    }\n\n    if (timemark.indexOf(':') === -1 && timemark.indexOf('.') >= 0) {\n      return Number(timemark);\n    }\n\n    var parts = timemark.split(':');\n\n    // add seconds\n    var secs = Number(parts.pop());\n\n    if (parts.length) {\n      // add minutes\n      secs += Number(parts.pop()) * 60;\n    }\n\n    if (parts.length) {\n      // add hours\n      secs += Number(parts.pop()) * 3600;\n    }\n\n    return secs;\n  },\n\n\n  /**\n   * Extract codec data from ffmpeg stderr and emit 'codecData' event if appropriate\n   * Call it with an initially empty codec object once with each line of stderr output until it returns true\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr output line\n   * @param {Object} codecObject object used to accumulate codec data between calls\n   * @return {Boolean} true if codec data is complete (and event was emitted), false otherwise\n   * @private\n   */\n  extractCodecData: function(command, stderrLine, codecsObject) {\n    var inputPattern = /Input #[0-9]+, ([^ ]+),/;\n    var durPattern = /Duration\\: ([^,]+)/;\n    var audioPattern = /Audio\\: (.*)/;\n    var videoPattern = /Video\\: (.*)/;\n\n    if (!('inputStack' in codecsObject)) {\n      codecsObject.inputStack = [];\n      codecsObject.inputIndex = -1;\n      codecsObject.inInput = false;\n    }\n\n    var inputStack = codecsObject.inputStack;\n    var inputIndex = codecsObject.inputIndex;\n    var inInput = codecsObject.inInput;\n\n    var format, dur, audio, video;\n\n    if (format = stderrLine.match(inputPattern)) {\n      inInput = codecsObject.inInput = true;\n      inputIndex = codecsObject.inputIndex = codecsObject.inputIndex + 1;\n\n      inputStack[inputIndex] = { format: format[1], audio: '', video: '', duration: '' };\n    } else if (inInput && (dur = stderrLine.match(durPattern))) {\n      inputStack[inputIndex].duration = dur[1];\n    } else if (inInput && (audio = stderrLine.match(audioPattern))) {\n      audio = audio[1].split(', ');\n      inputStack[inputIndex].audio = audio[0];\n      inputStack[inputIndex].audio_details = audio;\n    } else if (inInput && (video = stderrLine.match(videoPattern))) {\n      video = video[1].split(', ');\n      inputStack[inputIndex].video = video[0];\n      inputStack[inputIndex].video_details = video;\n    } else if (/Output #\\d+/.test(stderrLine)) {\n      inInput = codecsObject.inInput = false;\n    } else if (/Stream mapping:|Press (\\[q\\]|ctrl-c) to stop/.test(stderrLine)) {\n      command.emit.apply(command, ['codecData'].concat(inputStack));\n      return true;\n    }\n\n    return false;\n  },\n\n\n  /**\n   * Extract progress data from ffmpeg stderr and emit 'progress' event if appropriate\n   *\n   * @param {FfmpegCommand} command event emitter\n   * @param {String} stderrLine ffmpeg stderr data\n   * @private\n   */\n  extractProgress: function(command, stderrLine) {\n    var progress = parseProgressLine(stderrLine);\n\n    if (progress) {\n      // build progress report object\n      var ret = {\n        frames: parseInt(progress.frame, 10),\n        currentFps: parseInt(progress.fps, 10),\n        currentKbps: progress.bitrate ? parseFloat(progress.bitrate.replace('kbits/s', '')) : 0,\n        targetSize: parseInt(progress.size || progress.Lsize, 10),\n        timemark: progress.time\n      };\n\n      // calculate percent progress using duration\n      if (command._ffprobeData && command._ffprobeData.format && command._ffprobeData.format.duration) {\n        var duration = Number(command._ffprobeData.format.duration);\n        if (!isNaN(duration))\n          ret.percent = (utils.timemarkToSeconds(ret.timemark) / duration) * 100;\n      }\n      command.emit('progress', ret);\n    }\n  },\n\n\n  /**\n   * Extract error message(s) from ffmpeg stderr\n   *\n   * @param {String} stderr ffmpeg stderr data\n   * @return {String}\n   * @private\n   */\n  extractError: function(stderr) {\n    // Only return the last stderr lines that don't start with a space or a square bracket\n    return stderr.split(nlRegexp).reduce(function(messages, message) {\n      if (message.charAt(0) === ' ' || message.charAt(0) === '[') {\n        return [];\n      } else {\n        messages.push(message);\n        return messages;\n      }\n    }, []).join('\\n');\n  },\n\n\n  /**\n   * Creates a line ring buffer object with the following methods:\n   * - append(str) : appends a string or buffer\n   * - get() : returns the whole string\n   * - close() : prevents further append() calls and does a last call to callbacks\n   * - callback(cb) : calls cb for each line (incl. those already in the ring)\n   *\n   * @param {Number} maxLines maximum number of lines to store (<= 0 for unlimited)\n   */\n  linesRing: function(maxLines) {\n    var cbs = [];\n    var lines = [];\n    var current = null;\n    var closed = false\n    var max = maxLines - 1;\n\n    function emit(line) {\n      cbs.forEach(function(cb) { cb(line); });\n    }\n\n    return {\n      callback: function(cb) {\n        lines.forEach(function(l) { cb(l); });\n        cbs.push(cb);\n      },\n\n      append: function(str) {\n        if (closed) return;\n        if (str instanceof Buffer) str = '' + str;\n        if (!str || str.length === 0) return;\n\n        var newLines = str.split(nlRegexp);\n\n        if (newLines.length === 1) {\n          if (current !== null) {\n            current = current + newLines.shift();\n          } else {\n            current = newLines.shift();\n          }\n        } else {\n          if (current !== null) {\n            current = current + newLines.shift();\n            emit(current);\n            lines.push(current);\n          }\n\n          current = newLines.pop();\n\n          newLines.forEach(function(l) {\n            emit(l);\n            lines.push(l);\n          });\n\n          if (max > -1 && lines.length > max) {\n            lines.splice(0, lines.length - max);\n          }\n        }\n      },\n\n      get: function() {\n        if (current !== null) {\n          return lines.concat([current]).join('\\n');\n        } else {\n          return lines.join('\\n');\n        }\n      },\n\n      close: function() {\n        if (closed) return;\n\n        if (current !== null) {\n          emit(current);\n          lines.push(current);\n\n          if (max > -1 && lines.length > max) {\n            lines.shift();\n          }\n\n          current = null;\n        }\n\n        closed = true;\n      }\n    };\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDYTs7QUFFYixXQUFXLGdFQUE2QjtBQUN4QyxnQkFBZ0IsOENBQXNCO0FBQ3RDLFlBQVksbUJBQU8sQ0FBQyw2RUFBTzs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDBCQUEwQjtBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxXQUFXO0FBQzVDOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy9mbHVlbnQtZmZtcGVnL2xpYi91dGlscy5qcz9hZTU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qanNoaW50IG5vZGU6dHJ1ZSovXG4ndXNlIHN0cmljdCc7XG5cbnZhciBleGVjID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpLmV4ZWM7XG52YXIgaXNXaW5kb3dzID0gcmVxdWlyZSgnb3MnKS5wbGF0Zm9ybSgpLm1hdGNoKC93aW4oMzJ8NjQpLyk7XG52YXIgd2hpY2ggPSByZXF1aXJlKCd3aGljaCcpO1xuXG52YXIgbmxSZWdleHAgPSAvXFxyXFxufFxccnxcXG4vZztcbnZhciBzdHJlYW1SZWdleHAgPSAvXlxcWz8oLio/KVxcXT8kLztcbnZhciBmaWx0ZXJFc2NhcGVSZWdleHAgPSAvWyxdLztcbnZhciB3aGljaENhY2hlID0ge307XG5cbi8qKlxuICogUGFyc2UgcHJvZ3Jlc3MgbGluZSBmcm9tIGZmbXBlZyBzdGRlcnJcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbGluZSBwcm9ncmVzcyBsaW5lXG4gKiBAcmV0dXJuIHByb2dyZXNzIG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcGFyc2VQcm9ncmVzc0xpbmUobGluZSkge1xuICB2YXIgcHJvZ3Jlc3MgPSB7fTtcblxuICAvLyBSZW1vdmUgYWxsIHNwYWNlcyBhZnRlciA9IGFuZCB0cmltXG4gIGxpbmUgID0gbGluZS5yZXBsYWNlKC89XFxzKy9nLCAnPScpLnRyaW0oKTtcbiAgdmFyIHByb2dyZXNzUGFydHMgPSBsaW5lLnNwbGl0KCcgJyk7XG5cbiAgLy8gU3BsaXQgZXZlcnkgcHJvZ3Jlc3MgcGFydCBieSBcIj1cIiB0byBnZXQga2V5IGFuZCB2YWx1ZVxuICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvZ3Jlc3NQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9ncmVzc1NwbGl0ID0gcHJvZ3Jlc3NQYXJ0c1tpXS5zcGxpdCgnPScsIDIpO1xuICAgIHZhciBrZXkgPSBwcm9ncmVzc1NwbGl0WzBdO1xuICAgIHZhciB2YWx1ZSA9IHByb2dyZXNzU3BsaXRbMV07XG5cbiAgICAvLyBUaGlzIGlzIG5vdCBhIHByb2dyZXNzIGxpbmVcbiAgICBpZih0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBwcm9ncmVzc1trZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcHJvZ3Jlc3M7XG59XG5cblxudmFyIHV0aWxzID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzV2luZG93czogaXNXaW5kb3dzLFxuICBzdHJlYW1SZWdleHA6IHN0cmVhbVJlZ2V4cCxcblxuXG4gIC8qKlxuICAgKiBDb3B5IGFuIG9iamVjdCBrZXlzIGludG8gYW5vdGhlciBvbmVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBzb3VyY2Ugb2JqZWN0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkZXN0IGRlc3RpbmF0aW9uIG9iamVjdFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29weTogZnVuY3Rpb24oc291cmNlLCBkZXN0KSB7XG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgZGVzdFtrZXldID0gc291cmNlW2tleV07XG4gICAgfSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGFyZ3VtZW50IGxpc3RcbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWRkcyBuZXcgYXJndW1lbnRzIHRvIHRoZSBsaXN0LlxuICAgKiBJdCBhbHNvIGhhcyB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gICAqIC0gY2xlYXIoKSBlbXB0aWVzIHRoZSBhcmd1bWVudCBsaXN0XG4gICAqIC0gZ2V0KCkgcmV0dXJucyB0aGUgYXJndW1lbnQgbGlzdFxuICAgKiAtIGZpbmQoYXJnLCBjb3VudCkgZmluZHMgJ2FyZycgaW4gdGhlIGxpc3QgYW5kIHJldHVybiB0aGUgZm9sbG93aW5nICdjb3VudCcgaXRlbXMsIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICogLSByZW1vdmUoYXJnLCBjb3VudCkgcmVtb3ZlICdhcmcnIGluIHRoZSBsaXN0IGFzIHdlbGwgYXMgdGhlIGZvbGxvd2luZyAnY291bnQnIGl0ZW1zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhcmdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgLy8gQXBwZW5kIGFyZ3VtZW50KHMpIHRvIHRoZSBsaXN0XG4gICAgdmFyIGFyZ2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBsaXN0ID0gbGlzdC5jb25jYXQoYXJndW1lbnRzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QgPSBsaXN0LmNvbmNhdChbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBDbGVhciBhcmd1bWVudCBsaXN0XG4gICAgYXJnZnVuYy5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgbGlzdCA9IFtdO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gYXJndW1lbnQgbGlzdFxuICAgIGFyZ2Z1bmMuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgLy8gRmluZCBhcmd1bWVudCAnYXJnJyBpbiBsaXN0LCBhbmQgaWYgZm91bmQsIHJldHVybiBhbiBhcnJheSBvZiB0aGUgJ2NvdW50JyBpdGVtcyB0aGF0IGZvbGxvdyBpdFxuICAgIGFyZ2Z1bmMuZmluZCA9IGZ1bmN0aW9uKGFyZywgY291bnQpIHtcbiAgICAgIHZhciBpbmRleCA9IGxpc3QuaW5kZXhPZihhcmcpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gbGlzdC5zbGljZShpbmRleCArIDEsIGluZGV4ICsgMSArIChjb3VudCB8fCAwKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEZpbmQgYXJndW1lbnQgJ2FyZycgaW4gbGlzdCwgYW5kIGlmIGZvdW5kLCByZW1vdmUgaXQgYXMgd2VsbCBhcyB0aGUgJ2NvdW50JyBpdGVtcyB0aGF0IGZvbGxvdyBpdFxuICAgIGFyZ2Z1bmMucmVtb3ZlID0gZnVuY3Rpb24oYXJnLCBjb3VudCkge1xuICAgICAgdmFyIGluZGV4ID0gbGlzdC5pbmRleE9mKGFyZyk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAoY291bnQgfHwgMCkgKyAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQ2xvbmUgYXJndW1lbnQgbGlzdFxuICAgIGFyZ2Z1bmMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjbG9uZWQgPSB1dGlscy5hcmdzKCk7XG4gICAgICBjbG9uZWQobGlzdCk7XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH07XG5cbiAgICByZXR1cm4gYXJnZnVuYztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBmaWx0ZXIgc3RyaW5nc1xuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfE9iamVjdFtdfSBmaWx0ZXJzIGZpbHRlciBzcGVjaWZpY2F0aW9ucy4gV2hlbiB1c2luZyBvYmplY3RzLFxuICAgKiAgIGVhY2ggbXVzdCBoYXZlIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZpbHRlcnMuZmlsdGVyIGZpbHRlciBuYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbZmlsdGVycy5pbnB1dHNdIChhcnJheSBvZikgaW5wdXQgc3RyZWFtIHNwZWNpZmllcihzKSBmb3IgdGhlIGZpbHRlcixcbiAgICogICBkZWZhdWx0cyB0byBmZm1wZWcgYXV0b21hdGljYWxseSBjaG9vc2luZyB0aGUgZmlyc3QgdW51c2VkIG1hdGNoaW5nIHN0cmVhbXNcbiAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtmaWx0ZXJzLm91dHB1dHNdIChhcnJheSBvZikgb3V0cHV0IHN0cmVhbSBzcGVjaWZpZXIocykgZm9yIHRoZSBmaWx0ZXIsXG4gICAqICAgZGVmYXVsdHMgdG8gZmZtcGVnIGF1dG9tYXRpY2FsbHkgYXNzaWduaW5nIHRoZSBvdXRwdXQgdG8gdGhlIG91dHB1dCBmaWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ3xBcnJheX0gW2ZpbHRlcnMub3B0aW9uc10gZmlsdGVyIG9wdGlvbnMsIGNhbiBiZSBvbWl0dGVkIHRvIG5vdCBzZXQgYW55IG9wdGlvbnNcbiAgICogQHJldHVybiBTdHJpbmdbXVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWFrZUZpbHRlclN0cmluZ3M6IGZ1bmN0aW9uKGZpbHRlcnMpIHtcbiAgICByZXR1cm4gZmlsdGVycy5tYXAoZnVuY3Rpb24oZmlsdGVyU3BlYykge1xuICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJTcGVjID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmlsdGVyU3BlYztcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbHRlclN0cmluZyA9ICcnO1xuXG4gICAgICAvLyBGaWx0ZXIgc3RyaW5nIGZvcm1hdCBpczpcbiAgICAgIC8vIFtpbnB1dDFdW2lucHV0Ml0uLi5maWx0ZXJbb3V0cHV0MV1bb3V0cHV0Ml0uLi5cbiAgICAgIC8vIFRoZSAnZmlsdGVyJyBwYXJ0IGNhbiBvcHRpb25hbHkgaGF2ZSBhcmd1bWVudHM6XG4gICAgICAvLyAgIGZpbHRlcj1hcmcxOmFyZzI6YXJnM1xuICAgICAgLy8gICBmaWx0ZXI9YXJnMT12MTphcmcyPXYyOmFyZzM9djNcblxuICAgICAgLy8gQWRkIGlucHV0c1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyU3BlYy5pbnB1dHMpKSB7XG4gICAgICAgIGZpbHRlclN0cmluZyArPSBmaWx0ZXJTcGVjLmlucHV0cy5tYXAoZnVuY3Rpb24oc3RyZWFtU3BlYykge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1TcGVjLnJlcGxhY2Uoc3RyZWFtUmVnZXhwLCAnWyQxXScpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlclNwZWMuaW5wdXRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBmaWx0ZXJTdHJpbmcgKz0gZmlsdGVyU3BlYy5pbnB1dHMucmVwbGFjZShzdHJlYW1SZWdleHAsICdbJDFdJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBmaWx0ZXJcbiAgICAgIGZpbHRlclN0cmluZyArPSBmaWx0ZXJTcGVjLmZpbHRlcjtcblxuICAgICAgLy8gQWRkIG9wdGlvbnNcbiAgICAgIGlmIChmaWx0ZXJTcGVjLm9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXJTcGVjLm9wdGlvbnMgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBmaWx0ZXJTcGVjLm9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgLy8gT3B0aW9uIHN0cmluZ1xuICAgICAgICAgIGZpbHRlclN0cmluZyArPSAnPScgKyBmaWx0ZXJTcGVjLm9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWx0ZXJTcGVjLm9wdGlvbnMpKSB7XG4gICAgICAgICAgLy8gT3B0aW9uIGFycmF5ICh1bm5hbWVkIG9wdGlvbnMpXG4gICAgICAgICAgZmlsdGVyU3RyaW5nICs9ICc9JyArIGZpbHRlclNwZWMub3B0aW9ucy5tYXAoZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PT0gJ3N0cmluZycgJiYgb3B0aW9uLm1hdGNoKGZpbHRlckVzY2FwZVJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICdcXCcnICsgb3B0aW9uICsgJ1xcJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmpvaW4oJzonKTtcbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhmaWx0ZXJTcGVjLm9wdGlvbnMpLmxlbmd0aCkge1xuICAgICAgICAgIC8vIE9wdGlvbiBvYmplY3QgKG5hbWVkIG9wdGlvbnMpXG4gICAgICAgICAgZmlsdGVyU3RyaW5nICs9ICc9JyArIE9iamVjdC5rZXlzKGZpbHRlclNwZWMub3B0aW9ucykubWFwKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZmlsdGVyU3BlYy5vcHRpb25zW29wdGlvbl07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKGZpbHRlckVzY2FwZVJlZ2V4cCkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSAnXFwnJyArIHZhbHVlICsgJ1xcJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcHRpb24gKyAnPScgKyB2YWx1ZTtcbiAgICAgICAgICB9KS5qb2luKCc6Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWRkIG91dHB1dHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlclNwZWMub3V0cHV0cykpIHtcbiAgICAgICAgZmlsdGVyU3RyaW5nICs9IGZpbHRlclNwZWMub3V0cHV0cy5tYXAoZnVuY3Rpb24oc3RyZWFtU3BlYykge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1TcGVjLnJlcGxhY2Uoc3RyZWFtUmVnZXhwLCAnWyQxXScpO1xuICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZpbHRlclNwZWMub3V0cHV0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZmlsdGVyU3RyaW5nICs9IGZpbHRlclNwZWMub3V0cHV0cy5yZXBsYWNlKHN0cmVhbVJlZ2V4cCwgJ1skMV0nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbHRlclN0cmluZztcbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIGFuIGV4ZWN1dGFibGVcbiAgICpcbiAgICogVXNlcyAnd2hpY2gnIG9yICd3aGVyZScgZGVwZW5kaW5nIG9uIHBsYXRmb3JtXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGV4ZWN1dGFibGUgbmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBjYWxsYmFjayB3aXRoIHNpZ25hdHVyZSAoZXJyLCBwYXRoKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgd2hpY2g6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKG5hbWUgaW4gd2hpY2hDYWNoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHdoaWNoQ2FjaGVbbmFtZV0pO1xuICAgIH1cblxuICAgIHdoaWNoKG5hbWUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KXtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgLy8gVHJlYXQgZXJyb3JzIGFzIG5vdCBmb3VuZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgd2hpY2hDYWNoZVtuYW1lXSA9ICcnKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKG51bGwsIHdoaWNoQ2FjaGVbbmFtZV0gPSByZXN1bHQpO1xuICAgIH0pO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBbW2hoOl1tbTpdc3NbLnh4eF0gdGltZW1hcmsgaW50byBzZWNvbmRzXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0aW1lbWFyayB0aW1lbWFyayBzdHJpbmdcbiAgICogQHJldHVybiBOdW1iZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRpbWVtYXJrVG9TZWNvbmRzOiBmdW5jdGlvbih0aW1lbWFyaykge1xuICAgIGlmICh0eXBlb2YgdGltZW1hcmsgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGltZW1hcms7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVtYXJrLmluZGV4T2YoJzonKSA9PT0gLTEgJiYgdGltZW1hcmsuaW5kZXhPZignLicpID49IDApIHtcbiAgICAgIHJldHVybiBOdW1iZXIodGltZW1hcmspO1xuICAgIH1cblxuICAgIHZhciBwYXJ0cyA9IHRpbWVtYXJrLnNwbGl0KCc6Jyk7XG5cbiAgICAvLyBhZGQgc2Vjb25kc1xuICAgIHZhciBzZWNzID0gTnVtYmVyKHBhcnRzLnBvcCgpKTtcblxuICAgIGlmIChwYXJ0cy5sZW5ndGgpIHtcbiAgICAgIC8vIGFkZCBtaW51dGVzXG4gICAgICBzZWNzICs9IE51bWJlcihwYXJ0cy5wb3AoKSkgKiA2MDtcbiAgICB9XG5cbiAgICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgICAvLyBhZGQgaG91cnNcbiAgICAgIHNlY3MgKz0gTnVtYmVyKHBhcnRzLnBvcCgpKSAqIDM2MDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3M7XG4gIH0sXG5cblxuICAvKipcbiAgICogRXh0cmFjdCBjb2RlYyBkYXRhIGZyb20gZmZtcGVnIHN0ZGVyciBhbmQgZW1pdCAnY29kZWNEYXRhJyBldmVudCBpZiBhcHByb3ByaWF0ZVxuICAgKiBDYWxsIGl0IHdpdGggYW4gaW5pdGlhbGx5IGVtcHR5IGNvZGVjIG9iamVjdCBvbmNlIHdpdGggZWFjaCBsaW5lIG9mIHN0ZGVyciBvdXRwdXQgdW50aWwgaXQgcmV0dXJucyB0cnVlXG4gICAqXG4gICAqIEBwYXJhbSB7RmZtcGVnQ29tbWFuZH0gY29tbWFuZCBldmVudCBlbWl0dGVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdGRlcnJMaW5lIGZmbXBlZyBzdGRlcnIgb3V0cHV0IGxpbmVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvZGVjT2JqZWN0IG9iamVjdCB1c2VkIHRvIGFjY3VtdWxhdGUgY29kZWMgZGF0YSBiZXR3ZWVuIGNhbGxzXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgY29kZWMgZGF0YSBpcyBjb21wbGV0ZSAoYW5kIGV2ZW50IHdhcyBlbWl0dGVkKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0Q29kZWNEYXRhOiBmdW5jdGlvbihjb21tYW5kLCBzdGRlcnJMaW5lLCBjb2RlY3NPYmplY3QpIHtcbiAgICB2YXIgaW5wdXRQYXR0ZXJuID0gL0lucHV0ICNbMC05XSssIChbXiBdKyksLztcbiAgICB2YXIgZHVyUGF0dGVybiA9IC9EdXJhdGlvblxcOiAoW14sXSspLztcbiAgICB2YXIgYXVkaW9QYXR0ZXJuID0gL0F1ZGlvXFw6ICguKikvO1xuICAgIHZhciB2aWRlb1BhdHRlcm4gPSAvVmlkZW9cXDogKC4qKS87XG5cbiAgICBpZiAoISgnaW5wdXRTdGFjaycgaW4gY29kZWNzT2JqZWN0KSkge1xuICAgICAgY29kZWNzT2JqZWN0LmlucHV0U3RhY2sgPSBbXTtcbiAgICAgIGNvZGVjc09iamVjdC5pbnB1dEluZGV4ID0gLTE7XG4gICAgICBjb2RlY3NPYmplY3QuaW5JbnB1dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpbnB1dFN0YWNrID0gY29kZWNzT2JqZWN0LmlucHV0U3RhY2s7XG4gICAgdmFyIGlucHV0SW5kZXggPSBjb2RlY3NPYmplY3QuaW5wdXRJbmRleDtcbiAgICB2YXIgaW5JbnB1dCA9IGNvZGVjc09iamVjdC5pbklucHV0O1xuXG4gICAgdmFyIGZvcm1hdCwgZHVyLCBhdWRpbywgdmlkZW87XG5cbiAgICBpZiAoZm9ybWF0ID0gc3RkZXJyTGluZS5tYXRjaChpbnB1dFBhdHRlcm4pKSB7XG4gICAgICBpbklucHV0ID0gY29kZWNzT2JqZWN0LmluSW5wdXQgPSB0cnVlO1xuICAgICAgaW5wdXRJbmRleCA9IGNvZGVjc09iamVjdC5pbnB1dEluZGV4ID0gY29kZWNzT2JqZWN0LmlucHV0SW5kZXggKyAxO1xuXG4gICAgICBpbnB1dFN0YWNrW2lucHV0SW5kZXhdID0geyBmb3JtYXQ6IGZvcm1hdFsxXSwgYXVkaW86ICcnLCB2aWRlbzogJycsIGR1cmF0aW9uOiAnJyB9O1xuICAgIH0gZWxzZSBpZiAoaW5JbnB1dCAmJiAoZHVyID0gc3RkZXJyTGluZS5tYXRjaChkdXJQYXR0ZXJuKSkpIHtcbiAgICAgIGlucHV0U3RhY2tbaW5wdXRJbmRleF0uZHVyYXRpb24gPSBkdXJbMV07XG4gICAgfSBlbHNlIGlmIChpbklucHV0ICYmIChhdWRpbyA9IHN0ZGVyckxpbmUubWF0Y2goYXVkaW9QYXR0ZXJuKSkpIHtcbiAgICAgIGF1ZGlvID0gYXVkaW9bMV0uc3BsaXQoJywgJyk7XG4gICAgICBpbnB1dFN0YWNrW2lucHV0SW5kZXhdLmF1ZGlvID0gYXVkaW9bMF07XG4gICAgICBpbnB1dFN0YWNrW2lucHV0SW5kZXhdLmF1ZGlvX2RldGFpbHMgPSBhdWRpbztcbiAgICB9IGVsc2UgaWYgKGluSW5wdXQgJiYgKHZpZGVvID0gc3RkZXJyTGluZS5tYXRjaCh2aWRlb1BhdHRlcm4pKSkge1xuICAgICAgdmlkZW8gPSB2aWRlb1sxXS5zcGxpdCgnLCAnKTtcbiAgICAgIGlucHV0U3RhY2tbaW5wdXRJbmRleF0udmlkZW8gPSB2aWRlb1swXTtcbiAgICAgIGlucHV0U3RhY2tbaW5wdXRJbmRleF0udmlkZW9fZGV0YWlscyA9IHZpZGVvO1xuICAgIH0gZWxzZSBpZiAoL091dHB1dCAjXFxkKy8udGVzdChzdGRlcnJMaW5lKSkge1xuICAgICAgaW5JbnB1dCA9IGNvZGVjc09iamVjdC5pbklucHV0ID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvU3RyZWFtIG1hcHBpbmc6fFByZXNzIChcXFtxXFxdfGN0cmwtYykgdG8gc3RvcC8udGVzdChzdGRlcnJMaW5lKSkge1xuICAgICAgY29tbWFuZC5lbWl0LmFwcGx5KGNvbW1hbmQsIFsnY29kZWNEYXRhJ10uY29uY2F0KGlucHV0U3RhY2spKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHByb2dyZXNzIGRhdGEgZnJvbSBmZm1wZWcgc3RkZXJyIGFuZCBlbWl0ICdwcm9ncmVzcycgZXZlbnQgaWYgYXBwcm9wcmlhdGVcbiAgICpcbiAgICogQHBhcmFtIHtGZm1wZWdDb21tYW5kfSBjb21tYW5kIGV2ZW50IGVtaXR0ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ZGVyckxpbmUgZmZtcGVnIHN0ZGVyciBkYXRhXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0UHJvZ3Jlc3M6IGZ1bmN0aW9uKGNvbW1hbmQsIHN0ZGVyckxpbmUpIHtcbiAgICB2YXIgcHJvZ3Jlc3MgPSBwYXJzZVByb2dyZXNzTGluZShzdGRlcnJMaW5lKTtcblxuICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgLy8gYnVpbGQgcHJvZ3Jlc3MgcmVwb3J0IG9iamVjdFxuICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgZnJhbWVzOiBwYXJzZUludChwcm9ncmVzcy5mcmFtZSwgMTApLFxuICAgICAgICBjdXJyZW50RnBzOiBwYXJzZUludChwcm9ncmVzcy5mcHMsIDEwKSxcbiAgICAgICAgY3VycmVudEticHM6IHByb2dyZXNzLmJpdHJhdGUgPyBwYXJzZUZsb2F0KHByb2dyZXNzLmJpdHJhdGUucmVwbGFjZSgna2JpdHMvcycsICcnKSkgOiAwLFxuICAgICAgICB0YXJnZXRTaXplOiBwYXJzZUludChwcm9ncmVzcy5zaXplIHx8IHByb2dyZXNzLkxzaXplLCAxMCksXG4gICAgICAgIHRpbWVtYXJrOiBwcm9ncmVzcy50aW1lXG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxjdWxhdGUgcGVyY2VudCBwcm9ncmVzcyB1c2luZyBkdXJhdGlvblxuICAgICAgaWYgKGNvbW1hbmQuX2ZmcHJvYmVEYXRhICYmIGNvbW1hbmQuX2ZmcHJvYmVEYXRhLmZvcm1hdCAmJiBjb21tYW5kLl9mZnByb2JlRGF0YS5mb3JtYXQuZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gTnVtYmVyKGNvbW1hbmQuX2ZmcHJvYmVEYXRhLmZvcm1hdC5kdXJhdGlvbik7XG4gICAgICAgIGlmICghaXNOYU4oZHVyYXRpb24pKVxuICAgICAgICAgIHJldC5wZXJjZW50ID0gKHV0aWxzLnRpbWVtYXJrVG9TZWNvbmRzKHJldC50aW1lbWFyaykgLyBkdXJhdGlvbikgKiAxMDA7XG4gICAgICB9XG4gICAgICBjb21tYW5kLmVtaXQoJ3Byb2dyZXNzJywgcmV0KTtcbiAgICB9XG4gIH0sXG5cblxuICAvKipcbiAgICogRXh0cmFjdCBlcnJvciBtZXNzYWdlKHMpIGZyb20gZmZtcGVnIHN0ZGVyclxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RkZXJyIGZmbXBlZyBzdGRlcnIgZGF0YVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBleHRyYWN0RXJyb3I6IGZ1bmN0aW9uKHN0ZGVycikge1xuICAgIC8vIE9ubHkgcmV0dXJuIHRoZSBsYXN0IHN0ZGVyciBsaW5lcyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggYSBzcGFjZSBvciBhIHNxdWFyZSBicmFja2V0XG4gICAgcmV0dXJuIHN0ZGVyci5zcGxpdChubFJlZ2V4cCkucmVkdWNlKGZ1bmN0aW9uKG1lc3NhZ2VzLCBtZXNzYWdlKSB7XG4gICAgICBpZiAobWVzc2FnZS5jaGFyQXQoMCkgPT09ICcgJyB8fCBtZXNzYWdlLmNoYXJBdCgwKSA9PT0gJ1snKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlcztcbiAgICAgIH1cbiAgICB9LCBbXSkuam9pbignXFxuJyk7XG4gIH0sXG5cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGxpbmUgcmluZyBidWZmZXIgb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgKiAtIGFwcGVuZChzdHIpIDogYXBwZW5kcyBhIHN0cmluZyBvciBidWZmZXJcbiAgICogLSBnZXQoKSA6IHJldHVybnMgdGhlIHdob2xlIHN0cmluZ1xuICAgKiAtIGNsb3NlKCkgOiBwcmV2ZW50cyBmdXJ0aGVyIGFwcGVuZCgpIGNhbGxzIGFuZCBkb2VzIGEgbGFzdCBjYWxsIHRvIGNhbGxiYWNrc1xuICAgKiAtIGNhbGxiYWNrKGNiKSA6IGNhbGxzIGNiIGZvciBlYWNoIGxpbmUgKGluY2wuIHRob3NlIGFscmVhZHkgaW4gdGhlIHJpbmcpXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhMaW5lcyBtYXhpbXVtIG51bWJlciBvZiBsaW5lcyB0byBzdG9yZSAoPD0gMCBmb3IgdW5saW1pdGVkKVxuICAgKi9cbiAgbGluZXNSaW5nOiBmdW5jdGlvbihtYXhMaW5lcykge1xuICAgIHZhciBjYnMgPSBbXTtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgY3VycmVudCA9IG51bGw7XG4gICAgdmFyIGNsb3NlZCA9IGZhbHNlXG4gICAgdmFyIG1heCA9IG1heExpbmVzIC0gMTtcblxuICAgIGZ1bmN0aW9uIGVtaXQobGluZSkge1xuICAgICAgY2JzLmZvckVhY2goZnVuY3Rpb24oY2IpIHsgY2IobGluZSk7IH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjYWxsYmFjazogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgbGluZXMuZm9yRWFjaChmdW5jdGlvbihsKSB7IGNiKGwpOyB9KTtcbiAgICAgICAgY2JzLnB1c2goY2IpO1xuICAgICAgfSxcblxuICAgICAgYXBwZW5kOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgICAgICBpZiAoc3RyIGluc3RhbmNlb2YgQnVmZmVyKSBzdHIgPSAnJyArIHN0cjtcbiAgICAgICAgaWYgKCFzdHIgfHwgc3RyLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBuZXdMaW5lcyA9IHN0ci5zcGxpdChubFJlZ2V4cCk7XG5cbiAgICAgICAgaWYgKG5ld0xpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudCArIG5ld0xpbmVzLnNoaWZ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXdMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQgKyBuZXdMaW5lcy5zaGlmdCgpO1xuICAgICAgICAgICAgZW1pdChjdXJyZW50KTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudCA9IG5ld0xpbmVzLnBvcCgpO1xuXG4gICAgICAgICAgbmV3TGluZXMuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICAgICAgICBlbWl0KGwpO1xuICAgICAgICAgICAgbGluZXMucHVzaChsKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChtYXggPiAtMSAmJiBsaW5lcy5sZW5ndGggPiBtYXgpIHtcbiAgICAgICAgICAgIGxpbmVzLnNwbGljZSgwLCBsaW5lcy5sZW5ndGggLSBtYXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbGluZXMuY29uY2F0KFtjdXJyZW50XSkuam9pbignXFxuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjbG9zZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGVtaXQoY3VycmVudCk7XG4gICAgICAgICAgbGluZXMucHVzaChjdXJyZW50KTtcblxuICAgICAgICAgIGlmIChtYXggPiAtMSAmJiBsaW5lcy5sZW5ndGggPiBtYXgpIHtcbiAgICAgICAgICAgIGxpbmVzLnNoaWZ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/node_modules/which/which.js":
/*!****************************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/node_modules/which/which.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = which\nwhich.sync = whichSync\n\nvar isWindows = process.platform === 'win32' ||\n    process.env.OSTYPE === 'cygwin' ||\n    process.env.OSTYPE === 'msys'\n\nvar path = __webpack_require__(/*! path */ \"path\")\nvar COLON = isWindows ? ';' : ':'\nvar isexe = __webpack_require__(/*! isexe */ \"(rsc)/./node_modules/isexe/index.js\")\n\nfunction getNotFoundError (cmd) {\n  var er = new Error('not found: ' + cmd)\n  er.code = 'ENOENT'\n\n  return er\n}\n\nfunction getPathInfo (cmd, opt) {\n  var colon = opt.colon || COLON\n  var pathEnv = opt.path || process.env.PATH || ''\n  var pathExt = ['']\n\n  pathEnv = pathEnv.split(colon)\n\n  var pathExtExe = ''\n  if (isWindows) {\n    pathEnv.unshift(process.cwd())\n    pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')\n    pathExt = pathExtExe.split(colon)\n\n\n    // Always test the cmd itself first.  isexe will check to make sure\n    // it's found in the pathExt set.\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')\n      pathExt.unshift('')\n  }\n\n  // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n  if (cmd.match(/\\//) || isWindows && cmd.match(/\\\\/))\n    pathEnv = ['']\n\n  return {\n    env: pathEnv,\n    ext: pathExt,\n    extExe: pathExtExe\n  }\n}\n\nfunction which (cmd, opt, cb) {\n  if (typeof opt === 'function') {\n    cb = opt\n    opt = {}\n  }\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  ;(function F (i, l) {\n    if (i === l) {\n      if (opt.all && found.length)\n        return cb(null, found)\n      else\n        return cb(getNotFoundError(cmd))\n    }\n\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && (/^\\.[\\\\\\/]/).test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    ;(function E (ii, ll) {\n      if (ii === ll) return F(i + 1, l)\n      var ext = pathExt[ii]\n      isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {\n        if (!er && is) {\n          if (opt.all)\n            found.push(p + ext)\n          else\n            return cb(null, p + ext)\n        }\n        return E(ii + 1, ll)\n      })\n    })(0, pathExt.length)\n  })(0, pathEnv.length)\n}\n\nfunction whichSync (cmd, opt) {\n  opt = opt || {}\n\n  var info = getPathInfo(cmd, opt)\n  var pathEnv = info.env\n  var pathExt = info.ext\n  var pathExtExe = info.extExe\n  var found = []\n\n  for (var i = 0, l = pathEnv.length; i < l; i ++) {\n    var pathPart = pathEnv[i]\n    if (pathPart.charAt(0) === '\"' && pathPart.slice(-1) === '\"')\n      pathPart = pathPart.slice(1, -1)\n\n    var p = path.join(pathPart, cmd)\n    if (!pathPart && /^\\.[\\\\\\/]/.test(cmd)) {\n      p = cmd.slice(0, 2) + p\n    }\n    for (var j = 0, ll = pathExt.length; j < ll; j ++) {\n      var cur = p + pathExt[j]\n      var is\n      try {\n        is = isexe.sync(cur, { pathExt: pathExtExe })\n        if (is) {\n          if (opt.all)\n            found.push(cur)\n          else\n            return cur\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length)\n    return found\n\n  if (opt.nothrow)\n    return null\n\n  throw getNotFoundError(cmd)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvZmx1ZW50LWZmbXBlZy9ub2RlX21vZHVsZXMvd2hpY2gvd2hpY2guanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLDBCQUEwQjtBQUMxQixZQUFZLG1CQUFPLENBQUMsa0RBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxLQUFLLEtBQUs7QUFDeEU7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL2ZsdWVudC1mZm1wZWcvbm9kZV9tb2R1bGVzL3doaWNoL3doaWNoLmpzP2U2NWUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB3aGljaFxud2hpY2guc3luYyA9IHdoaWNoU3luY1xuXG52YXIgaXNXaW5kb3dzID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyB8fFxuICAgIHByb2Nlc3MuZW52Lk9TVFlQRSA9PT0gJ2N5Z3dpbicgfHxcbiAgICBwcm9jZXNzLmVudi5PU1RZUEUgPT09ICdtc3lzJ1xuXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIENPTE9OID0gaXNXaW5kb3dzID8gJzsnIDogJzonXG52YXIgaXNleGUgPSByZXF1aXJlKCdpc2V4ZScpXG5cbmZ1bmN0aW9uIGdldE5vdEZvdW5kRXJyb3IgKGNtZCkge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ25vdCBmb3VuZDogJyArIGNtZClcbiAgZXIuY29kZSA9ICdFTk9FTlQnXG5cbiAgcmV0dXJuIGVyXG59XG5cbmZ1bmN0aW9uIGdldFBhdGhJbmZvIChjbWQsIG9wdCkge1xuICB2YXIgY29sb24gPSBvcHQuY29sb24gfHwgQ09MT05cbiAgdmFyIHBhdGhFbnYgPSBvcHQucGF0aCB8fCBwcm9jZXNzLmVudi5QQVRIIHx8ICcnXG4gIHZhciBwYXRoRXh0ID0gWycnXVxuXG4gIHBhdGhFbnYgPSBwYXRoRW52LnNwbGl0KGNvbG9uKVxuXG4gIHZhciBwYXRoRXh0RXhlID0gJydcbiAgaWYgKGlzV2luZG93cykge1xuICAgIHBhdGhFbnYudW5zaGlmdChwcm9jZXNzLmN3ZCgpKVxuICAgIHBhdGhFeHRFeGUgPSAob3B0LnBhdGhFeHQgfHwgcHJvY2Vzcy5lbnYuUEFUSEVYVCB8fCAnLkVYRTsuQ01EOy5CQVQ7LkNPTScpXG4gICAgcGF0aEV4dCA9IHBhdGhFeHRFeGUuc3BsaXQoY29sb24pXG5cblxuICAgIC8vIEFsd2F5cyB0ZXN0IHRoZSBjbWQgaXRzZWxmIGZpcnN0LiAgaXNleGUgd2lsbCBjaGVjayB0byBtYWtlIHN1cmVcbiAgICAvLyBpdCdzIGZvdW5kIGluIHRoZSBwYXRoRXh0IHNldC5cbiAgICBpZiAoY21kLmluZGV4T2YoJy4nKSAhPT0gLTEgJiYgcGF0aEV4dFswXSAhPT0gJycpXG4gICAgICBwYXRoRXh0LnVuc2hpZnQoJycpXG4gIH1cblxuICAvLyBJZiBpdCBoYXMgYSBzbGFzaCwgdGhlbiB3ZSBkb24ndCBib3RoZXIgc2VhcmNoaW5nIHRoZSBwYXRoZW52LlxuICAvLyBqdXN0IGNoZWNrIHRoZSBmaWxlIGl0c2VsZiwgYW5kIHRoYXQncyBpdC5cbiAgaWYgKGNtZC5tYXRjaCgvXFwvLykgfHwgaXNXaW5kb3dzICYmIGNtZC5tYXRjaCgvXFxcXC8pKVxuICAgIHBhdGhFbnYgPSBbJyddXG5cbiAgcmV0dXJuIHtcbiAgICBlbnY6IHBhdGhFbnYsXG4gICAgZXh0OiBwYXRoRXh0LFxuICAgIGV4dEV4ZTogcGF0aEV4dEV4ZVxuICB9XG59XG5cbmZ1bmN0aW9uIHdoaWNoIChjbWQsIG9wdCwgY2IpIHtcbiAgaWYgKHR5cGVvZiBvcHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdFxuICAgIG9wdCA9IHt9XG4gIH1cblxuICB2YXIgaW5mbyA9IGdldFBhdGhJbmZvKGNtZCwgb3B0KVxuICB2YXIgcGF0aEVudiA9IGluZm8uZW52XG4gIHZhciBwYXRoRXh0ID0gaW5mby5leHRcbiAgdmFyIHBhdGhFeHRFeGUgPSBpbmZvLmV4dEV4ZVxuICB2YXIgZm91bmQgPSBbXVxuXG4gIDsoZnVuY3Rpb24gRiAoaSwgbCkge1xuICAgIGlmIChpID09PSBsKSB7XG4gICAgICBpZiAob3B0LmFsbCAmJiBmb3VuZC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBjYihudWxsLCBmb3VuZClcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGNiKGdldE5vdEZvdW5kRXJyb3IoY21kKSlcbiAgICB9XG5cbiAgICB2YXIgcGF0aFBhcnQgPSBwYXRoRW52W2ldXG4gICAgaWYgKHBhdGhQYXJ0LmNoYXJBdCgwKSA9PT0gJ1wiJyAmJiBwYXRoUGFydC5zbGljZSgtMSkgPT09ICdcIicpXG4gICAgICBwYXRoUGFydCA9IHBhdGhQYXJ0LnNsaWNlKDEsIC0xKVxuXG4gICAgdmFyIHAgPSBwYXRoLmpvaW4ocGF0aFBhcnQsIGNtZClcbiAgICBpZiAoIXBhdGhQYXJ0ICYmICgvXlxcLltcXFxcXFwvXS8pLnRlc3QoY21kKSkge1xuICAgICAgcCA9IGNtZC5zbGljZSgwLCAyKSArIHBcbiAgICB9XG4gICAgOyhmdW5jdGlvbiBFIChpaSwgbGwpIHtcbiAgICAgIGlmIChpaSA9PT0gbGwpIHJldHVybiBGKGkgKyAxLCBsKVxuICAgICAgdmFyIGV4dCA9IHBhdGhFeHRbaWldXG4gICAgICBpc2V4ZShwICsgZXh0LCB7IHBhdGhFeHQ6IHBhdGhFeHRFeGUgfSwgZnVuY3Rpb24gKGVyLCBpcykge1xuICAgICAgICBpZiAoIWVyICYmIGlzKSB7XG4gICAgICAgICAgaWYgKG9wdC5hbGwpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKHAgKyBleHQpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIHAgKyBleHQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEUoaWkgKyAxLCBsbClcbiAgICAgIH0pXG4gICAgfSkoMCwgcGF0aEV4dC5sZW5ndGgpXG4gIH0pKDAsIHBhdGhFbnYubGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB3aGljaFN5bmMgKGNtZCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fVxuXG4gIHZhciBpbmZvID0gZ2V0UGF0aEluZm8oY21kLCBvcHQpXG4gIHZhciBwYXRoRW52ID0gaW5mby5lbnZcbiAgdmFyIHBhdGhFeHQgPSBpbmZvLmV4dFxuICB2YXIgcGF0aEV4dEV4ZSA9IGluZm8uZXh0RXhlXG4gIHZhciBmb3VuZCA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoRW52Lmxlbmd0aDsgaSA8IGw7IGkgKyspIHtcbiAgICB2YXIgcGF0aFBhcnQgPSBwYXRoRW52W2ldXG4gICAgaWYgKHBhdGhQYXJ0LmNoYXJBdCgwKSA9PT0gJ1wiJyAmJiBwYXRoUGFydC5zbGljZSgtMSkgPT09ICdcIicpXG4gICAgICBwYXRoUGFydCA9IHBhdGhQYXJ0LnNsaWNlKDEsIC0xKVxuXG4gICAgdmFyIHAgPSBwYXRoLmpvaW4ocGF0aFBhcnQsIGNtZClcbiAgICBpZiAoIXBhdGhQYXJ0ICYmIC9eXFwuW1xcXFxcXC9dLy50ZXN0KGNtZCkpIHtcbiAgICAgIHAgPSBjbWQuc2xpY2UoMCwgMikgKyBwXG4gICAgfVxuICAgIGZvciAodmFyIGogPSAwLCBsbCA9IHBhdGhFeHQubGVuZ3RoOyBqIDwgbGw7IGogKyspIHtcbiAgICAgIHZhciBjdXIgPSBwICsgcGF0aEV4dFtqXVxuICAgICAgdmFyIGlzXG4gICAgICB0cnkge1xuICAgICAgICBpcyA9IGlzZXhlLnN5bmMoY3VyLCB7IHBhdGhFeHQ6IHBhdGhFeHRFeGUgfSlcbiAgICAgICAgaWYgKGlzKSB7XG4gICAgICAgICAgaWYgKG9wdC5hbGwpXG4gICAgICAgICAgICBmb3VuZC5wdXNoKGN1cilcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gY3VyXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHQuYWxsICYmIGZvdW5kLmxlbmd0aClcbiAgICByZXR1cm4gZm91bmRcblxuICBpZiAob3B0Lm5vdGhyb3cpXG4gICAgcmV0dXJuIG51bGxcblxuICB0aHJvdyBnZXROb3RGb3VuZEVycm9yKGNtZClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/fluent-ffmpeg/node_modules/which/which.js\n");

/***/ })

};
;