/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ytdl-core";
exports.ids = ["vendor-chunks/ytdl-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/ytdl-core/lib/cache.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/cache.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { setTimeout } = __webpack_require__(/*! timers */ \"timers\");\n\n// A cache that expires.\nmodule.exports = class Cache extends Map {\n  constructor(timeout = 1000) {\n    super();\n    this.timeout = timeout;\n  }\n  set(key, value) {\n    if (this.has(key)) {\n      clearTimeout(super.get(key).tid);\n    }\n    super.set(key, {\n      tid: setTimeout(this.delete.bind(this, key), this.timeout).unref(),\n      value,\n    });\n  }\n  get(key) {\n    let entry = super.get(key);\n    if (entry) {\n      return entry.value;\n    }\n    return null;\n  }\n  getOrSet(key, fn) {\n    if (this.has(key)) {\n      return this.get(key);\n    } else {\n      let value = fn();\n      this.set(key, value);\n      (async() => {\n        try {\n          await value;\n        } catch (err) {\n          this.delete(key);\n        }\n      })();\n      return value;\n    }\n  }\n  delete(key) {\n    let entry = super.get(key);\n    if (entry) {\n      clearTimeout(entry.tid);\n      super.delete(key);\n    }\n  }\n  clear() {\n    for (let entry of this.values()) {\n      clearTimeout(entry.tid);\n    }\n    super.clear();\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFROztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL3l0ZGwtY29yZS9saWIvY2FjaGUuanM/MmM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHNldFRpbWVvdXQgfSA9IHJlcXVpcmUoJ3RpbWVycycpO1xuXG4vLyBBIGNhY2hlIHRoYXQgZXhwaXJlcy5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ2FjaGUgZXh0ZW5kcyBNYXAge1xuICBjb25zdHJ1Y3Rvcih0aW1lb3V0ID0gMTAwMCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICBjbGVhclRpbWVvdXQoc3VwZXIuZ2V0KGtleSkudGlkKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0KGtleSwge1xuICAgICAgdGlkOiBzZXRUaW1lb3V0KHRoaXMuZGVsZXRlLmJpbmQodGhpcywga2V5KSwgdGhpcy50aW1lb3V0KS51bnJlZigpLFxuICAgICAgdmFsdWUsXG4gICAgfSk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGxldCBlbnRyeSA9IHN1cGVyLmdldChrZXkpO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRPclNldChrZXksIGZuKSB7XG4gICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgdmFsdWUgPSBmbigpO1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAoYXN5bmMoKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRoaXMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pKCk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG4gIGRlbGV0ZShrZXkpIHtcbiAgICBsZXQgZW50cnkgPSBzdXBlci5nZXQoa2V5KTtcbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGNsZWFyVGltZW91dChlbnRyeS50aWQpO1xuICAgICAgc3VwZXIuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAobGV0IGVudHJ5IG9mIHRoaXMudmFsdWVzKCkpIHtcbiAgICAgIGNsZWFyVGltZW91dChlbnRyeS50aWQpO1xuICAgIH1cbiAgICBzdXBlci5jbGVhcigpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/format-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/ytdl-core/lib/format-utils.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst FORMATS = __webpack_require__(/*! ./formats */ \"(rsc)/./node_modules/ytdl-core/lib/formats.js\");\n\n\n// Use these to help sort formats, higher index is better.\nconst audioEncodingRanks = [\n  'mp4a',\n  'mp3',\n  'vorbis',\n  'aac',\n  'opus',\n  'flac',\n];\nconst videoEncodingRanks = [\n  'mp4v',\n  'avc1',\n  'Sorenson H.283',\n  'MPEG-4 Visual',\n  'VP8',\n  'VP9',\n  'H.264',\n];\n\nconst getVideoBitrate = format => format.bitrate || 0;\nconst getVideoEncodingRank = format =>\n  videoEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\nconst getAudioBitrate = format => format.audioBitrate || 0;\nconst getAudioEncodingRank = format =>\n  audioEncodingRanks.findIndex(enc => format.codecs && format.codecs.includes(enc));\n\n\n/**\n * Sort formats by a list of functions.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Array.<Function>} sortBy\n * @returns {number}\n */\nconst sortFormatsBy = (a, b, sortBy) => {\n  let res = 0;\n  for (let fn of sortBy) {\n    res = fn(b) - fn(a);\n    if (res !== 0) {\n      break;\n    }\n  }\n  return res;\n};\n\n\nconst sortFormatsByVideo = (a, b) => sortFormatsBy(a, b, [\n  format => parseInt(format.qualityLabel),\n  getVideoBitrate,\n  getVideoEncodingRank,\n]);\n\n\nconst sortFormatsByAudio = (a, b) => sortFormatsBy(a, b, [\n  getAudioBitrate,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Sort formats from highest quality to lowest.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\nexports.sortFormats = (a, b) => sortFormatsBy(a, b, [\n  // Formats with both video and audio are ranked highest.\n  format => +!!format.isHLS,\n  format => +!!format.isDashMPD,\n  format => +(format.contentLength > 0),\n  format => +(format.hasVideo && format.hasAudio),\n  format => +format.hasVideo,\n  format => parseInt(format.qualityLabel) || 0,\n  getVideoBitrate,\n  getAudioBitrate,\n  getVideoEncodingRank,\n  getAudioEncodingRank,\n]);\n\n\n/**\n * Choose a format depending on the given options.\n *\n * @param {Array.<Object>} formats\n * @param {Object} options\n * @returns {Object}\n * @throws {Error} when no format matches the filter/format rules\n */\nexports.chooseFormat = (formats, options) => {\n  if (typeof options.format === 'object') {\n    if (!options.format.url) {\n      throw Error('Invalid format given, did you use `ytdl.getInfo()`?');\n    }\n    return options.format;\n  }\n\n  if (options.filter) {\n    formats = exports.filterFormats(formats, options.filter);\n  }\n\n  // We currently only support HLS-Formats for livestreams\n  // So we (now) remove all non-HLS streams\n  if (formats.some(fmt => fmt.isHLS)) {\n    formats = formats.filter(fmt => fmt.isHLS || !fmt.isLive);\n  }\n\n  let format;\n  const quality = options.quality || 'highest';\n  switch (quality) {\n    case 'highest':\n      format = formats[0];\n      break;\n\n    case 'lowest':\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestaudio': {\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      // Filter for only the best audio format\n      const bestAudioFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByAudio(bestAudioFormat, f) === 0);\n      // Check for the worst video quality for the best audio quality and pick according\n      // This does not loose default sorting of video encoding and bitrate\n      const worstVideoQuality = formats.map(f => parseInt(f.qualityLabel) || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (parseInt(f.qualityLabel) || 0) === worstVideoQuality);\n      break;\n    }\n\n    case 'lowestaudio':\n      formats = exports.filterFormats(formats, 'audio');\n      formats.sort(sortFormatsByAudio);\n      format = formats[formats.length - 1];\n      break;\n\n    case 'highestvideo': {\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      // Filter for only the best video format\n      const bestVideoFormat = formats[0];\n      formats = formats.filter(f => sortFormatsByVideo(bestVideoFormat, f) === 0);\n      // Check for the worst audio quality for the best video quality and pick according\n      // This does not loose default sorting of audio encoding and bitrate\n      const worstAudioQuality = formats.map(f => f.audioBitrate || 0).sort((a, b) => a - b)[0];\n      format = formats.find(f => (f.audioBitrate || 0) === worstAudioQuality);\n      break;\n    }\n\n    case 'lowestvideo':\n      formats = exports.filterFormats(formats, 'video');\n      formats.sort(sortFormatsByVideo);\n      format = formats[formats.length - 1];\n      break;\n\n    default:\n      format = getFormatByQuality(quality, formats);\n      break;\n  }\n\n  if (!format) {\n    throw Error(`No such format found: ${quality}`);\n  }\n  return format;\n};\n\n/**\n * Gets a format based on quality or array of quality's\n *\n * @param {string|[string]} quality\n * @param {[Object]} formats\n * @returns {Object}\n */\nconst getFormatByQuality = (quality, formats) => {\n  let getFormat = itag => formats.find(format => `${format.itag}` === `${itag}`);\n  if (Array.isArray(quality)) {\n    return getFormat(quality.find(q => getFormat(q)));\n  } else {\n    return getFormat(quality);\n  }\n};\n\n\n/**\n * @param {Array.<Object>} formats\n * @param {Function} filter\n * @returns {Array.<Object>}\n */\nexports.filterFormats = (formats, filter) => {\n  let fn;\n  switch (filter) {\n    case 'videoandaudio':\n    case 'audioandvideo':\n      fn = format => format.hasVideo && format.hasAudio;\n      break;\n\n    case 'video':\n      fn = format => format.hasVideo;\n      break;\n\n    case 'videoonly':\n      fn = format => format.hasVideo && !format.hasAudio;\n      break;\n\n    case 'audio':\n      fn = format => format.hasAudio;\n      break;\n\n    case 'audioonly':\n      fn = format => !format.hasVideo && format.hasAudio;\n      break;\n\n    default:\n      if (typeof filter === 'function') {\n        fn = filter;\n      } else {\n        throw TypeError(`Given filter (${filter}) is not supported`);\n      }\n  }\n  return formats.filter(format => !!format.url && fn(format));\n};\n\n\n/**\n * @param {Object} format\n * @returns {Object}\n */\nexports.addFormatMeta = format => {\n  format = Object.assign({}, FORMATS[format.itag], format);\n  format.hasVideo = !!format.qualityLabel;\n  format.hasAudio = !!format.audioBitrate;\n  format.container = format.mimeType ?\n    format.mimeType.split(';')[0].split('/')[1] : null;\n  format.codecs = format.mimeType ?\n    utils.between(format.mimeType, 'codecs=\"', '\"') : null;\n  format.videoCodec = format.hasVideo && format.codecs ?\n    format.codecs.split(', ')[0] : null;\n  format.audioCodec = format.hasAudio && format.codecs ?\n    format.codecs.split(', ').slice(-1)[0] : null;\n  format.isLive = /\\bsource[/=]yt_live_broadcast\\b/.test(format.url);\n  format.isHLS = /\\/manifest\\/hls_(variant|playlist)\\//.test(format.url);\n  format.isDashMPD = /\\/manifest\\/dash\\//.test(format.url);\n  return format;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9mb3JtYXQtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFXOzs7QUFHbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYixZQUFZLE9BQU87QUFDbkI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0RBQW9ELFlBQVksU0FBUyxLQUFLO0FBQzlFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsVUFBVTtBQUNyQixhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9mb3JtYXQtdXRpbHMuanM/MGVjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IEZPUk1BVFMgPSByZXF1aXJlKCcuL2Zvcm1hdHMnKTtcblxuXG4vLyBVc2UgdGhlc2UgdG8gaGVscCBzb3J0IGZvcm1hdHMsIGhpZ2hlciBpbmRleCBpcyBiZXR0ZXIuXG5jb25zdCBhdWRpb0VuY29kaW5nUmFua3MgPSBbXG4gICdtcDRhJyxcbiAgJ21wMycsXG4gICd2b3JiaXMnLFxuICAnYWFjJyxcbiAgJ29wdXMnLFxuICAnZmxhYycsXG5dO1xuY29uc3QgdmlkZW9FbmNvZGluZ1JhbmtzID0gW1xuICAnbXA0dicsXG4gICdhdmMxJyxcbiAgJ1NvcmVuc29uIEguMjgzJyxcbiAgJ01QRUctNCBWaXN1YWwnLFxuICAnVlA4JyxcbiAgJ1ZQOScsXG4gICdILjI2NCcsXG5dO1xuXG5jb25zdCBnZXRWaWRlb0JpdHJhdGUgPSBmb3JtYXQgPT4gZm9ybWF0LmJpdHJhdGUgfHwgMDtcbmNvbnN0IGdldFZpZGVvRW5jb2RpbmdSYW5rID0gZm9ybWF0ID0+XG4gIHZpZGVvRW5jb2RpbmdSYW5rcy5maW5kSW5kZXgoZW5jID0+IGZvcm1hdC5jb2RlY3MgJiYgZm9ybWF0LmNvZGVjcy5pbmNsdWRlcyhlbmMpKTtcbmNvbnN0IGdldEF1ZGlvQml0cmF0ZSA9IGZvcm1hdCA9PiBmb3JtYXQuYXVkaW9CaXRyYXRlIHx8IDA7XG5jb25zdCBnZXRBdWRpb0VuY29kaW5nUmFuayA9IGZvcm1hdCA9PlxuICBhdWRpb0VuY29kaW5nUmFua3MuZmluZEluZGV4KGVuYyA9PiBmb3JtYXQuY29kZWNzICYmIGZvcm1hdC5jb2RlY3MuaW5jbHVkZXMoZW5jKSk7XG5cblxuLyoqXG4gKiBTb3J0IGZvcm1hdHMgYnkgYSBsaXN0IG9mIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEBwYXJhbSB7QXJyYXkuPEZ1bmN0aW9uPn0gc29ydEJ5XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5jb25zdCBzb3J0Rm9ybWF0c0J5ID0gKGEsIGIsIHNvcnRCeSkgPT4ge1xuICBsZXQgcmVzID0gMDtcbiAgZm9yIChsZXQgZm4gb2Ygc29ydEJ5KSB7XG4gICAgcmVzID0gZm4oYikgLSBmbihhKTtcbiAgICBpZiAocmVzICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG5cblxuY29uc3Qgc29ydEZvcm1hdHNCeVZpZGVvID0gKGEsIGIpID0+IHNvcnRGb3JtYXRzQnkoYSwgYiwgW1xuICBmb3JtYXQgPT4gcGFyc2VJbnQoZm9ybWF0LnF1YWxpdHlMYWJlbCksXG4gIGdldFZpZGVvQml0cmF0ZSxcbiAgZ2V0VmlkZW9FbmNvZGluZ1JhbmssXG5dKTtcblxuXG5jb25zdCBzb3J0Rm9ybWF0c0J5QXVkaW8gPSAoYSwgYikgPT4gc29ydEZvcm1hdHNCeShhLCBiLCBbXG4gIGdldEF1ZGlvQml0cmF0ZSxcbiAgZ2V0QXVkaW9FbmNvZGluZ1JhbmssXG5dKTtcblxuXG4vKipcbiAqIFNvcnQgZm9ybWF0cyBmcm9tIGhpZ2hlc3QgcXVhbGl0eSB0byBsb3dlc3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLnNvcnRGb3JtYXRzID0gKGEsIGIpID0+IHNvcnRGb3JtYXRzQnkoYSwgYiwgW1xuICAvLyBGb3JtYXRzIHdpdGggYm90aCB2aWRlbyBhbmQgYXVkaW8gYXJlIHJhbmtlZCBoaWdoZXN0LlxuICBmb3JtYXQgPT4gKyEhZm9ybWF0LmlzSExTLFxuICBmb3JtYXQgPT4gKyEhZm9ybWF0LmlzRGFzaE1QRCxcbiAgZm9ybWF0ID0+ICsoZm9ybWF0LmNvbnRlbnRMZW5ndGggPiAwKSxcbiAgZm9ybWF0ID0+ICsoZm9ybWF0Lmhhc1ZpZGVvICYmIGZvcm1hdC5oYXNBdWRpbyksXG4gIGZvcm1hdCA9PiArZm9ybWF0Lmhhc1ZpZGVvLFxuICBmb3JtYXQgPT4gcGFyc2VJbnQoZm9ybWF0LnF1YWxpdHlMYWJlbCkgfHwgMCxcbiAgZ2V0VmlkZW9CaXRyYXRlLFxuICBnZXRBdWRpb0JpdHJhdGUsXG4gIGdldFZpZGVvRW5jb2RpbmdSYW5rLFxuICBnZXRBdWRpb0VuY29kaW5nUmFuayxcbl0pO1xuXG5cbi8qKlxuICogQ2hvb3NlIGEgZm9ybWF0IGRlcGVuZGluZyBvbiB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBmb3JtYXRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH1cbiAqIEB0aHJvd3Mge0Vycm9yfSB3aGVuIG5vIGZvcm1hdCBtYXRjaGVzIHRoZSBmaWx0ZXIvZm9ybWF0IHJ1bGVzXG4gKi9cbmV4cG9ydHMuY2hvb3NlRm9ybWF0ID0gKGZvcm1hdHMsIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLmZvcm1hdCA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoIW9wdGlvbnMuZm9ybWF0LnVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgZm9ybWF0IGdpdmVuLCBkaWQgeW91IHVzZSBgeXRkbC5nZXRJbmZvKClgPycpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucy5mb3JtYXQ7XG4gIH1cblxuICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsIG9wdGlvbnMuZmlsdGVyKTtcbiAgfVxuXG4gIC8vIFdlIGN1cnJlbnRseSBvbmx5IHN1cHBvcnQgSExTLUZvcm1hdHMgZm9yIGxpdmVzdHJlYW1zXG4gIC8vIFNvIHdlIChub3cpIHJlbW92ZSBhbGwgbm9uLUhMUyBzdHJlYW1zXG4gIGlmIChmb3JtYXRzLnNvbWUoZm10ID0+IGZtdC5pc0hMUykpIHtcbiAgICBmb3JtYXRzID0gZm9ybWF0cy5maWx0ZXIoZm10ID0+IGZtdC5pc0hMUyB8fCAhZm10LmlzTGl2ZSk7XG4gIH1cblxuICBsZXQgZm9ybWF0O1xuICBjb25zdCBxdWFsaXR5ID0gb3B0aW9ucy5xdWFsaXR5IHx8ICdoaWdoZXN0JztcbiAgc3dpdGNoIChxdWFsaXR5KSB7XG4gICAgY2FzZSAnaGlnaGVzdCc6XG4gICAgICBmb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdsb3dlc3QnOlxuICAgICAgZm9ybWF0ID0gZm9ybWF0c1tmb3JtYXRzLmxlbmd0aCAtIDFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdoaWdoZXN0YXVkaW8nOiB7XG4gICAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsICdhdWRpbycpO1xuICAgICAgZm9ybWF0cy5zb3J0KHNvcnRGb3JtYXRzQnlBdWRpbyk7XG4gICAgICAvLyBGaWx0ZXIgZm9yIG9ubHkgdGhlIGJlc3QgYXVkaW8gZm9ybWF0XG4gICAgICBjb25zdCBiZXN0QXVkaW9Gb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgZm9ybWF0cyA9IGZvcm1hdHMuZmlsdGVyKGYgPT4gc29ydEZvcm1hdHNCeUF1ZGlvKGJlc3RBdWRpb0Zvcm1hdCwgZikgPT09IDApO1xuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSB3b3JzdCB2aWRlbyBxdWFsaXR5IGZvciB0aGUgYmVzdCBhdWRpbyBxdWFsaXR5IGFuZCBwaWNrIGFjY29yZGluZ1xuICAgICAgLy8gVGhpcyBkb2VzIG5vdCBsb29zZSBkZWZhdWx0IHNvcnRpbmcgb2YgdmlkZW8gZW5jb2RpbmcgYW5kIGJpdHJhdGVcbiAgICAgIGNvbnN0IHdvcnN0VmlkZW9RdWFsaXR5ID0gZm9ybWF0cy5tYXAoZiA9PiBwYXJzZUludChmLnF1YWxpdHlMYWJlbCkgfHwgMCkuc29ydCgoYSwgYikgPT4gYSAtIGIpWzBdO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0cy5maW5kKGYgPT4gKHBhcnNlSW50KGYucXVhbGl0eUxhYmVsKSB8fCAwKSA9PT0gd29yc3RWaWRlb1F1YWxpdHkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2FzZSAnbG93ZXN0YXVkaW8nOlxuICAgICAgZm9ybWF0cyA9IGV4cG9ydHMuZmlsdGVyRm9ybWF0cyhmb3JtYXRzLCAnYXVkaW8nKTtcbiAgICAgIGZvcm1hdHMuc29ydChzb3J0Rm9ybWF0c0J5QXVkaW8pO1xuICAgICAgZm9ybWF0ID0gZm9ybWF0c1tmb3JtYXRzLmxlbmd0aCAtIDFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdoaWdoZXN0dmlkZW8nOiB7XG4gICAgICBmb3JtYXRzID0gZXhwb3J0cy5maWx0ZXJGb3JtYXRzKGZvcm1hdHMsICd2aWRlbycpO1xuICAgICAgZm9ybWF0cy5zb3J0KHNvcnRGb3JtYXRzQnlWaWRlbyk7XG4gICAgICAvLyBGaWx0ZXIgZm9yIG9ubHkgdGhlIGJlc3QgdmlkZW8gZm9ybWF0XG4gICAgICBjb25zdCBiZXN0VmlkZW9Gb3JtYXQgPSBmb3JtYXRzWzBdO1xuICAgICAgZm9ybWF0cyA9IGZvcm1hdHMuZmlsdGVyKGYgPT4gc29ydEZvcm1hdHNCeVZpZGVvKGJlc3RWaWRlb0Zvcm1hdCwgZikgPT09IDApO1xuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSB3b3JzdCBhdWRpbyBxdWFsaXR5IGZvciB0aGUgYmVzdCB2aWRlbyBxdWFsaXR5IGFuZCBwaWNrIGFjY29yZGluZ1xuICAgICAgLy8gVGhpcyBkb2VzIG5vdCBsb29zZSBkZWZhdWx0IHNvcnRpbmcgb2YgYXVkaW8gZW5jb2RpbmcgYW5kIGJpdHJhdGVcbiAgICAgIGNvbnN0IHdvcnN0QXVkaW9RdWFsaXR5ID0gZm9ybWF0cy5tYXAoZiA9PiBmLmF1ZGlvQml0cmF0ZSB8fCAwKS5zb3J0KChhLCBiKSA9PiBhIC0gYilbMF07XG4gICAgICBmb3JtYXQgPSBmb3JtYXRzLmZpbmQoZiA9PiAoZi5hdWRpb0JpdHJhdGUgfHwgMCkgPT09IHdvcnN0QXVkaW9RdWFsaXR5KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNhc2UgJ2xvd2VzdHZpZGVvJzpcbiAgICAgIGZvcm1hdHMgPSBleHBvcnRzLmZpbHRlckZvcm1hdHMoZm9ybWF0cywgJ3ZpZGVvJyk7XG4gICAgICBmb3JtYXRzLnNvcnQoc29ydEZvcm1hdHNCeVZpZGVvKTtcbiAgICAgIGZvcm1hdCA9IGZvcm1hdHNbZm9ybWF0cy5sZW5ndGggLSAxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGZvcm1hdCA9IGdldEZvcm1hdEJ5UXVhbGl0eShxdWFsaXR5LCBmb3JtYXRzKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgaWYgKCFmb3JtYXQpIHtcbiAgICB0aHJvdyBFcnJvcihgTm8gc3VjaCBmb3JtYXQgZm91bmQ6ICR7cXVhbGl0eX1gKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0O1xufTtcblxuLyoqXG4gKiBHZXRzIGEgZm9ybWF0IGJhc2VkIG9uIHF1YWxpdHkgb3IgYXJyYXkgb2YgcXVhbGl0eSdzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8W3N0cmluZ119IHF1YWxpdHlcbiAqIEBwYXJhbSB7W09iamVjdF19IGZvcm1hdHNcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IGdldEZvcm1hdEJ5UXVhbGl0eSA9IChxdWFsaXR5LCBmb3JtYXRzKSA9PiB7XG4gIGxldCBnZXRGb3JtYXQgPSBpdGFnID0+IGZvcm1hdHMuZmluZChmb3JtYXQgPT4gYCR7Zm9ybWF0Lml0YWd9YCA9PT0gYCR7aXRhZ31gKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkocXVhbGl0eSkpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0KHF1YWxpdHkuZmluZChxID0+IGdldEZvcm1hdChxKSkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRGb3JtYXQocXVhbGl0eSk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBmb3JtYXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaWx0ZXJcbiAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn1cbiAqL1xuZXhwb3J0cy5maWx0ZXJGb3JtYXRzID0gKGZvcm1hdHMsIGZpbHRlcikgPT4ge1xuICBsZXQgZm47XG4gIHN3aXRjaCAoZmlsdGVyKSB7XG4gICAgY2FzZSAndmlkZW9hbmRhdWRpbyc6XG4gICAgY2FzZSAnYXVkaW9hbmR2aWRlbyc6XG4gICAgICBmbiA9IGZvcm1hdCA9PiBmb3JtYXQuaGFzVmlkZW8gJiYgZm9ybWF0Lmhhc0F1ZGlvO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd2aWRlbyc6XG4gICAgICBmbiA9IGZvcm1hdCA9PiBmb3JtYXQuaGFzVmlkZW87XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3ZpZGVvb25seSc6XG4gICAgICBmbiA9IGZvcm1hdCA9PiBmb3JtYXQuaGFzVmlkZW8gJiYgIWZvcm1hdC5oYXNBdWRpbztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgZm4gPSBmb3JtYXQgPT4gZm9ybWF0Lmhhc0F1ZGlvO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdhdWRpb29ubHknOlxuICAgICAgZm4gPSBmb3JtYXQgPT4gIWZvcm1hdC5oYXNWaWRlbyAmJiBmb3JtYXQuaGFzQXVkaW87XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmbiA9IGZpbHRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcihgR2l2ZW4gZmlsdGVyICgke2ZpbHRlcn0pIGlzIG5vdCBzdXBwb3J0ZWRgKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZm9ybWF0cy5maWx0ZXIoZm9ybWF0ID0+ICEhZm9ybWF0LnVybCAmJiBmbihmb3JtYXQpKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gZm9ybWF0XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmFkZEZvcm1hdE1ldGEgPSBmb3JtYXQgPT4ge1xuICBmb3JtYXQgPSBPYmplY3QuYXNzaWduKHt9LCBGT1JNQVRTW2Zvcm1hdC5pdGFnXSwgZm9ybWF0KTtcbiAgZm9ybWF0Lmhhc1ZpZGVvID0gISFmb3JtYXQucXVhbGl0eUxhYmVsO1xuICBmb3JtYXQuaGFzQXVkaW8gPSAhIWZvcm1hdC5hdWRpb0JpdHJhdGU7XG4gIGZvcm1hdC5jb250YWluZXIgPSBmb3JtYXQubWltZVR5cGUgP1xuICAgIGZvcm1hdC5taW1lVHlwZS5zcGxpdCgnOycpWzBdLnNwbGl0KCcvJylbMV0gOiBudWxsO1xuICBmb3JtYXQuY29kZWNzID0gZm9ybWF0Lm1pbWVUeXBlID9cbiAgICB1dGlscy5iZXR3ZWVuKGZvcm1hdC5taW1lVHlwZSwgJ2NvZGVjcz1cIicsICdcIicpIDogbnVsbDtcbiAgZm9ybWF0LnZpZGVvQ29kZWMgPSBmb3JtYXQuaGFzVmlkZW8gJiYgZm9ybWF0LmNvZGVjcyA/XG4gICAgZm9ybWF0LmNvZGVjcy5zcGxpdCgnLCAnKVswXSA6IG51bGw7XG4gIGZvcm1hdC5hdWRpb0NvZGVjID0gZm9ybWF0Lmhhc0F1ZGlvICYmIGZvcm1hdC5jb2RlY3MgP1xuICAgIGZvcm1hdC5jb2RlY3Muc3BsaXQoJywgJykuc2xpY2UoLTEpWzBdIDogbnVsbDtcbiAgZm9ybWF0LmlzTGl2ZSA9IC9cXGJzb3VyY2VbLz1deXRfbGl2ZV9icm9hZGNhc3RcXGIvLnRlc3QoZm9ybWF0LnVybCk7XG4gIGZvcm1hdC5pc0hMUyA9IC9cXC9tYW5pZmVzdFxcL2hsc18odmFyaWFudHxwbGF5bGlzdClcXC8vLnRlc3QoZm9ybWF0LnVybCk7XG4gIGZvcm1hdC5pc0Rhc2hNUEQgPSAvXFwvbWFuaWZlc3RcXC9kYXNoXFwvLy50ZXN0KGZvcm1hdC51cmwpO1xuICByZXR1cm4gZm9ybWF0O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/format-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/formats.js":
/*!***********************************************!*\
  !*** ./node_modules/ytdl-core/lib/formats.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/**\n * http://en.wikipedia.org/wiki/YouTube#Quality_and_formats\n */\nmodule.exports = {\n\n  5: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.283, mp3\"',\n    qualityLabel: '240p',\n    bitrate: 250000,\n    audioBitrate: 64,\n  },\n\n  6: {\n    mimeType: 'video/flv; codecs=\"Sorenson H.263, mp3\"',\n    qualityLabel: '270p',\n    bitrate: 800000,\n    audioBitrate: 64,\n  },\n\n  13: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: null,\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  17: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '144p',\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  18: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  22: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  34: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  35: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  36: {\n    mimeType: 'video/3gp; codecs=\"MPEG-4 Visual, aac\"',\n    qualityLabel: '240p',\n    bitrate: 175000,\n    audioBitrate: 32,\n  },\n\n  37: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  38: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '3072p',\n    bitrate: 3500000,\n    audioBitrate: 192,\n  },\n\n  43: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  44: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '480p',\n    bitrate: 1000000,\n    audioBitrate: 128,\n  },\n\n  45: {\n    mimeType: 'video/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  46: {\n    mimeType: 'audio/webm; codecs=\"vp8, vorbis\"',\n    qualityLabel: '1080p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  82: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  83: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 500000,\n    audioBitrate: 96,\n  },\n\n  84: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 192,\n  },\n\n  85: {\n    mimeType: 'video/mp4; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 3000000,\n    audioBitrate: 192,\n  },\n\n  91: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: 48,\n  },\n\n  92: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  93: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '360p',\n    bitrate: 500000,\n    audioBitrate: 128,\n  },\n\n  94: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '480p',\n    bitrate: 800000,\n    audioBitrate: 128,\n  },\n\n  95: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1500000,\n    audioBitrate: 256,\n  },\n\n  96: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: 256,\n  },\n\n  100: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  101: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '360p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  102: {\n    mimeType: 'audio/webm; codecs=\"VP8, vorbis\"',\n    qualityLabel: '720p',\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  120: {\n    mimeType: 'video/flv; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 2000000,\n    audioBitrate: 128,\n  },\n\n  127: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  128: {\n    mimeType: 'audio/ts; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 96,\n  },\n\n  132: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '240p',\n    bitrate: 150000,\n    audioBitrate: 48,\n  },\n\n  133: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '240p',\n    bitrate: 200000,\n    audioBitrate: null,\n  },\n\n  134: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '360p',\n    bitrate: 300000,\n    audioBitrate: null,\n  },\n\n  135: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  136: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  137: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  138: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '4320p',\n    bitrate: 13500000,\n    audioBitrate: null,\n  },\n\n  139: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  140: {\n    mimeType: 'audio/m4a; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  141: {\n    mimeType: 'audio/mp4; codecs=\"aac\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 256,\n  },\n\n  151: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 50000,\n    audioBitrate: 24,\n  },\n\n  160: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '144p',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  171: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 128,\n  },\n\n  172: {\n    mimeType: 'audio/webm; codecs=\"vorbis\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 192,\n  },\n\n  242: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  243: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p',\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  244: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '480p',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  247: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p',\n    bitrate: 700000,\n    audioBitrate: null,\n  },\n\n  248: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p',\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  249: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 48,\n  },\n\n  250: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 64,\n  },\n\n  251: {\n    mimeType: 'audio/webm; codecs=\"opus\"',\n    qualityLabel: null,\n    bitrate: null,\n    audioBitrate: 160,\n  },\n\n  264: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1440p',\n    bitrate: 4000000,\n    audioBitrate: null,\n  },\n\n  266: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '2160p',\n    bitrate: 12500000,\n    audioBitrate: null,\n  },\n\n  271: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p',\n    bitrate: 9000000,\n    audioBitrate: null,\n  },\n\n  272: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '4320p',\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  278: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p 30fps',\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  298: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '720p',\n    bitrate: 3000000,\n    audioBitrate: null,\n  },\n\n  299: {\n    mimeType: 'video/mp4; codecs=\"H.264\"',\n    qualityLabel: '1080p',\n    bitrate: 5500000,\n    audioBitrate: null,\n  },\n\n  300: {\n    mimeType: 'video/ts; codecs=\"H.264, aac\"',\n    qualityLabel: '720p',\n    bitrate: 1318000,\n    audioBitrate: 48,\n  },\n\n  302: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HFR',\n    bitrate: 2500000,\n    audioBitrate: null,\n  },\n\n  303: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HFR',\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  308: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HFR',\n    bitrate: 10000000,\n    audioBitrate: null,\n  },\n\n  313: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p',\n    bitrate: 13000000,\n    audioBitrate: null,\n  },\n\n  315: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HFR',\n    bitrate: 20000000,\n    audioBitrate: null,\n  },\n\n  330: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '144p HDR, HFR',\n    bitrate: 80000,\n    audioBitrate: null,\n  },\n\n  331: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 100000,\n    audioBitrate: null,\n  },\n\n  332: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '360p HDR, HFR',\n    bitrate: 250000,\n    audioBitrate: null,\n  },\n\n  333: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '240p HDR, HFR',\n    bitrate: 500000,\n    audioBitrate: null,\n  },\n\n  334: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '720p HDR, HFR',\n    bitrate: 1000000,\n    audioBitrate: null,\n  },\n\n  335: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1080p HDR, HFR',\n    bitrate: 1500000,\n    audioBitrate: null,\n  },\n\n  336: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '1440p HDR, HFR',\n    bitrate: 5000000,\n    audioBitrate: null,\n  },\n\n  337: {\n    mimeType: 'video/webm; codecs=\"VP9\"',\n    qualityLabel: '2160p HDR, HFR',\n    bitrate: 12000000,\n    audioBitrate: null,\n  },\n\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9mb3JtYXRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy95dGRsLWNvcmUvbGliL2Zvcm1hdHMuanM/Zjc3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvWW91VHViZSNRdWFsaXR5X2FuZF9mb3JtYXRzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIDU6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL2ZsdjsgY29kZWNzPVwiU29yZW5zb24gSC4yODMsIG1wM1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyNDBwJyxcbiAgICBiaXRyYXRlOiAyNTAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA2NCxcbiAgfSxcblxuICA2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9mbHY7IGNvZGVjcz1cIlNvcmVuc29uIEguMjYzLCBtcDNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjcwcCcsXG4gICAgYml0cmF0ZTogODAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogNjQsXG4gIH0sXG5cbiAgMTM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvLzNncDsgY29kZWNzPVwiTVBFRy00IFZpc3VhbCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDE3OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby8zZ3A7IGNvZGVjcz1cIk1QRUctNCBWaXN1YWwsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxNDRwJyxcbiAgICBiaXRyYXRlOiA1MDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI0LFxuICB9LFxuXG4gIDE4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzYwcCcsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogOTYsXG4gIH0sXG5cbiAgMjI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwJyxcbiAgICBiaXRyYXRlOiAyMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDM0OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9mbHY7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzYwcCcsXG4gICAgYml0cmF0ZTogNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDM1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9mbHY7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNDgwcCcsXG4gICAgYml0cmF0ZTogODAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDM2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby8zZ3A7IGNvZGVjcz1cIk1QRUctNCBWaXN1YWwsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyNDBwJyxcbiAgICBiaXRyYXRlOiAxNzUwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAzMixcbiAgfSxcblxuICAzNzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzEwODBwJyxcbiAgICBiaXRyYXRlOiAzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDM4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzA3MnAnLFxuICAgIGJpdHJhdGU6IDM1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgNDM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICA0NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNDgwcCcsXG4gICAgYml0cmF0ZTogMTAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICA0NToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMjAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICA0Njoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwidnA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTA4MHAnLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgODI6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA5NixcbiAgfSxcblxuICA4Mzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI0MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDk2LFxuICB9LFxuXG4gIDg0OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMjAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICA4NToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzEwODBwJyxcbiAgICBiaXRyYXRlOiAzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDkxOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxNDRwJyxcbiAgICBiaXRyYXRlOiAxMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiA0OCxcbiAgfSxcblxuICA5Mjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjQwcCcsXG4gICAgYml0cmF0ZTogMTUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogNDgsXG4gIH0sXG5cbiAgOTM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDEyOCxcbiAgfSxcblxuICA5NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNDgwcCcsXG4gICAgYml0cmF0ZTogODAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDk1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwJyxcbiAgICBiaXRyYXRlOiAxNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMjU2LFxuICB9LFxuXG4gIDk2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby90czsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCcsXG4gICAgYml0cmF0ZTogMjUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDI1NixcbiAgfSxcblxuICAxMDA6IHtcbiAgICBtaW1lVHlwZTogJ2F1ZGlvL3dlYm07IGNvZGVjcz1cIlZQOCwgdm9yYmlzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAnLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgMTAxOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJWUDgsIHZvcmJpc1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTkyLFxuICB9LFxuXG4gIDEwMjoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vd2VibTsgY29kZWNzPVwiVlA4LCB2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDE5MixcbiAgfSxcblxuICAxMjA6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL2ZsdjsgY29kZWNzPVwiSC4yNjQsIGFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwJyxcbiAgICBiaXRyYXRlOiAyMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMTI4LFxuICB9LFxuXG4gIDEyNzoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vdHM7IGNvZGVjcz1cImFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDk2LFxuICB9LFxuXG4gIDEyODoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vdHM7IGNvZGVjcz1cImFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDk2LFxuICB9LFxuXG4gIDEzMjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjQwcCcsXG4gICAgYml0cmF0ZTogMTUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogNDgsXG4gIH0sXG5cbiAgMTMzOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI0MHAnLFxuICAgIGJpdHJhdGU6IDIwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTM0OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzM2MHAnLFxuICAgIGJpdHJhdGU6IDMwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTM1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQ4MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTM2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IDEwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDEzNzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCcsXG4gICAgYml0cmF0ZTogMjUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTM4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQzMjBwJyxcbiAgICBiaXRyYXRlOiAxMzUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTM5OiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby9tcDQ7IGNvZGVjcz1cImFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDE0MDoge1xuICAgIG1pbWVUeXBlOiAnYXVkaW8vbTRhOyBjb2RlY3M9XCJhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgMTQxOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby9tcDQ7IGNvZGVjcz1cImFhY1wiJyxcbiAgICBxdWFsaXR5TGFiZWw6IG51bGwsXG4gICAgYml0cmF0ZTogbnVsbCxcbiAgICBhdWRpb0JpdHJhdGU6IDI1NixcbiAgfSxcblxuICAxNTE6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3RzOyBjb2RlY3M9XCJILjI2NCwgYWFjXCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogMjQsXG4gIH0sXG5cbiAgMTYwOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzE0NHAnLFxuICAgIGJpdHJhdGU6IDEwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMTcxOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAxMjgsXG4gIH0sXG5cbiAgMTcyOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJ2b3JiaXNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiBudWxsLFxuICAgIGJpdHJhdGU6IG51bGwsXG4gICAgYXVkaW9CaXRyYXRlOiAxOTIsXG4gIH0sXG5cbiAgMjQyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjQwcCcsXG4gICAgYml0cmF0ZTogMTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNDM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICczNjBwJyxcbiAgICBiaXRyYXRlOiAyNTAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI0NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQ4MHAnLFxuICAgIGJpdHJhdGU6IDUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQ3OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogNzAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyNDg6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCcsXG4gICAgYml0cmF0ZTogMTUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjQ5OiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJvcHVzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogNDgsXG4gIH0sXG5cbiAgMjUwOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJvcHVzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogNjQsXG4gIH0sXG5cbiAgMjUxOiB7XG4gICAgbWltZVR5cGU6ICdhdWRpby93ZWJtOyBjb2RlY3M9XCJvcHVzXCInLFxuICAgIHF1YWxpdHlMYWJlbDogbnVsbCxcbiAgICBiaXRyYXRlOiBudWxsLFxuICAgIGF1ZGlvQml0cmF0ZTogMTYwLFxuICB9LFxuXG4gIDI2NDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxNDQwcCcsXG4gICAgYml0cmF0ZTogNDAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjY2OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby9tcDQ7IGNvZGVjcz1cIkguMjY0XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzIxNjBwJyxcbiAgICBiaXRyYXRlOiAxMjUwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjcxOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0MHAnLFxuICAgIGJpdHJhdGU6IDkwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI3Mjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzQzMjBwJyxcbiAgICBiaXRyYXRlOiAyMDAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMjc4OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0cCAzMGZwcycsXG4gICAgYml0cmF0ZTogODAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDI5ODoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vbXA0OyBjb2RlY3M9XCJILjI2NFwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICc3MjBwJyxcbiAgICBiaXRyYXRlOiAzMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAyOTk6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL21wNDsgY29kZWNzPVwiSC4yNjRcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTA4MHAnLFxuICAgIGJpdHJhdGU6IDU1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMwMDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vdHM7IGNvZGVjcz1cIkguMjY0LCBhYWNcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnNzIwcCcsXG4gICAgYml0cmF0ZTogMTMxODAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IDQ4LFxuICB9LFxuXG4gIDMwMjoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAgSEZSJyxcbiAgICBiaXRyYXRlOiAyNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMDM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxMDgwcCBIRlInLFxuICAgIGJpdHJhdGU6IDUwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMwODoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzE0NDBwIEhGUicsXG4gICAgYml0cmF0ZTogMTAwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMxMzoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzIxNjBwJyxcbiAgICBiaXRyYXRlOiAxMzAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzE1OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjE2MHAgSEZSJyxcbiAgICBiaXRyYXRlOiAyMDAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzMwOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMTQ0cCBIRFIsIEhGUicsXG4gICAgYml0cmF0ZTogODAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzMToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzI0MHAgSERSLCBIRlInLFxuICAgIGJpdHJhdGU6IDEwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzMyOiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMzYwcCBIRFIsIEhGUicsXG4gICAgYml0cmF0ZTogMjUwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMzM6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcyNDBwIEhEUiwgSEZSJyxcbiAgICBiaXRyYXRlOiA1MDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzNDoge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzcyMHAgSERSLCBIRlInLFxuICAgIGJpdHJhdGU6IDEwMDAwMDAsXG4gICAgYXVkaW9CaXRyYXRlOiBudWxsLFxuICB9LFxuXG4gIDMzNToge1xuICAgIG1pbWVUeXBlOiAndmlkZW8vd2VibTsgY29kZWNzPVwiVlA5XCInLFxuICAgIHF1YWxpdHlMYWJlbDogJzEwODBwIEhEUiwgSEZSJyxcbiAgICBiaXRyYXRlOiAxNTAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxuICAzMzY6IHtcbiAgICBtaW1lVHlwZTogJ3ZpZGVvL3dlYm07IGNvZGVjcz1cIlZQOVwiJyxcbiAgICBxdWFsaXR5TGFiZWw6ICcxNDQwcCBIRFIsIEhGUicsXG4gICAgYml0cmF0ZTogNTAwMDAwMCxcbiAgICBhdWRpb0JpdHJhdGU6IG51bGwsXG4gIH0sXG5cbiAgMzM3OiB7XG4gICAgbWltZVR5cGU6ICd2aWRlby93ZWJtOyBjb2RlY3M9XCJWUDlcIicsXG4gICAgcXVhbGl0eUxhYmVsOiAnMjE2MHAgSERSLCBIRlInLFxuICAgIGJpdHJhdGU6IDEyMDAwMDAwLFxuICAgIGF1ZGlvQml0cmF0ZTogbnVsbCxcbiAgfSxcblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/formats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst getInfo = __webpack_require__(/*! ./info */ \"(rsc)/./node_modules/ytdl-core/lib/info.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst formatUtils = __webpack_require__(/*! ./format-utils */ \"(rsc)/./node_modules/ytdl-core/lib/format-utils.js\");\nconst urlUtils = __webpack_require__(/*! ./url-utils */ \"(rsc)/./node_modules/ytdl-core/lib/url-utils.js\");\nconst sig = __webpack_require__(/*! ./sig */ \"(rsc)/./node_modules/ytdl-core/lib/sig.js\");\nconst miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\nconst m3u8stream = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\nconst { parseTimestamp } = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\n\n\n/**\n * @param {string} link\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nconst ytdl = (link, options) => {\n  const stream = createStream(options);\n  ytdl.getInfo(link, options).then(info => {\n    downloadFromInfoCallback(stream, info, options);\n  }, stream.emit.bind(stream, 'error'));\n  return stream;\n};\nmodule.exports = ytdl;\n\nytdl.getBasicInfo = getInfo.getBasicInfo;\nytdl.getInfo = getInfo.getInfo;\nytdl.chooseFormat = formatUtils.chooseFormat;\nytdl.filterFormats = formatUtils.filterFormats;\nytdl.validateID = urlUtils.validateID;\nytdl.validateURL = urlUtils.validateURL;\nytdl.getURLVideoID = urlUtils.getURLVideoID;\nytdl.getVideoID = urlUtils.getVideoID;\nytdl.cache = {\n  sig: sig.cache,\n  info: getInfo.cache,\n  watch: getInfo.watchPageCache,\n  cookie: getInfo.cookieCache,\n};\nytdl.version = (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/ytdl-core/package.json\").version);\n\n\nconst createStream = options => {\n  const stream = new PassThrough({\n    highWaterMark: (options && options.highWaterMark) || 1024 * 512,\n  });\n  stream._destroy = () => { stream.destroyed = true; };\n  return stream;\n};\n\n\nconst pipeAndSetEvents = (req, stream, end) => {\n  // Forward events from the request to the stream.\n  [\n    'abort', 'request', 'response', 'error', 'redirect', 'retry', 'reconnect',\n  ].forEach(event => {\n    req.prependListener(event, stream.emit.bind(stream, event));\n  });\n  req.pipe(stream, { end });\n};\n\n\n/**\n * Chooses a format to download.\n *\n * @param {stream.Readable} stream\n * @param {Object} info\n * @param {Object} options\n */\nconst downloadFromInfoCallback = (stream, info, options) => {\n  options = options || {};\n\n  let err = utils.playError(info.player_response, ['UNPLAYABLE', 'LIVE_STREAM_OFFLINE', 'LOGIN_REQUIRED']);\n  if (err) {\n    stream.emit('error', err);\n    return;\n  }\n\n  if (!info.formats.length) {\n    stream.emit('error', Error('This video is unavailable'));\n    return;\n  }\n\n  let format;\n  try {\n    format = formatUtils.chooseFormat(info.formats, options);\n  } catch (e) {\n    stream.emit('error', e);\n    return;\n  }\n  stream.emit('info', info, format);\n  if (stream.destroyed) { return; }\n\n  let contentLength, downloaded = 0;\n  const ondata = chunk => {\n    downloaded += chunk.length;\n    stream.emit('progress', chunk.length, downloaded, contentLength);\n  };\n\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      family: 6,\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n\n  // Download the file in chunks, in this case the default is 10MB,\n  // anything over this will cause youtube to throttle the download\n  const dlChunkSize = options.dlChunkSize || 1024 * 1024 * 10;\n  let req;\n  let shouldEnd = true;\n\n  if (format.isHLS || format.isDashMPD) {\n    req = m3u8stream(format.url, {\n      chunkReadahead: +info.live_chunk_readahead,\n      begin: options.begin || (format.isLive && Date.now()),\n      liveBuffer: options.liveBuffer,\n      requestOptions: options.requestOptions,\n      parser: format.isDashMPD ? 'dash-mpd' : 'm3u8',\n      id: format.itag,\n    });\n\n    req.on('progress', (segment, totalSegments) => {\n      stream.emit('progress', segment.size, segment.num, totalSegments);\n    });\n    pipeAndSetEvents(req, stream, shouldEnd);\n  } else {\n    const requestOptions = Object.assign({}, options.requestOptions, {\n      maxReconnects: 6,\n      maxRetries: 3,\n      backoff: { inc: 500, max: 10000 },\n    });\n\n    let shouldBeChunked = dlChunkSize !== 0 && (!format.hasAudio || !format.hasVideo);\n\n    if (shouldBeChunked) {\n      let start = (options.range && options.range.start) || 0;\n      let end = start + dlChunkSize;\n      const rangeEnd = options.range && options.range.end;\n\n      contentLength = options.range ?\n        (rangeEnd ? rangeEnd + 1 : parseInt(format.contentLength)) - start :\n        parseInt(format.contentLength);\n\n      const getNextChunk = () => {\n        if (!rangeEnd && end >= contentLength) end = 0;\n        if (rangeEnd && end > rangeEnd) end = rangeEnd;\n        shouldEnd = !end || end === rangeEnd;\n\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${start}-${end || ''}`,\n        });\n\n        req = miniget(format.url, requestOptions);\n        req.on('data', ondata);\n        req.on('end', () => {\n          if (stream.destroyed) { return; }\n          if (end && end !== rangeEnd) {\n            start = end + 1;\n            end += dlChunkSize;\n            getNextChunk();\n          }\n        });\n        pipeAndSetEvents(req, stream, shouldEnd);\n      };\n      getNextChunk();\n    } else {\n      // Audio only and video only formats don't support begin\n      if (options.begin) {\n        format.url += `&begin=${parseTimestamp(options.begin)}`;\n      }\n      if (options.range && (options.range.start || options.range.end)) {\n        requestOptions.headers = Object.assign({}, requestOptions.headers, {\n          Range: `bytes=${options.range.start || '0'}-${options.range.end || ''}`,\n        });\n      }\n      req = miniget(format.url, requestOptions);\n      req.on('response', res => {\n        if (stream.destroyed) { return; }\n        contentLength = contentLength || parseInt(res.headers['content-length']);\n      });\n      req.on('data', ondata);\n      pipeAndSetEvents(req, stream, shouldEnd);\n    }\n  }\n\n  stream._destroy = () => {\n    stream.destroyed = true;\n    req.destroy();\n    req.end();\n  };\n};\n\n\n/**\n * Can be used to download video after its `info` is gotten through\n * `ytdl.getInfo()`. In case the user might want to look at the\n * `info` object before deciding to download.\n *\n * @param {Object} info\n * @param {!Object} options\n * @returns {ReadableStream}\n */\nytdl.downloadFromInfo = (info, options) => {\n  const stream = createStream(options);\n  if (!info.full) {\n    throw Error('Cannot use `ytdl.downloadFromInfo()` when called ' +\n      'with info from `ytdl.getBasicInfo()`');\n  }\n  setImmediate(() => {\n    downloadFromInfoCallback(stream, info, options);\n  });\n  return stream;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IseURBQTZCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLDBEQUFRO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixvQkFBb0IsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsb0VBQWE7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDJEQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLGlFQUFZO0FBQ3ZDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBWTs7O0FBRy9DO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUdBQWtDOzs7QUFHakQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDRCQUE0QjtBQUM1QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLEtBQUs7QUFDMUI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQ7QUFDakQsMEJBQTBCLE1BQU0sR0FBRyxVQUFVO0FBQzdDLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsMEJBQTBCLDJCQUEyQixHQUFHLHdCQUF3QjtBQUNoRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL3l0ZGwtY29yZS9saWIvaW5kZXguanM/YzYxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3N0cmVhbScpLlBhc3NUaHJvdWdoO1xuY29uc3QgZ2V0SW5mbyA9IHJlcXVpcmUoJy4vaW5mbycpO1xuY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBmb3JtYXRVdGlscyA9IHJlcXVpcmUoJy4vZm9ybWF0LXV0aWxzJyk7XG5jb25zdCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXJsLXV0aWxzJyk7XG5jb25zdCBzaWcgPSByZXF1aXJlKCcuL3NpZycpO1xuY29uc3QgbWluaWdldCA9IHJlcXVpcmUoJ21pbmlnZXQnKTtcbmNvbnN0IG0zdThzdHJlYW0gPSByZXF1aXJlKCdtM3U4c3RyZWFtJyk7XG5jb25zdCB7IHBhcnNlVGltZXN0YW1wIH0gPSByZXF1aXJlKCdtM3U4c3RyZWFtJyk7XG5cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGlua1xuICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UmVhZGFibGVTdHJlYW19XG4gKi9cbmNvbnN0IHl0ZGwgPSAobGluaywgb3B0aW9ucykgPT4ge1xuICBjb25zdCBzdHJlYW0gPSBjcmVhdGVTdHJlYW0ob3B0aW9ucyk7XG4gIHl0ZGwuZ2V0SW5mbyhsaW5rLCBvcHRpb25zKS50aGVuKGluZm8gPT4ge1xuICAgIGRvd25sb2FkRnJvbUluZm9DYWxsYmFjayhzdHJlYW0sIGluZm8sIG9wdGlvbnMpO1xuICB9LCBzdHJlYW0uZW1pdC5iaW5kKHN0cmVhbSwgJ2Vycm9yJykpO1xuICByZXR1cm4gc3RyZWFtO1xufTtcbm1vZHVsZS5leHBvcnRzID0geXRkbDtcblxueXRkbC5nZXRCYXNpY0luZm8gPSBnZXRJbmZvLmdldEJhc2ljSW5mbztcbnl0ZGwuZ2V0SW5mbyA9IGdldEluZm8uZ2V0SW5mbztcbnl0ZGwuY2hvb3NlRm9ybWF0ID0gZm9ybWF0VXRpbHMuY2hvb3NlRm9ybWF0O1xueXRkbC5maWx0ZXJGb3JtYXRzID0gZm9ybWF0VXRpbHMuZmlsdGVyRm9ybWF0cztcbnl0ZGwudmFsaWRhdGVJRCA9IHVybFV0aWxzLnZhbGlkYXRlSUQ7XG55dGRsLnZhbGlkYXRlVVJMID0gdXJsVXRpbHMudmFsaWRhdGVVUkw7XG55dGRsLmdldFVSTFZpZGVvSUQgPSB1cmxVdGlscy5nZXRVUkxWaWRlb0lEO1xueXRkbC5nZXRWaWRlb0lEID0gdXJsVXRpbHMuZ2V0VmlkZW9JRDtcbnl0ZGwuY2FjaGUgPSB7XG4gIHNpZzogc2lnLmNhY2hlLFxuICBpbmZvOiBnZXRJbmZvLmNhY2hlLFxuICB3YXRjaDogZ2V0SW5mby53YXRjaFBhZ2VDYWNoZSxcbiAgY29va2llOiBnZXRJbmZvLmNvb2tpZUNhY2hlLFxufTtcbnl0ZGwudmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5cblxuY29uc3QgY3JlYXRlU3RyZWFtID0gb3B0aW9ucyA9PiB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCh7XG4gICAgaGlnaFdhdGVyTWFyazogKG9wdGlvbnMgJiYgb3B0aW9ucy5oaWdoV2F0ZXJNYXJrKSB8fCAxMDI0ICogNTEyLFxuICB9KTtcbiAgc3RyZWFtLl9kZXN0cm95ID0gKCkgPT4geyBzdHJlYW0uZGVzdHJveWVkID0gdHJ1ZTsgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn07XG5cblxuY29uc3QgcGlwZUFuZFNldEV2ZW50cyA9IChyZXEsIHN0cmVhbSwgZW5kKSA9PiB7XG4gIC8vIEZvcndhcmQgZXZlbnRzIGZyb20gdGhlIHJlcXVlc3QgdG8gdGhlIHN0cmVhbS5cbiAgW1xuICAgICdhYm9ydCcsICdyZXF1ZXN0JywgJ3Jlc3BvbnNlJywgJ2Vycm9yJywgJ3JlZGlyZWN0JywgJ3JldHJ5JywgJ3JlY29ubmVjdCcsXG4gIF0uZm9yRWFjaChldmVudCA9PiB7XG4gICAgcmVxLnByZXBlbmRMaXN0ZW5lcihldmVudCwgc3RyZWFtLmVtaXQuYmluZChzdHJlYW0sIGV2ZW50KSk7XG4gIH0pO1xuICByZXEucGlwZShzdHJlYW0sIHsgZW5kIH0pO1xufTtcblxuXG4vKipcbiAqIENob29zZXMgYSBmb3JtYXQgdG8gZG93bmxvYWQuXG4gKlxuICogQHBhcmFtIHtzdHJlYW0uUmVhZGFibGV9IHN0cmVhbVxuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmNvbnN0IGRvd25sb2FkRnJvbUluZm9DYWxsYmFjayA9IChzdHJlYW0sIGluZm8sIG9wdGlvbnMpID0+IHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGVyciA9IHV0aWxzLnBsYXlFcnJvcihpbmZvLnBsYXllcl9yZXNwb25zZSwgWydVTlBMQVlBQkxFJywgJ0xJVkVfU1RSRUFNX09GRkxJTkUnLCAnTE9HSU5fUkVRVUlSRUQnXSk7XG4gIGlmIChlcnIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaW5mby5mb3JtYXRzLmxlbmd0aCkge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yKCdUaGlzIHZpZGVvIGlzIHVuYXZhaWxhYmxlJykpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBmb3JtYXQ7XG4gIHRyeSB7XG4gICAgZm9ybWF0ID0gZm9ybWF0VXRpbHMuY2hvb3NlRm9ybWF0KGluZm8uZm9ybWF0cywgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgc3RyZWFtLmVtaXQoJ2luZm8nLCBpbmZvLCBmb3JtYXQpO1xuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCkgeyByZXR1cm47IH1cblxuICBsZXQgY29udGVudExlbmd0aCwgZG93bmxvYWRlZCA9IDA7XG4gIGNvbnN0IG9uZGF0YSA9IGNodW5rID0+IHtcbiAgICBkb3dubG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICBzdHJlYW0uZW1pdCgncHJvZ3Jlc3MnLCBjaHVuay5sZW5ndGgsIGRvd25sb2FkZWQsIGNvbnRlbnRMZW5ndGgpO1xuICB9O1xuXG4gIGlmIChvcHRpb25zLklQdjZCbG9jaykge1xuICAgIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3RPcHRpb25zLCB7XG4gICAgICBmYW1pbHk6IDYsXG4gICAgICBsb2NhbEFkZHJlc3M6IHV0aWxzLmdldFJhbmRvbUlQdjYob3B0aW9ucy5JUHY2QmxvY2spLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gRG93bmxvYWQgdGhlIGZpbGUgaW4gY2h1bmtzLCBpbiB0aGlzIGNhc2UgdGhlIGRlZmF1bHQgaXMgMTBNQixcbiAgLy8gYW55dGhpbmcgb3ZlciB0aGlzIHdpbGwgY2F1c2UgeW91dHViZSB0byB0aHJvdHRsZSB0aGUgZG93bmxvYWRcbiAgY29uc3QgZGxDaHVua1NpemUgPSBvcHRpb25zLmRsQ2h1bmtTaXplIHx8IDEwMjQgKiAxMDI0ICogMTA7XG4gIGxldCByZXE7XG4gIGxldCBzaG91bGRFbmQgPSB0cnVlO1xuXG4gIGlmIChmb3JtYXQuaXNITFMgfHwgZm9ybWF0LmlzRGFzaE1QRCkge1xuICAgIHJlcSA9IG0zdThzdHJlYW0oZm9ybWF0LnVybCwge1xuICAgICAgY2h1bmtSZWFkYWhlYWQ6ICtpbmZvLmxpdmVfY2h1bmtfcmVhZGFoZWFkLFxuICAgICAgYmVnaW46IG9wdGlvbnMuYmVnaW4gfHwgKGZvcm1hdC5pc0xpdmUgJiYgRGF0ZS5ub3coKSksXG4gICAgICBsaXZlQnVmZmVyOiBvcHRpb25zLmxpdmVCdWZmZXIsXG4gICAgICByZXF1ZXN0T3B0aW9uczogb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyxcbiAgICAgIHBhcnNlcjogZm9ybWF0LmlzRGFzaE1QRCA/ICdkYXNoLW1wZCcgOiAnbTN1OCcsXG4gICAgICBpZDogZm9ybWF0Lml0YWcsXG4gICAgfSk7XG5cbiAgICByZXEub24oJ3Byb2dyZXNzJywgKHNlZ21lbnQsIHRvdGFsU2VnbWVudHMpID0+IHtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcm9ncmVzcycsIHNlZ21lbnQuc2l6ZSwgc2VnbWVudC5udW0sIHRvdGFsU2VnbWVudHMpO1xuICAgIH0pO1xuICAgIHBpcGVBbmRTZXRFdmVudHMocmVxLCBzdHJlYW0sIHNob3VsZEVuZCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnJlcXVlc3RPcHRpb25zLCB7XG4gICAgICBtYXhSZWNvbm5lY3RzOiA2LFxuICAgICAgbWF4UmV0cmllczogMyxcbiAgICAgIGJhY2tvZmY6IHsgaW5jOiA1MDAsIG1heDogMTAwMDAgfSxcbiAgICB9KTtcblxuICAgIGxldCBzaG91bGRCZUNodW5rZWQgPSBkbENodW5rU2l6ZSAhPT0gMCAmJiAoIWZvcm1hdC5oYXNBdWRpbyB8fCAhZm9ybWF0Lmhhc1ZpZGVvKTtcblxuICAgIGlmIChzaG91bGRCZUNodW5rZWQpIHtcbiAgICAgIGxldCBzdGFydCA9IChvcHRpb25zLnJhbmdlICYmIG9wdGlvbnMucmFuZ2Uuc3RhcnQpIHx8IDA7XG4gICAgICBsZXQgZW5kID0gc3RhcnQgKyBkbENodW5rU2l6ZTtcbiAgICAgIGNvbnN0IHJhbmdlRW5kID0gb3B0aW9ucy5yYW5nZSAmJiBvcHRpb25zLnJhbmdlLmVuZDtcblxuICAgICAgY29udGVudExlbmd0aCA9IG9wdGlvbnMucmFuZ2UgP1xuICAgICAgICAocmFuZ2VFbmQgPyByYW5nZUVuZCArIDEgOiBwYXJzZUludChmb3JtYXQuY29udGVudExlbmd0aCkpIC0gc3RhcnQgOlxuICAgICAgICBwYXJzZUludChmb3JtYXQuY29udGVudExlbmd0aCk7XG5cbiAgICAgIGNvbnN0IGdldE5leHRDaHVuayA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFyYW5nZUVuZCAmJiBlbmQgPj0gY29udGVudExlbmd0aCkgZW5kID0gMDtcbiAgICAgICAgaWYgKHJhbmdlRW5kICYmIGVuZCA+IHJhbmdlRW5kKSBlbmQgPSByYW5nZUVuZDtcbiAgICAgICAgc2hvdWxkRW5kID0gIWVuZCB8fCBlbmQgPT09IHJhbmdlRW5kO1xuXG4gICAgICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICAgUmFuZ2U6IGBieXRlcz0ke3N0YXJ0fS0ke2VuZCB8fCAnJ31gLFxuICAgICAgICB9KTtcblxuICAgICAgICByZXEgPSBtaW5pZ2V0KGZvcm1hdC51cmwsIHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgcmVxLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgICAgICAgcmVxLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgaWYgKGVuZCAmJiBlbmQgIT09IHJhbmdlRW5kKSB7XG4gICAgICAgICAgICBzdGFydCA9IGVuZCArIDE7XG4gICAgICAgICAgICBlbmQgKz0gZGxDaHVua1NpemU7XG4gICAgICAgICAgICBnZXROZXh0Q2h1bmsoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwaXBlQW5kU2V0RXZlbnRzKHJlcSwgc3RyZWFtLCBzaG91bGRFbmQpO1xuICAgICAgfTtcbiAgICAgIGdldE5leHRDaHVuaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdWRpbyBvbmx5IGFuZCB2aWRlbyBvbmx5IGZvcm1hdHMgZG9uJ3Qgc3VwcG9ydCBiZWdpblxuICAgICAgaWYgKG9wdGlvbnMuYmVnaW4pIHtcbiAgICAgICAgZm9ybWF0LnVybCArPSBgJmJlZ2luPSR7cGFyc2VUaW1lc3RhbXAob3B0aW9ucy5iZWdpbil9YDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnJhbmdlICYmIChvcHRpb25zLnJhbmdlLnN0YXJ0IHx8IG9wdGlvbnMucmFuZ2UuZW5kKSkge1xuICAgICAgICByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgIFJhbmdlOiBgYnl0ZXM9JHtvcHRpb25zLnJhbmdlLnN0YXJ0IHx8ICcwJ30tJHtvcHRpb25zLnJhbmdlLmVuZCB8fCAnJ31gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IG1pbmlnZXQoZm9ybWF0LnVybCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgcmVxLm9uKCdyZXNwb25zZScsIHJlcyA9PiB7XG4gICAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7IHJldHVybjsgfVxuICAgICAgICBjb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aCB8fCBwYXJzZUludChyZXMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSk7XG4gICAgICB9KTtcbiAgICAgIHJlcS5vbignZGF0YScsIG9uZGF0YSk7XG4gICAgICBwaXBlQW5kU2V0RXZlbnRzKHJlcSwgc3RyZWFtLCBzaG91bGRFbmQpO1xuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5fZGVzdHJveSA9ICgpID0+IHtcbiAgICBzdHJlYW0uZGVzdHJveWVkID0gdHJ1ZTtcbiAgICByZXEuZGVzdHJveSgpO1xuICAgIHJlcS5lbmQoKTtcbiAgfTtcbn07XG5cblxuLyoqXG4gKiBDYW4gYmUgdXNlZCB0byBkb3dubG9hZCB2aWRlbyBhZnRlciBpdHMgYGluZm9gIGlzIGdvdHRlbiB0aHJvdWdoXG4gKiBgeXRkbC5nZXRJbmZvKClgLiBJbiBjYXNlIHRoZSB1c2VyIG1pZ2h0IHdhbnQgdG8gbG9vayBhdCB0aGVcbiAqIGBpbmZvYCBvYmplY3QgYmVmb3JlIGRlY2lkaW5nIHRvIGRvd25sb2FkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtSZWFkYWJsZVN0cmVhbX1cbiAqL1xueXRkbC5kb3dubG9hZEZyb21JbmZvID0gKGluZm8sIG9wdGlvbnMpID0+IHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlU3RyZWFtKG9wdGlvbnMpO1xuICBpZiAoIWluZm8uZnVsbCkge1xuICAgIHRocm93IEVycm9yKCdDYW5ub3QgdXNlIGB5dGRsLmRvd25sb2FkRnJvbUluZm8oKWAgd2hlbiBjYWxsZWQgJyArXG4gICAgICAnd2l0aCBpbmZvIGZyb20gYHl0ZGwuZ2V0QmFzaWNJbmZvKClgJyk7XG4gIH1cbiAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICBkb3dubG9hZEZyb21JbmZvQ2FsbGJhY2soc3RyZWFtLCBpbmZvLCBvcHRpb25zKTtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW07XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/info-extras.js":
/*!***************************************************!*\
  !*** ./node_modules/ytdl-core/lib/info-extras.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst qs = __webpack_require__(/*! querystring */ \"querystring\");\nconst { parseTimestamp } = __webpack_require__(/*! m3u8stream */ \"(rsc)/./node_modules/m3u8stream/dist/index.js\");\n\n\nconst BASE_URL = 'https://www.youtube.com/watch?v=';\nconst TITLE_TO_CATEGORY = {\n  song: { name: 'Music', url: 'https://music.youtube.com/' },\n};\n\nconst getText = obj => obj ? obj.runs ? obj.runs[0].text : obj.simpleText : null;\n\n\n/**\n * Get video media.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getMedia = info => {\n  let media = {};\n  let results = [];\n  try {\n    results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n  } catch (err) {\n    // Do nothing\n  }\n\n  let result = results.find(v => v.videoSecondaryInfoRenderer);\n  if (!result) { return {}; }\n\n  try {\n    let metadataRows =\n      (result.metadataRowContainer || result.videoSecondaryInfoRenderer.metadataRowContainer)\n        .metadataRowContainerRenderer.rows;\n    for (let row of metadataRows) {\n      if (row.metadataRowRenderer) {\n        let title = getText(row.metadataRowRenderer.title).toLowerCase();\n        let contents = row.metadataRowRenderer.contents[0];\n        media[title] = getText(contents);\n        let runs = contents.runs;\n        if (runs && runs[0].navigationEndpoint) {\n          media[`${title}_url`] = new URL(\n            runs[0].navigationEndpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n        if (title in TITLE_TO_CATEGORY) {\n          media.category = TITLE_TO_CATEGORY[title].name;\n          media.category_url = TITLE_TO_CATEGORY[title].url;\n        }\n      } else if (row.richMetadataRowRenderer) {\n        let contents = row.richMetadataRowRenderer.contents;\n        let boxArt = contents\n          .filter(meta => meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_BOX_ART');\n        for (let { richMetadataRenderer } of boxArt) {\n          let meta = richMetadataRenderer;\n          media.year = getText(meta.subtitle);\n          let type = getText(meta.callToAction).split(' ')[1];\n          media[type] = getText(meta.title);\n          media[`${type}_url`] = new URL(\n            meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n          media.thumbnails = meta.thumbnail.thumbnails;\n        }\n        let topic = contents\n          .filter(meta => meta.richMetadataRenderer.style === 'RICH_METADATA_RENDERER_STYLE_TOPIC');\n        for (let { richMetadataRenderer } of topic) {\n          let meta = richMetadataRenderer;\n          media.category = getText(meta.title);\n          media.category_url = new URL(\n            meta.endpoint.commandMetadata.webCommandMetadata.url, BASE_URL).toString();\n        }\n      }\n    }\n  } catch (err) {\n    // Do nothing.\n  }\n\n  return media;\n};\n\n\nconst isVerified = badges => !!(badges && badges.find(b => b.metadataBadgeRenderer.tooltip === 'Verified'));\n\n\n/**\n * Get video author.\n *\n * @param {Object} info\n * @returns {Object}\n */\nexports.getAuthor = info => {\n  let channelId, thumbnails = [], subscriberCount, verified = false;\n  try {\n    let results = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let v = results.find(v2 =>\n      v2.videoSecondaryInfoRenderer &&\n      v2.videoSecondaryInfoRenderer.owner &&\n      v2.videoSecondaryInfoRenderer.owner.videoOwnerRenderer);\n    let videoOwnerRenderer = v.videoSecondaryInfoRenderer.owner.videoOwnerRenderer;\n    channelId = videoOwnerRenderer.navigationEndpoint.browseEndpoint.browseId;\n    thumbnails = videoOwnerRenderer.thumbnail.thumbnails.map(thumbnail => {\n      thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n      return thumbnail;\n    });\n    subscriberCount = utils.parseAbbreviatedNumber(getText(videoOwnerRenderer.subscriberCountText));\n    verified = isVerified(videoOwnerRenderer.badges);\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    let videoDetails = info.player_response.microformat && info.player_response.microformat.playerMicroformatRenderer;\n    let id = (videoDetails && videoDetails.channelId) || channelId || info.player_response.videoDetails.channelId;\n    let author = {\n      id: id,\n      name: videoDetails ? videoDetails.ownerChannelName : info.player_response.videoDetails.author,\n      user: videoDetails ? videoDetails.ownerProfileUrl.split('/').slice(-1)[0] : null,\n      channel_url: `https://www.youtube.com/channel/${id}`,\n      external_channel_url: videoDetails ? `https://www.youtube.com/channel/${videoDetails.externalChannelId}` : '',\n      user_url: videoDetails ? new URL(videoDetails.ownerProfileUrl, BASE_URL).toString() : '',\n      thumbnails,\n      verified,\n      subscriber_count: subscriberCount,\n    };\n    if (thumbnails.length) {\n      utils.deprecate(author, 'avatar', author.thumbnails[0].url, 'author.avatar', 'author.thumbnails[0].url');\n    }\n    return author;\n  } catch (err) {\n    return {};\n  }\n};\n\nconst parseRelatedVideo = (details, rvsParams) => {\n  if (!details) return;\n  try {\n    let viewCount = getText(details.viewCountText);\n    let shortViewCount = getText(details.shortViewCountText);\n    let rvsDetails = rvsParams.find(elem => elem.id === details.videoId);\n    if (!/^\\d/.test(shortViewCount)) {\n      shortViewCount = (rvsDetails && rvsDetails.short_view_count_text) || '';\n    }\n    viewCount = (/^\\d/.test(viewCount) ? viewCount : shortViewCount).split(' ')[0];\n    let browseEndpoint = details.shortBylineText.runs[0].navigationEndpoint.browseEndpoint;\n    let channelId = browseEndpoint.browseId;\n    let name = getText(details.shortBylineText);\n    let user = (browseEndpoint.canonicalBaseUrl || '').split('/').slice(-1)[0];\n    let video = {\n      id: details.videoId,\n      title: getText(details.title),\n      published: getText(details.publishedTimeText),\n      author: {\n        id: channelId,\n        name,\n        user,\n        channel_url: `https://www.youtube.com/channel/${channelId}`,\n        user_url: `https://www.youtube.com/user/${user}`,\n        thumbnails: details.channelThumbnail.thumbnails.map(thumbnail => {\n          thumbnail.url = new URL(thumbnail.url, BASE_URL).toString();\n          return thumbnail;\n        }),\n        verified: isVerified(details.ownerBadges),\n\n        [Symbol.toPrimitive]() {\n          console.warn(`\\`relatedVideo.author\\` will be removed in a near future release, ` +\n            `use \\`relatedVideo.author.name\\` instead.`);\n          return video.author.name;\n        },\n\n      },\n      short_view_count_text: shortViewCount.split(' ')[0],\n      view_count: viewCount.replace(/,/g, ''),\n      length_seconds: details.lengthText ?\n        Math.floor(parseTimestamp(getText(details.lengthText)) / 1000) :\n        rvsParams && `${rvsParams.length_seconds}`,\n      thumbnails: details.thumbnail.thumbnails,\n      richThumbnails:\n        details.richThumbnail ?\n          details.richThumbnail.movingThumbnailRenderer.movingThumbnailDetails.thumbnails : [],\n      isLive: !!(details.badges && details.badges.find(b => b.metadataBadgeRenderer.label === 'LIVE NOW')),\n    };\n\n    utils.deprecate(video, 'author_thumbnail', video.author.thumbnails[0].url,\n      'relatedVideo.author_thumbnail', 'relatedVideo.author.thumbnails[0].url');\n    utils.deprecate(video, 'ucid', video.author.id, 'relatedVideo.ucid', 'relatedVideo.author.id');\n    utils.deprecate(video, 'video_thumbnail', video.thumbnails[0].url,\n      'relatedVideo.video_thumbnail', 'relatedVideo.thumbnails[0].url');\n    return video;\n  } catch (err) {\n    // Skip.\n  }\n};\n\n/**\n * Get related videos.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getRelatedVideos = info => {\n  let rvsParams = [], secondaryResults = [];\n  try {\n    rvsParams = info.response.webWatchNextResponseExtensionData.relatedVideoArgs.split(',').map(e => qs.parse(e));\n  } catch (err) {\n    // Do nothing.\n  }\n  try {\n    secondaryResults = info.response.contents.twoColumnWatchNextResults.secondaryResults.secondaryResults.results;\n  } catch (err) {\n    return [];\n  }\n  let videos = [];\n  for (let result of secondaryResults || []) {\n    let details = result.compactVideoRenderer;\n    if (details) {\n      let video = parseRelatedVideo(details, rvsParams);\n      if (video) videos.push(video);\n    } else {\n      let autoplay = result.compactAutoplayRenderer || result.itemSectionRenderer;\n      if (!autoplay || !Array.isArray(autoplay.contents)) continue;\n      for (let content of autoplay.contents) {\n        let video = parseRelatedVideo(content.compactVideoRenderer, rvsParams);\n        if (video) videos.push(video);\n      }\n    }\n  }\n  return videos;\n};\n\n/**\n * Get like count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getLikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let like = buttons.find(b => b.toggleButtonRenderer &&\n      b.toggleButtonRenderer.defaultIcon.iconType === 'LIKE');\n    return parseInt(like.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Get dislike count.\n *\n * @param {Object} info\n * @returns {number}\n */\nexports.getDislikes = info => {\n  try {\n    let contents = info.response.contents.twoColumnWatchNextResults.results.results.contents;\n    let video = contents.find(r => r.videoPrimaryInfoRenderer);\n    let buttons = video.videoPrimaryInfoRenderer.videoActions.menuRenderer.topLevelButtons;\n    let dislike = buttons.find(b => b.toggleButtonRenderer &&\n      b.toggleButtonRenderer.defaultIcon.iconType === 'DISLIKE');\n    return parseInt(dislike.toggleButtonRenderer.defaultText.accessibility.accessibilityData.label.replace(/\\D+/g, ''));\n  } catch (err) {\n    return null;\n  }\n};\n\n/**\n * Cleans up a few fields on `videoDetails`.\n *\n * @param {Object} videoDetails\n * @param {Object} info\n * @returns {Object}\n */\nexports.cleanVideoDetails = (videoDetails, info) => {\n  videoDetails.thumbnails = videoDetails.thumbnail.thumbnails;\n  delete videoDetails.thumbnail;\n  utils.deprecate(videoDetails, 'thumbnail', { thumbnails: videoDetails.thumbnails },\n    'videoDetails.thumbnail.thumbnails', 'videoDetails.thumbnails');\n  videoDetails.description = videoDetails.shortDescription || getText(videoDetails.description);\n  delete videoDetails.shortDescription;\n  utils.deprecate(videoDetails, 'shortDescription', videoDetails.description,\n    'videoDetails.shortDescription', 'videoDetails.description');\n\n  // Use more reliable `lengthSeconds` from `playerMicroformatRenderer`.\n  videoDetails.lengthSeconds =\n    (info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer.lengthSeconds) ||\n    info.player_response.videoDetails.lengthSeconds;\n  return videoDetails;\n};\n\n/**\n * Get storyboards info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getStoryboards = info => {\n  const parts = info.player_response.storyboards &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer.spec &&\n    info.player_response.storyboards.playerStoryboardSpecRenderer.spec.split('|');\n\n  if (!parts) return [];\n\n  const url = new URL(parts.shift());\n\n  return parts.map((part, i) => {\n    let [\n      thumbnailWidth,\n      thumbnailHeight,\n      thumbnailCount,\n      columns,\n      rows,\n      interval,\n      nameReplacement,\n      sigh,\n    ] = part.split('#');\n\n    url.searchParams.set('sigh', sigh);\n\n    thumbnailCount = parseInt(thumbnailCount, 10);\n    columns = parseInt(columns, 10);\n    rows = parseInt(rows, 10);\n\n    const storyboardCount = Math.ceil(thumbnailCount / (columns * rows));\n\n    return {\n      templateUrl: url.toString().replace('$L', i).replace('$N', nameReplacement),\n      thumbnailWidth: parseInt(thumbnailWidth, 10),\n      thumbnailHeight: parseInt(thumbnailHeight, 10),\n      thumbnailCount,\n      interval: parseInt(interval, 10),\n      columns,\n      rows,\n      storyboardCount,\n    };\n  });\n};\n\n/**\n * Get chapters info.\n *\n * @param {Object} info\n * @returns {Array.<Object>}\n */\nexports.getChapters = info => {\n  const playerOverlayRenderer = info.response &&\n    info.response.playerOverlays &&\n    info.response.playerOverlays.playerOverlayRenderer;\n  const playerBar = playerOverlayRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer &&\n    playerOverlayRenderer.decoratedPlayerBarRenderer.decoratedPlayerBarRenderer.playerBar;\n  const markersMap = playerBar &&\n    playerBar.multiMarkersPlayerBarRenderer &&\n    playerBar.multiMarkersPlayerBarRenderer.markersMap;\n  const marker = Array.isArray(markersMap) && markersMap.find(m => m.value && Array.isArray(m.value.chapters));\n  if (!marker) return [];\n  const chapters = marker.value.chapters;\n\n  return chapters.map(chapter => ({\n    title: getText(chapter.chapterRenderer.title),\n    start_time: chapter.chapterRenderer.timeRangeStartMillis / 1000,\n  }));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9pbmZvLWV4dHJhcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0IsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxpRUFBWTs7O0FBRy9DO0FBQ0E7QUFDQSxVQUFVLGtEQUFrRDtBQUM1RDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxHQUFHO0FBQ3pELDhFQUE4RSwrQkFBK0I7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxVQUFVO0FBQ2xFLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy95dGRsLWNvcmUvbGliL2luZm8tZXh0cmFzLmpzPzYwYWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5jb25zdCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCB7IHBhcnNlVGltZXN0YW1wIH0gPSByZXF1aXJlKCdtM3U4c3RyZWFtJyk7XG5cblxuY29uc3QgQkFTRV9VUkwgPSAnaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0nO1xuY29uc3QgVElUTEVfVE9fQ0FURUdPUlkgPSB7XG4gIHNvbmc6IHsgbmFtZTogJ011c2ljJywgdXJsOiAnaHR0cHM6Ly9tdXNpYy55b3V0dWJlLmNvbS8nIH0sXG59O1xuXG5jb25zdCBnZXRUZXh0ID0gb2JqID0+IG9iaiA/IG9iai5ydW5zID8gb2JqLnJ1bnNbMF0udGV4dCA6IG9iai5zaW1wbGVUZXh0IDogbnVsbDtcblxuXG4vKipcbiAqIEdldCB2aWRlbyBtZWRpYS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5nZXRNZWRpYSA9IGluZm8gPT4ge1xuICBsZXQgbWVkaWEgPSB7fTtcbiAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgdHJ5IHtcbiAgICByZXN1bHRzID0gaW5mby5yZXNwb25zZS5jb250ZW50cy50d29Db2x1bW5XYXRjaE5leHRSZXN1bHRzLnJlc3VsdHMucmVzdWx0cy5jb250ZW50cztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRG8gbm90aGluZ1xuICB9XG5cbiAgbGV0IHJlc3VsdCA9IHJlc3VsdHMuZmluZCh2ID0+IHYudmlkZW9TZWNvbmRhcnlJbmZvUmVuZGVyZXIpO1xuICBpZiAoIXJlc3VsdCkgeyByZXR1cm4ge307IH1cblxuICB0cnkge1xuICAgIGxldCBtZXRhZGF0YVJvd3MgPVxuICAgICAgKHJlc3VsdC5tZXRhZGF0YVJvd0NvbnRhaW5lciB8fCByZXN1bHQudmlkZW9TZWNvbmRhcnlJbmZvUmVuZGVyZXIubWV0YWRhdGFSb3dDb250YWluZXIpXG4gICAgICAgIC5tZXRhZGF0YVJvd0NvbnRhaW5lclJlbmRlcmVyLnJvd3M7XG4gICAgZm9yIChsZXQgcm93IG9mIG1ldGFkYXRhUm93cykge1xuICAgICAgaWYgKHJvdy5tZXRhZGF0YVJvd1JlbmRlcmVyKSB7XG4gICAgICAgIGxldCB0aXRsZSA9IGdldFRleHQocm93Lm1ldGFkYXRhUm93UmVuZGVyZXIudGl0bGUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGxldCBjb250ZW50cyA9IHJvdy5tZXRhZGF0YVJvd1JlbmRlcmVyLmNvbnRlbnRzWzBdO1xuICAgICAgICBtZWRpYVt0aXRsZV0gPSBnZXRUZXh0KGNvbnRlbnRzKTtcbiAgICAgICAgbGV0IHJ1bnMgPSBjb250ZW50cy5ydW5zO1xuICAgICAgICBpZiAocnVucyAmJiBydW5zWzBdLm5hdmlnYXRpb25FbmRwb2ludCkge1xuICAgICAgICAgIG1lZGlhW2Ake3RpdGxlfV91cmxgXSA9IG5ldyBVUkwoXG4gICAgICAgICAgICBydW5zWzBdLm5hdmlnYXRpb25FbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpdGxlIGluIFRJVExFX1RPX0NBVEVHT1JZKSB7XG4gICAgICAgICAgbWVkaWEuY2F0ZWdvcnkgPSBUSVRMRV9UT19DQVRFR09SWVt0aXRsZV0ubmFtZTtcbiAgICAgICAgICBtZWRpYS5jYXRlZ29yeV91cmwgPSBUSVRMRV9UT19DQVRFR09SWVt0aXRsZV0udXJsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJvdy5yaWNoTWV0YWRhdGFSb3dSZW5kZXJlcikge1xuICAgICAgICBsZXQgY29udGVudHMgPSByb3cucmljaE1ldGFkYXRhUm93UmVuZGVyZXIuY29udGVudHM7XG4gICAgICAgIGxldCBib3hBcnQgPSBjb250ZW50c1xuICAgICAgICAgIC5maWx0ZXIobWV0YSA9PiBtZXRhLnJpY2hNZXRhZGF0YVJlbmRlcmVyLnN0eWxlID09PSAnUklDSF9NRVRBREFUQV9SRU5ERVJFUl9TVFlMRV9CT1hfQVJUJyk7XG4gICAgICAgIGZvciAobGV0IHsgcmljaE1ldGFkYXRhUmVuZGVyZXIgfSBvZiBib3hBcnQpIHtcbiAgICAgICAgICBsZXQgbWV0YSA9IHJpY2hNZXRhZGF0YVJlbmRlcmVyO1xuICAgICAgICAgIG1lZGlhLnllYXIgPSBnZXRUZXh0KG1ldGEuc3VidGl0bGUpO1xuICAgICAgICAgIGxldCB0eXBlID0gZ2V0VGV4dChtZXRhLmNhbGxUb0FjdGlvbikuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgICBtZWRpYVt0eXBlXSA9IGdldFRleHQobWV0YS50aXRsZSk7XG4gICAgICAgICAgbWVkaWFbYCR7dHlwZX1fdXJsYF0gPSBuZXcgVVJMKFxuICAgICAgICAgICAgbWV0YS5lbmRwb2ludC5jb21tYW5kTWV0YWRhdGEud2ViQ29tbWFuZE1ldGFkYXRhLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgbWVkaWEudGh1bWJuYWlscyA9IG1ldGEudGh1bWJuYWlsLnRodW1ibmFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvcGljID0gY29udGVudHNcbiAgICAgICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5yaWNoTWV0YWRhdGFSZW5kZXJlci5zdHlsZSA9PT0gJ1JJQ0hfTUVUQURBVEFfUkVOREVSRVJfU1RZTEVfVE9QSUMnKTtcbiAgICAgICAgZm9yIChsZXQgeyByaWNoTWV0YWRhdGFSZW5kZXJlciB9IG9mIHRvcGljKSB7XG4gICAgICAgICAgbGV0IG1ldGEgPSByaWNoTWV0YWRhdGFSZW5kZXJlcjtcbiAgICAgICAgICBtZWRpYS5jYXRlZ29yeSA9IGdldFRleHQobWV0YS50aXRsZSk7XG4gICAgICAgICAgbWVkaWEuY2F0ZWdvcnlfdXJsID0gbmV3IFVSTChcbiAgICAgICAgICAgIG1ldGEuZW5kcG9pbnQuY29tbWFuZE1ldGFkYXRhLndlYkNvbW1hbmRNZXRhZGF0YS51cmwsIEJBU0VfVVJMKS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEbyBub3RoaW5nLlxuICB9XG5cbiAgcmV0dXJuIG1lZGlhO1xufTtcblxuXG5jb25zdCBpc1ZlcmlmaWVkID0gYmFkZ2VzID0+ICEhKGJhZGdlcyAmJiBiYWRnZXMuZmluZChiID0+IGIubWV0YWRhdGFCYWRnZVJlbmRlcmVyLnRvb2x0aXAgPT09ICdWZXJpZmllZCcpKTtcblxuXG4vKipcbiAqIEdldCB2aWRlbyBhdXRob3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluZm9cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZ2V0QXV0aG9yID0gaW5mbyA9PiB7XG4gIGxldCBjaGFubmVsSWQsIHRodW1ibmFpbHMgPSBbXSwgc3Vic2NyaWJlckNvdW50LCB2ZXJpZmllZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGxldCByZXN1bHRzID0gaW5mby5yZXNwb25zZS5jb250ZW50cy50d29Db2x1bW5XYXRjaE5leHRSZXN1bHRzLnJlc3VsdHMucmVzdWx0cy5jb250ZW50cztcbiAgICBsZXQgdiA9IHJlc3VsdHMuZmluZCh2MiA9PlxuICAgICAgdjIudmlkZW9TZWNvbmRhcnlJbmZvUmVuZGVyZXIgJiZcbiAgICAgIHYyLnZpZGVvU2Vjb25kYXJ5SW5mb1JlbmRlcmVyLm93bmVyICYmXG4gICAgICB2Mi52aWRlb1NlY29uZGFyeUluZm9SZW5kZXJlci5vd25lci52aWRlb093bmVyUmVuZGVyZXIpO1xuICAgIGxldCB2aWRlb093bmVyUmVuZGVyZXIgPSB2LnZpZGVvU2Vjb25kYXJ5SW5mb1JlbmRlcmVyLm93bmVyLnZpZGVvT3duZXJSZW5kZXJlcjtcbiAgICBjaGFubmVsSWQgPSB2aWRlb093bmVyUmVuZGVyZXIubmF2aWdhdGlvbkVuZHBvaW50LmJyb3dzZUVuZHBvaW50LmJyb3dzZUlkO1xuICAgIHRodW1ibmFpbHMgPSB2aWRlb093bmVyUmVuZGVyZXIudGh1bWJuYWlsLnRodW1ibmFpbHMubWFwKHRodW1ibmFpbCA9PiB7XG4gICAgICB0aHVtYm5haWwudXJsID0gbmV3IFVSTCh0aHVtYm5haWwudXJsLCBCQVNFX1VSTCkudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiB0aHVtYm5haWw7XG4gICAgfSk7XG4gICAgc3Vic2NyaWJlckNvdW50ID0gdXRpbHMucGFyc2VBYmJyZXZpYXRlZE51bWJlcihnZXRUZXh0KHZpZGVvT3duZXJSZW5kZXJlci5zdWJzY3JpYmVyQ291bnRUZXh0KSk7XG4gICAgdmVyaWZpZWQgPSBpc1ZlcmlmaWVkKHZpZGVvT3duZXJSZW5kZXJlci5iYWRnZXMpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEbyBub3RoaW5nLlxuICB9XG4gIHRyeSB7XG4gICAgbGV0IHZpZGVvRGV0YWlscyA9IGluZm8ucGxheWVyX3Jlc3BvbnNlLm1pY3JvZm9ybWF0ICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLm1pY3JvZm9ybWF0LnBsYXllck1pY3JvZm9ybWF0UmVuZGVyZXI7XG4gICAgbGV0IGlkID0gKHZpZGVvRGV0YWlscyAmJiB2aWRlb0RldGFpbHMuY2hhbm5lbElkKSB8fCBjaGFubmVsSWQgfHwgaW5mby5wbGF5ZXJfcmVzcG9uc2UudmlkZW9EZXRhaWxzLmNoYW5uZWxJZDtcbiAgICBsZXQgYXV0aG9yID0ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbmFtZTogdmlkZW9EZXRhaWxzID8gdmlkZW9EZXRhaWxzLm93bmVyQ2hhbm5lbE5hbWUgOiBpbmZvLnBsYXllcl9yZXNwb25zZS52aWRlb0RldGFpbHMuYXV0aG9yLFxuICAgICAgdXNlcjogdmlkZW9EZXRhaWxzID8gdmlkZW9EZXRhaWxzLm93bmVyUHJvZmlsZVVybC5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSA6IG51bGwsXG4gICAgICBjaGFubmVsX3VybDogYGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2NoYW5uZWwvJHtpZH1gLFxuICAgICAgZXh0ZXJuYWxfY2hhbm5lbF91cmw6IHZpZGVvRGV0YWlscyA/IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsLyR7dmlkZW9EZXRhaWxzLmV4dGVybmFsQ2hhbm5lbElkfWAgOiAnJyxcbiAgICAgIHVzZXJfdXJsOiB2aWRlb0RldGFpbHMgPyBuZXcgVVJMKHZpZGVvRGV0YWlscy5vd25lclByb2ZpbGVVcmwsIEJBU0VfVVJMKS50b1N0cmluZygpIDogJycsXG4gICAgICB0aHVtYm5haWxzLFxuICAgICAgdmVyaWZpZWQsXG4gICAgICBzdWJzY3JpYmVyX2NvdW50OiBzdWJzY3JpYmVyQ291bnQsXG4gICAgfTtcbiAgICBpZiAodGh1bWJuYWlscy5sZW5ndGgpIHtcbiAgICAgIHV0aWxzLmRlcHJlY2F0ZShhdXRob3IsICdhdmF0YXInLCBhdXRob3IudGh1bWJuYWlsc1swXS51cmwsICdhdXRob3IuYXZhdGFyJywgJ2F1dGhvci50aHVtYm5haWxzWzBdLnVybCcpO1xuICAgIH1cbiAgICByZXR1cm4gYXV0aG9yO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbn07XG5cbmNvbnN0IHBhcnNlUmVsYXRlZFZpZGVvID0gKGRldGFpbHMsIHJ2c1BhcmFtcykgPT4ge1xuICBpZiAoIWRldGFpbHMpIHJldHVybjtcbiAgdHJ5IHtcbiAgICBsZXQgdmlld0NvdW50ID0gZ2V0VGV4dChkZXRhaWxzLnZpZXdDb3VudFRleHQpO1xuICAgIGxldCBzaG9ydFZpZXdDb3VudCA9IGdldFRleHQoZGV0YWlscy5zaG9ydFZpZXdDb3VudFRleHQpO1xuICAgIGxldCBydnNEZXRhaWxzID0gcnZzUGFyYW1zLmZpbmQoZWxlbSA9PiBlbGVtLmlkID09PSBkZXRhaWxzLnZpZGVvSWQpO1xuICAgIGlmICghL15cXGQvLnRlc3Qoc2hvcnRWaWV3Q291bnQpKSB7XG4gICAgICBzaG9ydFZpZXdDb3VudCA9IChydnNEZXRhaWxzICYmIHJ2c0RldGFpbHMuc2hvcnRfdmlld19jb3VudF90ZXh0KSB8fCAnJztcbiAgICB9XG4gICAgdmlld0NvdW50ID0gKC9eXFxkLy50ZXN0KHZpZXdDb3VudCkgPyB2aWV3Q291bnQgOiBzaG9ydFZpZXdDb3VudCkuc3BsaXQoJyAnKVswXTtcbiAgICBsZXQgYnJvd3NlRW5kcG9pbnQgPSBkZXRhaWxzLnNob3J0QnlsaW5lVGV4dC5ydW5zWzBdLm5hdmlnYXRpb25FbmRwb2ludC5icm93c2VFbmRwb2ludDtcbiAgICBsZXQgY2hhbm5lbElkID0gYnJvd3NlRW5kcG9pbnQuYnJvd3NlSWQ7XG4gICAgbGV0IG5hbWUgPSBnZXRUZXh0KGRldGFpbHMuc2hvcnRCeWxpbmVUZXh0KTtcbiAgICBsZXQgdXNlciA9IChicm93c2VFbmRwb2ludC5jYW5vbmljYWxCYXNlVXJsIHx8ICcnKS5zcGxpdCgnLycpLnNsaWNlKC0xKVswXTtcbiAgICBsZXQgdmlkZW8gPSB7XG4gICAgICBpZDogZGV0YWlscy52aWRlb0lkLFxuICAgICAgdGl0bGU6IGdldFRleHQoZGV0YWlscy50aXRsZSksXG4gICAgICBwdWJsaXNoZWQ6IGdldFRleHQoZGV0YWlscy5wdWJsaXNoZWRUaW1lVGV4dCksXG4gICAgICBhdXRob3I6IHtcbiAgICAgICAgaWQ6IGNoYW5uZWxJZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdXNlcixcbiAgICAgICAgY2hhbm5lbF91cmw6IGBodHRwczovL3d3dy55b3V0dWJlLmNvbS9jaGFubmVsLyR7Y2hhbm5lbElkfWAsXG4gICAgICAgIHVzZXJfdXJsOiBgaHR0cHM6Ly93d3cueW91dHViZS5jb20vdXNlci8ke3VzZXJ9YCxcbiAgICAgICAgdGh1bWJuYWlsczogZGV0YWlscy5jaGFubmVsVGh1bWJuYWlsLnRodW1ibmFpbHMubWFwKHRodW1ibmFpbCA9PiB7XG4gICAgICAgICAgdGh1bWJuYWlsLnVybCA9IG5ldyBVUkwodGh1bWJuYWlsLnVybCwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIHRodW1ibmFpbDtcbiAgICAgICAgfSksXG4gICAgICAgIHZlcmlmaWVkOiBpc1ZlcmlmaWVkKGRldGFpbHMub3duZXJCYWRnZXMpLFxuXG4gICAgICAgIFtTeW1ib2wudG9QcmltaXRpdmVdKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgXFxgcmVsYXRlZFZpZGVvLmF1dGhvclxcYCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBuZWFyIGZ1dHVyZSByZWxlYXNlLCBgICtcbiAgICAgICAgICAgIGB1c2UgXFxgcmVsYXRlZFZpZGVvLmF1dGhvci5uYW1lXFxgIGluc3RlYWQuYCk7XG4gICAgICAgICAgcmV0dXJuIHZpZGVvLmF1dGhvci5uYW1lO1xuICAgICAgICB9LFxuXG4gICAgICB9LFxuICAgICAgc2hvcnRfdmlld19jb3VudF90ZXh0OiBzaG9ydFZpZXdDb3VudC5zcGxpdCgnICcpWzBdLFxuICAgICAgdmlld19jb3VudDogdmlld0NvdW50LnJlcGxhY2UoLywvZywgJycpLFxuICAgICAgbGVuZ3RoX3NlY29uZHM6IGRldGFpbHMubGVuZ3RoVGV4dCA/XG4gICAgICAgIE1hdGguZmxvb3IocGFyc2VUaW1lc3RhbXAoZ2V0VGV4dChkZXRhaWxzLmxlbmd0aFRleHQpKSAvIDEwMDApIDpcbiAgICAgICAgcnZzUGFyYW1zICYmIGAke3J2c1BhcmFtcy5sZW5ndGhfc2Vjb25kc31gLFxuICAgICAgdGh1bWJuYWlsczogZGV0YWlscy50aHVtYm5haWwudGh1bWJuYWlscyxcbiAgICAgIHJpY2hUaHVtYm5haWxzOlxuICAgICAgICBkZXRhaWxzLnJpY2hUaHVtYm5haWwgP1xuICAgICAgICAgIGRldGFpbHMucmljaFRodW1ibmFpbC5tb3ZpbmdUaHVtYm5haWxSZW5kZXJlci5tb3ZpbmdUaHVtYm5haWxEZXRhaWxzLnRodW1ibmFpbHMgOiBbXSxcbiAgICAgIGlzTGl2ZTogISEoZGV0YWlscy5iYWRnZXMgJiYgZGV0YWlscy5iYWRnZXMuZmluZChiID0+IGIubWV0YWRhdGFCYWRnZVJlbmRlcmVyLmxhYmVsID09PSAnTElWRSBOT1cnKSksXG4gICAgfTtcblxuICAgIHV0aWxzLmRlcHJlY2F0ZSh2aWRlbywgJ2F1dGhvcl90aHVtYm5haWwnLCB2aWRlby5hdXRob3IudGh1bWJuYWlsc1swXS51cmwsXG4gICAgICAncmVsYXRlZFZpZGVvLmF1dGhvcl90aHVtYm5haWwnLCAncmVsYXRlZFZpZGVvLmF1dGhvci50aHVtYm5haWxzWzBdLnVybCcpO1xuICAgIHV0aWxzLmRlcHJlY2F0ZSh2aWRlbywgJ3VjaWQnLCB2aWRlby5hdXRob3IuaWQsICdyZWxhdGVkVmlkZW8udWNpZCcsICdyZWxhdGVkVmlkZW8uYXV0aG9yLmlkJyk7XG4gICAgdXRpbHMuZGVwcmVjYXRlKHZpZGVvLCAndmlkZW9fdGh1bWJuYWlsJywgdmlkZW8udGh1bWJuYWlsc1swXS51cmwsXG4gICAgICAncmVsYXRlZFZpZGVvLnZpZGVvX3RodW1ibmFpbCcsICdyZWxhdGVkVmlkZW8udGh1bWJuYWlsc1swXS51cmwnKTtcbiAgICByZXR1cm4gdmlkZW87XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFNraXAuXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHJlbGF0ZWQgdmlkZW9zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmV4cG9ydHMuZ2V0UmVsYXRlZFZpZGVvcyA9IGluZm8gPT4ge1xuICBsZXQgcnZzUGFyYW1zID0gW10sIHNlY29uZGFyeVJlc3VsdHMgPSBbXTtcbiAgdHJ5IHtcbiAgICBydnNQYXJhbXMgPSBpbmZvLnJlc3BvbnNlLndlYldhdGNoTmV4dFJlc3BvbnNlRXh0ZW5zaW9uRGF0YS5yZWxhdGVkVmlkZW9BcmdzLnNwbGl0KCcsJykubWFwKGUgPT4gcXMucGFyc2UoZSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEbyBub3RoaW5nLlxuICB9XG4gIHRyeSB7XG4gICAgc2Vjb25kYXJ5UmVzdWx0cyA9IGluZm8ucmVzcG9uc2UuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cy5zZWNvbmRhcnlSZXN1bHRzLnNlY29uZGFyeVJlc3VsdHMucmVzdWx0cztcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGxldCB2aWRlb3MgPSBbXTtcbiAgZm9yIChsZXQgcmVzdWx0IG9mIHNlY29uZGFyeVJlc3VsdHMgfHwgW10pIHtcbiAgICBsZXQgZGV0YWlscyA9IHJlc3VsdC5jb21wYWN0VmlkZW9SZW5kZXJlcjtcbiAgICBpZiAoZGV0YWlscykge1xuICAgICAgbGV0IHZpZGVvID0gcGFyc2VSZWxhdGVkVmlkZW8oZGV0YWlscywgcnZzUGFyYW1zKTtcbiAgICAgIGlmICh2aWRlbykgdmlkZW9zLnB1c2godmlkZW8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgYXV0b3BsYXkgPSByZXN1bHQuY29tcGFjdEF1dG9wbGF5UmVuZGVyZXIgfHwgcmVzdWx0Lml0ZW1TZWN0aW9uUmVuZGVyZXI7XG4gICAgICBpZiAoIWF1dG9wbGF5IHx8ICFBcnJheS5pc0FycmF5KGF1dG9wbGF5LmNvbnRlbnRzKSkgY29udGludWU7XG4gICAgICBmb3IgKGxldCBjb250ZW50IG9mIGF1dG9wbGF5LmNvbnRlbnRzKSB7XG4gICAgICAgIGxldCB2aWRlbyA9IHBhcnNlUmVsYXRlZFZpZGVvKGNvbnRlbnQuY29tcGFjdFZpZGVvUmVuZGVyZXIsIHJ2c1BhcmFtcyk7XG4gICAgICAgIGlmICh2aWRlbykgdmlkZW9zLnB1c2godmlkZW8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmlkZW9zO1xufTtcblxuLyoqXG4gKiBHZXQgbGlrZSBjb3VudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRMaWtlcyA9IGluZm8gPT4ge1xuICB0cnkge1xuICAgIGxldCBjb250ZW50cyA9IGluZm8ucmVzcG9uc2UuY29udGVudHMudHdvQ29sdW1uV2F0Y2hOZXh0UmVzdWx0cy5yZXN1bHRzLnJlc3VsdHMuY29udGVudHM7XG4gICAgbGV0IHZpZGVvID0gY29udGVudHMuZmluZChyID0+IHIudmlkZW9QcmltYXJ5SW5mb1JlbmRlcmVyKTtcbiAgICBsZXQgYnV0dG9ucyA9IHZpZGVvLnZpZGVvUHJpbWFyeUluZm9SZW5kZXJlci52aWRlb0FjdGlvbnMubWVudVJlbmRlcmVyLnRvcExldmVsQnV0dG9ucztcbiAgICBsZXQgbGlrZSA9IGJ1dHRvbnMuZmluZChiID0+IGIudG9nZ2xlQnV0dG9uUmVuZGVyZXIgJiZcbiAgICAgIGIudG9nZ2xlQnV0dG9uUmVuZGVyZXIuZGVmYXVsdEljb24uaWNvblR5cGUgPT09ICdMSUtFJyk7XG4gICAgcmV0dXJuIHBhcnNlSW50KGxpa2UudG9nZ2xlQnV0dG9uUmVuZGVyZXIuZGVmYXVsdFRleHQuYWNjZXNzaWJpbGl0eS5hY2Nlc3NpYmlsaXR5RGF0YS5sYWJlbC5yZXBsYWNlKC9cXEQrL2csICcnKSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBkaXNsaWtlIGNvdW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5leHBvcnRzLmdldERpc2xpa2VzID0gaW5mbyA9PiB7XG4gIHRyeSB7XG4gICAgbGV0IGNvbnRlbnRzID0gaW5mby5yZXNwb25zZS5jb250ZW50cy50d29Db2x1bW5XYXRjaE5leHRSZXN1bHRzLnJlc3VsdHMucmVzdWx0cy5jb250ZW50cztcbiAgICBsZXQgdmlkZW8gPSBjb250ZW50cy5maW5kKHIgPT4gci52aWRlb1ByaW1hcnlJbmZvUmVuZGVyZXIpO1xuICAgIGxldCBidXR0b25zID0gdmlkZW8udmlkZW9QcmltYXJ5SW5mb1JlbmRlcmVyLnZpZGVvQWN0aW9ucy5tZW51UmVuZGVyZXIudG9wTGV2ZWxCdXR0b25zO1xuICAgIGxldCBkaXNsaWtlID0gYnV0dG9ucy5maW5kKGIgPT4gYi50b2dnbGVCdXR0b25SZW5kZXJlciAmJlxuICAgICAgYi50b2dnbGVCdXR0b25SZW5kZXJlci5kZWZhdWx0SWNvbi5pY29uVHlwZSA9PT0gJ0RJU0xJS0UnKTtcbiAgICByZXR1cm4gcGFyc2VJbnQoZGlzbGlrZS50b2dnbGVCdXR0b25SZW5kZXJlci5kZWZhdWx0VGV4dC5hY2Nlc3NpYmlsaXR5LmFjY2Vzc2liaWxpdHlEYXRhLmxhYmVsLnJlcGxhY2UoL1xcRCsvZywgJycpKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGEgZmV3IGZpZWxkcyBvbiBgdmlkZW9EZXRhaWxzYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmlkZW9EZXRhaWxzXG4gKiBAcGFyYW0ge09iamVjdH0gaW5mb1xuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jbGVhblZpZGVvRGV0YWlscyA9ICh2aWRlb0RldGFpbHMsIGluZm8pID0+IHtcbiAgdmlkZW9EZXRhaWxzLnRodW1ibmFpbHMgPSB2aWRlb0RldGFpbHMudGh1bWJuYWlsLnRodW1ibmFpbHM7XG4gIGRlbGV0ZSB2aWRlb0RldGFpbHMudGh1bWJuYWlsO1xuICB1dGlscy5kZXByZWNhdGUodmlkZW9EZXRhaWxzLCAndGh1bWJuYWlsJywgeyB0aHVtYm5haWxzOiB2aWRlb0RldGFpbHMudGh1bWJuYWlscyB9LFxuICAgICd2aWRlb0RldGFpbHMudGh1bWJuYWlsLnRodW1ibmFpbHMnLCAndmlkZW9EZXRhaWxzLnRodW1ibmFpbHMnKTtcbiAgdmlkZW9EZXRhaWxzLmRlc2NyaXB0aW9uID0gdmlkZW9EZXRhaWxzLnNob3J0RGVzY3JpcHRpb24gfHwgZ2V0VGV4dCh2aWRlb0RldGFpbHMuZGVzY3JpcHRpb24pO1xuICBkZWxldGUgdmlkZW9EZXRhaWxzLnNob3J0RGVzY3JpcHRpb247XG4gIHV0aWxzLmRlcHJlY2F0ZSh2aWRlb0RldGFpbHMsICdzaG9ydERlc2NyaXB0aW9uJywgdmlkZW9EZXRhaWxzLmRlc2NyaXB0aW9uLFxuICAgICd2aWRlb0RldGFpbHMuc2hvcnREZXNjcmlwdGlvbicsICd2aWRlb0RldGFpbHMuZGVzY3JpcHRpb24nKTtcblxuICAvLyBVc2UgbW9yZSByZWxpYWJsZSBgbGVuZ3RoU2Vjb25kc2AgZnJvbSBgcGxheWVyTWljcm9mb3JtYXRSZW5kZXJlcmAuXG4gIHZpZGVvRGV0YWlscy5sZW5ndGhTZWNvbmRzID1cbiAgICAoaW5mby5wbGF5ZXJfcmVzcG9uc2UubWljcm9mb3JtYXQgJiZcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZS5taWNyb2Zvcm1hdC5wbGF5ZXJNaWNyb2Zvcm1hdFJlbmRlcmVyLmxlbmd0aFNlY29uZHMpIHx8XG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UudmlkZW9EZXRhaWxzLmxlbmd0aFNlY29uZHM7XG4gIHJldHVybiB2aWRlb0RldGFpbHM7XG59O1xuXG4vKipcbiAqIEdldCBzdG9yeWJvYXJkcyBpbmZvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmV4cG9ydHMuZ2V0U3Rvcnlib2FyZHMgPSBpbmZvID0+IHtcbiAgY29uc3QgcGFydHMgPSBpbmZvLnBsYXllcl9yZXNwb25zZS5zdG9yeWJvYXJkcyAmJlxuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0b3J5Ym9hcmRzLnBsYXllclN0b3J5Ym9hcmRTcGVjUmVuZGVyZXIgJiZcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZS5zdG9yeWJvYXJkcy5wbGF5ZXJTdG9yeWJvYXJkU3BlY1JlbmRlcmVyLnNwZWMgJiZcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZS5zdG9yeWJvYXJkcy5wbGF5ZXJTdG9yeWJvYXJkU3BlY1JlbmRlcmVyLnNwZWMuc3BsaXQoJ3wnKTtcblxuICBpZiAoIXBhcnRzKSByZXR1cm4gW107XG5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChwYXJ0cy5zaGlmdCgpKTtcblxuICByZXR1cm4gcGFydHMubWFwKChwYXJ0LCBpKSA9PiB7XG4gICAgbGV0IFtcbiAgICAgIHRodW1ibmFpbFdpZHRoLFxuICAgICAgdGh1bWJuYWlsSGVpZ2h0LFxuICAgICAgdGh1bWJuYWlsQ291bnQsXG4gICAgICBjb2x1bW5zLFxuICAgICAgcm93cyxcbiAgICAgIGludGVydmFsLFxuICAgICAgbmFtZVJlcGxhY2VtZW50LFxuICAgICAgc2lnaCxcbiAgICBdID0gcGFydC5zcGxpdCgnIycpO1xuXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NpZ2gnLCBzaWdoKTtcblxuICAgIHRodW1ibmFpbENvdW50ID0gcGFyc2VJbnQodGh1bWJuYWlsQ291bnQsIDEwKTtcbiAgICBjb2x1bW5zID0gcGFyc2VJbnQoY29sdW1ucywgMTApO1xuICAgIHJvd3MgPSBwYXJzZUludChyb3dzLCAxMCk7XG5cbiAgICBjb25zdCBzdG9yeWJvYXJkQ291bnQgPSBNYXRoLmNlaWwodGh1bWJuYWlsQ291bnQgLyAoY29sdW1ucyAqIHJvd3MpKTtcblxuICAgIHJldHVybiB7XG4gICAgICB0ZW1wbGF0ZVVybDogdXJsLnRvU3RyaW5nKCkucmVwbGFjZSgnJEwnLCBpKS5yZXBsYWNlKCckTicsIG5hbWVSZXBsYWNlbWVudCksXG4gICAgICB0aHVtYm5haWxXaWR0aDogcGFyc2VJbnQodGh1bWJuYWlsV2lkdGgsIDEwKSxcbiAgICAgIHRodW1ibmFpbEhlaWdodDogcGFyc2VJbnQodGh1bWJuYWlsSGVpZ2h0LCAxMCksXG4gICAgICB0aHVtYm5haWxDb3VudCxcbiAgICAgIGludGVydmFsOiBwYXJzZUludChpbnRlcnZhbCwgMTApLFxuICAgICAgY29sdW1ucyxcbiAgICAgIHJvd3MsXG4gICAgICBzdG9yeWJvYXJkQ291bnQsXG4gICAgfTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldCBjaGFwdGVycyBpbmZvLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvXG4gKiBAcmV0dXJucyB7QXJyYXkuPE9iamVjdD59XG4gKi9cbmV4cG9ydHMuZ2V0Q2hhcHRlcnMgPSBpbmZvID0+IHtcbiAgY29uc3QgcGxheWVyT3ZlcmxheVJlbmRlcmVyID0gaW5mby5yZXNwb25zZSAmJlxuICAgIGluZm8ucmVzcG9uc2UucGxheWVyT3ZlcmxheXMgJiZcbiAgICBpbmZvLnJlc3BvbnNlLnBsYXllck92ZXJsYXlzLnBsYXllck92ZXJsYXlSZW5kZXJlcjtcbiAgY29uc3QgcGxheWVyQmFyID0gcGxheWVyT3ZlcmxheVJlbmRlcmVyICYmXG4gICAgcGxheWVyT3ZlcmxheVJlbmRlcmVyLmRlY29yYXRlZFBsYXllckJhclJlbmRlcmVyICYmXG4gICAgcGxheWVyT3ZlcmxheVJlbmRlcmVyLmRlY29yYXRlZFBsYXllckJhclJlbmRlcmVyLmRlY29yYXRlZFBsYXllckJhclJlbmRlcmVyICYmXG4gICAgcGxheWVyT3ZlcmxheVJlbmRlcmVyLmRlY29yYXRlZFBsYXllckJhclJlbmRlcmVyLmRlY29yYXRlZFBsYXllckJhclJlbmRlcmVyLnBsYXllckJhcjtcbiAgY29uc3QgbWFya2Vyc01hcCA9IHBsYXllckJhciAmJlxuICAgIHBsYXllckJhci5tdWx0aU1hcmtlcnNQbGF5ZXJCYXJSZW5kZXJlciAmJlxuICAgIHBsYXllckJhci5tdWx0aU1hcmtlcnNQbGF5ZXJCYXJSZW5kZXJlci5tYXJrZXJzTWFwO1xuICBjb25zdCBtYXJrZXIgPSBBcnJheS5pc0FycmF5KG1hcmtlcnNNYXApICYmIG1hcmtlcnNNYXAuZmluZChtID0+IG0udmFsdWUgJiYgQXJyYXkuaXNBcnJheShtLnZhbHVlLmNoYXB0ZXJzKSk7XG4gIGlmICghbWFya2VyKSByZXR1cm4gW107XG4gIGNvbnN0IGNoYXB0ZXJzID0gbWFya2VyLnZhbHVlLmNoYXB0ZXJzO1xuXG4gIHJldHVybiBjaGFwdGVycy5tYXAoY2hhcHRlciA9PiAoe1xuICAgIHRpdGxlOiBnZXRUZXh0KGNoYXB0ZXIuY2hhcHRlclJlbmRlcmVyLnRpdGxlKSxcbiAgICBzdGFydF90aW1lOiBjaGFwdGVyLmNoYXB0ZXJSZW5kZXJlci50aW1lUmFuZ2VTdGFydE1pbGxpcyAvIDEwMDAsXG4gIH0pKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/info-extras.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/info.js":
/*!********************************************!*\
  !*** ./node_modules/ytdl-core/lib/info.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst sax = __webpack_require__(/*! sax */ \"(rsc)/./node_modules/sax/lib/sax.js\");\nconst miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\n// Forces Node JS version of setTimeout for Electron based applications\nconst { setTimeout } = __webpack_require__(/*! timers */ \"timers\");\nconst formatUtils = __webpack_require__(/*! ./format-utils */ \"(rsc)/./node_modules/ytdl-core/lib/format-utils.js\");\nconst urlUtils = __webpack_require__(/*! ./url-utils */ \"(rsc)/./node_modules/ytdl-core/lib/url-utils.js\");\nconst extras = __webpack_require__(/*! ./info-extras */ \"(rsc)/./node_modules/ytdl-core/lib/info-extras.js\");\nconst sig = __webpack_require__(/*! ./sig */ \"(rsc)/./node_modules/ytdl-core/lib/sig.js\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/ytdl-core/lib/cache.js\");\n\n\nconst BASE_URL = 'https://www.youtube.com/watch?v=';\n\n\n// Cached for storing basic/full info.\nexports.cache = new Cache();\nexports.cookieCache = new Cache(1000 * 60 * 60 * 24);\nexports.watchPageCache = new Cache();\n// Cache for cver used in getVideoInfoPage\nlet cver = '2.20210622.10.00';\n\n\n// Special error class used to determine if an error is unrecoverable,\n// as in, ytdl-core should not try again to fetch the video metadata.\n// In this case, the video is usually unavailable in some way.\nclass UnrecoverableError extends Error {}\n\n\n// List of URLs that show up in `notice_url` for age restricted videos.\nconst AGE_RESTRICTED_URLS = [\n  'support.google.com/youtube/?p=age_restrictions',\n  'youtube.com/t/community_guidelines',\n];\n\n\n/**\n * Gets info from a video without getting additional formats.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n*/\nexports.getBasicInfo = async(id, options) => {\n  if (options.IPv6Block) {\n    options.requestOptions = Object.assign({}, options.requestOptions, {\n      family: 6,\n      localAddress: utils.getRandomIPv6(options.IPv6Block),\n    });\n  }\n  const retryOptions = Object.assign({}, miniget.defaultOptions, options.requestOptions);\n  options.requestOptions = Object.assign({}, options.requestOptions, {});\n  options.requestOptions.headers = Object.assign({},\n    {\n      // eslint-disable-next-line max-len\n      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36',\n    }, options.requestOptions.headers);\n  const validate = info => {\n    let playErr = utils.playError(info.player_response, ['ERROR'], UnrecoverableError);\n    let privateErr = privateVideoError(info.player_response);\n    if (playErr || privateErr) {\n      throw playErr || privateErr;\n    }\n    return info && info.player_response && (\n      info.player_response.streamingData || isRental(info.player_response) || isNotYetBroadcasted(info.player_response)\n    );\n  };\n  let info = await pipeline([id, options], validate, retryOptions, [\n    getWatchHTMLPage,\n    getWatchJSONPage,\n    getVideoInfoPage,\n  ]);\n\n  Object.assign(info, {\n    formats: parseFormats(info.player_response),\n    related_videos: extras.getRelatedVideos(info),\n  });\n\n  // Add additional properties to info.\n  const media = extras.getMedia(info);\n  const additional = {\n    author: extras.getAuthor(info),\n    media,\n    likes: extras.getLikes(info),\n    dislikes: extras.getDislikes(info),\n    age_restricted: !!(media && AGE_RESTRICTED_URLS.some(url =>\n      Object.values(media).some(v => typeof v === 'string' && v.includes(url)))\n    ),\n\n    // Give the standard link to the video.\n    video_url: BASE_URL + id,\n    storyboards: extras.getStoryboards(info),\n    chapters: extras.getChapters(info),\n  };\n\n  info.videoDetails = extras.cleanVideoDetails(Object.assign({},\n    info.player_response && info.player_response.microformat &&\n    info.player_response.microformat.playerMicroformatRenderer,\n    info.player_response && info.player_response.videoDetails, additional), info);\n\n  return info;\n};\n\nconst privateVideoError = player_response => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && playability.status === 'LOGIN_REQUIRED' && playability.messages &&\n    playability.messages.filter(m => /This is a private video/.test(m)).length) {\n    return new UnrecoverableError(playability.reason || (playability.messages && playability.messages[0]));\n  } else {\n    return null;\n  }\n};\n\n\nconst isRental = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'UNPLAYABLE' &&\n    playability.errorScreen && playability.errorScreen.playerLegacyDesktopYpcOfferRenderer;\n};\n\n\nconst isNotYetBroadcasted = player_response => {\n  let playability = player_response.playabilityStatus;\n  return playability && playability.status === 'LIVE_STREAM_OFFLINE';\n};\n\n\nconst getWatchHTMLURL = (id, options) => `${BASE_URL + id}&hl=${options.lang || 'en'}`;\nconst getWatchHTMLPageBody = (id, options) => {\n  const url = getWatchHTMLURL(id, options);\n  return exports.watchPageCache.getOrSet(url, () => utils.exposedMiniget(url, options).text());\n};\n\n\nconst EMBED_URL = 'https://www.youtube.com/embed/';\nconst getEmbedPageBody = (id, options) => {\n  const embedUrl = `${EMBED_URL + id}?hl=${options.lang || 'en'}`;\n  return utils.exposedMiniget(embedUrl, options).text();\n};\n\n\nconst getHTML5player = body => {\n  let html5playerRes =\n    /<script\\s+src=\"([^\"]+)\"(?:\\s+type=\"text\\/javascript\")?\\s+name=\"player_ias\\/base\"\\s*>|\"jsUrl\":\"([^\"]+)\"/\n      .exec(body);\n  return html5playerRes ? html5playerRes[1] || html5playerRes[2] : null;\n};\n\n\nconst getIdentityToken = (id, options, key, throwIfNotFound) =>\n  exports.cookieCache.getOrSet(key, async() => {\n    let page = await getWatchHTMLPageBody(id, options);\n    let match = page.match(/([\"'])ID_TOKEN\\1[:,]\\s?\"([^\"]+)\"/);\n    if (!match && throwIfNotFound) {\n      throw new UnrecoverableError('Cookie header used in request, but unable to find YouTube identity token');\n    }\n    return match && match[2];\n  });\n\n\n/**\n * Goes through each endpoint in the pipeline, retrying on failure if the error is recoverable.\n * If unable to succeed with one endpoint, moves onto the next one.\n *\n * @param {Array.<Object>} args\n * @param {Function} validate\n * @param {Object} retryOptions\n * @param {Array.<Function>} endpoints\n * @returns {[Object, Object, Object]}\n */\nconst pipeline = async(args, validate, retryOptions, endpoints) => {\n  let info;\n  for (let func of endpoints) {\n    try {\n      const newInfo = await retryFunc(func, args.concat([info]), retryOptions);\n      if (newInfo.player_response) {\n        newInfo.player_response.videoDetails = assign(\n          info && info.player_response && info.player_response.videoDetails,\n          newInfo.player_response.videoDetails);\n        newInfo.player_response = assign(info && info.player_response, newInfo.player_response);\n      }\n      info = assign(info, newInfo);\n      if (validate(info, false)) {\n        break;\n      }\n    } catch (err) {\n      if (err instanceof UnrecoverableError || func === endpoints[endpoints.length - 1]) {\n        throw err;\n      }\n      // Unable to find video metadata... so try next endpoint.\n    }\n  }\n  return info;\n};\n\n\n/**\n * Like Object.assign(), but ignores `null` and `undefined` from `source`.\n *\n * @param {Object} target\n * @param {Object} source\n * @returns {Object}\n */\nconst assign = (target, source) => {\n  if (!target || !source) { return target || source; }\n  for (let [key, value] of Object.entries(source)) {\n    if (value !== null && value !== undefined) {\n      target[key] = value;\n    }\n  }\n  return target;\n};\n\n\n/**\n * Given a function, calls it with `args` until it's successful,\n * or until it encounters an unrecoverable error.\n * Currently, any error from miniget is considered unrecoverable. Errors such as\n * too many redirects, invalid URL, status code 404, status code 502.\n *\n * @param {Function} func\n * @param {Array.<Object>} args\n * @param {Object} options\n * @param {number} options.maxRetries\n * @param {Object} options.backoff\n * @param {number} options.backoff.inc\n */\nconst retryFunc = async(func, args, options) => {\n  let currentTry = 0, result;\n  while (currentTry <= options.maxRetries) {\n    try {\n      result = await func(...args);\n      break;\n    } catch (err) {\n      if (err instanceof UnrecoverableError ||\n        (err instanceof miniget.MinigetError && err.statusCode < 500) || currentTry >= options.maxRetries) {\n        throw err;\n      }\n      let wait = Math.min(++currentTry * options.backoff.inc, options.backoff.max);\n      await new Promise(resolve => setTimeout(resolve, wait));\n    }\n  }\n  return result;\n};\n\n\nconst jsonClosingChars = /^[)\\]}'\\s]+/;\nconst parseJSON = (source, varName, json) => {\n  if (!json || typeof json === 'object') {\n    return json;\n  } else {\n    try {\n      json = json.replace(jsonClosingChars, '');\n      return JSON.parse(json);\n    } catch (err) {\n      throw Error(`Error parsing ${varName} in ${source}: ${err.message}`);\n    }\n  }\n};\n\n\nconst findJSON = (source, varName, body, left, right, prependJSON) => {\n  let jsonStr = utils.between(body, left, right);\n  if (!jsonStr) {\n    throw Error(`Could not find ${varName} in ${source}`);\n  }\n  return parseJSON(source, varName, utils.cutAfterJS(`${prependJSON}${jsonStr}`));\n};\n\n\nconst findPlayerResponse = (source, info) => {\n  const player_response = info && (\n    (info.args && info.args.player_response) ||\n    info.player_response || info.playerResponse || info.embedded_player_response);\n  return parseJSON(source, 'player_response', player_response);\n};\n\n\nconst getWatchJSONURL = (id, options) => `${getWatchHTMLURL(id, options)}&pbj=1`;\nconst getWatchJSONPage = async(id, options) => {\n  const reqOptions = Object.assign({ headers: {} }, options.requestOptions);\n  let cookie = reqOptions.headers.Cookie || reqOptions.headers.cookie;\n  reqOptions.headers = Object.assign({\n    'x-youtube-client-name': '1',\n    'x-youtube-client-version': cver,\n    'x-youtube-identity-token': exports.cookieCache.get(cookie || 'browser') || '',\n  }, reqOptions.headers);\n\n  const setIdentityToken = async(key, throwIfNotFound) => {\n    if (reqOptions.headers['x-youtube-identity-token']) { return; }\n    reqOptions.headers['x-youtube-identity-token'] = await getIdentityToken(id, options, key, throwIfNotFound);\n  };\n\n  if (cookie) {\n    await setIdentityToken(cookie, true);\n  }\n\n  const jsonUrl = getWatchJSONURL(id, options);\n  const body = await utils.exposedMiniget(jsonUrl, options, reqOptions).text();\n  let parsedBody = parseJSON('watch.json', 'body', body);\n  if (parsedBody.reload === 'now') {\n    await setIdentityToken('browser', false);\n  }\n  if (parsedBody.reload === 'now' || !Array.isArray(parsedBody)) {\n    throw Error('Unable to retrieve video metadata in watch.json');\n  }\n  let info = parsedBody.reduce((part, curr) => Object.assign(curr, part), {});\n  info.player_response = findPlayerResponse('watch.json', info);\n  info.html5player = info.player && info.player.assets && info.player.assets.js;\n\n  return info;\n};\n\n\nconst getWatchHTMLPage = async(id, options) => {\n  let body = await getWatchHTMLPageBody(id, options);\n  let info = { page: 'watch' };\n  try {\n    cver = utils.between(body, '{\"key\":\"cver\",\"value\":\"', '\"}');\n    info.player_response = findJSON('watch.html', 'player_response',\n      body, /\\bytInitialPlayerResponse\\s*=\\s*\\{/i, '</script>', '{');\n  } catch (err) {\n    let args = findJSON('watch.html', 'player_response', body, /\\bytplayer\\.config\\s*=\\s*{/, '</script>', '{');\n    info.player_response = findPlayerResponse('watch.html', args);\n  }\n  info.response = findJSON('watch.html', 'response', body, /\\bytInitialData(\"\\])?\\s*=\\s*\\{/i, '</script>', '{');\n  info.html5player = getHTML5player(body);\n  return info;\n};\n\n\nconst INFO_HOST = 'www.youtube.com';\nconst INFO_PATH = '/get_video_info';\nconst VIDEO_EURL = 'https://youtube.googleapis.com/v/';\nconst getVideoInfoPage = async(id, options) => {\n  const url = new URL(`https://${INFO_HOST}${INFO_PATH}`);\n  url.searchParams.set('video_id', id);\n  url.searchParams.set('c', 'TVHTML5');\n  url.searchParams.set('cver', `7${cver.substr(1)}`);\n  url.searchParams.set('eurl', VIDEO_EURL + id);\n  url.searchParams.set('ps', 'default');\n  url.searchParams.set('gl', 'US');\n  url.searchParams.set('hl', options.lang || 'en');\n  url.searchParams.set('html5', '1');\n  const body = await utils.exposedMiniget(url.toString(), options).text();\n  let info = querystring.parse(body);\n  info.player_response = findPlayerResponse('get_video_info', info);\n  return info;\n};\n\n\n/**\n * @param {Object} player_response\n * @returns {Array.<Object>}\n */\nconst parseFormats = player_response => {\n  let formats = [];\n  if (player_response && player_response.streamingData) {\n    formats = formats\n      .concat(player_response.streamingData.formats || [])\n      .concat(player_response.streamingData.adaptiveFormats || []);\n  }\n  return formats;\n};\n\n\n/**\n * Gets info from a video additional formats and deciphered URLs.\n *\n * @param {string} id\n * @param {Object} options\n * @returns {Promise<Object>}\n */\nexports.getInfo = async(id, options) => {\n  let info = await exports.getBasicInfo(id, options);\n  const hasManifest =\n    info.player_response && info.player_response.streamingData && (\n      info.player_response.streamingData.dashManifestUrl ||\n      info.player_response.streamingData.hlsManifestUrl\n    );\n  let funcs = [];\n  if (info.formats.length) {\n    info.html5player = info.html5player ||\n      getHTML5player(await getWatchHTMLPageBody(id, options)) || getHTML5player(await getEmbedPageBody(id, options));\n    if (!info.html5player) {\n      throw Error('Unable to find html5player file');\n    }\n    const html5player = new URL(info.html5player, BASE_URL).toString();\n    funcs.push(sig.decipherFormats(info.formats, html5player, options));\n  }\n  if (hasManifest && info.player_response.streamingData.dashManifestUrl) {\n    let url = info.player_response.streamingData.dashManifestUrl;\n    funcs.push(getDashManifest(url, options));\n  }\n  if (hasManifest && info.player_response.streamingData.hlsManifestUrl) {\n    let url = info.player_response.streamingData.hlsManifestUrl;\n    funcs.push(getM3U8(url, options));\n  }\n\n  let results = await Promise.all(funcs);\n  info.formats = Object.values(Object.assign({}, ...results));\n  info.formats = info.formats.map(formatUtils.addFormatMeta);\n  info.formats.sort(formatUtils.sortFormats);\n  info.full = true;\n  return info;\n};\n\n\n/**\n * Gets additional DASH formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getDashManifest = (url, options) => new Promise((resolve, reject) => {\n  let formats = {};\n  const parser = sax.parser(false);\n  parser.onerror = reject;\n  let adaptationSet;\n  parser.onopentag = node => {\n    if (node.name === 'ADAPTATIONSET') {\n      adaptationSet = node.attributes;\n    } else if (node.name === 'REPRESENTATION') {\n      const itag = parseInt(node.attributes.ID);\n      if (!isNaN(itag)) {\n        formats[url] = Object.assign({\n          itag, url,\n          bitrate: parseInt(node.attributes.BANDWIDTH),\n          mimeType: `${adaptationSet.MIMETYPE}; codecs=\"${node.attributes.CODECS}\"`,\n        }, node.attributes.HEIGHT ? {\n          width: parseInt(node.attributes.WIDTH),\n          height: parseInt(node.attributes.HEIGHT),\n          fps: parseInt(node.attributes.FRAMERATE),\n        } : {\n          audioSampleRate: node.attributes.AUDIOSAMPLINGRATE,\n        });\n      }\n    }\n  };\n  parser.onend = () => { resolve(formats); };\n  const req = utils.exposedMiniget(new URL(url, BASE_URL).toString(), options);\n  req.setEncoding('utf8');\n  req.on('error', reject);\n  req.on('data', chunk => { parser.write(chunk); });\n  req.on('end', parser.close.bind(parser));\n});\n\n\n/**\n * Gets additional formats.\n *\n * @param {string} url\n * @param {Object} options\n * @returns {Promise<Array.<Object>>}\n */\nconst getM3U8 = async(url, options) => {\n  url = new URL(url, BASE_URL);\n  const body = await utils.exposedMiniget(url.toString(), options).text();\n  let formats = {};\n  body\n    .split('\\n')\n    .filter(line => /^https?:\\/\\//.test(line))\n    .forEach(line => {\n      const itag = parseInt(line.match(/\\/itag\\/(\\d+)\\//)[1]);\n      formats[line] = { itag, url: line };\n    });\n  return formats;\n};\n\n\n// Cache get info functions.\n// In case a user wants to get a video's info before downloading.\nfor (let funcName of ['getBasicInfo', 'getInfo']) {\n  /**\n   * @param {string} link\n   * @param {Object} options\n   * @returns {Promise<Object>}\n   */\n  const func = exports[funcName];\n  exports[funcName] = async(link, options = {}) => {\n    utils.checkForUpdates();\n    let id = await urlUtils.getVideoID(link);\n    const key = [funcName, id, options.lang].join('-');\n    return exports.cache.getOrSet(key, () => func(id, options));\n  };\n}\n\n\n// Export a few helpers.\nexports.validateID = urlUtils.validateID;\nexports.validateURL = urlUtils.validateURL;\nexports.getURLVideoID = urlUtils.getURLVideoID;\nexports.getVideoID = urlUtils.getVideoID;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9pbmZvLmpzIiwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLFlBQVksbUJBQU8sQ0FBQyxnREFBSztBQUN6QixnQkFBZ0IsbUJBQU8sQ0FBQywyREFBUztBQUNqQyxjQUFjLG1CQUFPLENBQUMsNERBQVM7QUFDL0I7QUFDQSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHNCQUFRO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDBFQUFnQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBYTtBQUN0QyxlQUFlLG1CQUFPLENBQUMsd0VBQWU7QUFDdEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFPO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyw0REFBUzs7O0FBRy9COzs7QUFHQTtBQUNBLGFBQWE7QUFDYixtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDLDJDQUEyQyw0QkFBNEI7QUFDdkUsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0Q0FBNEMsY0FBYyxNQUFNLHFCQUFxQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHNCQUFzQixlQUFlLE1BQU0scUJBQXFCO0FBQ2hFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLGtCQUFrQjtBQUM3QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLFNBQVMsS0FBSyxPQUFPLElBQUksWUFBWTtBQUN4RTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLEtBQUssT0FBTztBQUN2RDtBQUNBLHdEQUF3RCxZQUFZLEVBQUUsUUFBUTtBQUM5RTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw0Q0FBNEMsNkJBQTZCO0FBQ3pFO0FBQ0EscUNBQXFDLGFBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQSwrQ0FBK0MsbUJBQW1CO0FBQ2xFLElBQUk7QUFDSiwwRkFBMEYsa0JBQWtCO0FBQzVHO0FBQ0E7QUFDQSwwRkFBMEYsbUJBQW1CO0FBQzdHO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVSxFQUFFLFVBQVU7QUFDdkQ7QUFDQTtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUIsVUFBVSx1QkFBdUI7QUFDakYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy95dGRsLWNvcmUvbGliL2luZm8uanM/NmVlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBzYXggPSByZXF1aXJlKCdzYXgnKTtcbmNvbnN0IG1pbmlnZXQgPSByZXF1aXJlKCdtaW5pZ2V0Jyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbi8vIEZvcmNlcyBOb2RlIEpTIHZlcnNpb24gb2Ygc2V0VGltZW91dCBmb3IgRWxlY3Ryb24gYmFzZWQgYXBwbGljYXRpb25zXG5jb25zdCB7IHNldFRpbWVvdXQgfSA9IHJlcXVpcmUoJ3RpbWVycycpO1xuY29uc3QgZm9ybWF0VXRpbHMgPSByZXF1aXJlKCcuL2Zvcm1hdC11dGlscycpO1xuY29uc3QgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3VybC11dGlscycpO1xuY29uc3QgZXh0cmFzID0gcmVxdWlyZSgnLi9pbmZvLWV4dHJhcycpO1xuY29uc3Qgc2lnID0gcmVxdWlyZSgnLi9zaWcnKTtcbmNvbnN0IENhY2hlID0gcmVxdWlyZSgnLi9jYWNoZScpO1xuXG5cbmNvbnN0IEJBU0VfVVJMID0gJ2h0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9JztcblxuXG4vLyBDYWNoZWQgZm9yIHN0b3JpbmcgYmFzaWMvZnVsbCBpbmZvLlxuZXhwb3J0cy5jYWNoZSA9IG5ldyBDYWNoZSgpO1xuZXhwb3J0cy5jb29raWVDYWNoZSA9IG5ldyBDYWNoZSgxMDAwICogNjAgKiA2MCAqIDI0KTtcbmV4cG9ydHMud2F0Y2hQYWdlQ2FjaGUgPSBuZXcgQ2FjaGUoKTtcbi8vIENhY2hlIGZvciBjdmVyIHVzZWQgaW4gZ2V0VmlkZW9JbmZvUGFnZVxubGV0IGN2ZXIgPSAnMi4yMDIxMDYyMi4xMC4wMCc7XG5cblxuLy8gU3BlY2lhbCBlcnJvciBjbGFzcyB1c2VkIHRvIGRldGVybWluZSBpZiBhbiBlcnJvciBpcyB1bnJlY292ZXJhYmxlLFxuLy8gYXMgaW4sIHl0ZGwtY29yZSBzaG91bGQgbm90IHRyeSBhZ2FpbiB0byBmZXRjaCB0aGUgdmlkZW8gbWV0YWRhdGEuXG4vLyBJbiB0aGlzIGNhc2UsIHRoZSB2aWRlbyBpcyB1c3VhbGx5IHVuYXZhaWxhYmxlIGluIHNvbWUgd2F5LlxuY2xhc3MgVW5yZWNvdmVyYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuXG4vLyBMaXN0IG9mIFVSTHMgdGhhdCBzaG93IHVwIGluIGBub3RpY2VfdXJsYCBmb3IgYWdlIHJlc3RyaWN0ZWQgdmlkZW9zLlxuY29uc3QgQUdFX1JFU1RSSUNURURfVVJMUyA9IFtcbiAgJ3N1cHBvcnQuZ29vZ2xlLmNvbS95b3V0dWJlLz9wPWFnZV9yZXN0cmljdGlvbnMnLFxuICAneW91dHViZS5jb20vdC9jb21tdW5pdHlfZ3VpZGVsaW5lcycsXG5dO1xuXG5cbi8qKlxuICogR2V0cyBpbmZvIGZyb20gYSB2aWRlbyB3aXRob3V0IGdldHRpbmcgYWRkaXRpb25hbCBmb3JtYXRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4qL1xuZXhwb3J0cy5nZXRCYXNpY0luZm8gPSBhc3luYyhpZCwgb3B0aW9ucykgPT4ge1xuICBpZiAob3B0aW9ucy5JUHY2QmxvY2spIHtcbiAgICBvcHRpb25zLnJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucywge1xuICAgICAgZmFtaWx5OiA2LFxuICAgICAgbG9jYWxBZGRyZXNzOiB1dGlscy5nZXRSYW5kb21JUHY2KG9wdGlvbnMuSVB2NkJsb2NrKSxcbiAgICB9KTtcbiAgfVxuICBjb25zdCByZXRyeU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBtaW5pZ2V0LmRlZmF1bHRPcHRpb25zLCBvcHRpb25zLnJlcXVlc3RPcHRpb25zKTtcbiAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMucmVxdWVzdE9wdGlvbnMsIHt9KTtcbiAgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSxcbiAgICB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgJ1VzZXItQWdlbnQnOiAnTW96aWxsYS81LjAgKFdpbmRvd3MgTlQgMTAuMDsgV2luNjQ7IHg2NCkgQXBwbGVXZWJLaXQvNTM3LjM2IChLSFRNTCwgbGlrZSBHZWNrbykgQ2hyb21lLzg3LjAuNDI4MC4xMDEgU2FmYXJpLzUzNy4zNicsXG4gICAgfSwgb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKTtcbiAgY29uc3QgdmFsaWRhdGUgPSBpbmZvID0+IHtcbiAgICBsZXQgcGxheUVyciA9IHV0aWxzLnBsYXlFcnJvcihpbmZvLnBsYXllcl9yZXNwb25zZSwgWydFUlJPUiddLCBVbnJlY292ZXJhYmxlRXJyb3IpO1xuICAgIGxldCBwcml2YXRlRXJyID0gcHJpdmF0ZVZpZGVvRXJyb3IoaW5mby5wbGF5ZXJfcmVzcG9uc2UpO1xuICAgIGlmIChwbGF5RXJyIHx8IHByaXZhdGVFcnIpIHtcbiAgICAgIHRocm93IHBsYXlFcnIgfHwgcHJpdmF0ZUVycjtcbiAgICB9XG4gICAgcmV0dXJuIGluZm8gJiYgaW5mby5wbGF5ZXJfcmVzcG9uc2UgJiYgKFxuICAgICAgaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YSB8fCBpc1JlbnRhbChpbmZvLnBsYXllcl9yZXNwb25zZSkgfHwgaXNOb3RZZXRCcm9hZGNhc3RlZChpbmZvLnBsYXllcl9yZXNwb25zZSlcbiAgICApO1xuICB9O1xuICBsZXQgaW5mbyA9IGF3YWl0IHBpcGVsaW5lKFtpZCwgb3B0aW9uc10sIHZhbGlkYXRlLCByZXRyeU9wdGlvbnMsIFtcbiAgICBnZXRXYXRjaEhUTUxQYWdlLFxuICAgIGdldFdhdGNoSlNPTlBhZ2UsXG4gICAgZ2V0VmlkZW9JbmZvUGFnZSxcbiAgXSk7XG5cbiAgT2JqZWN0LmFzc2lnbihpbmZvLCB7XG4gICAgZm9ybWF0czogcGFyc2VGb3JtYXRzKGluZm8ucGxheWVyX3Jlc3BvbnNlKSxcbiAgICByZWxhdGVkX3ZpZGVvczogZXh0cmFzLmdldFJlbGF0ZWRWaWRlb3MoaW5mbyksXG4gIH0pO1xuXG4gIC8vIEFkZCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gaW5mby5cbiAgY29uc3QgbWVkaWEgPSBleHRyYXMuZ2V0TWVkaWEoaW5mbyk7XG4gIGNvbnN0IGFkZGl0aW9uYWwgPSB7XG4gICAgYXV0aG9yOiBleHRyYXMuZ2V0QXV0aG9yKGluZm8pLFxuICAgIG1lZGlhLFxuICAgIGxpa2VzOiBleHRyYXMuZ2V0TGlrZXMoaW5mbyksXG4gICAgZGlzbGlrZXM6IGV4dHJhcy5nZXREaXNsaWtlcyhpbmZvKSxcbiAgICBhZ2VfcmVzdHJpY3RlZDogISEobWVkaWEgJiYgQUdFX1JFU1RSSUNURURfVVJMUy5zb21lKHVybCA9PlxuICAgICAgT2JqZWN0LnZhbHVlcyhtZWRpYSkuc29tZSh2ID0+IHR5cGVvZiB2ID09PSAnc3RyaW5nJyAmJiB2LmluY2x1ZGVzKHVybCkpKVxuICAgICksXG5cbiAgICAvLyBHaXZlIHRoZSBzdGFuZGFyZCBsaW5rIHRvIHRoZSB2aWRlby5cbiAgICB2aWRlb191cmw6IEJBU0VfVVJMICsgaWQsXG4gICAgc3Rvcnlib2FyZHM6IGV4dHJhcy5nZXRTdG9yeWJvYXJkcyhpbmZvKSxcbiAgICBjaGFwdGVyczogZXh0cmFzLmdldENoYXB0ZXJzKGluZm8pLFxuICB9O1xuXG4gIGluZm8udmlkZW9EZXRhaWxzID0gZXh0cmFzLmNsZWFuVmlkZW9EZXRhaWxzKE9iamVjdC5hc3NpZ24oe30sXG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UgJiYgaW5mby5wbGF5ZXJfcmVzcG9uc2UubWljcm9mb3JtYXQgJiZcbiAgICBpbmZvLnBsYXllcl9yZXNwb25zZS5taWNyb2Zvcm1hdC5wbGF5ZXJNaWNyb2Zvcm1hdFJlbmRlcmVyLFxuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscywgYWRkaXRpb25hbCksIGluZm8pO1xuXG4gIHJldHVybiBpbmZvO1xufTtcblxuY29uc3QgcHJpdmF0ZVZpZGVvRXJyb3IgPSBwbGF5ZXJfcmVzcG9uc2UgPT4ge1xuICBsZXQgcGxheWFiaWxpdHkgPSBwbGF5ZXJfcmVzcG9uc2UgJiYgcGxheWVyX3Jlc3BvbnNlLnBsYXlhYmlsaXR5U3RhdHVzO1xuICBpZiAocGxheWFiaWxpdHkgJiYgcGxheWFiaWxpdHkuc3RhdHVzID09PSAnTE9HSU5fUkVRVUlSRUQnICYmIHBsYXlhYmlsaXR5Lm1lc3NhZ2VzICYmXG4gICAgcGxheWFiaWxpdHkubWVzc2FnZXMuZmlsdGVyKG0gPT4gL1RoaXMgaXMgYSBwcml2YXRlIHZpZGVvLy50ZXN0KG0pKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFVucmVjb3ZlcmFibGVFcnJvcihwbGF5YWJpbGl0eS5yZWFzb24gfHwgKHBsYXlhYmlsaXR5Lm1lc3NhZ2VzICYmIHBsYXlhYmlsaXR5Lm1lc3NhZ2VzWzBdKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cblxuY29uc3QgaXNSZW50YWwgPSBwbGF5ZXJfcmVzcG9uc2UgPT4ge1xuICBsZXQgcGxheWFiaWxpdHkgPSBwbGF5ZXJfcmVzcG9uc2UucGxheWFiaWxpdHlTdGF0dXM7XG4gIHJldHVybiBwbGF5YWJpbGl0eSAmJiBwbGF5YWJpbGl0eS5zdGF0dXMgPT09ICdVTlBMQVlBQkxFJyAmJlxuICAgIHBsYXlhYmlsaXR5LmVycm9yU2NyZWVuICYmIHBsYXlhYmlsaXR5LmVycm9yU2NyZWVuLnBsYXllckxlZ2FjeURlc2t0b3BZcGNPZmZlclJlbmRlcmVyO1xufTtcblxuXG5jb25zdCBpc05vdFlldEJyb2FkY2FzdGVkID0gcGxheWVyX3Jlc3BvbnNlID0+IHtcbiAgbGV0IHBsYXlhYmlsaXR5ID0gcGxheWVyX3Jlc3BvbnNlLnBsYXlhYmlsaXR5U3RhdHVzO1xuICByZXR1cm4gcGxheWFiaWxpdHkgJiYgcGxheWFiaWxpdHkuc3RhdHVzID09PSAnTElWRV9TVFJFQU1fT0ZGTElORSc7XG59O1xuXG5cbmNvbnN0IGdldFdhdGNoSFRNTFVSTCA9IChpZCwgb3B0aW9ucykgPT4gYCR7QkFTRV9VUkwgKyBpZH0maGw9JHtvcHRpb25zLmxhbmcgfHwgJ2VuJ31gO1xuY29uc3QgZ2V0V2F0Y2hIVE1MUGFnZUJvZHkgPSAoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgdXJsID0gZ2V0V2F0Y2hIVE1MVVJMKGlkLCBvcHRpb25zKTtcbiAgcmV0dXJuIGV4cG9ydHMud2F0Y2hQYWdlQ2FjaGUuZ2V0T3JTZXQodXJsLCAoKSA9PiB1dGlscy5leHBvc2VkTWluaWdldCh1cmwsIG9wdGlvbnMpLnRleHQoKSk7XG59O1xuXG5cbmNvbnN0IEVNQkVEX1VSTCA9ICdodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nO1xuY29uc3QgZ2V0RW1iZWRQYWdlQm9keSA9IChpZCwgb3B0aW9ucykgPT4ge1xuICBjb25zdCBlbWJlZFVybCA9IGAke0VNQkVEX1VSTCArIGlkfT9obD0ke29wdGlvbnMubGFuZyB8fCAnZW4nfWA7XG4gIHJldHVybiB1dGlscy5leHBvc2VkTWluaWdldChlbWJlZFVybCwgb3B0aW9ucykudGV4dCgpO1xufTtcblxuXG5jb25zdCBnZXRIVE1MNXBsYXllciA9IGJvZHkgPT4ge1xuICBsZXQgaHRtbDVwbGF5ZXJSZXMgPVxuICAgIC88c2NyaXB0XFxzK3NyYz1cIihbXlwiXSspXCIoPzpcXHMrdHlwZT1cInRleHRcXC9qYXZhc2NyaXB0XCIpP1xccytuYW1lPVwicGxheWVyX2lhc1xcL2Jhc2VcIlxccyo+fFwianNVcmxcIjpcIihbXlwiXSspXCIvXG4gICAgICAuZXhlYyhib2R5KTtcbiAgcmV0dXJuIGh0bWw1cGxheWVyUmVzID8gaHRtbDVwbGF5ZXJSZXNbMV0gfHwgaHRtbDVwbGF5ZXJSZXNbMl0gOiBudWxsO1xufTtcblxuXG5jb25zdCBnZXRJZGVudGl0eVRva2VuID0gKGlkLCBvcHRpb25zLCBrZXksIHRocm93SWZOb3RGb3VuZCkgPT5cbiAgZXhwb3J0cy5jb29raWVDYWNoZS5nZXRPclNldChrZXksIGFzeW5jKCkgPT4ge1xuICAgIGxldCBwYWdlID0gYXdhaXQgZ2V0V2F0Y2hIVE1MUGFnZUJvZHkoaWQsIG9wdGlvbnMpO1xuICAgIGxldCBtYXRjaCA9IHBhZ2UubWF0Y2goLyhbXCInXSlJRF9UT0tFTlxcMVs6LF1cXHM/XCIoW15cIl0rKVwiLyk7XG4gICAgaWYgKCFtYXRjaCAmJiB0aHJvd0lmTm90Rm91bmQpIHtcbiAgICAgIHRocm93IG5ldyBVbnJlY292ZXJhYmxlRXJyb3IoJ0Nvb2tpZSBoZWFkZXIgdXNlZCBpbiByZXF1ZXN0LCBidXQgdW5hYmxlIHRvIGZpbmQgWW91VHViZSBpZGVudGl0eSB0b2tlbicpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMl07XG4gIH0pO1xuXG5cbi8qKlxuICogR29lcyB0aHJvdWdoIGVhY2ggZW5kcG9pbnQgaW4gdGhlIHBpcGVsaW5lLCByZXRyeWluZyBvbiBmYWlsdXJlIGlmIHRoZSBlcnJvciBpcyByZWNvdmVyYWJsZS5cbiAqIElmIHVuYWJsZSB0byBzdWNjZWVkIHdpdGggb25lIGVuZHBvaW50LCBtb3ZlcyBvbnRvIHRoZSBuZXh0IG9uZS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBhcmdzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB2YWxpZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJldHJ5T3B0aW9uc1xuICogQHBhcmFtIHtBcnJheS48RnVuY3Rpb24+fSBlbmRwb2ludHNcbiAqIEByZXR1cm5zIHtbT2JqZWN0LCBPYmplY3QsIE9iamVjdF19XG4gKi9cbmNvbnN0IHBpcGVsaW5lID0gYXN5bmMoYXJncywgdmFsaWRhdGUsIHJldHJ5T3B0aW9ucywgZW5kcG9pbnRzKSA9PiB7XG4gIGxldCBpbmZvO1xuICBmb3IgKGxldCBmdW5jIG9mIGVuZHBvaW50cykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdJbmZvID0gYXdhaXQgcmV0cnlGdW5jKGZ1bmMsIGFyZ3MuY29uY2F0KFtpbmZvXSksIHJldHJ5T3B0aW9ucyk7XG4gICAgICBpZiAobmV3SW5mby5wbGF5ZXJfcmVzcG9uc2UpIHtcbiAgICAgICAgbmV3SW5mby5wbGF5ZXJfcmVzcG9uc2UudmlkZW9EZXRhaWxzID0gYXNzaWduKFxuICAgICAgICAgIGluZm8gJiYgaW5mby5wbGF5ZXJfcmVzcG9uc2UgJiYgaW5mby5wbGF5ZXJfcmVzcG9uc2UudmlkZW9EZXRhaWxzLFxuICAgICAgICAgIG5ld0luZm8ucGxheWVyX3Jlc3BvbnNlLnZpZGVvRGV0YWlscyk7XG4gICAgICAgIG5ld0luZm8ucGxheWVyX3Jlc3BvbnNlID0gYXNzaWduKGluZm8gJiYgaW5mby5wbGF5ZXJfcmVzcG9uc2UsIG5ld0luZm8ucGxheWVyX3Jlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGluZm8gPSBhc3NpZ24oaW5mbywgbmV3SW5mbyk7XG4gICAgICBpZiAodmFsaWRhdGUoaW5mbywgZmFsc2UpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVucmVjb3ZlcmFibGVFcnJvciB8fCBmdW5jID09PSBlbmRwb2ludHNbZW5kcG9pbnRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIC8vIFVuYWJsZSB0byBmaW5kIHZpZGVvIG1ldGFkYXRhLi4uIHNvIHRyeSBuZXh0IGVuZHBvaW50LlxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn07XG5cblxuLyoqXG4gKiBMaWtlIE9iamVjdC5hc3NpZ24oKSwgYnV0IGlnbm9yZXMgYG51bGxgIGFuZCBgdW5kZWZpbmVkYCBmcm9tIGBzb3VyY2VgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmNvbnN0IGFzc2lnbiA9ICh0YXJnZXQsIHNvdXJjZSkgPT4ge1xuICBpZiAoIXRhcmdldCB8fCAhc291cmNlKSB7IHJldHVybiB0YXJnZXQgfHwgc291cmNlOyB9XG4gIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG5cbi8qKlxuICogR2l2ZW4gYSBmdW5jdGlvbiwgY2FsbHMgaXQgd2l0aCBgYXJnc2AgdW50aWwgaXQncyBzdWNjZXNzZnVsLFxuICogb3IgdW50aWwgaXQgZW5jb3VudGVycyBhbiB1bnJlY292ZXJhYmxlIGVycm9yLlxuICogQ3VycmVudGx5LCBhbnkgZXJyb3IgZnJvbSBtaW5pZ2V0IGlzIGNvbnNpZGVyZWQgdW5yZWNvdmVyYWJsZS4gRXJyb3JzIHN1Y2ggYXNcbiAqIHRvbyBtYW55IHJlZGlyZWN0cywgaW52YWxpZCBVUkwsIHN0YXR1cyBjb2RlIDQwNCwgc3RhdHVzIGNvZGUgNTAyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmNcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGFyZ3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5tYXhSZXRyaWVzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5iYWNrb2ZmXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5iYWNrb2ZmLmluY1xuICovXG5jb25zdCByZXRyeUZ1bmMgPSBhc3luYyhmdW5jLCBhcmdzLCBvcHRpb25zKSA9PiB7XG4gIGxldCBjdXJyZW50VHJ5ID0gMCwgcmVzdWx0O1xuICB3aGlsZSAoY3VycmVudFRyeSA8PSBvcHRpb25zLm1heFJldHJpZXMpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgZnVuYyguLi5hcmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVucmVjb3ZlcmFibGVFcnJvciB8fFxuICAgICAgICAoZXJyIGluc3RhbmNlb2YgbWluaWdldC5NaW5pZ2V0RXJyb3IgJiYgZXJyLnN0YXR1c0NvZGUgPCA1MDApIHx8IGN1cnJlbnRUcnkgPj0gb3B0aW9ucy5tYXhSZXRyaWVzKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGxldCB3YWl0ID0gTWF0aC5taW4oKytjdXJyZW50VHJ5ICogb3B0aW9ucy5iYWNrb2ZmLmluYywgb3B0aW9ucy5iYWNrb2ZmLm1heCk7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgd2FpdCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG5jb25zdCBqc29uQ2xvc2luZ0NoYXJzID0gL15bKVxcXX0nXFxzXSsvO1xuY29uc3QgcGFyc2VKU09OID0gKHNvdXJjZSwgdmFyTmFtZSwganNvbikgPT4ge1xuICBpZiAoIWpzb24gfHwgdHlwZW9mIGpzb24gPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGpzb247XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSBqc29uLnJlcGxhY2UoanNvbkNsb3NpbmdDaGFycywgJycpO1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBFcnJvcihgRXJyb3IgcGFyc2luZyAke3Zhck5hbWV9IGluICR7c291cmNlfTogJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbn07XG5cblxuY29uc3QgZmluZEpTT04gPSAoc291cmNlLCB2YXJOYW1lLCBib2R5LCBsZWZ0LCByaWdodCwgcHJlcGVuZEpTT04pID0+IHtcbiAgbGV0IGpzb25TdHIgPSB1dGlscy5iZXR3ZWVuKGJvZHksIGxlZnQsIHJpZ2h0KTtcbiAgaWYgKCFqc29uU3RyKSB7XG4gICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBmaW5kICR7dmFyTmFtZX0gaW4gJHtzb3VyY2V9YCk7XG4gIH1cbiAgcmV0dXJuIHBhcnNlSlNPTihzb3VyY2UsIHZhck5hbWUsIHV0aWxzLmN1dEFmdGVySlMoYCR7cHJlcGVuZEpTT059JHtqc29uU3RyfWApKTtcbn07XG5cblxuY29uc3QgZmluZFBsYXllclJlc3BvbnNlID0gKHNvdXJjZSwgaW5mbykgPT4ge1xuICBjb25zdCBwbGF5ZXJfcmVzcG9uc2UgPSBpbmZvICYmIChcbiAgICAoaW5mby5hcmdzICYmIGluZm8uYXJncy5wbGF5ZXJfcmVzcG9uc2UpIHx8XG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UgfHwgaW5mby5wbGF5ZXJSZXNwb25zZSB8fCBpbmZvLmVtYmVkZGVkX3BsYXllcl9yZXNwb25zZSk7XG4gIHJldHVybiBwYXJzZUpTT04oc291cmNlLCAncGxheWVyX3Jlc3BvbnNlJywgcGxheWVyX3Jlc3BvbnNlKTtcbn07XG5cblxuY29uc3QgZ2V0V2F0Y2hKU09OVVJMID0gKGlkLCBvcHRpb25zKSA9PiBgJHtnZXRXYXRjaEhUTUxVUkwoaWQsIG9wdGlvbnMpfSZwYmo9MWA7XG5jb25zdCBnZXRXYXRjaEpTT05QYWdlID0gYXN5bmMoaWQsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgcmVxT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyBoZWFkZXJzOiB7fSB9LCBvcHRpb25zLnJlcXVlc3RPcHRpb25zKTtcbiAgbGV0IGNvb2tpZSA9IHJlcU9wdGlvbnMuaGVhZGVycy5Db29raWUgfHwgcmVxT3B0aW9ucy5oZWFkZXJzLmNvb2tpZTtcbiAgcmVxT3B0aW9ucy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgJ3gteW91dHViZS1jbGllbnQtbmFtZSc6ICcxJyxcbiAgICAneC15b3V0dWJlLWNsaWVudC12ZXJzaW9uJzogY3ZlcixcbiAgICAneC15b3V0dWJlLWlkZW50aXR5LXRva2VuJzogZXhwb3J0cy5jb29raWVDYWNoZS5nZXQoY29va2llIHx8ICdicm93c2VyJykgfHwgJycsXG4gIH0sIHJlcU9wdGlvbnMuaGVhZGVycyk7XG5cbiAgY29uc3Qgc2V0SWRlbnRpdHlUb2tlbiA9IGFzeW5jKGtleSwgdGhyb3dJZk5vdEZvdW5kKSA9PiB7XG4gICAgaWYgKHJlcU9wdGlvbnMuaGVhZGVyc1sneC15b3V0dWJlLWlkZW50aXR5LXRva2VuJ10pIHsgcmV0dXJuOyB9XG4gICAgcmVxT3B0aW9ucy5oZWFkZXJzWyd4LXlvdXR1YmUtaWRlbnRpdHktdG9rZW4nXSA9IGF3YWl0IGdldElkZW50aXR5VG9rZW4oaWQsIG9wdGlvbnMsIGtleSwgdGhyb3dJZk5vdEZvdW5kKTtcbiAgfTtcblxuICBpZiAoY29va2llKSB7XG4gICAgYXdhaXQgc2V0SWRlbnRpdHlUb2tlbihjb29raWUsIHRydWUpO1xuICB9XG5cbiAgY29uc3QganNvblVybCA9IGdldFdhdGNoSlNPTlVSTChpZCwgb3B0aW9ucyk7XG4gIGNvbnN0IGJvZHkgPSBhd2FpdCB1dGlscy5leHBvc2VkTWluaWdldChqc29uVXJsLCBvcHRpb25zLCByZXFPcHRpb25zKS50ZXh0KCk7XG4gIGxldCBwYXJzZWRCb2R5ID0gcGFyc2VKU09OKCd3YXRjaC5qc29uJywgJ2JvZHknLCBib2R5KTtcbiAgaWYgKHBhcnNlZEJvZHkucmVsb2FkID09PSAnbm93Jykge1xuICAgIGF3YWl0IHNldElkZW50aXR5VG9rZW4oJ2Jyb3dzZXInLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHBhcnNlZEJvZHkucmVsb2FkID09PSAnbm93JyB8fCAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgIHRocm93IEVycm9yKCdVbmFibGUgdG8gcmV0cmlldmUgdmlkZW8gbWV0YWRhdGEgaW4gd2F0Y2guanNvbicpO1xuICB9XG4gIGxldCBpbmZvID0gcGFyc2VkQm9keS5yZWR1Y2UoKHBhcnQsIGN1cnIpID0+IE9iamVjdC5hc3NpZ24oY3VyciwgcGFydCksIHt9KTtcbiAgaW5mby5wbGF5ZXJfcmVzcG9uc2UgPSBmaW5kUGxheWVyUmVzcG9uc2UoJ3dhdGNoLmpzb24nLCBpbmZvKTtcbiAgaW5mby5odG1sNXBsYXllciA9IGluZm8ucGxheWVyICYmIGluZm8ucGxheWVyLmFzc2V0cyAmJiBpbmZvLnBsYXllci5hc3NldHMuanM7XG5cbiAgcmV0dXJuIGluZm87XG59O1xuXG5cbmNvbnN0IGdldFdhdGNoSFRNTFBhZ2UgPSBhc3luYyhpZCwgb3B0aW9ucykgPT4ge1xuICBsZXQgYm9keSA9IGF3YWl0IGdldFdhdGNoSFRNTFBhZ2VCb2R5KGlkLCBvcHRpb25zKTtcbiAgbGV0IGluZm8gPSB7IHBhZ2U6ICd3YXRjaCcgfTtcbiAgdHJ5IHtcbiAgICBjdmVyID0gdXRpbHMuYmV0d2Vlbihib2R5LCAne1wia2V5XCI6XCJjdmVyXCIsXCJ2YWx1ZVwiOlwiJywgJ1wifScpO1xuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlID0gZmluZEpTT04oJ3dhdGNoLmh0bWwnLCAncGxheWVyX3Jlc3BvbnNlJyxcbiAgICAgIGJvZHksIC9cXGJ5dEluaXRpYWxQbGF5ZXJSZXNwb25zZVxccyo9XFxzKlxcey9pLCAnPC9zY3JpcHQ+JywgJ3snKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgbGV0IGFyZ3MgPSBmaW5kSlNPTignd2F0Y2guaHRtbCcsICdwbGF5ZXJfcmVzcG9uc2UnLCBib2R5LCAvXFxieXRwbGF5ZXJcXC5jb25maWdcXHMqPVxccyp7LywgJzwvc2NyaXB0PicsICd7Jyk7XG4gICAgaW5mby5wbGF5ZXJfcmVzcG9uc2UgPSBmaW5kUGxheWVyUmVzcG9uc2UoJ3dhdGNoLmh0bWwnLCBhcmdzKTtcbiAgfVxuICBpbmZvLnJlc3BvbnNlID0gZmluZEpTT04oJ3dhdGNoLmh0bWwnLCAncmVzcG9uc2UnLCBib2R5LCAvXFxieXRJbml0aWFsRGF0YShcIlxcXSk/XFxzKj1cXHMqXFx7L2ksICc8L3NjcmlwdD4nLCAneycpO1xuICBpbmZvLmh0bWw1cGxheWVyID0gZ2V0SFRNTDVwbGF5ZXIoYm9keSk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuXG5jb25zdCBJTkZPX0hPU1QgPSAnd3d3LnlvdXR1YmUuY29tJztcbmNvbnN0IElORk9fUEFUSCA9ICcvZ2V0X3ZpZGVvX2luZm8nO1xuY29uc3QgVklERU9fRVVSTCA9ICdodHRwczovL3lvdXR1YmUuZ29vZ2xlYXBpcy5jb20vdi8nO1xuY29uc3QgZ2V0VmlkZW9JbmZvUGFnZSA9IGFzeW5jKGlkLCBvcHRpb25zKSA9PiB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwoYGh0dHBzOi8vJHtJTkZPX0hPU1R9JHtJTkZPX1BBVEh9YCk7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd2aWRlb19pZCcsIGlkKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2MnLCAnVFZIVE1MNScpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnY3ZlcicsIGA3JHtjdmVyLnN1YnN0cigxKX1gKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2V1cmwnLCBWSURFT19FVVJMICsgaWQpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgncHMnLCAnZGVmYXVsdCcpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnZ2wnLCAnVVMnKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2hsJywgb3B0aW9ucy5sYW5nIHx8ICdlbicpO1xuICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnaHRtbDUnLCAnMScpO1xuICBjb25zdCBib2R5ID0gYXdhaXQgdXRpbHMuZXhwb3NlZE1pbmlnZXQodXJsLnRvU3RyaW5nKCksIG9wdGlvbnMpLnRleHQoKTtcbiAgbGV0IGluZm8gPSBxdWVyeXN0cmluZy5wYXJzZShib2R5KTtcbiAgaW5mby5wbGF5ZXJfcmVzcG9uc2UgPSBmaW5kUGxheWVyUmVzcG9uc2UoJ2dldF92aWRlb19pbmZvJywgaW5mbyk7XG4gIHJldHVybiBpbmZvO1xufTtcblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXJfcmVzcG9uc2VcbiAqIEByZXR1cm5zIHtBcnJheS48T2JqZWN0Pn1cbiAqL1xuY29uc3QgcGFyc2VGb3JtYXRzID0gcGxheWVyX3Jlc3BvbnNlID0+IHtcbiAgbGV0IGZvcm1hdHMgPSBbXTtcbiAgaWYgKHBsYXllcl9yZXNwb25zZSAmJiBwbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YSkge1xuICAgIGZvcm1hdHMgPSBmb3JtYXRzXG4gICAgICAuY29uY2F0KHBsYXllcl9yZXNwb25zZS5zdHJlYW1pbmdEYXRhLmZvcm1hdHMgfHwgW10pXG4gICAgICAuY29uY2F0KHBsYXllcl9yZXNwb25zZS5zdHJlYW1pbmdEYXRhLmFkYXB0aXZlRm9ybWF0cyB8fCBbXSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1hdHM7XG59O1xuXG5cbi8qKlxuICogR2V0cyBpbmZvIGZyb20gYSB2aWRlbyBhZGRpdGlvbmFsIGZvcm1hdHMgYW5kIGRlY2lwaGVyZWQgVVJMcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxPYmplY3Q+fVxuICovXG5leHBvcnRzLmdldEluZm8gPSBhc3luYyhpZCwgb3B0aW9ucykgPT4ge1xuICBsZXQgaW5mbyA9IGF3YWl0IGV4cG9ydHMuZ2V0QmFzaWNJbmZvKGlkLCBvcHRpb25zKTtcbiAgY29uc3QgaGFzTWFuaWZlc3QgPVxuICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEgJiYgKFxuICAgICAgaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YS5kYXNoTWFuaWZlc3RVcmwgfHxcbiAgICAgIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEuaGxzTWFuaWZlc3RVcmxcbiAgICApO1xuICBsZXQgZnVuY3MgPSBbXTtcbiAgaWYgKGluZm8uZm9ybWF0cy5sZW5ndGgpIHtcbiAgICBpbmZvLmh0bWw1cGxheWVyID0gaW5mby5odG1sNXBsYXllciB8fFxuICAgICAgZ2V0SFRNTDVwbGF5ZXIoYXdhaXQgZ2V0V2F0Y2hIVE1MUGFnZUJvZHkoaWQsIG9wdGlvbnMpKSB8fCBnZXRIVE1MNXBsYXllcihhd2FpdCBnZXRFbWJlZFBhZ2VCb2R5KGlkLCBvcHRpb25zKSk7XG4gICAgaWYgKCFpbmZvLmh0bWw1cGxheWVyKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGZpbmQgaHRtbDVwbGF5ZXIgZmlsZScpO1xuICAgIH1cbiAgICBjb25zdCBodG1sNXBsYXllciA9IG5ldyBVUkwoaW5mby5odG1sNXBsYXllciwgQkFTRV9VUkwpLnRvU3RyaW5nKCk7XG4gICAgZnVuY3MucHVzaChzaWcuZGVjaXBoZXJGb3JtYXRzKGluZm8uZm9ybWF0cywgaHRtbDVwbGF5ZXIsIG9wdGlvbnMpKTtcbiAgfVxuICBpZiAoaGFzTWFuaWZlc3QgJiYgaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YS5kYXNoTWFuaWZlc3RVcmwpIHtcbiAgICBsZXQgdXJsID0gaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YS5kYXNoTWFuaWZlc3RVcmw7XG4gICAgZnVuY3MucHVzaChnZXREYXNoTWFuaWZlc3QodXJsLCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGhhc01hbmlmZXN0ICYmIGluZm8ucGxheWVyX3Jlc3BvbnNlLnN0cmVhbWluZ0RhdGEuaGxzTWFuaWZlc3RVcmwpIHtcbiAgICBsZXQgdXJsID0gaW5mby5wbGF5ZXJfcmVzcG9uc2Uuc3RyZWFtaW5nRGF0YS5obHNNYW5pZmVzdFVybDtcbiAgICBmdW5jcy5wdXNoKGdldE0zVTgodXJsLCBvcHRpb25zKSk7XG4gIH1cblxuICBsZXQgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGZ1bmNzKTtcbiAgaW5mby5mb3JtYXRzID0gT2JqZWN0LnZhbHVlcyhPYmplY3QuYXNzaWduKHt9LCAuLi5yZXN1bHRzKSk7XG4gIGluZm8uZm9ybWF0cyA9IGluZm8uZm9ybWF0cy5tYXAoZm9ybWF0VXRpbHMuYWRkRm9ybWF0TWV0YSk7XG4gIGluZm8uZm9ybWF0cy5zb3J0KGZvcm1hdFV0aWxzLnNvcnRGb3JtYXRzKTtcbiAgaW5mby5mdWxsID0gdHJ1ZTtcbiAgcmV0dXJuIGluZm87XG59O1xuXG5cbi8qKlxuICogR2V0cyBhZGRpdGlvbmFsIERBU0ggZm9ybWF0cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybnMge1Byb21pc2U8QXJyYXkuPE9iamVjdD4+fVxuICovXG5jb25zdCBnZXREYXNoTWFuaWZlc3QgPSAodXJsLCBvcHRpb25zKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGxldCBmb3JtYXRzID0ge307XG4gIGNvbnN0IHBhcnNlciA9IHNheC5wYXJzZXIoZmFsc2UpO1xuICBwYXJzZXIub25lcnJvciA9IHJlamVjdDtcbiAgbGV0IGFkYXB0YXRpb25TZXQ7XG4gIHBhcnNlci5vbm9wZW50YWcgPSBub2RlID0+IHtcbiAgICBpZiAobm9kZS5uYW1lID09PSAnQURBUFRBVElPTlNFVCcpIHtcbiAgICAgIGFkYXB0YXRpb25TZXQgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgfSBlbHNlIGlmIChub2RlLm5hbWUgPT09ICdSRVBSRVNFTlRBVElPTicpIHtcbiAgICAgIGNvbnN0IGl0YWcgPSBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuSUQpO1xuICAgICAgaWYgKCFpc05hTihpdGFnKSkge1xuICAgICAgICBmb3JtYXRzW3VybF0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICBpdGFnLCB1cmwsXG4gICAgICAgICAgYml0cmF0ZTogcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLkJBTkRXSURUSCksXG4gICAgICAgICAgbWltZVR5cGU6IGAke2FkYXB0YXRpb25TZXQuTUlNRVRZUEV9OyBjb2RlY3M9XCIke25vZGUuYXR0cmlidXRlcy5DT0RFQ1N9XCJgLFxuICAgICAgICB9LCBub2RlLmF0dHJpYnV0ZXMuSEVJR0hUID8ge1xuICAgICAgICAgIHdpZHRoOiBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuV0lEVEgpLFxuICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQobm9kZS5hdHRyaWJ1dGVzLkhFSUdIVCksXG4gICAgICAgICAgZnBzOiBwYXJzZUludChub2RlLmF0dHJpYnV0ZXMuRlJBTUVSQVRFKSxcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBhdWRpb1NhbXBsZVJhdGU6IG5vZGUuYXR0cmlidXRlcy5BVURJT1NBTVBMSU5HUkFURSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBwYXJzZXIub25lbmQgPSAoKSA9PiB7IHJlc29sdmUoZm9ybWF0cyk7IH07XG4gIGNvbnN0IHJlcSA9IHV0aWxzLmV4cG9zZWRNaW5pZ2V0KG5ldyBVUkwodXJsLCBCQVNFX1VSTCkudG9TdHJpbmcoKSwgb3B0aW9ucyk7XG4gIHJlcS5zZXRFbmNvZGluZygndXRmOCcpO1xuICByZXEub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgcmVxLm9uKCdkYXRhJywgY2h1bmsgPT4geyBwYXJzZXIud3JpdGUoY2h1bmspOyB9KTtcbiAgcmVxLm9uKCdlbmQnLCBwYXJzZXIuY2xvc2UuYmluZChwYXJzZXIpKTtcbn0pO1xuXG5cbi8qKlxuICogR2V0cyBhZGRpdGlvbmFsIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5LjxPYmplY3Q+Pn1cbiAqL1xuY29uc3QgZ2V0TTNVOCA9IGFzeW5jKHVybCwgb3B0aW9ucykgPT4ge1xuICB1cmwgPSBuZXcgVVJMKHVybCwgQkFTRV9VUkwpO1xuICBjb25zdCBib2R5ID0gYXdhaXQgdXRpbHMuZXhwb3NlZE1pbmlnZXQodXJsLnRvU3RyaW5nKCksIG9wdGlvbnMpLnRleHQoKTtcbiAgbGV0IGZvcm1hdHMgPSB7fTtcbiAgYm9keVxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuZmlsdGVyKGxpbmUgPT4gL15odHRwcz86XFwvXFwvLy50ZXN0KGxpbmUpKVxuICAgIC5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgY29uc3QgaXRhZyA9IHBhcnNlSW50KGxpbmUubWF0Y2goL1xcL2l0YWdcXC8oXFxkKylcXC8vKVsxXSk7XG4gICAgICBmb3JtYXRzW2xpbmVdID0geyBpdGFnLCB1cmw6IGxpbmUgfTtcbiAgICB9KTtcbiAgcmV0dXJuIGZvcm1hdHM7XG59O1xuXG5cbi8vIENhY2hlIGdldCBpbmZvIGZ1bmN0aW9ucy5cbi8vIEluIGNhc2UgYSB1c2VyIHdhbnRzIHRvIGdldCBhIHZpZGVvJ3MgaW5mbyBiZWZvcmUgZG93bmxvYWRpbmcuXG5mb3IgKGxldCBmdW5jTmFtZSBvZiBbJ2dldEJhc2ljSW5mbycsICdnZXRJbmZvJ10pIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59XG4gICAqL1xuICBjb25zdCBmdW5jID0gZXhwb3J0c1tmdW5jTmFtZV07XG4gIGV4cG9ydHNbZnVuY05hbWVdID0gYXN5bmMobGluaywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgdXRpbHMuY2hlY2tGb3JVcGRhdGVzKCk7XG4gICAgbGV0IGlkID0gYXdhaXQgdXJsVXRpbHMuZ2V0VmlkZW9JRChsaW5rKTtcbiAgICBjb25zdCBrZXkgPSBbZnVuY05hbWUsIGlkLCBvcHRpb25zLmxhbmddLmpvaW4oJy0nKTtcbiAgICByZXR1cm4gZXhwb3J0cy5jYWNoZS5nZXRPclNldChrZXksICgpID0+IGZ1bmMoaWQsIG9wdGlvbnMpKTtcbiAgfTtcbn1cblxuXG4vLyBFeHBvcnQgYSBmZXcgaGVscGVycy5cbmV4cG9ydHMudmFsaWRhdGVJRCA9IHVybFV0aWxzLnZhbGlkYXRlSUQ7XG5leHBvcnRzLnZhbGlkYXRlVVJMID0gdXJsVXRpbHMudmFsaWRhdGVVUkw7XG5leHBvcnRzLmdldFVSTFZpZGVvSUQgPSB1cmxVdGlscy5nZXRVUkxWaWRlb0lEO1xuZXhwb3J0cy5nZXRWaWRlb0lEID0gdXJsVXRpbHMuZ2V0VmlkZW9JRDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/info.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/sig.js":
/*!*******************************************!*\
  !*** ./node_modules/ytdl-core/lib/sig.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst Cache = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/ytdl-core/lib/cache.js\");\nconst utils = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/ytdl-core/lib/utils.js\");\nconst vm = __webpack_require__(/*! vm */ \"vm\");\n\n// A shared cache to keep track of html5player js functions.\nexports.cache = new Cache();\n\n/**\n * Extract signature deciphering and n parameter transform functions from html5player file.\n *\n * @param {string} html5playerfile\n * @param {Object} options\n * @returns {Promise<Array.<string>>}\n */\nexports.getFunctions = (html5playerfile, options) => exports.cache.getOrSet(html5playerfile, async() => {\n  const body = await utils.exposedMiniget(html5playerfile, options).text();\n  const functions = exports.extractFunctions(body);\n  if (!functions || !functions.length) {\n    throw Error('Could not extract functions');\n  }\n  exports.cache.set(html5playerfile, functions);\n  return functions;\n});\n\n/**\n * Extracts the actions that should be taken to decipher a signature\n * and tranform the n parameter\n *\n * @param {string} body\n * @returns {Array.<string>}\n */\nexports.extractFunctions = body => {\n  const functions = [];\n  const extractManipulations = caller => {\n    const functionName = utils.between(caller, `a=a.split(\"\");`, `.`);\n    if (!functionName) return '';\n    const functionStart = `var ${functionName}={`;\n    const ndx = body.indexOf(functionStart);\n    if (ndx < 0) return '';\n    const subBody = body.slice(ndx + functionStart.length - 1);\n    return `var ${functionName}=${utils.cutAfterJS(subBody)}`;\n  };\n  const extractDecipher = () => {\n    const functionName = utils.between(body, `a.set(\"alr\",\"yes\");c&&(c=`, `(decodeURIC`);\n    if (functionName && functionName.length) {\n      const functionStart = `${functionName}=function(a)`;\n      const ndx = body.indexOf(functionStart);\n      if (ndx >= 0) {\n        const subBody = body.slice(ndx + functionStart.length);\n        let functionBody = `var ${functionStart}${utils.cutAfterJS(subBody)}`;\n        functionBody = `${extractManipulations(functionBody)};${functionBody};${functionName}(sig);`;\n        functions.push(functionBody);\n      }\n    }\n  };\n  const extractNCode = () => {\n    let functionName = utils.between(body, `&&(b=a.get(\"n\"))&&(b=`, `(b)`);\n    if (functionName.includes('[')) functionName = utils.between(body, `var ${functionName.split('[')[0]}=[`, `]`);\n    if (functionName && functionName.length) {\n      const functionStart = `${functionName}=function(a)`;\n      const ndx = body.indexOf(functionStart);\n      if (ndx >= 0) {\n        const subBody = body.slice(ndx + functionStart.length);\n        const functionBody = `var ${functionStart}${utils.cutAfterJS(subBody)};${functionName}(ncode);`;\n        functions.push(functionBody);\n      }\n    }\n  };\n  extractDecipher();\n  extractNCode();\n  return functions;\n};\n\n/**\n * Apply decipher and n-transform to individual format\n *\n * @param {Object} format\n * @param {vm.Script} decipherScript\n * @param {vm.Script} nTransformScript\n */\nexports.setDownloadURL = (format, decipherScript, nTransformScript) => {\n  const decipher = url => {\n    const args = querystring.parse(url);\n    if (!args.s || !decipherScript) return args.url;\n    const components = new URL(decodeURIComponent(args.url));\n    components.searchParams.set(args.sp ? args.sp : 'signature',\n      decipherScript.runInNewContext({ sig: decodeURIComponent(args.s) }));\n    return components.toString();\n  };\n  const ncode = url => {\n    const components = new URL(decodeURIComponent(url));\n    const n = components.searchParams.get('n');\n    if (!n || !nTransformScript) return url;\n    components.searchParams.set('n', nTransformScript.runInNewContext({ ncode: n }));\n    return components.toString();\n  };\n  const cipher = !format.url;\n  const url = format.url || format.signatureCipher || format.cipher;\n  format.url = cipher ? ncode(decipher(url)) : ncode(url);\n  delete format.signatureCipher;\n  delete format.cipher;\n};\n\n/**\n * Applies decipher and n parameter transforms to all format URL's.\n *\n * @param {Array.<Object>} formats\n * @param {string} html5player\n * @param {Object} options\n */\nexports.decipherFormats = async(formats, html5player, options) => {\n  let decipheredFormats = {};\n  let functions = await exports.getFunctions(html5player, options);\n  const decipherScript = functions.length ? new vm.Script(functions[0]) : null;\n  const nTransformScript = functions.length > 1 ? new vm.Script(functions[1]) : null;\n  formats.forEach(format => {\n    exports.setDownloadURL(format, decipherScript, nTransformScript);\n    decipheredFormats[format.url] = format;\n  });\n  return decipheredFormats;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi9zaWcuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsY0FBYyxtQkFBTyxDQUFDLDREQUFTO0FBQy9CLGNBQWMsbUJBQU8sQ0FBQyw0REFBUztBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGlDQUFpQyxhQUFhLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWEsR0FBRywwQkFBMEI7QUFDNUQ7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxjQUFjLEVBQUUsMEJBQTBCO0FBQzVFLDBCQUEwQixvQ0FBb0MsRUFBRSxjQUFjLEVBQUUsYUFBYSxNQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSwyQkFBMkI7QUFDekc7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsY0FBYyxFQUFFLDJCQUEyQixFQUFFLGFBQWEsUUFBUTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxVQUFVO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vbm9kZV9tb2R1bGVzL3l0ZGwtY29yZS9saWIvc2lnLmpzPzVhODkiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgQ2FjaGUgPSByZXF1aXJlKCcuL2NhY2hlJyk7XG5jb25zdCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmNvbnN0IHZtID0gcmVxdWlyZSgndm0nKTtcblxuLy8gQSBzaGFyZWQgY2FjaGUgdG8ga2VlcCB0cmFjayBvZiBodG1sNXBsYXllciBqcyBmdW5jdGlvbnMuXG5leHBvcnRzLmNhY2hlID0gbmV3IENhY2hlKCk7XG5cbi8qKlxuICogRXh0cmFjdCBzaWduYXR1cmUgZGVjaXBoZXJpbmcgYW5kIG4gcGFyYW1ldGVyIHRyYW5zZm9ybSBmdW5jdGlvbnMgZnJvbSBodG1sNXBsYXllciBmaWxlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sNXBsYXllcmZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheS48c3RyaW5nPj59XG4gKi9cbmV4cG9ydHMuZ2V0RnVuY3Rpb25zID0gKGh0bWw1cGxheWVyZmlsZSwgb3B0aW9ucykgPT4gZXhwb3J0cy5jYWNoZS5nZXRPclNldChodG1sNXBsYXllcmZpbGUsIGFzeW5jKCkgPT4ge1xuICBjb25zdCBib2R5ID0gYXdhaXQgdXRpbHMuZXhwb3NlZE1pbmlnZXQoaHRtbDVwbGF5ZXJmaWxlLCBvcHRpb25zKS50ZXh0KCk7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IGV4cG9ydHMuZXh0cmFjdEZ1bmN0aW9ucyhib2R5KTtcbiAgaWYgKCFmdW5jdGlvbnMgfHwgIWZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGV4dHJhY3QgZnVuY3Rpb25zJyk7XG4gIH1cbiAgZXhwb3J0cy5jYWNoZS5zZXQoaHRtbDVwbGF5ZXJmaWxlLCBmdW5jdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb25zO1xufSk7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGFjdGlvbnMgdGhhdCBzaG91bGQgYmUgdGFrZW4gdG8gZGVjaXBoZXIgYSBzaWduYXR1cmVcbiAqIGFuZCB0cmFuZm9ybSB0aGUgbiBwYXJhbWV0ZXJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9keVxuICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxuICovXG5leHBvcnRzLmV4dHJhY3RGdW5jdGlvbnMgPSBib2R5ID0+IHtcbiAgY29uc3QgZnVuY3Rpb25zID0gW107XG4gIGNvbnN0IGV4dHJhY3RNYW5pcHVsYXRpb25zID0gY2FsbGVyID0+IHtcbiAgICBjb25zdCBmdW5jdGlvbk5hbWUgPSB1dGlscy5iZXR3ZWVuKGNhbGxlciwgYGE9YS5zcGxpdChcIlwiKTtgLCBgLmApO1xuICAgIGlmICghZnVuY3Rpb25OYW1lKSByZXR1cm4gJyc7XG4gICAgY29uc3QgZnVuY3Rpb25TdGFydCA9IGB2YXIgJHtmdW5jdGlvbk5hbWV9PXtgO1xuICAgIGNvbnN0IG5keCA9IGJvZHkuaW5kZXhPZihmdW5jdGlvblN0YXJ0KTtcbiAgICBpZiAobmR4IDwgMCkgcmV0dXJuICcnO1xuICAgIGNvbnN0IHN1YkJvZHkgPSBib2R5LnNsaWNlKG5keCArIGZ1bmN0aW9uU3RhcnQubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIGB2YXIgJHtmdW5jdGlvbk5hbWV9PSR7dXRpbHMuY3V0QWZ0ZXJKUyhzdWJCb2R5KX1gO1xuICB9O1xuICBjb25zdCBleHRyYWN0RGVjaXBoZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gdXRpbHMuYmV0d2Vlbihib2R5LCBgYS5zZXQoXCJhbHJcIixcInllc1wiKTtjJiYoYz1gLCBgKGRlY29kZVVSSUNgKTtcbiAgICBpZiAoZnVuY3Rpb25OYW1lICYmIGZ1bmN0aW9uTmFtZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uU3RhcnQgPSBgJHtmdW5jdGlvbk5hbWV9PWZ1bmN0aW9uKGEpYDtcbiAgICAgIGNvbnN0IG5keCA9IGJvZHkuaW5kZXhPZihmdW5jdGlvblN0YXJ0KTtcbiAgICAgIGlmIChuZHggPj0gMCkge1xuICAgICAgICBjb25zdCBzdWJCb2R5ID0gYm9keS5zbGljZShuZHggKyBmdW5jdGlvblN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgIGxldCBmdW5jdGlvbkJvZHkgPSBgdmFyICR7ZnVuY3Rpb25TdGFydH0ke3V0aWxzLmN1dEFmdGVySlMoc3ViQm9keSl9YDtcbiAgICAgICAgZnVuY3Rpb25Cb2R5ID0gYCR7ZXh0cmFjdE1hbmlwdWxhdGlvbnMoZnVuY3Rpb25Cb2R5KX07JHtmdW5jdGlvbkJvZHl9OyR7ZnVuY3Rpb25OYW1lfShzaWcpO2A7XG4gICAgICAgIGZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uQm9keSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBleHRyYWN0TkNvZGUgPSAoKSA9PiB7XG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IHV0aWxzLmJldHdlZW4oYm9keSwgYCYmKGI9YS5nZXQoXCJuXCIpKSYmKGI9YCwgYChiKWApO1xuICAgIGlmIChmdW5jdGlvbk5hbWUuaW5jbHVkZXMoJ1snKSkgZnVuY3Rpb25OYW1lID0gdXRpbHMuYmV0d2Vlbihib2R5LCBgdmFyICR7ZnVuY3Rpb25OYW1lLnNwbGl0KCdbJylbMF19PVtgLCBgXWApO1xuICAgIGlmIChmdW5jdGlvbk5hbWUgJiYgZnVuY3Rpb25OYW1lLmxlbmd0aCkge1xuICAgICAgY29uc3QgZnVuY3Rpb25TdGFydCA9IGAke2Z1bmN0aW9uTmFtZX09ZnVuY3Rpb24oYSlgO1xuICAgICAgY29uc3QgbmR4ID0gYm9keS5pbmRleE9mKGZ1bmN0aW9uU3RhcnQpO1xuICAgICAgaWYgKG5keCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IHN1YkJvZHkgPSBib2R5LnNsaWNlKG5keCArIGZ1bmN0aW9uU3RhcnQubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25Cb2R5ID0gYHZhciAke2Z1bmN0aW9uU3RhcnR9JHt1dGlscy5jdXRBZnRlckpTKHN1YkJvZHkpfTske2Z1bmN0aW9uTmFtZX0obmNvZGUpO2A7XG4gICAgICAgIGZ1bmN0aW9ucy5wdXNoKGZ1bmN0aW9uQm9keSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBleHRyYWN0RGVjaXBoZXIoKTtcbiAgZXh0cmFjdE5Db2RlKCk7XG4gIHJldHVybiBmdW5jdGlvbnM7XG59O1xuXG4vKipcbiAqIEFwcGx5IGRlY2lwaGVyIGFuZCBuLXRyYW5zZm9ybSB0byBpbmRpdmlkdWFsIGZvcm1hdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3JtYXRcbiAqIEBwYXJhbSB7dm0uU2NyaXB0fSBkZWNpcGhlclNjcmlwdFxuICogQHBhcmFtIHt2bS5TY3JpcHR9IG5UcmFuc2Zvcm1TY3JpcHRcbiAqL1xuZXhwb3J0cy5zZXREb3dubG9hZFVSTCA9IChmb3JtYXQsIGRlY2lwaGVyU2NyaXB0LCBuVHJhbnNmb3JtU2NyaXB0KSA9PiB7XG4gIGNvbnN0IGRlY2lwaGVyID0gdXJsID0+IHtcbiAgICBjb25zdCBhcmdzID0gcXVlcnlzdHJpbmcucGFyc2UodXJsKTtcbiAgICBpZiAoIWFyZ3MucyB8fCAhZGVjaXBoZXJTY3JpcHQpIHJldHVybiBhcmdzLnVybDtcbiAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQoYXJncy51cmwpKTtcbiAgICBjb21wb25lbnRzLnNlYXJjaFBhcmFtcy5zZXQoYXJncy5zcCA/IGFyZ3Muc3AgOiAnc2lnbmF0dXJlJyxcbiAgICAgIGRlY2lwaGVyU2NyaXB0LnJ1bkluTmV3Q29udGV4dCh7IHNpZzogZGVjb2RlVVJJQ29tcG9uZW50KGFyZ3MucykgfSkpO1xuICAgIHJldHVybiBjb21wb25lbnRzLnRvU3RyaW5nKCk7XG4gIH07XG4gIGNvbnN0IG5jb2RlID0gdXJsID0+IHtcbiAgICBjb25zdCBjb21wb25lbnRzID0gbmV3IFVSTChkZWNvZGVVUklDb21wb25lbnQodXJsKSk7XG4gICAgY29uc3QgbiA9IGNvbXBvbmVudHMuc2VhcmNoUGFyYW1zLmdldCgnbicpO1xuICAgIGlmICghbiB8fCAhblRyYW5zZm9ybVNjcmlwdCkgcmV0dXJuIHVybDtcbiAgICBjb21wb25lbnRzLnNlYXJjaFBhcmFtcy5zZXQoJ24nLCBuVHJhbnNmb3JtU2NyaXB0LnJ1bkluTmV3Q29udGV4dCh7IG5jb2RlOiBuIH0pKTtcbiAgICByZXR1cm4gY29tcG9uZW50cy50b1N0cmluZygpO1xuICB9O1xuICBjb25zdCBjaXBoZXIgPSAhZm9ybWF0LnVybDtcbiAgY29uc3QgdXJsID0gZm9ybWF0LnVybCB8fCBmb3JtYXQuc2lnbmF0dXJlQ2lwaGVyIHx8IGZvcm1hdC5jaXBoZXI7XG4gIGZvcm1hdC51cmwgPSBjaXBoZXIgPyBuY29kZShkZWNpcGhlcih1cmwpKSA6IG5jb2RlKHVybCk7XG4gIGRlbGV0ZSBmb3JtYXQuc2lnbmF0dXJlQ2lwaGVyO1xuICBkZWxldGUgZm9ybWF0LmNpcGhlcjtcbn07XG5cbi8qKlxuICogQXBwbGllcyBkZWNpcGhlciBhbmQgbiBwYXJhbWV0ZXIgdHJhbnNmb3JtcyB0byBhbGwgZm9ybWF0IFVSTCdzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGZvcm1hdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sNXBsYXllclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuZXhwb3J0cy5kZWNpcGhlckZvcm1hdHMgPSBhc3luYyhmb3JtYXRzLCBodG1sNXBsYXllciwgb3B0aW9ucykgPT4ge1xuICBsZXQgZGVjaXBoZXJlZEZvcm1hdHMgPSB7fTtcbiAgbGV0IGZ1bmN0aW9ucyA9IGF3YWl0IGV4cG9ydHMuZ2V0RnVuY3Rpb25zKGh0bWw1cGxheWVyLCBvcHRpb25zKTtcbiAgY29uc3QgZGVjaXBoZXJTY3JpcHQgPSBmdW5jdGlvbnMubGVuZ3RoID8gbmV3IHZtLlNjcmlwdChmdW5jdGlvbnNbMF0pIDogbnVsbDtcbiAgY29uc3QgblRyYW5zZm9ybVNjcmlwdCA9IGZ1bmN0aW9ucy5sZW5ndGggPiAxID8gbmV3IHZtLlNjcmlwdChmdW5jdGlvbnNbMV0pIDogbnVsbDtcbiAgZm9ybWF0cy5mb3JFYWNoKGZvcm1hdCA9PiB7XG4gICAgZXhwb3J0cy5zZXREb3dubG9hZFVSTChmb3JtYXQsIGRlY2lwaGVyU2NyaXB0LCBuVHJhbnNmb3JtU2NyaXB0KTtcbiAgICBkZWNpcGhlcmVkRm9ybWF0c1tmb3JtYXQudXJsXSA9IGZvcm1hdDtcbiAgfSk7XG4gIHJldHVybiBkZWNpcGhlcmVkRm9ybWF0cztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/sig.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/url-utils.js":
/*!*************************************************!*\
  !*** ./node_modules/ytdl-core/lib/url-utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Get video ID.\n *\n * There are a few type of video URL formats.\n *  - https://www.youtube.com/watch?v=VIDEO_ID\n *  - https://m.youtube.com/watch?v=VIDEO_ID\n *  - https://youtu.be/VIDEO_ID\n *  - https://www.youtube.com/v/VIDEO_ID\n *  - https://www.youtube.com/embed/VIDEO_ID\n *  - https://music.youtube.com/watch?v=VIDEO_ID\n *  - https://gaming.youtube.com/watch?v=VIDEO_ID\n *\n * @param {string} link\n * @return {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst validQueryDomains = new Set([\n  'youtube.com',\n  'www.youtube.com',\n  'm.youtube.com',\n  'music.youtube.com',\n  'gaming.youtube.com',\n]);\nconst validPathDomains = /^https?:\\/\\/(youtu\\.be\\/|(www\\.)?youtube\\.com\\/(embed|v|shorts)\\/)/;\nexports.getURLVideoID = link => {\n  const parsed = new URL(link.trim());\n  let id = parsed.searchParams.get('v');\n  if (validPathDomains.test(link.trim()) && !id) {\n    const paths = parsed.pathname.split('/');\n    id = parsed.host === 'youtu.be' ? paths[1] : paths[2];\n  } else if (parsed.hostname && !validQueryDomains.has(parsed.hostname)) {\n    throw Error('Not a YouTube domain');\n  }\n  if (!id) {\n    throw Error(`No video id found: \"${link}\"`);\n  }\n  id = id.substring(0, 11);\n  if (!exports.validateID(id)) {\n    throw TypeError(`Video id (${id}) does not match expected ` +\n      `format (${idRegex.toString()})`);\n  }\n  return id;\n};\n\n\n/**\n * Gets video ID either from a url or by checking if the given string\n * matches the video ID format.\n *\n * @param {string} str\n * @returns {string}\n * @throws {Error} If unable to find a id\n * @throws {TypeError} If videoid doesn't match specs\n */\nconst urlRegex = /^https?:\\/\\//;\nexports.getVideoID = str => {\n  if (exports.validateID(str)) {\n    return str;\n  } else if (urlRegex.test(str.trim())) {\n    return exports.getURLVideoID(str);\n  } else {\n    throw Error(`No video id found: ${str}`);\n  }\n};\n\n\n/**\n * Returns true if given id satifies YouTube's id format.\n *\n * @param {string} id\n * @return {boolean}\n */\nconst idRegex = /^[a-zA-Z0-9-_]{11}$/;\nexports.validateID = id => idRegex.test(id.trim());\n\n\n/**\n * Checks wether the input string includes a valid id.\n *\n * @param {string} string\n * @returns {boolean}\n */\nexports.validateURL = string => {\n  try {\n    exports.getURLVideoID(string);\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi91cmwtdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWixZQUFZLE9BQU87QUFDbkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2IsWUFBWSxPQUFPO0FBQ25CLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osc0NBQXNDLElBQUk7QUFDMUM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBLGdDQUFnQyxHQUFHO0FBQ25DLGtCQUFrQjs7O0FBR2xCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL25vZGVfbW9kdWxlcy95dGRsLWNvcmUvbGliL3VybC11dGlscy5qcz8yYzUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR2V0IHZpZGVvIElELlxuICpcbiAqIFRoZXJlIGFyZSBhIGZldyB0eXBlIG9mIHZpZGVvIFVSTCBmb3JtYXRzLlxuICogIC0gaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1WSURFT19JRFxuICogIC0gaHR0cHM6Ly9tLnlvdXR1YmUuY29tL3dhdGNoP3Y9VklERU9fSURcbiAqICAtIGh0dHBzOi8veW91dHUuYmUvVklERU9fSURcbiAqICAtIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3YvVklERU9fSURcbiAqICAtIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL1ZJREVPX0lEXG4gKiAgLSBodHRwczovL211c2ljLnlvdXR1YmUuY29tL3dhdGNoP3Y9VklERU9fSURcbiAqICAtIGh0dHBzOi8vZ2FtaW5nLnlvdXR1YmUuY29tL3dhdGNoP3Y9VklERU9fSURcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbGlua1xuICogQHJldHVybiB7c3RyaW5nfVxuICogQHRocm93cyB7RXJyb3J9IElmIHVuYWJsZSB0byBmaW5kIGEgaWRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgdmlkZW9pZCBkb2Vzbid0IG1hdGNoIHNwZWNzXG4gKi9cbmNvbnN0IHZhbGlkUXVlcnlEb21haW5zID0gbmV3IFNldChbXG4gICd5b3V0dWJlLmNvbScsXG4gICd3d3cueW91dHViZS5jb20nLFxuICAnbS55b3V0dWJlLmNvbScsXG4gICdtdXNpYy55b3V0dWJlLmNvbScsXG4gICdnYW1pbmcueW91dHViZS5jb20nLFxuXSk7XG5jb25zdCB2YWxpZFBhdGhEb21haW5zID0gL15odHRwcz86XFwvXFwvKHlvdXR1XFwuYmVcXC98KHd3d1xcLik/eW91dHViZVxcLmNvbVxcLyhlbWJlZHx2fHNob3J0cylcXC8pLztcbmV4cG9ydHMuZ2V0VVJMVmlkZW9JRCA9IGxpbmsgPT4ge1xuICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKGxpbmsudHJpbSgpKTtcbiAgbGV0IGlkID0gcGFyc2VkLnNlYXJjaFBhcmFtcy5nZXQoJ3YnKTtcbiAgaWYgKHZhbGlkUGF0aERvbWFpbnMudGVzdChsaW5rLnRyaW0oKSkgJiYgIWlkKSB7XG4gICAgY29uc3QgcGF0aHMgPSBwYXJzZWQucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICBpZCA9IHBhcnNlZC5ob3N0ID09PSAneW91dHUuYmUnID8gcGF0aHNbMV0gOiBwYXRoc1syXTtcbiAgfSBlbHNlIGlmIChwYXJzZWQuaG9zdG5hbWUgJiYgIXZhbGlkUXVlcnlEb21haW5zLmhhcyhwYXJzZWQuaG9zdG5hbWUpKSB7XG4gICAgdGhyb3cgRXJyb3IoJ05vdCBhIFlvdVR1YmUgZG9tYWluJyk7XG4gIH1cbiAgaWYgKCFpZCkge1xuICAgIHRocm93IEVycm9yKGBObyB2aWRlbyBpZCBmb3VuZDogXCIke2xpbmt9XCJgKTtcbiAgfVxuICBpZCA9IGlkLnN1YnN0cmluZygwLCAxMSk7XG4gIGlmICghZXhwb3J0cy52YWxpZGF0ZUlEKGlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcihgVmlkZW8gaWQgKCR7aWR9KSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBgICtcbiAgICAgIGBmb3JtYXQgKCR7aWRSZWdleC50b1N0cmluZygpfSlgKTtcbiAgfVxuICByZXR1cm4gaWQ7XG59O1xuXG5cbi8qKlxuICogR2V0cyB2aWRlbyBJRCBlaXRoZXIgZnJvbSBhIHVybCBvciBieSBjaGVja2luZyBpZiB0aGUgZ2l2ZW4gc3RyaW5nXG4gKiBtYXRjaGVzIHRoZSB2aWRlbyBJRCBmb3JtYXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB1bmFibGUgdG8gZmluZCBhIGlkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHZpZGVvaWQgZG9lc24ndCBtYXRjaCBzcGVjc1xuICovXG5jb25zdCB1cmxSZWdleCA9IC9eaHR0cHM/OlxcL1xcLy87XG5leHBvcnRzLmdldFZpZGVvSUQgPSBzdHIgPT4ge1xuICBpZiAoZXhwb3J0cy52YWxpZGF0ZUlEKHN0cikpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9IGVsc2UgaWYgKHVybFJlZ2V4LnRlc3Qoc3RyLnRyaW0oKSkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5nZXRVUkxWaWRlb0lEKHN0cik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoYE5vIHZpZGVvIGlkIGZvdW5kOiAke3N0cn1gKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBpZCBzYXRpZmllcyBZb3VUdWJlJ3MgaWQgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaWRSZWdleCA9IC9eW2EtekEtWjAtOS1fXXsxMX0kLztcbmV4cG9ydHMudmFsaWRhdGVJRCA9IGlkID0+IGlkUmVnZXgudGVzdChpZC50cmltKCkpO1xuXG5cbi8qKlxuICogQ2hlY2tzIHdldGhlciB0aGUgaW5wdXQgc3RyaW5nIGluY2x1ZGVzIGEgdmFsaWQgaWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMudmFsaWRhdGVVUkwgPSBzdHJpbmcgPT4ge1xuICB0cnkge1xuICAgIGV4cG9ydHMuZ2V0VVJMVmlkZW9JRChzdHJpbmcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/url-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/lib/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const miniget = __webpack_require__(/*! miniget */ \"(rsc)/./node_modules/miniget/dist/index.js\");\n\n\n/**\n * Extract string inbetween another.\n *\n * @param {string} haystack\n * @param {string} left\n * @param {string} right\n * @returns {string}\n */\nexports.between = (haystack, left, right) => {\n  let pos;\n  if (left instanceof RegExp) {\n    const match = haystack.match(left);\n    if (!match) { return ''; }\n    pos = match.index + match[0].length;\n  } else {\n    pos = haystack.indexOf(left);\n    if (pos === -1) { return ''; }\n    pos += left.length;\n  }\n  haystack = haystack.slice(pos);\n  pos = haystack.indexOf(right);\n  if (pos === -1) { return ''; }\n  haystack = haystack.slice(0, pos);\n  return haystack;\n};\n\n\n/**\n * Get a number from an abbreviated number string.\n *\n * @param {string} string\n * @returns {number}\n */\nexports.parseAbbreviatedNumber = string => {\n  const match = string\n    .replace(',', '.')\n    .replace(' ', '')\n    .match(/([\\d,.]+)([MK]?)/);\n  if (match) {\n    let [, num, multi] = match;\n    num = parseFloat(num);\n    return Math.round(multi === 'M' ? num * 1000000 :\n      multi === 'K' ? num * 1000 : num);\n  }\n  return null;\n};\n\n/**\n * Escape sequences for cutAfterJS\n * @param {string} start the character string the escape sequence\n * @param {string} end the character string to stop the escape seequence\n * @param {undefined|Regex} startPrefix a regex to check against the preceding 10 characters\n */\nconst ESCAPING_SEQUENZES = [\n  // Strings\n  { start: '\"', end: '\"' },\n  { start: \"'\", end: \"'\" },\n  { start: '`', end: '`' },\n  // RegeEx\n  { start: '/', end: '/', startPrefix: /(^|[[{:;,/])\\s?$/ },\n];\n\n/**\n * Match begin and end braces of input JS, return only JS\n *\n * @param {string} mixedJson\n * @returns {string}\n*/\nexports.cutAfterJS = mixedJson => {\n  // Define the general open and closing tag\n  let open, close;\n  if (mixedJson[0] === '[') {\n    open = '[';\n    close = ']';\n  } else if (mixedJson[0] === '{') {\n    open = '{';\n    close = '}';\n  }\n\n  if (!open) {\n    throw new Error(`Can't cut unsupported JSON (need to begin with [ or { ) but got: ${mixedJson[0]}`);\n  }\n\n  // States if the loop is currently inside an escaped js object\n  let isEscapedObject = null;\n\n  // States if the current character is treated as escaped or not\n  let isEscaped = false;\n\n  // Current open brackets to be closed\n  let counter = 0;\n\n  let i;\n  // Go through all characters from the start\n  for (i = 0; i < mixedJson.length; i++) {\n    // End of current escaped object\n    if (!isEscaped && isEscapedObject !== null && mixedJson[i] === isEscapedObject.end) {\n      isEscapedObject = null;\n      continue;\n    // Might be the start of a new escaped object\n    } else if (!isEscaped && isEscapedObject === null) {\n      for (const escaped of ESCAPING_SEQUENZES) {\n        if (mixedJson[i] !== escaped.start) continue;\n        // Test startPrefix against last 10 characters\n        if (!escaped.startPrefix || mixedJson.substring(i - 10, i).match(escaped.startPrefix)) {\n          isEscapedObject = escaped;\n          break;\n        }\n      }\n      // Continue if we found a new escaped object\n      if (isEscapedObject !== null) {\n        continue;\n      }\n    }\n\n    // Toggle the isEscaped boolean for every backslash\n    // Reset for every regular character\n    isEscaped = mixedJson[i] === '\\\\' && !isEscaped;\n\n    if (isEscapedObject !== null) continue;\n\n    if (mixedJson[i] === open) {\n      counter++;\n    } else if (mixedJson[i] === close) {\n      counter--;\n    }\n\n    // All brackets have been closed, thus end of JSON is reached\n    if (counter === 0) {\n      // Return the cut JSON\n      return mixedJson.substring(0, i + 1);\n    }\n  }\n\n  // We ran through the whole string and ended up with an unclosed bracket\n  throw Error(\"Can't cut unsupported JSON (no matching closing bracket found)\");\n};\n\n\n/**\n * Checks if there is a playability error.\n *\n * @param {Object} player_response\n * @param {Array.<string>} statuses\n * @param {Error} ErrorType\n * @returns {!Error}\n */\nexports.playError = (player_response, statuses, ErrorType = Error) => {\n  let playability = player_response && player_response.playabilityStatus;\n  if (playability && statuses.includes(playability.status)) {\n    return new ErrorType(playability.reason || (playability.messages && playability.messages[0]));\n  }\n  return null;\n};\n\n/**\n * Does a miniget request and calls options.requestCallback if present\n *\n * @param {string} url the request url\n * @param {Object} options an object with optional requestOptions and requestCallback parameters\n * @param {Object} requestOptionsOverwrite overwrite of options.requestOptions\n * @returns {miniget.Stream}\n */\nexports.exposedMiniget = (url, options = {}, requestOptionsOverwrite) => {\n  const req = miniget(url, requestOptionsOverwrite || options.requestOptions);\n  if (typeof options.requestCallback === 'function') options.requestCallback(req);\n  return req;\n};\n\n/**\n * Temporary helper to help deprecating a few properties.\n *\n * @param {Object} obj\n * @param {string} prop\n * @param {Object} value\n * @param {string} oldPath\n * @param {string} newPath\n */\nexports.deprecate = (obj, prop, value, oldPath, newPath) => {\n  Object.defineProperty(obj, prop, {\n    get: () => {\n      console.warn(`\\`${oldPath}\\` will be removed in a near future release, ` +\n        `use \\`${newPath}\\` instead.`);\n      return value;\n    },\n  });\n};\n\n\n// Check for updates.\nconst pkg = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/ytdl-core/package.json\");\nconst UPDATE_INTERVAL = 1000 * 60 * 60 * 12;\nexports.lastUpdateCheck = 0;\nexports.checkForUpdates = () => {\n  if (!process.env.YTDL_NO_UPDATE && !pkg.version.startsWith('0.0.0-') &&\n    Date.now() - exports.lastUpdateCheck >= UPDATE_INTERVAL) {\n    exports.lastUpdateCheck = Date.now();\n    return miniget('https://api.github.com/repos/fent/node-ytdl-core/releases/latest', {\n      headers: { 'User-Agent': 'ytdl-core' },\n    }).text().then(response => {\n      if (JSON.parse(response).tag_name !== `v${pkg.version}`) {\n        console.warn('\\x1b[33mWARNING:\\x1B[0m ytdl-core is out of date! Update with \"npm install ytdl-core@latest\".');\n      }\n    }, err => {\n      console.warn('Error checking for updates:', err.message);\n      console.warn('You can disable this check by setting the `YTDL_NO_UPDATE` env variable.');\n    });\n  }\n  return null;\n};\n\n\n/**\n * Gets random IPv6 Address from a block\n *\n * @param {string} ip the IPv6 block in CIDR-Notation\n * @returns {string}\n */\nexports.getRandomIPv6 = ip => {\n  // Start with a fast Regex-Check\n  if (!isIPv6(ip)) throw Error('Invalid IPv6 format');\n  // Start by splitting and normalizing addr and mask\n  const [rawAddr, rawMask] = ip.split('/');\n  let base10Mask = parseInt(rawMask);\n  if (!base10Mask || base10Mask > 128 || base10Mask < 24) throw Error('Invalid IPv6 subnet');\n  const base10addr = normalizeIP(rawAddr);\n  // Get random addr to pad with\n  // using Math.random since we're not requiring high level of randomness\n  const randomAddr = new Array(8).fill(1).map(() => Math.floor(Math.random() * 0xffff));\n\n  // Merge base10addr with randomAddr\n  const mergedAddr = randomAddr.map((randomItem, idx) => {\n    // Calculate the amount of static bits\n    const staticBits = Math.min(base10Mask, 16);\n    // Adjust the bitmask with the staticBits\n    base10Mask -= staticBits;\n    // Calculate the bitmask\n    // lsb makes the calculation way more complicated\n    const mask = 0xffff - ((2 ** (16 - staticBits)) - 1);\n    // Combine base10addr and random\n    return (base10addr[idx] & mask) + (randomItem & (mask ^ 0xffff));\n  });\n  // Return new addr\n  return mergedAddr.map(x => x.toString('16')).join(':');\n};\n\n\n// eslint-disable-next-line max-len\nconst IPV6_REGEX = /^(([0-9a-f]{1,4}:)(:[0-9a-f]{1,4}){1,6}|([0-9a-f]{1,4}:){1,2}(:[0-9a-f]{1,4}){1,5}|([0-9a-f]{1,4}:){1,3}(:[0-9a-f]{1,4}){1,4}|([0-9a-f]{1,4}:){1,4}(:[0-9a-f]{1,4}){1,3}|([0-9a-f]{1,4}:){1,5}(:[0-9a-f]{1,4}){1,2}|([0-9a-f]{1,4}:){1,6}(:[0-9a-f]{1,4})|([0-9a-f]{1,4}:){1,7}(([0-9a-f]{1,4})|:))\\/(1[0-1]\\d|12[0-8]|\\d{1,2})$/;\n/**\n * Quick check for a valid IPv6\n * The Regex only accepts a subset of all IPv6 Addresses\n *\n * @param {string} ip the IPv6 block in CIDR-Notation to test\n * @returns {boolean} true if valid\n */\nconst isIPv6 = exports.isIPv6 = ip => IPV6_REGEX.test(ip);\n\n\n/**\n * Normalise an IP Address\n *\n * @param {string} ip the IPv6 Addr\n * @returns {number[]} the 8 parts of the IPv6 as Integers\n */\nconst normalizeIP = exports.normalizeIP = ip => {\n  // Split by fill position\n  const parts = ip.split('::').map(x => x.split(':'));\n  // Normalize start and end\n  const partStart = parts[0] || [];\n  const partEnd = parts[1] || [];\n  partEnd.reverse();\n  // Placeholder for full ip\n  const fullIP = new Array(8).fill(0);\n  // Fill in start and end parts\n  for (let i = 0; i < Math.min(partStart.length, 8); i++) {\n    fullIP[i] = parseInt(partStart[i], 16) || 0;\n  }\n  for (let i = 0; i < Math.min(partEnd.length, 8); i++) {\n    fullIP[7 - i] = parseInt(partEnd[i], 16) || 0;\n  }\n  return fullIP;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQywyREFBUzs7O0FBR2pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQixJQUFJLHNCQUFzQjtBQUMxQixJQUFJLHNCQUFzQjtBQUMxQjtBQUNBLElBQUksMENBQTBDLEVBQUUsV0FBVztBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxhQUFhO0FBQ2IsY0FBYztBQUNkOztBQUVBO0FBQ0EsMkVBQTJFLGFBQWEsYUFBYTtBQUNyRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGdCQUFnQjtBQUMzQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7O0FBR0E7QUFDQSxZQUFZLG1CQUFPLENBQUMsb0VBQWlCO0FBQ3JDO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsSUFBSSx1QkFBdUI7QUFDM0I7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDLEtBQUs7QUFDTCxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdDQUFnQyxJQUFJLGFBQWEsSUFBSSxFQUFFLElBQUksV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksRUFBRSxJQUFJLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLEVBQUUsSUFBSSxXQUFXLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxFQUFFLElBQUksV0FBVyxJQUFJLEdBQUcsSUFBSSxXQUFXLElBQUksRUFBRSxJQUFJLFdBQVcsSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLFlBQVksSUFBSSxHQUFHLElBQUksV0FBVyxJQUFJLDRCQUE0QixJQUFJO0FBQ2xWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBLGVBQWUsY0FBYzs7O0FBRzdCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFVBQVU7QUFDdkI7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQ0FBbUM7QUFDckQ7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9ub2RlX21vZHVsZXMveXRkbC1jb3JlL2xpYi91dGlscy5qcz8zNzM4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG1pbmlnZXQgPSByZXF1aXJlKCdtaW5pZ2V0Jyk7XG5cblxuLyoqXG4gKiBFeHRyYWN0IHN0cmluZyBpbmJldHdlZW4gYW5vdGhlci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaGF5c3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XG4gKiBAcGFyYW0ge3N0cmluZ30gcmlnaHRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMuYmV0d2VlbiA9IChoYXlzdGFjaywgbGVmdCwgcmlnaHQpID0+IHtcbiAgbGV0IHBvcztcbiAgaWYgKGxlZnQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICBjb25zdCBtYXRjaCA9IGhheXN0YWNrLm1hdGNoKGxlZnQpO1xuICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuICcnOyB9XG4gICAgcG9zID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcG9zID0gaGF5c3RhY2suaW5kZXhPZihsZWZ0KTtcbiAgICBpZiAocG9zID09PSAtMSkgeyByZXR1cm4gJyc7IH1cbiAgICBwb3MgKz0gbGVmdC5sZW5ndGg7XG4gIH1cbiAgaGF5c3RhY2sgPSBoYXlzdGFjay5zbGljZShwb3MpO1xuICBwb3MgPSBoYXlzdGFjay5pbmRleE9mKHJpZ2h0KTtcbiAgaWYgKHBvcyA9PT0gLTEpIHsgcmV0dXJuICcnOyB9XG4gIGhheXN0YWNrID0gaGF5c3RhY2suc2xpY2UoMCwgcG9zKTtcbiAgcmV0dXJuIGhheXN0YWNrO1xufTtcblxuXG4vKipcbiAqIEdldCBhIG51bWJlciBmcm9tIGFuIGFiYnJldmlhdGVkIG51bWJlciBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5wYXJzZUFiYnJldmlhdGVkTnVtYmVyID0gc3RyaW5nID0+IHtcbiAgY29uc3QgbWF0Y2ggPSBzdHJpbmdcbiAgICAucmVwbGFjZSgnLCcsICcuJylcbiAgICAucmVwbGFjZSgnICcsICcnKVxuICAgIC5tYXRjaCgvKFtcXGQsLl0rKShbTUtdPykvKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgbGV0IFssIG51bSwgbXVsdGldID0gbWF0Y2g7XG4gICAgbnVtID0gcGFyc2VGbG9hdChudW0pO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG11bHRpID09PSAnTScgPyBudW0gKiAxMDAwMDAwIDpcbiAgICAgIG11bHRpID09PSAnSycgPyBudW0gKiAxMDAwIDogbnVtKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRXNjYXBlIHNlcXVlbmNlcyBmb3IgY3V0QWZ0ZXJKU1xuICogQHBhcmFtIHtzdHJpbmd9IHN0YXJ0IHRoZSBjaGFyYWN0ZXIgc3RyaW5nIHRoZSBlc2NhcGUgc2VxdWVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmQgdGhlIGNoYXJhY3RlciBzdHJpbmcgdG8gc3RvcCB0aGUgZXNjYXBlIHNlZXF1ZW5jZVxuICogQHBhcmFtIHt1bmRlZmluZWR8UmVnZXh9IHN0YXJ0UHJlZml4IGEgcmVnZXggdG8gY2hlY2sgYWdhaW5zdCB0aGUgcHJlY2VkaW5nIDEwIGNoYXJhY3RlcnNcbiAqL1xuY29uc3QgRVNDQVBJTkdfU0VRVUVOWkVTID0gW1xuICAvLyBTdHJpbmdzXG4gIHsgc3RhcnQ6ICdcIicsIGVuZDogJ1wiJyB9LFxuICB7IHN0YXJ0OiBcIidcIiwgZW5kOiBcIidcIiB9LFxuICB7IHN0YXJ0OiAnYCcsIGVuZDogJ2AnIH0sXG4gIC8vIFJlZ2VFeFxuICB7IHN0YXJ0OiAnLycsIGVuZDogJy8nLCBzdGFydFByZWZpeDogLyhefFtbezo7LC9dKVxccz8kLyB9LFxuXTtcblxuLyoqXG4gKiBNYXRjaCBiZWdpbiBhbmQgZW5kIGJyYWNlcyBvZiBpbnB1dCBKUywgcmV0dXJuIG9ubHkgSlNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWl4ZWRKc29uXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuKi9cbmV4cG9ydHMuY3V0QWZ0ZXJKUyA9IG1peGVkSnNvbiA9PiB7XG4gIC8vIERlZmluZSB0aGUgZ2VuZXJhbCBvcGVuIGFuZCBjbG9zaW5nIHRhZ1xuICBsZXQgb3BlbiwgY2xvc2U7XG4gIGlmIChtaXhlZEpzb25bMF0gPT09ICdbJykge1xuICAgIG9wZW4gPSAnWyc7XG4gICAgY2xvc2UgPSAnXSc7XG4gIH0gZWxzZSBpZiAobWl4ZWRKc29uWzBdID09PSAneycpIHtcbiAgICBvcGVuID0gJ3snO1xuICAgIGNsb3NlID0gJ30nO1xuICB9XG5cbiAgaWYgKCFvcGVuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjdXQgdW5zdXBwb3J0ZWQgSlNPTiAobmVlZCB0byBiZWdpbiB3aXRoIFsgb3IgeyApIGJ1dCBnb3Q6ICR7bWl4ZWRKc29uWzBdfWApO1xuICB9XG5cbiAgLy8gU3RhdGVzIGlmIHRoZSBsb29wIGlzIGN1cnJlbnRseSBpbnNpZGUgYW4gZXNjYXBlZCBqcyBvYmplY3RcbiAgbGV0IGlzRXNjYXBlZE9iamVjdCA9IG51bGw7XG5cbiAgLy8gU3RhdGVzIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyB0cmVhdGVkIGFzIGVzY2FwZWQgb3Igbm90XG4gIGxldCBpc0VzY2FwZWQgPSBmYWxzZTtcblxuICAvLyBDdXJyZW50IG9wZW4gYnJhY2tldHMgdG8gYmUgY2xvc2VkXG4gIGxldCBjb3VudGVyID0gMDtcblxuICBsZXQgaTtcbiAgLy8gR28gdGhyb3VnaCBhbGwgY2hhcmFjdGVycyBmcm9tIHRoZSBzdGFydFxuICBmb3IgKGkgPSAwOyBpIDwgbWl4ZWRKc29uLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gRW5kIG9mIGN1cnJlbnQgZXNjYXBlZCBvYmplY3RcbiAgICBpZiAoIWlzRXNjYXBlZCAmJiBpc0VzY2FwZWRPYmplY3QgIT09IG51bGwgJiYgbWl4ZWRKc29uW2ldID09PSBpc0VzY2FwZWRPYmplY3QuZW5kKSB7XG4gICAgICBpc0VzY2FwZWRPYmplY3QgPSBudWxsO1xuICAgICAgY29udGludWU7XG4gICAgLy8gTWlnaHQgYmUgdGhlIHN0YXJ0IG9mIGEgbmV3IGVzY2FwZWQgb2JqZWN0XG4gICAgfSBlbHNlIGlmICghaXNFc2NhcGVkICYmIGlzRXNjYXBlZE9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlc2NhcGVkIG9mIEVTQ0FQSU5HX1NFUVVFTlpFUykge1xuICAgICAgICBpZiAobWl4ZWRKc29uW2ldICE9PSBlc2NhcGVkLnN0YXJ0KSBjb250aW51ZTtcbiAgICAgICAgLy8gVGVzdCBzdGFydFByZWZpeCBhZ2FpbnN0IGxhc3QgMTAgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoIWVzY2FwZWQuc3RhcnRQcmVmaXggfHwgbWl4ZWRKc29uLnN1YnN0cmluZyhpIC0gMTAsIGkpLm1hdGNoKGVzY2FwZWQuc3RhcnRQcmVmaXgpKSB7XG4gICAgICAgICAgaXNFc2NhcGVkT2JqZWN0ID0gZXNjYXBlZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ29udGludWUgaWYgd2UgZm91bmQgYSBuZXcgZXNjYXBlZCBvYmplY3RcbiAgICAgIGlmIChpc0VzY2FwZWRPYmplY3QgIT09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVG9nZ2xlIHRoZSBpc0VzY2FwZWQgYm9vbGVhbiBmb3IgZXZlcnkgYmFja3NsYXNoXG4gICAgLy8gUmVzZXQgZm9yIGV2ZXJ5IHJlZ3VsYXIgY2hhcmFjdGVyXG4gICAgaXNFc2NhcGVkID0gbWl4ZWRKc29uW2ldID09PSAnXFxcXCcgJiYgIWlzRXNjYXBlZDtcblxuICAgIGlmIChpc0VzY2FwZWRPYmplY3QgIT09IG51bGwpIGNvbnRpbnVlO1xuXG4gICAgaWYgKG1peGVkSnNvbltpXSA9PT0gb3Blbikge1xuICAgICAgY291bnRlcisrO1xuICAgIH0gZWxzZSBpZiAobWl4ZWRKc29uW2ldID09PSBjbG9zZSkge1xuICAgICAgY291bnRlci0tO1xuICAgIH1cblxuICAgIC8vIEFsbCBicmFja2V0cyBoYXZlIGJlZW4gY2xvc2VkLCB0aHVzIGVuZCBvZiBKU09OIGlzIHJlYWNoZWRcbiAgICBpZiAoY291bnRlciA9PT0gMCkge1xuICAgICAgLy8gUmV0dXJuIHRoZSBjdXQgSlNPTlxuICAgICAgcmV0dXJuIG1peGVkSnNvbi5zdWJzdHJpbmcoMCwgaSArIDEpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIHJhbiB0aHJvdWdoIHRoZSB3aG9sZSBzdHJpbmcgYW5kIGVuZGVkIHVwIHdpdGggYW4gdW5jbG9zZWQgYnJhY2tldFxuICB0aHJvdyBFcnJvcihcIkNhbid0IGN1dCB1bnN1cHBvcnRlZCBKU09OIChubyBtYXRjaGluZyBjbG9zaW5nIGJyYWNrZXQgZm91bmQpXCIpO1xufTtcblxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGVyZSBpcyBhIHBsYXlhYmlsaXR5IGVycm9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwbGF5ZXJfcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHN0YXR1c2VzXG4gKiBAcGFyYW0ge0Vycm9yfSBFcnJvclR5cGVcbiAqIEByZXR1cm5zIHshRXJyb3J9XG4gKi9cbmV4cG9ydHMucGxheUVycm9yID0gKHBsYXllcl9yZXNwb25zZSwgc3RhdHVzZXMsIEVycm9yVHlwZSA9IEVycm9yKSA9PiB7XG4gIGxldCBwbGF5YWJpbGl0eSA9IHBsYXllcl9yZXNwb25zZSAmJiBwbGF5ZXJfcmVzcG9uc2UucGxheWFiaWxpdHlTdGF0dXM7XG4gIGlmIChwbGF5YWJpbGl0eSAmJiBzdGF0dXNlcy5pbmNsdWRlcyhwbGF5YWJpbGl0eS5zdGF0dXMpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvclR5cGUocGxheWFiaWxpdHkucmVhc29uIHx8IChwbGF5YWJpbGl0eS5tZXNzYWdlcyAmJiBwbGF5YWJpbGl0eS5tZXNzYWdlc1swXSkpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBEb2VzIGEgbWluaWdldCByZXF1ZXN0IGFuZCBjYWxscyBvcHRpb25zLnJlcXVlc3RDYWxsYmFjayBpZiBwcmVzZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgcmVxdWVzdCB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHJlcXVlc3RPcHRpb25zIGFuZCByZXF1ZXN0Q2FsbGJhY2sgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zT3ZlcndyaXRlIG92ZXJ3cml0ZSBvZiBvcHRpb25zLnJlcXVlc3RPcHRpb25zXG4gKiBAcmV0dXJucyB7bWluaWdldC5TdHJlYW19XG4gKi9cbmV4cG9ydHMuZXhwb3NlZE1pbmlnZXQgPSAodXJsLCBvcHRpb25zID0ge30sIHJlcXVlc3RPcHRpb25zT3ZlcndyaXRlKSA9PiB7XG4gIGNvbnN0IHJlcSA9IG1pbmlnZXQodXJsLCByZXF1ZXN0T3B0aW9uc092ZXJ3cml0ZSB8fCBvcHRpb25zLnJlcXVlc3RPcHRpb25zKTtcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnJlcXVlc3RDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgb3B0aW9ucy5yZXF1ZXN0Q2FsbGJhY2socmVxKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogVGVtcG9yYXJ5IGhlbHBlciB0byBoZWxwIGRlcHJlY2F0aW5nIGEgZmV3IHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IG9sZFBhdGhcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdQYXRoXG4gKi9cbmV4cG9ydHMuZGVwcmVjYXRlID0gKG9iaiwgcHJvcCwgdmFsdWUsIG9sZFBhdGgsIG5ld1BhdGgpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKGBcXGAke29sZFBhdGh9XFxgIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIG5lYXIgZnV0dXJlIHJlbGVhc2UsIGAgK1xuICAgICAgICBgdXNlIFxcYCR7bmV3UGF0aH1cXGAgaW5zdGVhZC5gKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICB9KTtcbn07XG5cblxuLy8gQ2hlY2sgZm9yIHVwZGF0ZXMuXG5jb25zdCBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbmNvbnN0IFVQREFURV9JTlRFUlZBTCA9IDEwMDAgKiA2MCAqIDYwICogMTI7XG5leHBvcnRzLmxhc3RVcGRhdGVDaGVjayA9IDA7XG5leHBvcnRzLmNoZWNrRm9yVXBkYXRlcyA9ICgpID0+IHtcbiAgaWYgKCFwcm9jZXNzLmVudi5ZVERMX05PX1VQREFURSAmJiAhcGtnLnZlcnNpb24uc3RhcnRzV2l0aCgnMC4wLjAtJykgJiZcbiAgICBEYXRlLm5vdygpIC0gZXhwb3J0cy5sYXN0VXBkYXRlQ2hlY2sgPj0gVVBEQVRFX0lOVEVSVkFMKSB7XG4gICAgZXhwb3J0cy5sYXN0VXBkYXRlQ2hlY2sgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiBtaW5pZ2V0KCdodHRwczovL2FwaS5naXRodWIuY29tL3JlcG9zL2ZlbnQvbm9kZS15dGRsLWNvcmUvcmVsZWFzZXMvbGF0ZXN0Jywge1xuICAgICAgaGVhZGVyczogeyAnVXNlci1BZ2VudCc6ICd5dGRsLWNvcmUnIH0sXG4gICAgfSkudGV4dCgpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKEpTT04ucGFyc2UocmVzcG9uc2UpLnRhZ19uYW1lICE9PSBgdiR7cGtnLnZlcnNpb259YCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1xceDFiWzMzbVdBUk5JTkc6XFx4MUJbMG0geXRkbC1jb3JlIGlzIG91dCBvZiBkYXRlISBVcGRhdGUgd2l0aCBcIm5wbSBpbnN0YWxsIHl0ZGwtY29yZUBsYXRlc3RcIi4nKTtcbiAgICAgIH1cbiAgICB9LCBlcnIgPT4ge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvciBjaGVja2luZyBmb3IgdXBkYXRlczonLCBlcnIubWVzc2FnZSk7XG4gICAgICBjb25zb2xlLndhcm4oJ1lvdSBjYW4gZGlzYWJsZSB0aGlzIGNoZWNrIGJ5IHNldHRpbmcgdGhlIGBZVERMX05PX1VQREFURWAgZW52IHZhcmlhYmxlLicpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuXG4vKipcbiAqIEdldHMgcmFuZG9tIElQdjYgQWRkcmVzcyBmcm9tIGEgYmxvY2tcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaXAgdGhlIElQdjYgYmxvY2sgaW4gQ0lEUi1Ob3RhdGlvblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5nZXRSYW5kb21JUHY2ID0gaXAgPT4ge1xuICAvLyBTdGFydCB3aXRoIGEgZmFzdCBSZWdleC1DaGVja1xuICBpZiAoIWlzSVB2NihpcCkpIHRocm93IEVycm9yKCdJbnZhbGlkIElQdjYgZm9ybWF0Jyk7XG4gIC8vIFN0YXJ0IGJ5IHNwbGl0dGluZyBhbmQgbm9ybWFsaXppbmcgYWRkciBhbmQgbWFza1xuICBjb25zdCBbcmF3QWRkciwgcmF3TWFza10gPSBpcC5zcGxpdCgnLycpO1xuICBsZXQgYmFzZTEwTWFzayA9IHBhcnNlSW50KHJhd01hc2spO1xuICBpZiAoIWJhc2UxME1hc2sgfHwgYmFzZTEwTWFzayA+IDEyOCB8fCBiYXNlMTBNYXNrIDwgMjQpIHRocm93IEVycm9yKCdJbnZhbGlkIElQdjYgc3VibmV0Jyk7XG4gIGNvbnN0IGJhc2UxMGFkZHIgPSBub3JtYWxpemVJUChyYXdBZGRyKTtcbiAgLy8gR2V0IHJhbmRvbSBhZGRyIHRvIHBhZCB3aXRoXG4gIC8vIHVzaW5nIE1hdGgucmFuZG9tIHNpbmNlIHdlJ3JlIG5vdCByZXF1aXJpbmcgaGlnaCBsZXZlbCBvZiByYW5kb21uZXNzXG4gIGNvbnN0IHJhbmRvbUFkZHIgPSBuZXcgQXJyYXkoOCkuZmlsbCgxKS5tYXAoKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmKSk7XG5cbiAgLy8gTWVyZ2UgYmFzZTEwYWRkciB3aXRoIHJhbmRvbUFkZHJcbiAgY29uc3QgbWVyZ2VkQWRkciA9IHJhbmRvbUFkZHIubWFwKChyYW5kb21JdGVtLCBpZHgpID0+IHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGFtb3VudCBvZiBzdGF0aWMgYml0c1xuICAgIGNvbnN0IHN0YXRpY0JpdHMgPSBNYXRoLm1pbihiYXNlMTBNYXNrLCAxNik7XG4gICAgLy8gQWRqdXN0IHRoZSBiaXRtYXNrIHdpdGggdGhlIHN0YXRpY0JpdHNcbiAgICBiYXNlMTBNYXNrIC09IHN0YXRpY0JpdHM7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiaXRtYXNrXG4gICAgLy8gbHNiIG1ha2VzIHRoZSBjYWxjdWxhdGlvbiB3YXkgbW9yZSBjb21wbGljYXRlZFxuICAgIGNvbnN0IG1hc2sgPSAweGZmZmYgLSAoKDIgKiogKDE2IC0gc3RhdGljQml0cykpIC0gMSk7XG4gICAgLy8gQ29tYmluZSBiYXNlMTBhZGRyIGFuZCByYW5kb21cbiAgICByZXR1cm4gKGJhc2UxMGFkZHJbaWR4XSAmIG1hc2spICsgKHJhbmRvbUl0ZW0gJiAobWFzayBeIDB4ZmZmZikpO1xuICB9KTtcbiAgLy8gUmV0dXJuIG5ldyBhZGRyXG4gIHJldHVybiBtZXJnZWRBZGRyLm1hcCh4ID0+IHgudG9TdHJpbmcoJzE2JykpLmpvaW4oJzonKTtcbn07XG5cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbmNvbnN0IElQVjZfUkVHRVggPSAvXigoWzAtOWEtZl17MSw0fTopKDpbMC05YS1mXXsxLDR9KXsxLDZ9fChbMC05YS1mXXsxLDR9Oil7MSwyfSg6WzAtOWEtZl17MSw0fSl7MSw1fXwoWzAtOWEtZl17MSw0fTopezEsM30oOlswLTlhLWZdezEsNH0pezEsNH18KFswLTlhLWZdezEsNH06KXsxLDR9KDpbMC05YS1mXXsxLDR9KXsxLDN9fChbMC05YS1mXXsxLDR9Oil7MSw1fSg6WzAtOWEtZl17MSw0fSl7MSwyfXwoWzAtOWEtZl17MSw0fTopezEsNn0oOlswLTlhLWZdezEsNH0pfChbMC05YS1mXXsxLDR9Oil7MSw3fSgoWzAtOWEtZl17MSw0fSl8OikpXFwvKDFbMC0xXVxcZHwxMlswLThdfFxcZHsxLDJ9KSQvO1xuLyoqXG4gKiBRdWljayBjaGVjayBmb3IgYSB2YWxpZCBJUHY2XG4gKiBUaGUgUmVnZXggb25seSBhY2NlcHRzIGEgc3Vic2V0IG9mIGFsbCBJUHY2IEFkZHJlc3Nlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpcCB0aGUgSVB2NiBibG9jayBpbiBDSURSLU5vdGF0aW9uIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHZhbGlkXG4gKi9cbmNvbnN0IGlzSVB2NiA9IGV4cG9ydHMuaXNJUHY2ID0gaXAgPT4gSVBWNl9SRUdFWC50ZXN0KGlwKTtcblxuXG4vKipcbiAqIE5vcm1hbGlzZSBhbiBJUCBBZGRyZXNzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlwIHRoZSBJUHY2IEFkZHJcbiAqIEByZXR1cm5zIHtudW1iZXJbXX0gdGhlIDggcGFydHMgb2YgdGhlIElQdjYgYXMgSW50ZWdlcnNcbiAqL1xuY29uc3Qgbm9ybWFsaXplSVAgPSBleHBvcnRzLm5vcm1hbGl6ZUlQID0gaXAgPT4ge1xuICAvLyBTcGxpdCBieSBmaWxsIHBvc2l0aW9uXG4gIGNvbnN0IHBhcnRzID0gaXAuc3BsaXQoJzo6JykubWFwKHggPT4geC5zcGxpdCgnOicpKTtcbiAgLy8gTm9ybWFsaXplIHN0YXJ0IGFuZCBlbmRcbiAgY29uc3QgcGFydFN0YXJ0ID0gcGFydHNbMF0gfHwgW107XG4gIGNvbnN0IHBhcnRFbmQgPSBwYXJ0c1sxXSB8fCBbXTtcbiAgcGFydEVuZC5yZXZlcnNlKCk7XG4gIC8vIFBsYWNlaG9sZGVyIGZvciBmdWxsIGlwXG4gIGNvbnN0IGZ1bGxJUCA9IG5ldyBBcnJheSg4KS5maWxsKDApO1xuICAvLyBGaWxsIGluIHN0YXJ0IGFuZCBlbmQgcGFydHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihwYXJ0U3RhcnQubGVuZ3RoLCA4KTsgaSsrKSB7XG4gICAgZnVsbElQW2ldID0gcGFyc2VJbnQocGFydFN0YXJ0W2ldLCAxNikgfHwgMDtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWluKHBhcnRFbmQubGVuZ3RoLCA4KTsgaSsrKSB7XG4gICAgZnVsbElQWzcgLSBpXSA9IHBhcnNlSW50KHBhcnRFbmRbaV0sIDE2KSB8fCAwO1xuICB9XG4gIHJldHVybiBmdWxsSVA7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ytdl-core/lib/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ytdl-core/package.json":
/*!*********************************************!*\
  !*** ./node_modules/ytdl-core/package.json ***!
  \*********************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"ytdl-core","description":"YouTube video downloader in pure javascript.","keywords":["youtube","video","download"],"version":"4.11.5","repository":{"type":"git","url":"git://github.com/fent/node-ytdl-core.git"},"author":"fent <fentbox@gmail.com> (https://github.com/fent)","contributors":["Tobias Kutscha (https://github.com/TimeForANinja)","Andrew Kelley (https://github.com/andrewrk)","Mauricio Allende (https://github.com/mallendeo)","Rodrigo Altamirano (https://github.com/raltamirano)","Jim Buck (https://github.com/JimmyBoh)","Paweł Ruciński (https://github.com/Roki100)","Alexander Paolini (https://github.com/Million900o)"],"main":"./lib/index.js","types":"./typings/index.d.ts","files":["lib","typings"],"scripts":{"test":"nyc --reporter=lcov --reporter=text-summary npm run test:unit","test:unit":"mocha --ignore test/irl-test.js test/*-test.js --timeout 4000","test:irl":"mocha --timeout 16000 test/irl-test.js","lint":"eslint ./","lint:fix":"eslint --fix ./","lint:typings":"tslint typings/index.d.ts","lint:typings:fix":"tslint --fix typings/index.d.ts"},"dependencies":{"m3u8stream":"^0.8.6","miniget":"^4.2.2","sax":"^1.1.3"},"devDependencies":{"@types/node":"^13.1.0","assert-diff":"^3.0.1","dtslint":"^3.6.14","eslint":"^6.8.0","mocha":"^7.0.0","muk-require":"^1.2.0","nock":"^13.0.4","nyc":"^15.0.0","sinon":"^9.0.0","stream-equal":"~1.1.0","typescript":"^3.9.7"},"engines":{"node":">=12"},"license":"MIT"}');

/***/ })

};
;