/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/file-notes/route";
exports.ids = ["app/api/file-notes/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream/web");

/***/ }),

/***/ "?32c4":
/*!****************************!*\
  !*** bufferutil (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?66e9":
/*!********************************!*\
  !*** utf-8-validate (ignored) ***!
  \********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ffile-notes%2Froute&page=%2Fapi%2Ffile-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ffile-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ffile-notes%2Froute&page=%2Fapi%2Ffile-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ffile-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_janjedrach_Cursor_eduscribe_src_app_api_file_notes_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/file-notes/route.ts */ \"(rsc)/./src/app/api/file-notes/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/file-notes/route\",\n        pathname: \"/api/file-notes\",\n        filename: \"route\",\n        bundlePath: \"app/api/file-notes/route\"\n    },\n    resolvedPagePath: \"/Users/janjedrach/Cursor/eduscribe/src/app/api/file-notes/route.ts\",\n    nextConfigOutput,\n    userland: _Users_janjedrach_Cursor_eduscribe_src_app_api_file_notes_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/file-notes/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZmaWxlLW5vdGVzJTJGcm91dGUmcGFnZT0lMkZhcGklMkZmaWxlLW5vdGVzJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGZmlsZS1ub3RlcyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9anMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz1tZHgmcm9vdERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9c3RhbmRhbG9uZSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNrQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8/OTZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvamFuamVkcmFjaC9DdXJzb3IvZWR1c2NyaWJlL3NyYy9hcHAvYXBpL2ZpbGUtbm90ZXMvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9maWxlLW5vdGVzL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZmlsZS1ub3Rlc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvZmlsZS1ub3Rlcy9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy9qYW5qZWRyYWNoL0N1cnNvci9lZHVzY3JpYmUvc3JjL2FwcC9hcGkvZmlsZS1ub3Rlcy9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvZmlsZS1ub3Rlcy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ffile-notes%2Froute&page=%2Fapi%2Ffile-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ffile-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/file-notes/route.ts":
/*!*****************************************!*\
  !*** ./src/app/api/file-notes/route.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELETE: () => (/* binding */ DELETE),\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   dynamic: () => (/* binding */ dynamic)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _services_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/ai */ \"(rsc)/./src/services/ai.ts\");\n/* harmony import */ var _services_fileExtraction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/fileExtraction */ \"(rsc)/./src/services/fileExtraction.ts\");\n/* harmony import */ var _services_subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/subscription */ \"(rsc)/./src/services/subscription.ts\");\n/* harmony import */ var _services_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/queue */ \"(rsc)/./src/services/queue.ts\");\n\n\n\n\n\n\n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get user's subscription plan for queue priority\n */ async function getSubscriptionPlan(userId) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey);\n        const { data } = await supabase.from(\"user_subscriptions\").select(\"plan_id\").eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        const planId = data?.plan_id;\n        // Ensure we return a valid plan type\n        if (planId === \"student\" || planId === \"pro\") {\n            return {\n                planId\n            };\n        }\n        return {\n            planId: \"free\"\n        };\n    } catch (error) {\n        console.warn(\"[File Notes API] Could not fetch subscription:\", error);\n        return {\n            planId: \"free\"\n        };\n    }\n}\n/**\n * File Notes API Endpoint - Isolated System\n * \n * Processes an uploaded file to:\n * 1. Store the file in Supabase storage\n * 2. Extract text content from the file\n * 3. Generate AI notes\n * 4. Store in the isolated file_notes table\n */ async function POST(request) {\n    console.log(\"[File Notes API] Request received: POST\");\n    try {\n        // STEP 1: Authenticate the request\n        console.log(\"[File Notes API] Authenticating request\");\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[File Notes API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[File Notes API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[File Notes API] User authenticated: ${user.id}`);\n        // STEP 1.5: Check usage limits BEFORE processing\n        console.log(\"[File Notes API] Checking usage limits\");\n        const usageCheck = await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.checkUsageLimits)(user.id, token, \"file\");\n        if (!usageCheck.canGenerate) {\n            console.log(`[File Notes API] Generation limit reached: ${usageCheck.reason}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Generation limit reached\",\n                message: usageCheck.reason || \"You have reached your monthly note generation limit\",\n                usage: usageCheck.usage,\n                limits: usageCheck.limits\n            }, {\n                status: 429\n            }); // 429 = Too Many Requests\n        }\n        if (!usageCheck.canSave) {\n            console.log(`[File Notes API] Storage limit reached: ${usageCheck.reason}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Storage limit reached\",\n                message: usageCheck.reason || \"You have reached your saved notes limit\",\n                usage: usageCheck.usage,\n                limits: usageCheck.limits\n            }, {\n                status: 429\n            });\n        }\n        console.log(`[File Notes API] Usage check passed - can generate: ${usageCheck.canGenerate}, can save: ${usageCheck.canSave}`);\n        // Get user's subscription for priority\n        const subscription = await getSubscriptionPlan(user.id);\n        // Wrap the processing in queue\n        const result = await (0,_services_queue__WEBPACK_IMPORTED_MODULE_4__.queueRequest)(user.id, subscription.planId, \"file\", async ()=>{\n            // STEP 2: Parse the form data with file\n            const formData = await request.formData();\n            const file = formData.get(\"file\");\n            const customTitle = formData.get(\"title\");\n            if (!file) {\n                console.error(\"[File Notes API] No file provided\");\n                return {\n                    success: false,\n                    error: \"Missing file\",\n                    message: \"Please provide a file to generate notes from\"\n                };\n            }\n            // STEP 3: Validate the file\n            const fileType = file.type;\n            const fileSize = file.size;\n            const fileName = file.name;\n            // Check file size (max 20MB)\n            const MAX_FILE_SIZE = 20 * 1024 * 1024; // 20MB\n            if (fileSize > MAX_FILE_SIZE) {\n                console.error(`[File Notes API] File too large: ${fileSize} bytes`);\n                return {\n                    success: false,\n                    error: \"File too large\",\n                    message: \"The uploaded file exceeds the maximum size of 20MB\"\n                };\n            }\n            // Check supported file types - NOW INCLUDING POWERPOINT\n            const supportedTypes = [\n                \"application/pdf\",\n                \"text/plain\",\n                \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n                \"application/msword\",\n                \"text/markdown\",\n                \"text/csv\",\n                // PowerPoint support\n                \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n                \"application/vnd.ms-powerpoint\" // ppt\n            ];\n            if (!supportedTypes.includes(fileType)) {\n                console.error(`[File Notes API] Unsupported file type: ${fileType}`);\n                return {\n                    success: false,\n                    error: \"Unsupported file type\",\n                    message: \"Please upload a supported file type (PDF, TXT, DOC, DOCX, MD, CSV, PPT, PPTX)\"\n                };\n            }\n            console.log(`[File Notes API] File validated: ${fileName} (${fileType}, ${fileSize} bytes)`);\n            // STEP 4: Upload the file to Supabase Storage (with fallback)\n            const filePath = `${user.id}/${Date.now()}_${fileName}`;\n            const fileBuffer = await file.arrayBuffer();\n            const fileData = new Uint8Array(fileBuffer);\n            console.log(`[File Notes API] Attempting to upload file to storage: ${filePath}`);\n            let publicUrl = null;\n            let storageSuccess = false;\n            try {\n                const { data: storageData, error: storageError } = await supabase.storage.from(\"files\").upload(filePath, fileData, {\n                    contentType: fileType,\n                    upsert: false\n                });\n                if (storageError) {\n                    console.warn(\"[File Notes API] Storage upload failed:\", storageError.message);\n                    // Check if it's a bucket not found error\n                    if (storageError.message.includes(\"Bucket not found\") || storageError.message.includes(\"bucket\")) {\n                        console.log(\"[File Notes API] Storage bucket not found, proceeding without file storage\");\n                    } else {\n                        console.log(\"[File Notes API] Storage error, proceeding without file storage\");\n                    }\n                    // Continue without storage - we'll store just the metadata\n                    storageSuccess = false;\n                } else {\n                    // Get the public URL for the file\n                    const { data: { publicUrl: url } } = supabase.storage.from(\"files\").getPublicUrl(filePath);\n                    publicUrl = url;\n                    storageSuccess = true;\n                    console.log(`[File Notes API] File uploaded successfully. Public URL: ${publicUrl}`);\n                }\n            } catch (uploadError) {\n                console.warn(\"[File Notes API] Storage upload exception:\", uploadError.message);\n                console.log(\"[File Notes API] Proceeding without file storage\");\n                storageSuccess = false;\n            }\n            // Log storage status\n            if (storageSuccess) {\n                console.log(\"[File Notes API] ✅ File stored in Supabase Storage\");\n            } else {\n                console.log(\"[File Notes API] ⚠️  File not stored in storage (metadata only)\");\n            }\n            // STEP 5: Extract text from the file using the new extraction service\n            console.log(\"[File Notes API] Extracting text from file\");\n            let extractedContent;\n            try {\n                extractedContent = await (0,_services_fileExtraction__WEBPACK_IMPORTED_MODULE_2__.extractTextFromFile)(fileBuffer, fileType, fileName);\n                if (!extractedContent.text || extractedContent.text.trim().length === 0) {\n                    console.error(\"[File Notes API] No text content extracted from file\");\n                    return {\n                        success: false,\n                        error: \"No content\",\n                        message: \"Could not extract any text content from the uploaded file\"\n                    };\n                }\n                console.log(`[File Notes API] Successfully extracted text (${extractedContent.text.length} chars)`);\n                if (extractedContent.slideCount) {\n                    console.log(`[File Notes API] PowerPoint presentation with ${extractedContent.slideCount} slides`);\n                }\n            } catch (extractError) {\n                console.error(\"[File Notes API] Error extracting text from file:\", extractError);\n                return {\n                    success: false,\n                    error: \"Text extraction failed\",\n                    message: extractError.message || \"Failed to extract text from the uploaded file\"\n                };\n            }\n            // STEP 6: Generate notes using AI\n            console.log(\"[File Notes API] Generating notes from extracted text\");\n            let notesResult;\n            try {\n                // Create a more descriptive title for PowerPoint presentations\n                let contentTitle = fileName;\n                if (extractedContent.slideCount) {\n                    contentTitle = `${fileName} (${extractedContent.slideCount} slides)`;\n                }\n                notesResult = await (0,_services_ai__WEBPACK_IMPORTED_MODULE_1__.generateNotes)({\n                    transcript: extractedContent.text,\n                    videoTitle: contentTitle // Using filename as the title\n                });\n                if (!notesResult.content) {\n                    console.error(\"[File Notes API] AI note generation failed:\", notesResult.error);\n                    return {\n                        success: false,\n                        error: \"Note generation failed\",\n                        message: notesResult.error || \"Failed to generate notes from the file content\"\n                    };\n                }\n                console.log(`[File Notes API] Successfully generated notes (${notesResult.content.length} chars)`);\n            } catch (aiError) {\n                console.error(\"[File Notes API] Error during AI note generation:\", aiError);\n                return {\n                    success: false,\n                    error: \"AI processing failed\",\n                    message: aiError.message || \"An error occurred while generating notes with AI\"\n                };\n            }\n            // STEP 7: Create the note record for isolated file_notes table\n            const noteId = `file_${Date.now()}`;\n            const noteData = {\n                id: noteId,\n                user_id: user.id,\n                title: customTitle || fileName,\n                file_name: fileName,\n                file_url: publicUrl,\n                file_type: fileType,\n                content: notesResult.content,\n                summary: notesResult.summary,\n                quiz: notesResult.quiz,\n                // Add PowerPoint-specific metadata\n                slide_count: extractedContent.slideCount || null,\n                slide_titles: extractedContent.slideTitles || null,\n                created_at: new Date().toISOString()\n            };\n            console.log(`[File Notes API] Created note with ID: ${noteId}`);\n            console.log(\"[File Notes API] Note data structure:\", Object.keys(noteData).join(\", \"));\n            if (publicUrl) {\n                console.log(\"[File Notes API] ✅ Note includes file URL for download\");\n            } else {\n                console.log(\"[File Notes API] ⚠️  Note created without file URL (storage unavailable)\");\n            }\n            // STEP 8: Store the note in Supabase file_notes table\n            console.log(\"[File Notes API] Storing note in Supabase file_notes table\");\n            try {\n                // Verify database connection before attempting insert\n                try {\n                    const { error: pingError } = await supabase.from(\"file_notes\").select(\"count\").limit(1);\n                    if (pingError) {\n                        console.error(\"[File Notes API] Database connection check failed:\", pingError);\n                        return {\n                            success: false,\n                            error: \"Database connection error\",\n                            message: \"Could not connect to the database. Please try again later.\",\n                            details: {\n                                code: pingError.code,\n                                message: pingError.message\n                            }\n                        };\n                    }\n                } catch (pingException) {\n                    console.error(\"[File Notes API] Database ping exception:\", pingException);\n                }\n                const { data, error } = await supabase.from(\"file_notes\").insert(noteData).select().single();\n                if (error) {\n                    console.error(\"[File Notes API] Database storage error:\", error);\n                    // Log detailed diagnostic information\n                    console.error(\"[File Notes API] Database error details:\", {\n                        code: error.code,\n                        message: error.message,\n                        details: error.details,\n                        hint: error.hint\n                    });\n                    // Handle specific database errors with appropriate status codes\n                    if (error.code === \"23505\") {\n                        return {\n                            success: false,\n                            error: \"Duplicate record\",\n                            message: \"These notes already exist in the database\",\n                            details: {\n                                code: error.code,\n                                message: error.message\n                            }\n                        };\n                    } else if (error.code?.startsWith(\"22\") || error.code?.startsWith(\"23\")) {\n                        // Data exception (22) or integrity constraint violation (23)\n                        return {\n                            success: false,\n                            error: \"Invalid data format\",\n                            message: \"The note data could not be stored due to validation errors\",\n                            details: {\n                                code: error.code,\n                                message: error.message\n                            }\n                        };\n                    } else if (error.code === \"42P01\") {\n                        // Undefined table\n                        return {\n                            success: false,\n                            error: \"Schema error\",\n                            message: \"The file_notes table does not exist. Please run the database initialization.\",\n                            details: {\n                                code: error.code,\n                                message: error.message\n                            }\n                        };\n                    }\n                    return {\n                        success: false,\n                        error: \"Database error\",\n                        message: \"Failed to store the notes in the database\",\n                        details: {\n                            code: error.code,\n                            message: error.message\n                        }\n                    };\n                }\n                console.log(`[File Notes API] Successfully stored note in database with ID: ${data?.id || noteId}`);\n                // STEP 8.5: Track usage after successful creation\n                console.log(\"[File Notes API] Incrementing usage counters\");\n                try {\n                    await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.incrementUsage)(user.id, token, \"file\");\n                    console.log(\"[File Notes API] Usage tracking completed\");\n                } catch (usageError) {\n                    console.error(\"[File Notes API] Usage tracking failed (note still created):\", usageError);\n                // Don't fail the request if usage tracking fails\n                }\n                // STEP 8.6: Refresh saved notes count\n                console.log(\"[File Notes API] Refreshing saved notes count\");\n                try {\n                    await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.refreshSavedNotesCount)(user.id, token);\n                    console.log(\"[File Notes API] Saved notes count refreshed\");\n                } catch (countError) {\n                    console.error(\"[File Notes API] Saved notes count refresh failed (note still created):\", countError);\n                // Don't fail the request if count refresh fails\n                }\n                // STEP 9: Return the successful result\n                return {\n                    success: true,\n                    data\n                };\n            } catch (dbError) {\n                console.error(\"[File Notes API] Unexpected database error:\", dbError);\n                return {\n                    success: false,\n                    error: \"Database exception\",\n                    message: dbError?.message || \"An unexpected error occurred while storing notes\",\n                    details: dbError\n                };\n            }\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(result);\n    } catch (error) {\n        console.error(\"[File Notes API] Critical error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred on the server\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * Get all file notes for the authenticated user\n */ async function GET(request) {\n    console.log(\"[File Notes API] Request received: GET\");\n    try {\n        // STEP 1: Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[File Notes API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[File Notes API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[File Notes API] User authenticated: ${user.id}`);\n        // STEP 2: Fetch the user's file notes\n        const { data, error } = await supabase.from(\"file_notes\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"[File Notes API] Database fetch error:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Database error\",\n                message: \"Failed to fetch file notes from the database\",\n                details: {\n                    code: error.code,\n                    message: error.message\n                }\n            }, {\n                status: 500\n            });\n        }\n        console.log(`[File Notes API] Successfully fetched ${data.length} file notes`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data\n        });\n    } catch (error) {\n        console.error(\"[File Notes API] Error fetching file notes:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred while fetching file notes\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * Delete a specific file note for the authenticated user\n */ async function DELETE(request) {\n    console.log(\"[File Notes API] Request received: DELETE\");\n    try {\n        // STEP 1: Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[File Notes API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[File Notes API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[File Notes API] User authenticated: ${user.id}`);\n        // STEP 2: Get the note ID from query parameters\n        const noteId = request.nextUrl.searchParams.get(\"id\");\n        if (!noteId) {\n            console.error(\"[File Notes API] Note ID missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Missing note ID\",\n                message: \"Note ID is required for deletion\"\n            }, {\n                status: 400\n            });\n        }\n        console.log(`[File Notes API] Deleting note with ID: ${noteId}`);\n        // STEP 3: Delete the note (with user ownership check)\n        const { data, error } = await supabase.from(\"file_notes\").delete().eq(\"id\", noteId).eq(\"user_id\", user.id) // Ensure user can only delete their own notes\n        .select();\n        if (error) {\n            console.error(\"[File Notes API] Database delete error:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Database error\",\n                message: \"Failed to delete the note from the database\",\n                details: {\n                    code: error.code,\n                    message: error.message\n                }\n            }, {\n                status: 500\n            });\n        }\n        // Check if any rows were affected\n        if (!data || data.length === 0) {\n            console.error(`[File Notes API] Note not found or access denied: ${noteId}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Note not found\",\n                message: \"The note was not found or you do not have permission to delete it\"\n            }, {\n                status: 404\n            });\n        }\n        console.log(`[File Notes API] Successfully deleted note: ${noteId}`);\n        // Refresh saved notes count after deletion\n        try {\n            await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.refreshSavedNotesCount)(user.id, token);\n            console.log(\"[File Notes API] Saved notes count refreshed after deletion\");\n        } catch (countError) {\n            console.error(\"[File Notes API] Saved notes count refresh failed after deletion:\", countError);\n        // Don't fail the request if count refresh fails\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"Note deleted successfully\",\n            data: data[0]\n        });\n    } catch (error) {\n        console.error(\"[File Notes API] Error deleting file note:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred while deleting the note\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n// Configure dynamic behavior to avoid caching\nconst dynamic = \"force-dynamic\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0RBQWtELEVBQUV5RSxPQUFPLENBQUM7WUFDM0UsT0FBT2pHLHFEQUFZQSxDQUFDa0MsSUFBSSxDQUFDO2dCQUN2QkMsU0FBUztnQkFDVFgsT0FBTztnQkFDUFksU0FBUztZQUNYLEdBQUc7Z0JBQUVDLFFBQVE7WUFBSTtRQUNuQjtRQUVBWixRQUFRSSxHQUFHLENBQUMsQ0FBQyw0Q0FBNEMsRUFBRW9FLE9BQU8sQ0FBQztRQUVuRSwyQ0FBMkM7UUFDM0MsSUFBSTtZQUNGLE1BQU0zRiw4RUFBc0JBLENBQUNvQyxLQUFLSSxFQUFFLEVBQUVSO1lBQ3RDYixRQUFRSSxHQUFHLENBQUM7UUFDZCxFQUFFLE9BQU82RixZQUFZO1lBQ25CakcsUUFBUUQsS0FBSyxDQUFDLHFFQUFxRWtHO1FBQ25GLGdEQUFnRDtRQUNsRDtRQUVBLE9BQU8xSCxxREFBWUEsQ0FBQ2tDLElBQUksQ0FBQztZQUN2QkMsU0FBUztZQUNUQyxTQUFTO1lBQ1RuQixNQUFNQSxJQUFJLENBQUMsRUFBRTtRQUNmO0lBQ0YsRUFBRSxPQUFPTyxPQUFZO1FBQ25CQyxRQUFRRCxLQUFLLENBQUMsOENBQThDQTtRQUM1RCxPQUFPeEIscURBQVlBLENBQUNrQyxJQUFJLENBQUM7WUFDdkJDLFNBQVM7WUFDVFgsT0FBTztZQUNQWSxTQUFTO1lBQ1RnRixTQUFTNUYsTUFBTVksT0FBTztRQUN4QixHQUFHO1lBQUVDLFFBQVE7UUFBSTtJQUNuQjtBQUNGO0FBRUEsOENBQThDO0FBQ3ZDLE1BQU04RixVQUFVLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9hcHAvYXBpL2ZpbGUtbm90ZXMvcm91dGUudHM/NzE2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IGdlbmVyYXRlTm90ZXMgfSBmcm9tICdAL3NlcnZpY2VzL2FpJztcbmltcG9ydCB7IGV4dHJhY3RUZXh0RnJvbUZpbGUgfSBmcm9tICdAL3NlcnZpY2VzL2ZpbGVFeHRyYWN0aW9uJztcbmltcG9ydCB7IGNoZWNrVXNhZ2VMaW1pdHMsIGluY3JlbWVudFVzYWdlLCByZWZyZXNoU2F2ZWROb3Rlc0NvdW50IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgcXVldWVSZXF1ZXN0IH0gZnJvbSAnQC9zZXJ2aWNlcy9xdWV1ZSc7XG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50XG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XG5cbi8qKlxuICogR2V0IHVzZXIncyBzdWJzY3JpcHRpb24gcGxhbiBmb3IgcXVldWUgcHJpb3JpdHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUGxhbih1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8eyBwbGFuSWQ6ICdmcmVlJyB8ICdzdHVkZW50JyB8ICdwcm8nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl9zdWJzY3JpcHRpb25zJylcbiAgICAgIC5zZWxlY3QoJ3BsYW5faWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBjb25zdCBwbGFuSWQgPSBkYXRhPy5wbGFuX2lkO1xuICAgIFxuICAgIC8vIEVuc3VyZSB3ZSByZXR1cm4gYSB2YWxpZCBwbGFuIHR5cGVcbiAgICBpZiAocGxhbklkID09PSAnc3R1ZGVudCcgfHwgcGxhbklkID09PSAncHJvJykge1xuICAgICAgcmV0dXJuIHsgcGxhbklkIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHBsYW5JZDogJ2ZyZWUnIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdbRmlsZSBOb3RlcyBBUEldIENvdWxkIG5vdCBmZXRjaCBzdWJzY3JpcHRpb246JywgZXJyb3IpO1xuICAgIHJldHVybiB7IHBsYW5JZDogJ2ZyZWUnIH07XG4gIH1cbn1cblxuLyoqXG4gKiBGaWxlIE5vdGVzIEFQSSBFbmRwb2ludCAtIElzb2xhdGVkIFN5c3RlbVxuICogXG4gKiBQcm9jZXNzZXMgYW4gdXBsb2FkZWQgZmlsZSB0bzpcbiAqIDEuIFN0b3JlIHRoZSBmaWxlIGluIFN1cGFiYXNlIHN0b3JhZ2VcbiAqIDIuIEV4dHJhY3QgdGV4dCBjb250ZW50IGZyb20gdGhlIGZpbGVcbiAqIDMuIEdlbmVyYXRlIEFJIG5vdGVzXG4gKiA0LiBTdG9yZSBpbiB0aGUgaXNvbGF0ZWQgZmlsZV9ub3RlcyB0YWJsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBSZXF1ZXN0IHJlY2VpdmVkOiBQT1NUJyk7XG5cbiAgdHJ5IHtcbiAgICAvLyBTVEVQIDE6IEF1dGhlbnRpY2F0ZSB0aGUgcmVxdWVzdFxuICAgIGNvbnNvbGUubG9nKCdbRmlsZSBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW5nIHJlcXVlc3QnKTtcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlciB8fCAhYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tGaWxlIE5vdGVzIEFQSV0gQXV0aGVudGljYXRpb24gbWlzc2luZycpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyxcbiAgICAgICAgbWVzc2FnZTogJ1ZhbGlkIEJlYXJlciB0b2tlbiBpcyByZXF1aXJlZCdcbiAgICAgIH0sIHsgc3RhdHVzOiA0MDEgfSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnQgd2l0aCB0aGUgdG9rZW5cbiAgICBjb25zdCB0b2tlbiA9IGF1dGhIZWFkZXIucmVwbGFjZSgnQmVhcmVyICcsICcnKTtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAvLyBWZXJpZnkgdGhlIHVzZXIncyB0b2tlbiBhbmQgc2V0IHRoZSBzZXNzaW9uXG4gICAgY29uc3QgeyBkYXRhOiB7IHVzZXIgfSwgZXJyb3I6IGF1dGhFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UuYXV0aC5nZXRVc2VyKHRva2VuKTtcbiAgICBpZiAoYXV0aEVycm9yIHx8ICF1c2VyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW9uIGZhaWxlZDonLCBhdXRoRXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcsXG4gICAgICAgIG1lc3NhZ2U6IGF1dGhFcnJvcj8ubWVzc2FnZSB8fCAnSW52YWxpZCBhdXRoZW50aWNhdGlvbiB0b2tlbidcbiAgICAgIH0sIHsgc3RhdHVzOiA0MDEgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbRmlsZSBOb3RlcyBBUEldIFVzZXIgYXV0aGVudGljYXRlZDogJHt1c2VyLmlkfWApO1xuXG4gICAgLy8gU1RFUCAxLjU6IENoZWNrIHVzYWdlIGxpbWl0cyBCRUZPUkUgcHJvY2Vzc2luZ1xuICAgIGNvbnNvbGUubG9nKCdbRmlsZSBOb3RlcyBBUEldIENoZWNraW5nIHVzYWdlIGxpbWl0cycpO1xuICAgIGNvbnN0IHVzYWdlQ2hlY2sgPSBhd2FpdCBjaGVja1VzYWdlTGltaXRzKHVzZXIuaWQsIHRva2VuLCAnZmlsZScpO1xuICAgIFxuICAgIGlmICghdXNhZ2VDaGVjay5jYW5HZW5lcmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gR2VuZXJhdGlvbiBsaW1pdCByZWFjaGVkOiAke3VzYWdlQ2hlY2sucmVhc29ufWApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnR2VuZXJhdGlvbiBsaW1pdCByZWFjaGVkJyxcbiAgICAgICAgbWVzc2FnZTogdXNhZ2VDaGVjay5yZWFzb24gfHwgJ1lvdSBoYXZlIHJlYWNoZWQgeW91ciBtb250aGx5IG5vdGUgZ2VuZXJhdGlvbiBsaW1pdCcsXG4gICAgICAgIHVzYWdlOiB1c2FnZUNoZWNrLnVzYWdlLFxuICAgICAgICBsaW1pdHM6IHVzYWdlQ2hlY2subGltaXRzXG4gICAgICB9LCB7IHN0YXR1czogNDI5IH0pOyAvLyA0MjkgPSBUb28gTWFueSBSZXF1ZXN0c1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXVzYWdlQ2hlY2suY2FuU2F2ZSkge1xuICAgICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gU3RvcmFnZSBsaW1pdCByZWFjaGVkOiAke3VzYWdlQ2hlY2sucmVhc29ufWApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnU3RvcmFnZSBsaW1pdCByZWFjaGVkJyxcbiAgICAgICAgbWVzc2FnZTogdXNhZ2VDaGVjay5yZWFzb24gfHwgJ1lvdSBoYXZlIHJlYWNoZWQgeW91ciBzYXZlZCBub3RlcyBsaW1pdCcsXG4gICAgICAgIHVzYWdlOiB1c2FnZUNoZWNrLnVzYWdlLFxuICAgICAgICBsaW1pdHM6IHVzYWdlQ2hlY2subGltaXRzXG4gICAgICB9LCB7IHN0YXR1czogNDI5IH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBVc2FnZSBjaGVjayBwYXNzZWQgLSBjYW4gZ2VuZXJhdGU6ICR7dXNhZ2VDaGVjay5jYW5HZW5lcmF0ZX0sIGNhbiBzYXZlOiAke3VzYWdlQ2hlY2suY2FuU2F2ZX1gKTtcblxuICAgIC8vIEdldCB1c2VyJ3Mgc3Vic2NyaXB0aW9uIGZvciBwcmlvcml0eVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvblBsYW4odXNlci5pZCk7XG4gICAgXG4gICAgLy8gV3JhcCB0aGUgcHJvY2Vzc2luZyBpbiBxdWV1ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXVlUmVxdWVzdChcbiAgICAgIHVzZXIuaWQsXG4gICAgICBzdWJzY3JpcHRpb24ucGxhbklkLFxuICAgICAgJ2ZpbGUnLFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBTVEVQIDI6IFBhcnNlIHRoZSBmb3JtIGRhdGEgd2l0aCBmaWxlXG4gICAgICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgICAgICBjb25zdCBmaWxlID0gZm9ybURhdGEuZ2V0KCdmaWxlJykgYXMgRmlsZSB8IG51bGw7XG4gICAgICAgIGNvbnN0IGN1c3RvbVRpdGxlID0gZm9ybURhdGEuZ2V0KCd0aXRsZScpIGFzIHN0cmluZyB8IG51bGw7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIE5vIGZpbGUgcHJvdmlkZWQnKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ01pc3NpbmcgZmlsZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHByb3ZpZGUgYSBmaWxlIHRvIGdlbmVyYXRlIG5vdGVzIGZyb20nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgMzogVmFsaWRhdGUgdGhlIGZpbGVcbiAgICAgICAgY29uc3QgZmlsZVR5cGUgPSBmaWxlLnR5cGU7XG4gICAgICAgIGNvbnN0IGZpbGVTaXplID0gZmlsZS5zaXplO1xuICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGZpbGUubmFtZTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZSAobWF4IDIwTUIpXG4gICAgICAgIGNvbnN0IE1BWF9GSUxFX1NJWkUgPSAyMCAqIDEwMjQgKiAxMDI0OyAvLyAyME1CXG4gICAgICAgIGlmIChmaWxlU2l6ZSA+IE1BWF9GSUxFX1NJWkUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbRmlsZSBOb3RlcyBBUEldIEZpbGUgdG9vIGxhcmdlOiAke2ZpbGVTaXplfSBieXRlc2ApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmlsZSB0b28gbGFyZ2UnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSB1cGxvYWRlZCBmaWxlIGV4Y2VlZHMgdGhlIG1heGltdW0gc2l6ZSBvZiAyME1CJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIHN1cHBvcnRlZCBmaWxlIHR5cGVzIC0gTk9XIElOQ0xVRElORyBQT1dFUlBPSU5UXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZFR5cGVzID0gW1xuICAgICAgICAgICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAgICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnLCAvLyBkb2N4XG4gICAgICAgICAgJ2FwcGxpY2F0aW9uL21zd29yZCcsIC8vIGRvY1xuICAgICAgICAgICd0ZXh0L21hcmtkb3duJyxcbiAgICAgICAgICAndGV4dC9jc3YnLFxuICAgICAgICAgIC8vIFBvd2VyUG9pbnQgc3VwcG9ydFxuICAgICAgICAgICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQucHJlc2VudGF0aW9ubWwucHJlc2VudGF0aW9uJywgLy8gcHB0eFxuICAgICAgICAgICdhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludCcgLy8gcHB0XG4gICAgICAgIF07XG4gICAgICAgIFxuICAgICAgICBpZiAoIXN1cHBvcnRlZFR5cGVzLmluY2x1ZGVzKGZpbGVUeXBlKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtGaWxlIE5vdGVzIEFQSV0gVW5zdXBwb3J0ZWQgZmlsZSB0eXBlOiAke2ZpbGVUeXBlfWApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnVW5zdXBwb3J0ZWQgZmlsZSB0eXBlJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgdXBsb2FkIGEgc3VwcG9ydGVkIGZpbGUgdHlwZSAoUERGLCBUWFQsIERPQywgRE9DWCwgTUQsIENTViwgUFBULCBQUFRYKSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBGaWxlIHZhbGlkYXRlZDogJHtmaWxlTmFtZX0gKCR7ZmlsZVR5cGV9LCAke2ZpbGVTaXplfSBieXRlcylgKTtcblxuICAgICAgICAvLyBTVEVQIDQ6IFVwbG9hZCB0aGUgZmlsZSB0byBTdXBhYmFzZSBTdG9yYWdlICh3aXRoIGZhbGxiYWNrKVxuICAgICAgICBjb25zdCBmaWxlUGF0aCA9IGAke3VzZXIuaWR9LyR7RGF0ZS5ub3coKX1fJHtmaWxlTmFtZX1gO1xuICAgICAgICBjb25zdCBmaWxlQnVmZmVyID0gYXdhaXQgZmlsZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICBjb25zdCBmaWxlRGF0YSA9IG5ldyBVaW50OEFycmF5KGZpbGVCdWZmZXIpO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gQXR0ZW1wdGluZyB0byB1cGxvYWQgZmlsZSB0byBzdG9yYWdlOiAke2ZpbGVQYXRofWApO1xuICAgICAgICBcbiAgICAgICAgbGV0IHB1YmxpY1VybCA9IG51bGw7XG4gICAgICAgIGxldCBzdG9yYWdlU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBzdG9yYWdlRGF0YSwgZXJyb3I6IHN0b3JhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuc3RvcmFnZVxuICAgICAgICAgICAgLmZyb20oJ2ZpbGVzJylcbiAgICAgICAgICAudXBsb2FkKGZpbGVQYXRoLCBmaWxlRGF0YSwge1xuICAgICAgICAgICAgY29udGVudFR5cGU6IGZpbGVUeXBlLFxuICAgICAgICAgICAgdXBzZXJ0OiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKHN0b3JhZ2VFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbRmlsZSBOb3RlcyBBUEldIFN0b3JhZ2UgdXBsb2FkIGZhaWxlZDonLCBzdG9yYWdlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0J3MgYSBidWNrZXQgbm90IGZvdW5kIGVycm9yXG4gICAgICAgICAgICBpZiAoc3RvcmFnZUVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0J1Y2tldCBub3QgZm91bmQnKSB8fCBzdG9yYWdlRXJyb3IubWVzc2FnZS5pbmNsdWRlcygnYnVja2V0JykpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0gU3RvcmFnZSBidWNrZXQgbm90IGZvdW5kLCBwcm9jZWVkaW5nIHdpdGhvdXQgZmlsZSBzdG9yYWdlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBTdG9yYWdlIGVycm9yLCBwcm9jZWVkaW5nIHdpdGhvdXQgZmlsZSBzdG9yYWdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIENvbnRpbnVlIHdpdGhvdXQgc3RvcmFnZSAtIHdlJ2xsIHN0b3JlIGp1c3QgdGhlIG1ldGFkYXRhXG4gICAgICAgICAgICBzdG9yYWdlU3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdldCB0aGUgcHVibGljIFVSTCBmb3IgdGhlIGZpbGVcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBwdWJsaWNVcmw6IHVybCB9IH0gPSBzdXBhYmFzZVxuICAgICAgICAgIC5zdG9yYWdlXG4gICAgICAgICAgICAgIC5mcm9tKCdmaWxlcycpXG4gICAgICAgICAgLmdldFB1YmxpY1VybChmaWxlUGF0aCk7XG4gICAgICAgIFxuICAgICAgICAgICAgcHVibGljVXJsID0gdXJsO1xuICAgICAgICAgICAgc3RvcmFnZVN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBGaWxlIHVwbG9hZGVkIHN1Y2Nlc3NmdWxseS4gUHVibGljIFVSTDogJHtwdWJsaWNVcmx9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICB9IGNhdGNoICh1cGxvYWRFcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbRmlsZSBOb3RlcyBBUEldIFN0b3JhZ2UgdXBsb2FkIGV4Y2VwdGlvbjonLCB1cGxvYWRFcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBQcm9jZWVkaW5nIHdpdGhvdXQgZmlsZSBzdG9yYWdlJyk7XG4gICAgICAgICAgc3RvcmFnZVN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gTG9nIHN0b3JhZ2Ugc3RhdHVzXG4gICAgICAgIGlmIChzdG9yYWdlU3VjY2Vzcykge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdbRmlsZSBOb3RlcyBBUEldIOKchSBGaWxlIHN0b3JlZCBpbiBTdXBhYmFzZSBTdG9yYWdlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0g4pqg77iPICBGaWxlIG5vdCBzdG9yZWQgaW4gc3RvcmFnZSAobWV0YWRhdGEgb25seSknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgNTogRXh0cmFjdCB0ZXh0IGZyb20gdGhlIGZpbGUgdXNpbmcgdGhlIG5ldyBleHRyYWN0aW9uIHNlcnZpY2VcbiAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0gRXh0cmFjdGluZyB0ZXh0IGZyb20gZmlsZScpO1xuICAgICAgICBsZXQgZXh0cmFjdGVkQ29udGVudDtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZXh0cmFjdGVkQ29udGVudCA9IGF3YWl0IGV4dHJhY3RUZXh0RnJvbUZpbGUoZmlsZUJ1ZmZlciwgZmlsZVR5cGUsIGZpbGVOYW1lKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIWV4dHJhY3RlZENvbnRlbnQudGV4dCB8fCBleHRyYWN0ZWRDb250ZW50LnRleHQudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBObyB0ZXh0IGNvbnRlbnQgZXh0cmFjdGVkIGZyb20gZmlsZScpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiAnTm8gY29udGVudCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb3VsZCBub3QgZXh0cmFjdCBhbnkgdGV4dCBjb250ZW50IGZyb20gdGhlIHVwbG9hZGVkIGZpbGUnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIHRleHQgKCR7ZXh0cmFjdGVkQ29udGVudC50ZXh0Lmxlbmd0aH0gY2hhcnMpYCk7XG4gICAgICAgICAgaWYgKGV4dHJhY3RlZENvbnRlbnQuc2xpZGVDb3VudCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gUG93ZXJQb2ludCBwcmVzZW50YXRpb24gd2l0aCAke2V4dHJhY3RlZENvbnRlbnQuc2xpZGVDb3VudH0gc2xpZGVzYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChleHRyYWN0RXJyb3I6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tGaWxlIE5vdGVzIEFQSV0gRXJyb3IgZXh0cmFjdGluZyB0ZXh0IGZyb20gZmlsZTonLCBleHRyYWN0RXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnVGV4dCBleHRyYWN0aW9uIGZhaWxlZCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBleHRyYWN0RXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIGV4dHJhY3QgdGV4dCBmcm9tIHRoZSB1cGxvYWRlZCBmaWxlJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDY6IEdlbmVyYXRlIG5vdGVzIHVzaW5nIEFJXG4gICAgICAgIGNvbnNvbGUubG9nKCdbRmlsZSBOb3RlcyBBUEldIEdlbmVyYXRpbmcgbm90ZXMgZnJvbSBleHRyYWN0ZWQgdGV4dCcpO1xuICAgICAgICBsZXQgbm90ZXNSZXN1bHQ7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIG1vcmUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIFBvd2VyUG9pbnQgcHJlc2VudGF0aW9uc1xuICAgICAgICAgIGxldCBjb250ZW50VGl0bGUgPSBmaWxlTmFtZTtcbiAgICAgICAgICBpZiAoZXh0cmFjdGVkQ29udGVudC5zbGlkZUNvdW50KSB7XG4gICAgICAgICAgICBjb250ZW50VGl0bGUgPSBgJHtmaWxlTmFtZX0gKCR7ZXh0cmFjdGVkQ29udGVudC5zbGlkZUNvdW50fSBzbGlkZXMpYDtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgbm90ZXNSZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZU5vdGVzKHtcbiAgICAgICAgICAgIHRyYW5zY3JpcHQ6IGV4dHJhY3RlZENvbnRlbnQudGV4dCwgLy8gUmV1c2luZyB0aGUgdHJhbnNjcmlwdCBmaWVsZCBmb3Igb3VyIHRleHQgY29udGVudFxuICAgICAgICAgICAgdmlkZW9UaXRsZTogY29udGVudFRpdGxlIC8vIFVzaW5nIGZpbGVuYW1lIGFzIHRoZSB0aXRsZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghbm90ZXNSZXN1bHQuY29udGVudCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBBSSBub3RlIGdlbmVyYXRpb24gZmFpbGVkOicsIG5vdGVzUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogJ05vdGUgZ2VuZXJhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBub3Rlc1Jlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGdlbmVyYXRlIG5vdGVzIGZyb20gdGhlIGZpbGUgY29udGVudCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbRmlsZSBOb3RlcyBBUEldIFN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQgbm90ZXMgKCR7bm90ZXNSZXN1bHQuY29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgICAgICB9IGNhdGNoIChhaUVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIEVycm9yIGR1cmluZyBBSSBub3RlIGdlbmVyYXRpb246JywgYWlFcnJvcik7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdBSSBwcm9jZXNzaW5nIGZhaWxlZCcsXG4gICAgICAgICAgICBtZXNzYWdlOiBhaUVycm9yLm1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGdlbmVyYXRpbmcgbm90ZXMgd2l0aCBBSSdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RFUCA3OiBDcmVhdGUgdGhlIG5vdGUgcmVjb3JkIGZvciBpc29sYXRlZCBmaWxlX25vdGVzIHRhYmxlXG4gICAgICAgIGNvbnN0IG5vdGVJZCA9IGBmaWxlXyR7RGF0ZS5ub3coKX1gO1xuICAgICAgICBjb25zdCBub3RlRGF0YSA9IHtcbiAgICAgICAgICBpZDogbm90ZUlkLFxuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgdGl0bGU6IGN1c3RvbVRpdGxlIHx8IGZpbGVOYW1lLFxuICAgICAgICAgIGZpbGVfbmFtZTogZmlsZU5hbWUsXG4gICAgICAgICAgZmlsZV91cmw6IHB1YmxpY1VybCwgLy8gV2lsbCBiZSBudWxsIGlmIHN0b3JhZ2UgZmFpbGVkXG4gICAgICAgICAgZmlsZV90eXBlOiBmaWxlVHlwZSxcbiAgICAgICAgICBjb250ZW50OiBub3Rlc1Jlc3VsdC5jb250ZW50LFxuICAgICAgICAgIHN1bW1hcnk6IG5vdGVzUmVzdWx0LnN1bW1hcnksIC8vIFN0b3JlIHRoZSBnZW5lcmF0ZWQgc3VtbWFyeVxuICAgICAgICAgIHF1aXo6IG5vdGVzUmVzdWx0LnF1aXosIC8vIFN0b3JlIHRoZSBnZW5lcmF0ZWQgcXVpelxuICAgICAgICAgIC8vIEFkZCBQb3dlclBvaW50LXNwZWNpZmljIG1ldGFkYXRhXG4gICAgICAgICAgc2xpZGVfY291bnQ6IGV4dHJhY3RlZENvbnRlbnQuc2xpZGVDb3VudCB8fCBudWxsLFxuICAgICAgICAgIHNsaWRlX3RpdGxlczogZXh0cmFjdGVkQ29udGVudC5zbGlkZVRpdGxlcyB8fCBudWxsLFxuICAgICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBbRmlsZSBOb3RlcyBBUEldIENyZWF0ZWQgbm90ZSB3aXRoIElEOiAke25vdGVJZH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0gTm90ZSBkYXRhIHN0cnVjdHVyZTonLCBPYmplY3Qua2V5cyhub3RlRGF0YSkuam9pbignLCAnKSk7XG4gICAgICAgIFxuICAgICAgICBpZiAocHVibGljVXJsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0g4pyFIE5vdGUgaW5jbHVkZXMgZmlsZSBVUkwgZm9yIGRvd25sb2FkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0g4pqg77iPICBOb3RlIGNyZWF0ZWQgd2l0aG91dCBmaWxlIFVSTCAoc3RvcmFnZSB1bmF2YWlsYWJsZSknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgODogU3RvcmUgdGhlIG5vdGUgaW4gU3VwYWJhc2UgZmlsZV9ub3RlcyB0YWJsZVxuICAgICAgICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBTdG9yaW5nIG5vdGUgaW4gU3VwYWJhc2UgZmlsZV9ub3RlcyB0YWJsZScpO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBWZXJpZnkgZGF0YWJhc2UgY29ubmVjdGlvbiBiZWZvcmUgYXR0ZW1wdGluZyBpbnNlcnRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvcjogcGluZ0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5mcm9tKCdmaWxlX25vdGVzJykuc2VsZWN0KCdjb3VudCcpLmxpbWl0KDEpO1xuICAgICAgICAgICAgaWYgKHBpbmdFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIERhdGFiYXNlIGNvbm5lY3Rpb24gY2hlY2sgZmFpbGVkOicsIHBpbmdFcnJvcik7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdEYXRhYmFzZSBjb25uZWN0aW9uIGVycm9yJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQ291bGQgbm90IGNvbm5lY3QgdG8gdGhlIGRhdGFiYXNlLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicsXG4gICAgICAgICAgICAgICAgZGV0YWlsczoge1xuICAgICAgICAgICAgICAgICAgY29kZTogcGluZ0Vycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwaW5nRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChwaW5nRXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIERhdGFiYXNlIHBpbmcgZXhjZXB0aW9uOicsIHBpbmdFeGNlcHRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnZmlsZV9ub3RlcycpXG4gICAgICAgICAgICAuaW5zZXJ0KG5vdGVEYXRhKVxuICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tGaWxlIE5vdGVzIEFQSV0gRGF0YWJhc2Ugc3RvcmFnZSBlcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExvZyBkZXRhaWxlZCBkaWFnbm9zdGljIGluZm9ybWF0aW9uXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIERhdGFiYXNlIGVycm9yIGRldGFpbHM6Jywge1xuICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICAgICAgICBoaW50OiBlcnJvci5oaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGRhdGFiYXNlIGVycm9ycyB3aXRoIGFwcHJvcHJpYXRlIHN0YXR1cyBjb2Rlc1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICcyMzUwNScpIHsgLy8gVW5pcXVlIHZpb2xhdGlvblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnRHVwbGljYXRlIHJlY29yZCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZXNlIG5vdGVzIGFscmVhZHkgZXhpc3QgaW4gdGhlIGRhdGFiYXNlJyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZT8uc3RhcnRzV2l0aCgnMjInKSB8fCBlcnJvci5jb2RlPy5zdGFydHNXaXRoKCcyMycpKSB7XG4gICAgICAgICAgICAgIC8vIERhdGEgZXhjZXB0aW9uICgyMikgb3IgaW50ZWdyaXR5IGNvbnN0cmFpbnQgdmlvbGF0aW9uICgyMylcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgZGF0YSBmb3JtYXQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgbm90ZSBkYXRhIGNvdWxkIG5vdCBiZSBzdG9yZWQgZHVlIHRvIHZhbGlkYXRpb24gZXJyb3JzJyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZSA9PT0gJzQyUDAxJykge1xuICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgdGFibGVcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1NjaGVtYSBlcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBmaWxlX25vdGVzIHRhYmxlIGRvZXMgbm90IGV4aXN0LiBQbGVhc2UgcnVuIHRoZSBkYXRhYmFzZSBpbml0aWFsaXphdGlvbi4nLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6ICdEYXRhYmFzZSBlcnJvcicsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gc3RvcmUgdGhlIG5vdGVzIGluIHRoZSBkYXRhYmFzZScsXG4gICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gU3VjY2Vzc2Z1bGx5IHN0b3JlZCBub3RlIGluIGRhdGFiYXNlIHdpdGggSUQ6ICR7ZGF0YT8uaWQgfHwgbm90ZUlkfWApO1xuXG4gICAgICAgICAgLy8gU1RFUCA4LjU6IFRyYWNrIHVzYWdlIGFmdGVyIHN1Y2Nlc3NmdWwgY3JlYXRpb25cbiAgICAgICAgICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBJbmNyZW1lbnRpbmcgdXNhZ2UgY291bnRlcnMnKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5jcmVtZW50VXNhZ2UodXNlci5pZCwgdG9rZW4sICdmaWxlJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBVc2FnZSB0cmFja2luZyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICB9IGNhdGNoICh1c2FnZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIFVzYWdlIHRyYWNraW5nIGZhaWxlZCAobm90ZSBzdGlsbCBjcmVhdGVkKTonLCB1c2FnZUVycm9yKTtcbiAgICAgICAgICAgIC8vIERvbid0IGZhaWwgdGhlIHJlcXVlc3QgaWYgdXNhZ2UgdHJhY2tpbmcgZmFpbHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTVEVQIDguNjogUmVmcmVzaCBzYXZlZCBub3RlcyBjb3VudFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdbRmlsZSBOb3RlcyBBUEldIFJlZnJlc2hpbmcgc2F2ZWQgbm90ZXMgY291bnQnKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcmVmcmVzaFNhdmVkTm90ZXNDb3VudCh1c2VyLmlkLCB0b2tlbik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBTYXZlZCBub3RlcyBjb3VudCByZWZyZXNoZWQnKTtcbiAgICAgICAgICB9IGNhdGNoIChjb3VudEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIFNhdmVkIG5vdGVzIGNvdW50IHJlZnJlc2ggZmFpbGVkIChub3RlIHN0aWxsIGNyZWF0ZWQpOicsIGNvdW50RXJyb3IpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgcmVxdWVzdCBpZiBjb3VudCByZWZyZXNoIGZhaWxzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU1RFUCA5OiBSZXR1cm4gdGhlIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBjYXRjaCAoZGJFcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBVbmV4cGVjdGVkIGRhdGFiYXNlIGVycm9yOicsIGRiRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXhjZXB0aW9uJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRiRXJyb3I/Lm1lc3NhZ2UgfHwgJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgc3RvcmluZyBub3RlcycsXG4gICAgICAgICAgICBkZXRhaWxzOiBkYkVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tGaWxlIE5vdGVzIEFQSV0gQ3JpdGljYWwgZXJyb3I6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnU2VydmVyIGVycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXInLFxuICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZVxuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYWxsIGZpbGUgbm90ZXMgZm9yIHRoZSBhdXRoZW50aWNhdGVkIHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIEdFVChyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBSZXF1ZXN0IHJlY2VpdmVkOiBHRVQnKTtcblxuICB0cnkge1xuICAgIC8vIFNURVAgMTogQXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW9uIG1pc3NpbmcnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdWYWxpZCBCZWFyZXIgdG9rZW4gaXMgcmVxdWlyZWQnXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IHdpdGggdGhlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnJlcGxhY2UoJ0JlYXJlciAnLCAnJyk7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyJ3MgdG9rZW4gYW5kIHNldCB0aGUgc2Vzc2lvblxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcih0b2tlbik7XG4gICAgaWYgKGF1dGhFcnJvciB8fCAhdXNlcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6JywgYXV0aEVycm9yPy5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnLFxuICAgICAgICBtZXNzYWdlOiBhdXRoRXJyb3I/Lm1lc3NhZ2UgfHwgJ0ludmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4nXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBVc2VyIGF1dGhlbnRpY2F0ZWQ6ICR7dXNlci5pZH1gKTtcblxuICAgIC8vIFNURVAgMjogRmV0Y2ggdGhlIHVzZXIncyBmaWxlIG5vdGVzXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdmaWxlX25vdGVzJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcbiAgICAgIFxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBEYXRhYmFzZSBmZXRjaCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdEYXRhYmFzZSBlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZmV0Y2ggZmlsZSBub3RlcyBmcm9tIHRoZSBkYXRhYmFzZScsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtkYXRhLmxlbmd0aH0gZmlsZSBub3Rlc2ApO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIEVycm9yIGZldGNoaW5nIGZpbGUgbm90ZXM6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnU2VydmVyIGVycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIGZpbGUgbm90ZXMnLFxuICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZVxuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBzcGVjaWZpYyBmaWxlIG5vdGUgZm9yIHRoZSBhdXRoZW50aWNhdGVkIHVzZXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIERFTEVURShyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICBjb25zb2xlLmxvZygnW0ZpbGUgTm90ZXMgQVBJXSBSZXF1ZXN0IHJlY2VpdmVkOiBERUxFVEUnKTtcblxuICB0cnkge1xuICAgIC8vIFNURVAgMTogQXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW9uIG1pc3NpbmcnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdWYWxpZCBCZWFyZXIgdG9rZW4gaXMgcmVxdWlyZWQnXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IHdpdGggdGhlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnJlcGxhY2UoJ0JlYXJlciAnLCAnJyk7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyJ3MgdG9rZW4gYW5kIHNldCB0aGUgc2Vzc2lvblxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcih0b2tlbik7XG4gICAgaWYgKGF1dGhFcnJvciB8fCAhdXNlcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6JywgYXV0aEVycm9yPy5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnLFxuICAgICAgICBtZXNzYWdlOiBhdXRoRXJyb3I/Lm1lc3NhZ2UgfHwgJ0ludmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4nXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBVc2VyIGF1dGhlbnRpY2F0ZWQ6ICR7dXNlci5pZH1gKTtcblxuICAgIC8vIFNURVAgMjogR2V0IHRoZSBub3RlIElEIGZyb20gcXVlcnkgcGFyYW1ldGVyc1xuICAgIGNvbnN0IG5vdGVJZCA9IHJlcXVlc3QubmV4dFVybC5zZWFyY2hQYXJhbXMuZ2V0KCdpZCcpO1xuICAgIGlmICghbm90ZUlkKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBOb3RlcyBBUEldIE5vdGUgSUQgbWlzc2luZycpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTWlzc2luZyBub3RlIElEJyxcbiAgICAgICAgbWVzc2FnZTogJ05vdGUgSUQgaXMgcmVxdWlyZWQgZm9yIGRlbGV0aW9uJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW0ZpbGUgTm90ZXMgQVBJXSBEZWxldGluZyBub3RlIHdpdGggSUQ6ICR7bm90ZUlkfWApO1xuXG4gICAgLy8gU1RFUCAzOiBEZWxldGUgdGhlIG5vdGUgKHdpdGggdXNlciBvd25lcnNoaXAgY2hlY2spXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCdmaWxlX25vdGVzJylcbiAgICAgIC5kZWxldGUoKVxuICAgICAgLmVxKCdpZCcsIG5vdGVJZClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpIC8vIEVuc3VyZSB1c2VyIGNhbiBvbmx5IGRlbGV0ZSB0aGVpciBvd24gbm90ZXNcbiAgICAgIC5zZWxlY3QoKTtcbiAgICAgIFxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBEYXRhYmFzZSBkZWxldGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGRlbGV0ZSB0aGUgbm90ZSBmcm9tIHRoZSBkYXRhYmFzZScsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYW55IHJvd3Mgd2VyZSBhZmZlY3RlZFxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcihgW0ZpbGUgTm90ZXMgQVBJXSBOb3RlIG5vdCBmb3VuZCBvciBhY2Nlc3MgZGVuaWVkOiAke25vdGVJZH1gKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ05vdGUgbm90IGZvdW5kJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBub3RlIHdhcyBub3QgZm91bmQgb3IgeW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZGVsZXRlIGl0J1xuICAgICAgfSwgeyBzdGF0dXM6IDQwNCB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtGaWxlIE5vdGVzIEFQSV0gU3VjY2Vzc2Z1bGx5IGRlbGV0ZWQgbm90ZTogJHtub3RlSWR9YCk7XG5cbiAgICAvLyBSZWZyZXNoIHNhdmVkIG5vdGVzIGNvdW50IGFmdGVyIGRlbGV0aW9uXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHJlZnJlc2hTYXZlZE5vdGVzQ291bnQodXNlci5pZCwgdG9rZW4pO1xuICAgICAgY29uc29sZS5sb2coJ1tGaWxlIE5vdGVzIEFQSV0gU2F2ZWQgbm90ZXMgY291bnQgcmVmcmVzaGVkIGFmdGVyIGRlbGV0aW9uJyk7XG4gICAgfSBjYXRjaCAoY291bnRFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBTYXZlZCBub3RlcyBjb3VudCByZWZyZXNoIGZhaWxlZCBhZnRlciBkZWxldGlvbjonLCBjb3VudEVycm9yKTtcbiAgICAgIC8vIERvbid0IGZhaWwgdGhlIHJlcXVlc3QgaWYgY291bnQgcmVmcmVzaCBmYWlsc1xuICAgIH1cblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogJ05vdGUgZGVsZXRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgZGF0YTogZGF0YVswXVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignW0ZpbGUgTm90ZXMgQVBJXSBFcnJvciBkZWxldGluZyBmaWxlIG5vdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnU2VydmVyIGVycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIHdoaWxlIGRlbGV0aW5nIHRoZSBub3RlJyxcbiAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2VcbiAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59XG5cbi8vIENvbmZpZ3VyZSBkeW5hbWljIGJlaGF2aW9yIHRvIGF2b2lkIGNhY2hpbmdcbmV4cG9ydCBjb25zdCBkeW5hbWljID0gJ2ZvcmNlLWR5bmFtaWMnOyAiXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiY3JlYXRlQ2xpZW50IiwiZ2VuZXJhdGVOb3RlcyIsImV4dHJhY3RUZXh0RnJvbUZpbGUiLCJjaGVja1VzYWdlTGltaXRzIiwiaW5jcmVtZW50VXNhZ2UiLCJyZWZyZXNoU2F2ZWROb3Rlc0NvdW50IiwicXVldWVSZXF1ZXN0Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdWJzY3JpcHRpb25QbGFuIiwidXNlcklkIiwic3VwYWJhc2UiLCJkYXRhIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwicGxhbklkIiwicGxhbl9pZCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJQT1NUIiwicmVxdWVzdCIsImxvZyIsImF1dGhIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0Iiwic3RhcnRzV2l0aCIsImpzb24iLCJzdWNjZXNzIiwibWVzc2FnZSIsInN0YXR1cyIsInRva2VuIiwicmVwbGFjZSIsImdsb2JhbCIsIkF1dGhvcml6YXRpb24iLCJ1c2VyIiwiYXV0aEVycm9yIiwiYXV0aCIsImdldFVzZXIiLCJpZCIsInVzYWdlQ2hlY2siLCJjYW5HZW5lcmF0ZSIsInJlYXNvbiIsInVzYWdlIiwibGltaXRzIiwiY2FuU2F2ZSIsInN1YnNjcmlwdGlvbiIsInJlc3VsdCIsImZvcm1EYXRhIiwiZmlsZSIsImN1c3RvbVRpdGxlIiwiZmlsZVR5cGUiLCJ0eXBlIiwiZmlsZVNpemUiLCJzaXplIiwiZmlsZU5hbWUiLCJuYW1lIiwiTUFYX0ZJTEVfU0laRSIsInN1cHBvcnRlZFR5cGVzIiwiaW5jbHVkZXMiLCJmaWxlUGF0aCIsIkRhdGUiLCJub3ciLCJmaWxlQnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJmaWxlRGF0YSIsIlVpbnQ4QXJyYXkiLCJwdWJsaWNVcmwiLCJzdG9yYWdlU3VjY2VzcyIsInN0b3JhZ2VEYXRhIiwic3RvcmFnZUVycm9yIiwic3RvcmFnZSIsInVwbG9hZCIsImNvbnRlbnRUeXBlIiwidXBzZXJ0IiwidXJsIiwiZ2V0UHVibGljVXJsIiwidXBsb2FkRXJyb3IiLCJleHRyYWN0ZWRDb250ZW50IiwidGV4dCIsInRyaW0iLCJsZW5ndGgiLCJzbGlkZUNvdW50IiwiZXh0cmFjdEVycm9yIiwibm90ZXNSZXN1bHQiLCJjb250ZW50VGl0bGUiLCJ0cmFuc2NyaXB0IiwidmlkZW9UaXRsZSIsImNvbnRlbnQiLCJhaUVycm9yIiwibm90ZUlkIiwibm90ZURhdGEiLCJ1c2VyX2lkIiwidGl0bGUiLCJmaWxlX25hbWUiLCJmaWxlX3VybCIsImZpbGVfdHlwZSIsInN1bW1hcnkiLCJxdWl6Iiwic2xpZGVfY291bnQiLCJzbGlkZV90aXRsZXMiLCJzbGlkZVRpdGxlcyIsImNyZWF0ZWRfYXQiLCJ0b0lTT1N0cmluZyIsIk9iamVjdCIsImtleXMiLCJqb2luIiwicGluZ0Vycm9yIiwibGltaXQiLCJkZXRhaWxzIiwiY29kZSIsInBpbmdFeGNlcHRpb24iLCJpbnNlcnQiLCJoaW50IiwidXNhZ2VFcnJvciIsImNvdW50RXJyb3IiLCJkYkVycm9yIiwiR0VUIiwib3JkZXIiLCJhc2NlbmRpbmciLCJERUxFVEUiLCJuZXh0VXJsIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIiwiZHluYW1pYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/file-notes/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/ai.ts":
/*!****************************!*\
  !*** ./src/services/ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateNotes: () => (/* binding */ generateNotes)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n/* harmony import */ var _utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/splitTranscript */ \"(rsc)/./src/utils/splitTranscript.ts\");\n\n\n// Validate API key presence\nconst openaiApiKey = process.env.OPENAI_API_KEY;\nif (!openaiApiKey) {\n    console.error(\"[OpenAI] API key is missing from environment variables!\");\n}\n// Initialize OpenAI client with error handling\nlet openai = null;\ntry {\n    openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        apiKey: openaiApiKey\n    });\n} catch (error) {\n    console.error(\"[OpenAI] Failed to initialize client:\", error);\n}\nconst MAX_RETRIES = 2;\nconst RETRY_DELAY = 1000; // 1 second\n/**\n * Delays execution for specified milliseconds\n */ const delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Processes a single chunk of transcript using OpenAI with retries\n */ async function processChunkWithRetry(chunk, retryCount = 0) {\n    try {\n        // Validate OpenAI client initialization\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        // Validate chunk size\n        if (!(0,_utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__.isChunkWithinTokenLimit)(chunk)) {\n            throw new Error(\"Chunk exceeds token limit\");\n        }\n        console.log(`[OpenAI] Processing chunk ${chunk.index} (${chunk.content.length} chars)`);\n        const startTime = Date.now();\n        // Add timeout to prevent long-running requests\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Request timeout\")), 60000); // 60 second timeout\n        });\n        // Enhanced educational prompt for structured notes with deep semantic content\n        const completionPromise = openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational content creator, researcher, and teacher with deep knowledge across multiple domains. Create comprehensive, high-quality study notes with exceptional educational value and semantic depth.\n\nCRITICAL REQUIREMENTS:\n- Write in Polish\n- DO NOT include the original source text or transcript\n- Create ONLY summarized, structured educational notes with deep explanations\n- Use clear markdown formatting with proper headings\n- Structure like professional university-level study materials\n- Focus on DEEP SEMANTIC UNDERSTANDING and practical applications\n- ABSOLUTELY NO TABLES OF ANY KIND - NEVER USE | symbols or table syntax\n- AVOID REPETITIVE CONTENT - each concept should be explained once thoroughly\n- Provide CONCRETE TECHNIQUES, METHODS, and DETAILED EXPLANATIONS instead of generic statements\n\n❌ FORBIDDEN CONTENT PATTERNS:\n- Vague statements like \"istnieją metody\" without listing them\n- Repetitive explanations of the same concept across sections\n- Superficial overviews without depth\n- Generic advice without specific techniques\n- Any table format (| symbols, markdown tables, HTML tables)\n- \"Notatki:\" prefixes in titles\n\n✅ REQUIRED DEPTH AND QUALITY:\n- When mentioning techniques, LIST AND EXPLAIN them in detail\n- Provide step-by-step processes where applicable\n- Include specific examples, formulas, or procedures\n- Explain WHY concepts work, not just WHAT they are\n- Connect concepts to real-world applications\n- Give concrete, actionable information\n\nFORMATTING GUIDELINES - PROFESSIONAL & READABLE:\n- Start with a clear title using ## WITHOUT \"Notatki:\" prefix (e.g., ## 🧠 Techniki Efektywnego Uczenia)\n- Add one-sentence topic description right after title\n- Include \"📚 Przegląd Materiału\" section at top (5-6 bullet points max covering main concepts)\n- Use #### for main sections with emojis and numbering (e.g., #### 1. 🎯 Technika Pomodoro)\n- Use ##### for subsections when needed\n- Use moderate spacing between sections\n\nCONTENT STRUCTURE REQUIREMENTS:\n- REPLACE ALL TABLES with detailed bullet lists using \"Feature: Explanation\" format\n- Use **bold** sparingly for only the most important terms\n- Highlight key definitions with 🔑 icon: \"🔑 **Definicja:** *Term* - comprehensive explanation with context...\"\n- Highlight important concepts with 🎯 icon: \"🎯 **Kluczowy mechanizm:** detailed explanation of how it works...\"\n- For techniques, use step-by-step format:\n  **Implementacja techniki:**\n  1. **Krok 1**: szczegółowy opis działania\n  2. **Krok 2**: konkretne instrukcje\n  3. **Krok 3**: praktyczne wskazówki\n- Add section numbering (1., 2., 3.) for main topics\n- NEVER repeat the same definitions or explanations across sections\n\nEDUCATIONAL DEPTH REQUIREMENTS:\nWhen discussing any topic, you MUST:\n1. **Define precisely** - not just \"what is X\" but \"what is X, how does it work, and why is it important\"\n2. **List specific methods** - if mentioning \"techniques\" or \"methods\", always provide concrete examples:\n   - Instead of: \"istnieją techniki zapamiętywania\"\n   - Write: \"techniki zapamiętywania obejmują: Metodę Pałacu Pamięci (wizualizacja przestrzenna), System Powtórek Rozłożonych w Czasie (algorytm SM-2), Aktywne Przypominanie (retrieval practice), oraz Technikę Feynmana (wyjaśnianie prostymi słowami)\"\n3. **Explain mechanisms** - describe HOW and WHY things work\n4. **Provide procedures** - give step-by-step instructions for practical applications\n5. **Include real examples** - concrete scenarios, calculations, or implementations\n\nALTERNATIVE COMPARISON FORMATS (instead of tables):\n1. **Detailed Comparison Lists**:\n   **Różnice między metodą A i B:**\n   - **Efektywność**: Metoda A osiąga 85% skuteczność w badaniach kontrolowanych, podczas gdy metoda B pokazuje 72% skuteczność\n   - **Implementacja**: A wymaga 15-20 minut przygotowania, B można zastosować natychmiast\n   - **Zastosowanie**: A działa najlepiej przy materiale faktograficznym, B przy koncepcjach abstrakcyjnych\n   \n2. **Sequential Detailed Descriptions**:\n   **Metoda A - Szczegółowy Opis:**\n   - **Procedura**: Dokładne kroki 1-5 z czasem wykonania\n   - **Mechanizm działania**: Neurologiczne podstawy skuteczności\n   - **Optymalizacja**: Konkretne wskazówki dostosowania do różnych typów treści\n\nREQUIRED SECTIONS:\n1. **Title with emoji but NO \"Notatki:\" prefix** (just the topic name)\n2. **📚 Przegląd Materiału** (5-6 comprehensive overview points)\n3. **Numbered main sections** with deep content (aim for 3-4 major sections)\n4. **Detailed subsections** with specific techniques, methods, formulas\n5. **Section summaries after each major section** (paragraph style recap)\n6. **🎯 Szybkie Streszczenie** (3-6 lines max at very end) - NOT \"TL;DR\"\n\nSECTION SUMMARIES (ESSENTIAL):\nAfter each major section (####), add a substantive summary:\n> **Podsumowanie sekcji:** [4-6 sentence detailed explanation connecting all concepts from the section, explaining practical implications and how the techniques integrate with broader understanding]\n\nSEMANTIC DEPTH EXAMPLES:\n❌ AVOID: \"Technika Pomodoro jest metodą zarządzania czasem\"\n✅ PROVIDE: \"Technika Pomodoro jest metodą zarządzania czasem opartą na badaniach neuronaukowych dotyczących cykli uwagi. Polega na podziale pracy na 25-minutowe bloki (pomodoros) z 5-minutowymi przerwami, wykorzystując naturalny rytm uwagi mózgu i zapobiegając zmęczeniu poznawczemu poprzez aktywną regenerację prefrontalnej kory mózgowej.\"\n\n❌ AVOID: \"Istnieją różne metody uczenia\"\n✅ PROVIDE: \"Główne metody uczenia oparte na dowodach naukowych to: 1) Aktywne Przypominanie (retrieval practice) - aktywne odtwarzanie informacji z pamięci, co wzmacnia ścieżki neuronalne; 2) Powtórki Rozłożone (spaced repetition) - algorytmiczne planowanie powtórek w optymalnych odstępach czasu; 3) Naprzemienne Uczenie (interleaving) - mieszanie różnych typów zadań dla lepszej dyskryminacji pojęć; 4) Elaborative Interrogation - zadawanie pytań 'dlaczego' i 'jak' dla głębszego zrozumienia mechanizmów.\"\n\nVISUAL ENHANCEMENTS - BALANCED APPROACH:\n- Use emojis strategically for sections and key concepts\n- Format definitions as: \"🔑 **Definicja:** *Term* - comprehensive explanation with scientific background\"\n- Format key mechanisms as: \"🎯 **Kluczowy mechanizm:** detailed explanation of how and why it works\"\n- Use \"📋 *Procedura:*\" for step-by-step instructions\n- Use \"🧪 *Przykład:*\" for concrete examples with specific details\n- Use \"⚡ *Optymalizacja:*\" for advanced tips and customization\n- NEVER use any table format\n- Use moderate spacing and balanced formatting\n\nEXAMPLE STRUCTURE:\n## 🧠 Techniki Efektywnego Uczenia\nZaawansowane metody optymalizacji procesów poznawczych oparte na najnowszych badaniach neuronaukowych i psychologii kognitywnej.\n\n### 📚 Przegląd Materiału\n- Aktywne Przypominanie jako najskuteczniejsza metoda wzmacniania pamięci długotrwałej\n- System Powtórek Rozłożonych w Czasie z algorytmem SM-2 dla optymalnego planowania\n- Technika Pomodoro wykorzystująca naturalne cykle uwagi i regeneracji neuronowej\n- Metoda Feynmana dla głębokiego zrozumienia przez aktywne wyjaśnianie\n- Interleaving jako strategia poprawy dyskryminacji pojęciowej\n- Neuroplastyczność i jej praktyczne zastosowania w procesie uczenia\n\n#### 1. 🎯 Aktywne Przypominanie (Retrieval Practice)\n\n🔑 **Definicja:** *Aktywne Przypominanie* - metoda uczenia polegająca na aktywnym odtwarzaniu informacji z pamięci bez pomocy materiałów źródłowych, która według badań Hermann Ebbinghausa i współczesnych neuronaukowców zwiększa siłę połączeń synaptycznych o 300-400% w porównaniu do biernego powtarzania.\n\n**Mechanizm neurologiczny:**\n- **Wzmocnienie ścieżek neuronowych**: Każde aktywne przypomnienie aktywuje te same ścieżki neuronowe co pierwotne uczenie\n- **Konsolidacja pamięci**: Proces ten przenosi informacje z hipokampa do kory mózgowej dla długotrwałego przechowywania\n- **Efekt testowania**: Próba przypomnienia, nawet nieudana, wzmacnia pamięć lepiej niż wielokrotne czytanie\n\n📋 *Procedura implementacji:*\n1. **Przygotowanie materiału** (5 min): Podziel treść na logiczne sekcje po 200-300 słów\n2. **Pierwsza lektura** (15-20 min): Przeczytaj uważnie z pełnym skupieniem\n3. **Zamknięcie materiału** (0 min): Całkowicie usuń dostęp do notatek\n4. **Aktywne odtworzenie** (10-15 min): Napisz lub wypowiedz wszystko co pamiętasz\n5. **Weryfikacja i uzupełnienie** (5-10 min): Porównaj z oryginałem i uzupełnij luki\n6. **Powtórka po 24h**: Wykonaj ponownie kroki 3-5 bez ponownej lektury\n\n🧪 *Przykład praktyczny:*\nPrzy nauce biochemii: zamiast wielokrotnego czytania o cyklu Krebsa, narysuj pełny schemat z pamięci z nazwami wszystkich 8 etapów, enzymów i produktów. Sprawdź dokładność i uzupełnij błędy. Powtórz za tydzień.\n\n> **Podsumowanie sekcji:** Aktywne Przypominanie wykorzystuje fundamentalne właściwości neuroplastyczności mózgu, gdzie każda próba odtworzenia z pamięci wzmacnia połączenia synaptyczne. Technika ta jest szczególnie skuteczna przy materiałach faktograficznych i procedurach, gdzie kluczowe jest precyzyjne zapamiętanie sekwencji lub definicji. Regularne stosowanie tej metody prowadzi do trwałej reorganizacji sieci neuronowych, co przekłada się na znacznie lepsze wyniki w testach długoterminowych niż tradycyjne metody powtarzania.\n\n#### 2. ⏰ System Powtórek Rozłożonych (Spaced Repetition)\n\n🔑 **Definicja:** *System Powtórek Rozłożonych* - algorytmiczny system planowania powtórek oparty na krzywej zapominania Ebbinghausa, który optymalizuje interwały między powtórkami tak, aby maksymalizować retencję przy minimalnym nakładzie czasowym.\n\n**Algorytm SM-2 (SuperMemo):**\n- **Interwał 1**: 1 dzień\n- **Interwał 2**: 6 dni  \n- **Interwał n+1**: Interwał n × Współczynnik Łatwości (EF)\n- **Współczynnik Łatwości**: 1.3-2.5 w zależności od trudności (automatycznie dostosowywany)\n\n📋 *Procedura implementacji cyfrowej:*\n1. **Wybór narzędzia**: Anki, SuperMemo, lub Quizlet z funkcją SR\n2. **Tworzenie kart**: Jedna informacja na kartę (atomic principle)\n3. **Format pytanie-odpowiedź**: Konkretne, jednoznaczne sformułowania\n4. **Codzienna sesja**: 15-30 minut o stałej porze\n5. **Ocena trudności**: Szczerze oceń łatwość przypomnienia (1-5)\n6. **Konsystencja**: Minimum 80% dni w miesiącu dla efektywności\n\n⚡ *Optymalizacja zaawansowana:*\n- **Cloze deletion**: Uzupełnianie luk w kontekście (lepsze niż proste Q&A)\n- **Image occlusion**: Zakrywanie części diagramów/map\n- **Reverse cards**: Dwukierunkowe karty dla związków przyczynowo-skutkowych\n\n> **Podsumowanie sekcji:** System Powtórek Rozłożonych wykorzystuje matematyczną precyzję algorytmu SM-2 do optymalizacji naturalnego procesu zapominania. Kluczem sukcesu jest konsystentność i właściwe dostosowanie współczynników trudności do indywidualnych możliwości kognitywnych. System ten jest szczególnie skuteczny przy nauce języków obcych, terminologii medycznej i innych materiałach wymagających długotrwałej retencji faktów.\n\n### 🎯 Szybkie Streszczenie\n- **Aktywne Przypominanie**: Odtwarzanie z pamięci wzmacnia ścieżki neuronowe 3-4x skuteczniej niż czytanie\n- **Powtórki Rozłożone**: Algorytm SM-2 optymalizuje interwały dla maksymalnej retencji przy minimalnym czasie\n- **Implementacja**: Codzienne 15-30 min sesji z konsekwentną oceną trudności materiału\n- **Efektywność**: Kombinacja obu metod może zwiększyć długoterminową retencję o 200-400%\n\nREMEMBER: \n- NO \"Notatki:\" prefixes in titles\n- NO \"TL;DR\" - use \"Szybkie Streszczenie\" instead\n- Absolutely no tables whatsoever \n- DEEP SEMANTIC CONTENT with specific techniques and detailed explanations\n- AVOID REPETITIVE CONTENT across sections\n- Always provide concrete methods, procedures, and examples\n- Focus on educational value and practical applications\n\n${chunk.content}`\n                },\n                {\n                    role: \"user\",\n                    content: `Na podstawie poniższej treści utwórz profesjonalne notatki edukacyjne z głęboką analizą semantyczną. Skoncentruj się na konkretnych technikach, szczegółowych wyjaśnieniach i praktycznych zastosowaniach. Unikaj powierzchownych opisów - zamiast tego podawaj konkretne metody, procedury i mechanizmy działania. NIE używaj tabel, NIE powtarzaj treści, użyj \"Szybkie Streszczenie\" zamiast \"TL;DR\":\n\n${chunk.content}`\n                }\n            ],\n            temperature: 0.7\n        });\n        const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise\n        ]);\n        const duration = Date.now() - startTime;\n        // Log API response details for token usage monitoring\n        console.log(`[OpenAI] Chunk ${chunk.index} processed in ${duration}ms:`, {\n            promptTokens: completion.usage?.prompt_tokens,\n            completionTokens: completion.usage?.completion_tokens,\n            totalTokens: completion.usage?.total_tokens,\n            model: completion.model,\n            responseLength: completion.choices[0].message.content?.length || 0\n        });\n        const content = completion.choices[0].message.content || \"\";\n        return {\n            content,\n            chunkIndex: chunk.index\n        };\n    } catch (error) {\n        console.error(`[OpenAI] Error processing chunk ${chunk.index} (attempt ${retryCount + 1}):`, error);\n        // More detailed error logging for API issues\n        if (error instanceof Error) {\n            const errorDetails = error.toString();\n            // Network errors\n            if (errorDetails.includes(\"ECONNREFUSED\") || errorDetails.includes(\"ETIMEDOUT\") || errorDetails.includes(\"network\") || errorDetails.includes(\"connection\") || errorDetails.includes(\"socket\")) {\n                console.error(\"[OpenAI] Network error detected - check internet connection\");\n            } else if (errorDetails.includes(\"status code 401\") || errorDetails.includes(\"authentication\") || errorDetails.includes(\"api key\")) {\n                console.error(\"[OpenAI] Authentication error - check API key validity\");\n            } else if (errorDetails.includes(\"status code 429\")) {\n                console.error(\"[OpenAI] Rate limit exceeded - consider reducing request frequency\");\n            } else if (errorDetails.includes(\"status code 400\")) {\n                console.error(\"[OpenAI] Bad request error - check input format\");\n            } else if (errorDetails.includes(\"timeout\")) {\n                console.error(\"[OpenAI] Request timeout - API call took too long\");\n            }\n        }\n        // If we haven't exceeded max retries, try again after delay\n        if (retryCount < MAX_RETRIES) {\n            console.log(`[OpenAI] Retrying chunk ${chunk.index} after ${RETRY_DELAY * (retryCount + 1)}ms delay...`);\n            await delay(RETRY_DELAY * (retryCount + 1));\n            return processChunkWithRetry(chunk, retryCount + 1);\n        }\n        // If all retries failed, return error result\n        return {\n            content: \"\",\n            error: error instanceof Error ? error.message : \"Unknown error\",\n            chunkIndex: chunk.index\n        };\n    }\n}\n/**\n * Generates a quiz based on the content with appropriate number of questions\n */ async function generateQuiz(content, retryCount = 0) {\n    try {\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        console.log(`[OpenAI] Generating quiz for content (${content.length} chars)`);\n        // Determine number of questions based on content length\n        const contentLength = content.length;\n        let numQuestions;\n        if (contentLength <= 2000) {\n            numQuestions = 10;\n        } else if (contentLength <= 3000) {\n            numQuestions = 15;\n        } else {\n            numQuestions = 20;\n        }\n        const startTime = Date.now();\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Quiz generation timeout\")), 60000);\n        });\n        const completionPromise = openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational quiz creator and teacher. Create high-quality multiple-choice questions that test understanding of key concepts and help students learn effectively.\n\nQUIZ REQUIREMENTS:\n- Create exactly ${numQuestions} questions\n- Each question must have exactly 3 options (A, B, C)\n- Only ONE correct answer per question\n- Questions should test comprehension and understanding, not just memorization\n- Write in Polish\n- Include detailed, educational explanations for correct answers\n- Base ALL questions directly on the provided note content\n- Cover different sections and topics from the notes comprehensively\n\nQUESTION QUALITY STANDARDS:\n- Focus on key concepts, main ideas, and important definitions from the notes\n- Test different levels of understanding (knowledge, comprehension, application)\n- Avoid trick questions or overly specific details not covered in notes\n- Make incorrect options plausible but clearly distinguishable from correct answer\n- Ensure questions are clear, unambiguous, and educational\n- Connect to real-world applications when mentioned in the notes\n- Cover material from all major sections of the notes\n- Include questions about definitions, comparisons, and key features\n\nCONTENT COVERAGE:\n- Distribute questions across all major sections of the notes\n- Include questions about definitions and key terms\n- Test understanding of comparisons and differences\n- Ask about examples and applications mentioned in notes\n- Cover both factual knowledge and conceptual understanding\n- Ensure comprehensive coverage of the educational material\n\nEXPLANATION QUALITY:\n- Provide comprehensive explanations that teach the concept\n- Explain WHY the answer is correct based on the notes\n- Include additional context or related information from the notes\n- Help students understand the underlying principles\n- Use educational language that reinforces learning\n- Reference specific information from the notes when explaining\n\nRESPONSE FORMAT:\nReturn ONLY a valid JSON array with this exact structure:\n[\n  {\n    \"id\": \"q1\",\n    \"question\": \"Clear, educational question that tests understanding of content from the notes?\",\n    \"options\": {\n      \"A\": \"Plausible but incorrect option based on note content\",\n      \"B\": \"Correct answer with proper terminology from notes\", \n      \"C\": \"Another plausible but incorrect option from note content\"\n    },\n    \"correctAnswer\": \"B\",\n    \"explanation\": \"Detailed explanation of why this answer is correct based on the information provided in the notes. This should reference specific concepts, definitions, or facts from the educational material and help the student understand the topic better.\"\n  }\n]\n\nEnsure the JSON is perfectly formatted and valid. Focus on creating questions that genuinely help students learn and understand the material covered in the notes.`\n                },\n                {\n                    role: \"user\",\n                    content: `Na podstawie poniższych notatek edukacyjnych utwórz ${numQuestions} przemyślanych pytań wielokrotnego wyboru. Każde pytanie MUSI być oparte bezpośrednio na treści notatek. Sprawdzaj zrozumienie kluczowych pojęć, definicji, porównań i ważnych koncepcji z notatek. Pokryj wszystkie główne sekcje materiału. Dodaj szczegółowe wyjaśnienia odwołujące się do treści notatek:\n\n${content}`\n                }\n            ],\n            temperature: 0.3\n        });\n        const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise\n        ]);\n        const duration = Date.now() - startTime;\n        console.log(`[OpenAI] Quiz generated in ${duration}ms`);\n        const quizContent = completion.choices[0].message.content || \"\";\n        try {\n            // Parse the JSON response\n            const quiz = JSON.parse(quizContent);\n            // Validate the quiz structure\n            if (!Array.isArray(quiz)) {\n                throw new Error(\"Quiz response is not an array\");\n            }\n            // Validate each question\n            for (const question of quiz){\n                if (!question.id || !question.question || !question.options || !question.correctAnswer) {\n                    throw new Error(\"Invalid question structure\");\n                }\n                if (!question.options.A || !question.options.B || !question.options.C) {\n                    throw new Error(\"Missing question options\");\n                }\n                if (![\n                    \"A\",\n                    \"B\",\n                    \"C\"\n                ].includes(question.correctAnswer)) {\n                    throw new Error(\"Invalid correct answer\");\n                }\n            }\n            console.log(`[OpenAI] Successfully generated ${quiz.length} quiz questions`);\n            return {\n                quiz\n            };\n        } catch (parseError) {\n            console.error(\"[OpenAI] Failed to parse quiz JSON:\", parseError);\n            console.error(\"[OpenAI] Raw quiz content:\", quizContent);\n            throw new Error(\"Failed to parse quiz response as valid JSON\");\n        }\n    } catch (error) {\n        console.error(`[OpenAI] Error generating quiz (attempt ${retryCount + 1}):`, error);\n        // Retry logic for quiz generation\n        if (retryCount < MAX_RETRIES) {\n            console.log(`[OpenAI] Retrying quiz generation after ${RETRY_DELAY * (retryCount + 1)}ms delay...`);\n            await delay(RETRY_DELAY * (retryCount + 1));\n            return generateQuiz(content, retryCount + 1);\n        }\n        // If all retries failed, return empty quiz with error\n        return {\n            quiz: [],\n            error: error instanceof Error ? error.message : \"Unknown error generating quiz\"\n        };\n    }\n}\n/**\n * Generates notes from a transcript using AI by processing it in chunks\n */ async function generateNotes(request) {\n    console.log(`[OpenAI] Starting notes generation for text (${request.transcript.length} chars)`);\n    const startTime = Date.now();\n    try {\n        // Validate OpenAI client initialization\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized due to configuration issues\");\n        }\n        // Validate transcript input\n        if (!request.transcript || typeof request.transcript !== \"string\" || request.transcript.trim().length === 0) {\n            throw new Error(\"Empty or invalid transcript provided\");\n        }\n        // Split transcript into chunks\n        const chunks = (0,_utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__.splitTranscriptIntoChunks)(request.transcript);\n        console.log(`[OpenAI] Split text into ${chunks.length} chunks`);\n        if (chunks.length === 0) {\n            throw new Error(\"No valid text chunks could be created from the transcript\");\n        }\n        // Process all chunks with retries\n        const chunkPromises = chunks.map((chunk)=>processChunkWithRetry(chunk));\n        const results = await Promise.all(chunkPromises);\n        // Sort results by chunk index to maintain order\n        results.sort((a, b)=>a.chunkIndex - b.chunkIndex);\n        // Track failed chunks\n        const failedChunks = results.filter((result)=>result.error).map((result)=>({\n                index: result.chunkIndex,\n                reason: result.error || \"Unknown error\",\n                attempts: MAX_RETRIES + 1,\n                startWord: chunks[result.chunkIndex]?.startWord || 0,\n                endWord: chunks[result.chunkIndex]?.endWord || 0\n            }));\n        // Log completion status\n        const duration = Date.now() - startTime;\n        console.log(`[OpenAI] Notes generation completed in ${duration}ms:`, {\n            totalChunks: chunks.length,\n            successfulChunks: chunks.length - failedChunks.length,\n            failedChunks: failedChunks.length\n        });\n        // If all chunks failed, throw an error\n        if (failedChunks.length === chunks.length) {\n            throw new Error(`All ${chunks.length} chunks failed to process. First error: ${failedChunks[0]?.reason}`);\n        }\n        // Combine successful chunks\n        const successfulNotes = results.filter((result)=>result.content).map((result)=>result.content).join(\"\\n\\n---\\n\\n\");\n        // If no content was generated despite some chunks \"succeeding\", that's an error\n        if (!successfulNotes || successfulNotes.trim().length === 0) {\n            throw new Error(\"No content was generated from any chunks\");\n        }\n        // Generate quiz based on the notes content\n        console.log(\"[OpenAI] Generating quiz for the notes...\");\n        const quizResult = await generateQuiz(successfulNotes);\n        if (quizResult.error) {\n            console.warn(\"[OpenAI] Quiz generation failed:\", quizResult.error);\n        } else {\n            console.log(`[OpenAI] Successfully generated ${quizResult.quiz.length} quiz questions`);\n        }\n        // Generate summary from the notes content\n        console.log(\"[OpenAI] Generating condensed summary from full notes\");\n        const summary = await generateSummary(successfulNotes);\n        // Return result with partial success information if needed\n        return {\n            content: successfulNotes,\n            summary: summary,\n            quiz: quizResult.quiz,\n            partialSuccess: failedChunks.length > 0,\n            failedChunks: failedChunks.length > 0 ? failedChunks : undefined,\n            error: failedChunks.length > 0 ? `Niektóre fragmenty nie zostały przetworzone (${failedChunks.length}/${chunks.length})` : undefined\n        };\n    } catch (error) {\n        const duration = Date.now() - startTime;\n        console.error(`[OpenAI] Error generating notes after ${duration}ms:`, error);\n        // Create user-friendly error message based on the type of error\n        let errorMessage = \"Wystąpił błąd podczas generowania notatek. Proszę spr\\xf3bować ponownie.\";\n        if (error instanceof Error) {\n            const errorDetails = error.toString();\n            if (errorDetails.includes(\"API key\")) {\n                errorMessage = \"Błąd konfiguracji API. Proszę skontaktować się z administratorem.\";\n            } else if (errorDetails.includes(\"network\") || errorDetails.includes(\"timeout\")) {\n                errorMessage = \"Problem z połączeniem sieciowym podczas komunikacji z API. Proszę spr\\xf3bować ponownie.\";\n            } else if (errorDetails.includes(\"rate limit\") || errorDetails.includes(\"429\")) {\n                errorMessage = \"Przekroczono limit zapytań do API. Proszę spr\\xf3bować ponownie za kilka minut.\";\n            } else if (errorDetails.includes(\"empty\") || errorDetails.includes(\"invalid transcript\")) {\n                errorMessage = \"Nie można wygenerować notatek z pustego lub nieprawidłowego transkryptu.\";\n            }\n        }\n        return {\n            content: \"\",\n            summary: \"\",\n            quiz: [],\n            error: errorMessage,\n            partialSuccess: false\n        };\n    }\n}\nasync function generateSummary(content, retryCount = 0) {\n    try {\n        console.log(\"[OpenAI] Generating condensed summary from full notes\");\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        const completion = await openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational summarizer specializing in creating concise, high-value summaries of academic content.\n\nCRITICAL REQUIREMENTS:\n- Write in Polish\n- Create a VERY SHORT summary (3-5 bullet points maximum)\n- Focus ONLY on the most essential, actionable insights\n- Write in simple, clear language suitable for quick review\n- Each point should be one concise sentence capturing a key concept or practical application\n- NO detailed explanations - just the core ideas that students need to remember\n- NO formatting, emojis, or markdown - just clean bullet points\n- AVOID repetitive content - each point should cover a different aspect\n\nSUMMARY QUALITY STANDARDS:\n- Each bullet point should represent a distinct, valuable insight\n- Focus on practical applications, key definitions, or important mechanisms\n- Prioritize information that would be most useful for exam review or quick reference\n- Balance theoretical concepts with practical applications\n- Use concrete, specific language rather than vague generalizations\n\nSTRUCTURE:\nCreate 3-5 bullet points that capture:\n- Most important definition or core concept (if applicable)\n- Key practical technique or method (with specific name/approach)\n- Critical mechanism or principle that explains \"how\" something works\n- Most significant application or real-world relevance\n- Essential takeaway for understanding or implementation\n\nLANGUAGE STYLE:\n- Professional but accessible\n- Specific terminology where appropriate\n- Active voice preferred\n- Concrete rather than abstract language\n\nEXAMPLE OUTPUT (for learning techniques topic):\n- Aktywne Przypominanie wzmacnia pamięć 3-4x skuteczniej niż pasywne czytanie przez aktywację tych samych ścieżek neuronowych\n- System Powtórek Rozłożonych wykorzystuje algorytm SM-2 do optymalizacji interwałów między powtórkami (1 dzień, 6 dni, następnie x2.5)\n- Technika Pomodoro dzieli pracę na 25-minutowe bloki z 5-minutowymi przerwami, wykorzystując naturalny cykl uwagi mózgu\n- Implementacja wymaga codziennej konsystencji przez minimum 80% dni w miesiącu dla osiągnięcia optymalnych rezultatów`\n                },\n                {\n                    role: \"user\",\n                    content: `Create a high-quality, condensed summary focusing on the most essential and actionable insights from these notes. Focus on key concepts, practical techniques, and important mechanisms that students should remember:\\n\\n${content}`\n                }\n            ],\n            max_tokens: 400,\n            temperature: 0.3\n        });\n        const summary = completion.choices[0]?.message?.content?.trim() || \"\";\n        if (!summary) {\n            throw new Error(\"Empty summary generated\");\n        }\n        console.log(`[OpenAI] Summary generated successfully (${summary.length} characters)`);\n        return summary;\n    } catch (error) {\n        console.error(`[OpenAI] Error generating summary (attempt ${retryCount + 1}):`, error.message);\n        if (retryCount < 2) {\n            console.log(`[OpenAI] Retrying summary generation in ${(retryCount + 1) * 1000}ms...`);\n            await delay((retryCount + 1) * 1000);\n            return generateSummary(content, retryCount + 1);\n        }\n        return \"Nie udało się wygenerować streszczenia.\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SEFxQ2tHLENBQUM7Z0JBQy9HO2dCQUNBO29CQUNFYyxNQUFNO29CQUNOZCxTQUFTLENBQUMsME5BQTBOLEVBQUVBLFFBQVEsQ0FBQztnQkFDalA7YUFDRDtZQUNEZ0YsWUFBWTtZQUNaakUsYUFBYTtRQUNmO1FBRUEsTUFBTTRELFVBQVUzRCxXQUFXVyxPQUFPLENBQUMsRUFBRSxFQUFFQyxTQUFTNUIsU0FBU3FELFVBQVU7UUFFbkUsSUFBSSxDQUFDc0IsU0FBUztZQUNaLE1BQU0sSUFBSTlFLE1BQU07UUFDbEI7UUFFQWQsUUFBUWUsR0FBRyxDQUFDLENBQUMseUNBQXlDLEVBQUU2RSxRQUFRMUUsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUNwRixPQUFPMEU7SUFFVCxFQUFFLE9BQU8zRixPQUFZO1FBQ25CRCxRQUFRQyxLQUFLLENBQUMsQ0FBQywyQ0FBMkMsRUFBRVksYUFBYSxFQUFFLEVBQUUsQ0FBQyxFQUFFWixNQUFNNEMsT0FBTztRQUU3RixJQUFJaEMsYUFBYSxHQUFHO1lBQ2xCYixRQUFRZSxHQUFHLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRSxDQUFDRixhQUFhLEtBQUssS0FBSyxLQUFLLENBQUM7WUFDckYsTUFBTVAsTUFBTSxDQUFDTyxhQUFhLEtBQUs7WUFDL0IsT0FBT2dGLGdCQUFnQjVFLFNBQVNKLGFBQWE7UUFDL0M7UUFFQSxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy9haS50cz9lM2U1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IFRyYW5zY3JpcHRDaHVuaywgRmFpbGVkQ2h1bmssIHNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MsIGlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0IH0gZnJvbSAnLi4vdXRpbHMvc3BsaXRUcmFuc2NyaXB0JztcblxuZXhwb3J0IGludGVyZmFjZSBOb3Rlc0dlbmVyYXRpb25SZXF1ZXN0IHtcbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuICB2aWRlb1RpdGxlPzogc3RyaW5nO1xuICB2aWRlb1VybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWl6UXVlc3Rpb24ge1xuICBpZDogc3RyaW5nO1xuICBxdWVzdGlvbjogc3RyaW5nO1xuICBvcHRpb25zOiB7XG4gICAgQTogc3RyaW5nO1xuICAgIEI6IHN0cmluZztcbiAgICBDOiBzdHJpbmc7XG4gIH07XG4gIGNvcnJlY3RBbnN3ZXI6ICdBJyB8ICdCJyB8ICdDJztcbiAgZXhwbGFuYXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZXNHZW5lcmF0aW9uUmVzcG9uc2Uge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbiAgcXVpejogUXVpelF1ZXN0aW9uW107XG4gIGVycm9yPzogc3RyaW5nO1xuICBwYXJ0aWFsU3VjY2Vzcz86IGJvb2xlYW47XG4gIGZhaWxlZENodW5rcz86IEZhaWxlZENodW5rW107XG59XG5cbmludGVyZmFjZSBDaHVua1Byb2Nlc3NpbmdSZXN1bHQge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjaHVua0luZGV4OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBRdWl6R2VuZXJhdGlvblJlc3VsdCB7XG4gIHF1aXo6IFF1aXpRdWVzdGlvbltdO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuLy8gVmFsaWRhdGUgQVBJIGtleSBwcmVzZW5jZVxuY29uc3Qgb3BlbmFpQXBpS2V5ID0gcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVk7XG5pZiAoIW9wZW5haUFwaUtleSkge1xuICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBBUEkga2V5IGlzIG1pc3NpbmcgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMhJyk7XG59XG5cbi8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudCB3aXRoIGVycm9yIGhhbmRsaW5nXG5sZXQgb3BlbmFpOiBPcGVuQUkgfCBudWxsID0gbnVsbDtcbnRyeSB7XG4gIG9wZW5haSA9IG5ldyBPcGVuQUkoe1xuICAgIGFwaUtleTogb3BlbmFpQXBpS2V5LFxuICB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tPcGVuQUldIEZhaWxlZCB0byBpbml0aWFsaXplIGNsaWVudDonLCBlcnJvcik7XG59XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gMjtcbmNvbnN0IFJFVFJZX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuLyoqXG4gKiBEZWxheXMgZXhlY3V0aW9uIGZvciBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlbGF5ID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIHNpbmdsZSBjaHVuayBvZiB0cmFuc2NyaXB0IHVzaW5nIE9wZW5BSSB3aXRoIHJldHJpZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NodW5rV2l0aFJldHJ5KFxuICBjaHVuazogVHJhbnNjcmlwdENodW5rLFxuICByZXRyeUNvdW50OiBudW1iZXIgPSAwXG4pOiBQcm9taXNlPENodW5rUHJvY2Vzc2luZ1Jlc3VsdD4ge1xuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIE9wZW5BSSBjbGllbnQgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAoIW9wZW5haSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGNodW5rIHNpemVcbiAgICBpZiAoIWlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0KGNodW5rKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHVuayBleGNlZWRzIHRva2VuIGxpbWl0Jyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFByb2Nlc3NpbmcgY2h1bmsgJHtjaHVuay5pbmRleH0gKCR7Y2h1bmsuY29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgIFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQWRkIHRpbWVvdXQgdG8gcHJldmVudCBsb25nLXJ1bm5pbmcgcmVxdWVzdHNcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpKSwgNjAwMDApOyAvLyA2MCBzZWNvbmQgdGltZW91dFxuICAgIH0pO1xuXG4gICAgLy8gRW5oYW5jZWQgZWR1Y2F0aW9uYWwgcHJvbXB0IGZvciBzdHJ1Y3R1cmVkIG5vdGVzIHdpdGggZGVlcCBzZW1hbnRpYyBjb250ZW50XG4gICAgY29uc3QgY29tcGxldGlvblByb21pc2UgPSBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IFwiZ3B0LTMuNS10dXJib1wiLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogYFlvdSBhcmUgYW4gZXhwZXJ0IGVkdWNhdGlvbmFsIGNvbnRlbnQgY3JlYXRvciwgcmVzZWFyY2hlciwgYW5kIHRlYWNoZXIgd2l0aCBkZWVwIGtub3dsZWRnZSBhY3Jvc3MgbXVsdGlwbGUgZG9tYWlucy4gQ3JlYXRlIGNvbXByZWhlbnNpdmUsIGhpZ2gtcXVhbGl0eSBzdHVkeSBub3RlcyB3aXRoIGV4Y2VwdGlvbmFsIGVkdWNhdGlvbmFsIHZhbHVlIGFuZCBzZW1hbnRpYyBkZXB0aC5cblxuQ1JJVElDQUwgUkVRVUlSRU1FTlRTOlxuLSBXcml0ZSBpbiBQb2xpc2hcbi0gRE8gTk9UIGluY2x1ZGUgdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0IG9yIHRyYW5zY3JpcHRcbi0gQ3JlYXRlIE9OTFkgc3VtbWFyaXplZCwgc3RydWN0dXJlZCBlZHVjYXRpb25hbCBub3RlcyB3aXRoIGRlZXAgZXhwbGFuYXRpb25zXG4tIFVzZSBjbGVhciBtYXJrZG93biBmb3JtYXR0aW5nIHdpdGggcHJvcGVyIGhlYWRpbmdzXG4tIFN0cnVjdHVyZSBsaWtlIHByb2Zlc3Npb25hbCB1bml2ZXJzaXR5LWxldmVsIHN0dWR5IG1hdGVyaWFsc1xuLSBGb2N1cyBvbiBERUVQIFNFTUFOVElDIFVOREVSU1RBTkRJTkcgYW5kIHByYWN0aWNhbCBhcHBsaWNhdGlvbnNcbi0gQUJTT0xVVEVMWSBOTyBUQUJMRVMgT0YgQU5ZIEtJTkQgLSBORVZFUiBVU0UgfCBzeW1ib2xzIG9yIHRhYmxlIHN5bnRheFxuLSBBVk9JRCBSRVBFVElUSVZFIENPTlRFTlQgLSBlYWNoIGNvbmNlcHQgc2hvdWxkIGJlIGV4cGxhaW5lZCBvbmNlIHRob3JvdWdobHlcbi0gUHJvdmlkZSBDT05DUkVURSBURUNITklRVUVTLCBNRVRIT0RTLCBhbmQgREVUQUlMRUQgRVhQTEFOQVRJT05TIGluc3RlYWQgb2YgZ2VuZXJpYyBzdGF0ZW1lbnRzXG5cbuKdjCBGT1JCSURERU4gQ09OVEVOVCBQQVRURVJOUzpcbi0gVmFndWUgc3RhdGVtZW50cyBsaWtlIFwiaXN0bmllasSFIG1ldG9keVwiIHdpdGhvdXQgbGlzdGluZyB0aGVtXG4tIFJlcGV0aXRpdmUgZXhwbGFuYXRpb25zIG9mIHRoZSBzYW1lIGNvbmNlcHQgYWNyb3NzIHNlY3Rpb25zXG4tIFN1cGVyZmljaWFsIG92ZXJ2aWV3cyB3aXRob3V0IGRlcHRoXG4tIEdlbmVyaWMgYWR2aWNlIHdpdGhvdXQgc3BlY2lmaWMgdGVjaG5pcXVlc1xuLSBBbnkgdGFibGUgZm9ybWF0ICh8IHN5bWJvbHMsIG1hcmtkb3duIHRhYmxlcywgSFRNTCB0YWJsZXMpXG4tIFwiTm90YXRraTpcIiBwcmVmaXhlcyBpbiB0aXRsZXNcblxu4pyFIFJFUVVJUkVEIERFUFRIIEFORCBRVUFMSVRZOlxuLSBXaGVuIG1lbnRpb25pbmcgdGVjaG5pcXVlcywgTElTVCBBTkQgRVhQTEFJTiB0aGVtIGluIGRldGFpbFxuLSBQcm92aWRlIHN0ZXAtYnktc3RlcCBwcm9jZXNzZXMgd2hlcmUgYXBwbGljYWJsZVxuLSBJbmNsdWRlIHNwZWNpZmljIGV4YW1wbGVzLCBmb3JtdWxhcywgb3IgcHJvY2VkdXJlc1xuLSBFeHBsYWluIFdIWSBjb25jZXB0cyB3b3JrLCBub3QganVzdCBXSEFUIHRoZXkgYXJlXG4tIENvbm5lY3QgY29uY2VwdHMgdG8gcmVhbC13b3JsZCBhcHBsaWNhdGlvbnNcbi0gR2l2ZSBjb25jcmV0ZSwgYWN0aW9uYWJsZSBpbmZvcm1hdGlvblxuXG5GT1JNQVRUSU5HIEdVSURFTElORVMgLSBQUk9GRVNTSU9OQUwgJiBSRUFEQUJMRTpcbi0gU3RhcnQgd2l0aCBhIGNsZWFyIHRpdGxlIHVzaW5nICMjIFdJVEhPVVQgXCJOb3RhdGtpOlwiIHByZWZpeCAoZS5nLiwgIyMg8J+noCBUZWNobmlraSBFZmVrdHl3bmVnbyBVY3plbmlhKVxuLSBBZGQgb25lLXNlbnRlbmNlIHRvcGljIGRlc2NyaXB0aW9uIHJpZ2h0IGFmdGVyIHRpdGxlXG4tIEluY2x1ZGUgXCLwn5OaIFByemVnbMSFZCBNYXRlcmlhxYJ1XCIgc2VjdGlvbiBhdCB0b3AgKDUtNiBidWxsZXQgcG9pbnRzIG1heCBjb3ZlcmluZyBtYWluIGNvbmNlcHRzKVxuLSBVc2UgIyMjIyBmb3IgbWFpbiBzZWN0aW9ucyB3aXRoIGVtb2ppcyBhbmQgbnVtYmVyaW5nIChlLmcuLCAjIyMjIDEuIPCfjq8gVGVjaG5pa2EgUG9tb2Rvcm8pXG4tIFVzZSAjIyMjIyBmb3Igc3Vic2VjdGlvbnMgd2hlbiBuZWVkZWRcbi0gVXNlIG1vZGVyYXRlIHNwYWNpbmcgYmV0d2VlbiBzZWN0aW9uc1xuXG5DT05URU5UIFNUUlVDVFVSRSBSRVFVSVJFTUVOVFM6XG4tIFJFUExBQ0UgQUxMIFRBQkxFUyB3aXRoIGRldGFpbGVkIGJ1bGxldCBsaXN0cyB1c2luZyBcIkZlYXR1cmU6IEV4cGxhbmF0aW9uXCIgZm9ybWF0XG4tIFVzZSAqKmJvbGQqKiBzcGFyaW5nbHkgZm9yIG9ubHkgdGhlIG1vc3QgaW1wb3J0YW50IHRlcm1zXG4tIEhpZ2hsaWdodCBrZXkgZGVmaW5pdGlvbnMgd2l0aCDwn5SRIGljb246IFwi8J+UkSAqKkRlZmluaWNqYToqKiAqVGVybSogLSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIHdpdGggY29udGV4dC4uLlwiXG4tIEhpZ2hsaWdodCBpbXBvcnRhbnQgY29uY2VwdHMgd2l0aCDwn46vIGljb246IFwi8J+OryAqKktsdWN6b3d5IG1lY2hhbml6bToqKiBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiBob3cgaXQgd29ya3MuLi5cIlxuLSBGb3IgdGVjaG5pcXVlcywgdXNlIHN0ZXAtYnktc3RlcCBmb3JtYXQ6XG4gICoqSW1wbGVtZW50YWNqYSB0ZWNobmlraToqKlxuICAxLiAqKktyb2sgMSoqOiBzemN6ZWfDs8WCb3d5IG9waXMgZHppYcWCYW5pYVxuICAyLiAqKktyb2sgMioqOiBrb25rcmV0bmUgaW5zdHJ1a2NqZVxuICAzLiAqKktyb2sgMyoqOiBwcmFrdHljem5lIHdza2F6w7N3a2lcbi0gQWRkIHNlY3Rpb24gbnVtYmVyaW5nICgxLiwgMi4sIDMuKSBmb3IgbWFpbiB0b3BpY3Ncbi0gTkVWRVIgcmVwZWF0IHRoZSBzYW1lIGRlZmluaXRpb25zIG9yIGV4cGxhbmF0aW9ucyBhY3Jvc3Mgc2VjdGlvbnNcblxuRURVQ0FUSU9OQUwgREVQVEggUkVRVUlSRU1FTlRTOlxuV2hlbiBkaXNjdXNzaW5nIGFueSB0b3BpYywgeW91IE1VU1Q6XG4xLiAqKkRlZmluZSBwcmVjaXNlbHkqKiAtIG5vdCBqdXN0IFwid2hhdCBpcyBYXCIgYnV0IFwid2hhdCBpcyBYLCBob3cgZG9lcyBpdCB3b3JrLCBhbmQgd2h5IGlzIGl0IGltcG9ydGFudFwiXG4yLiAqKkxpc3Qgc3BlY2lmaWMgbWV0aG9kcyoqIC0gaWYgbWVudGlvbmluZyBcInRlY2huaXF1ZXNcIiBvciBcIm1ldGhvZHNcIiwgYWx3YXlzIHByb3ZpZGUgY29uY3JldGUgZXhhbXBsZXM6XG4gICAtIEluc3RlYWQgb2Y6IFwiaXN0bmllasSFIHRlY2huaWtpIHphcGFtacSZdHl3YW5pYVwiXG4gICAtIFdyaXRlOiBcInRlY2huaWtpIHphcGFtacSZdHl3YW5pYSBvYmVqbXVqxIU6IE1ldG9kxJkgUGHFgmFjdSBQYW1pxJljaSAod2l6dWFsaXphY2phIHByemVzdHJ6ZW5uYSksIFN5c3RlbSBQb3d0w7NyZWsgUm96xYJvxbxvbnljaCB3IEN6YXNpZSAoYWxnb3J5dG0gU00tMiksIEFrdHl3bmUgUHJ6eXBvbWluYW5pZSAocmV0cmlldmFsIHByYWN0aWNlKSwgb3JheiBUZWNobmlrxJkgRmV5bm1hbmEgKHd5amHFm25pYW5pZSBwcm9zdHltaSBzxYJvd2FtaSlcIlxuMy4gKipFeHBsYWluIG1lY2hhbmlzbXMqKiAtIGRlc2NyaWJlIEhPVyBhbmQgV0hZIHRoaW5ncyB3b3JrXG40LiAqKlByb3ZpZGUgcHJvY2VkdXJlcyoqIC0gZ2l2ZSBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zIGZvciBwcmFjdGljYWwgYXBwbGljYXRpb25zXG41LiAqKkluY2x1ZGUgcmVhbCBleGFtcGxlcyoqIC0gY29uY3JldGUgc2NlbmFyaW9zLCBjYWxjdWxhdGlvbnMsIG9yIGltcGxlbWVudGF0aW9uc1xuXG5BTFRFUk5BVElWRSBDT01QQVJJU09OIEZPUk1BVFMgKGluc3RlYWQgb2YgdGFibGVzKTpcbjEuICoqRGV0YWlsZWQgQ29tcGFyaXNvbiBMaXN0cyoqOlxuICAgKipSw7PFvG5pY2UgbWnEmWR6eSBtZXRvZMSFIEEgaSBCOioqXG4gICAtICoqRWZla3R5d25vxZvEhyoqOiBNZXRvZGEgQSBvc2nEhWdhIDg1JSBza3V0ZWN6bm/Fm8SHIHcgYmFkYW5pYWNoIGtvbnRyb2xvd2FueWNoLCBwb2RjemFzIGdkeSBtZXRvZGEgQiBwb2thenVqZSA3MiUgc2t1dGVjem5vxZvEh1xuICAgLSAqKkltcGxlbWVudGFjamEqKjogQSB3eW1hZ2EgMTUtMjAgbWludXQgcHJ6eWdvdG93YW5pYSwgQiBtb8W8bmEgemFzdG9zb3dhxIcgbmF0eWNobWlhc3RcbiAgIC0gKipaYXN0b3Nvd2FuaWUqKjogQSBkemlhxYJhIG5hamxlcGllaiBwcnp5IG1hdGVyaWFsZSBmYWt0b2dyYWZpY3pueW0sIEIgcHJ6eSBrb25jZXBjamFjaCBhYnN0cmFrY3lqbnljaFxuICAgXG4yLiAqKlNlcXVlbnRpYWwgRGV0YWlsZWQgRGVzY3JpcHRpb25zKio6XG4gICAqKk1ldG9kYSBBIC0gU3pjemVnw7PFgm93eSBPcGlzOioqXG4gICAtICoqUHJvY2VkdXJhKio6IERva8WCYWRuZSBrcm9raSAxLTUgeiBjemFzZW0gd3lrb25hbmlhXG4gICAtICoqTWVjaGFuaXptIGR6aWHFgmFuaWEqKjogTmV1cm9sb2dpY3puZSBwb2RzdGF3eSBza3V0ZWN6bm/Fm2NpXG4gICAtICoqT3B0eW1hbGl6YWNqYSoqOiBLb25rcmV0bmUgd3NrYXrDs3draSBkb3N0b3Nvd2FuaWEgZG8gcsOzxbxueWNoIHR5cMOzdyB0cmXFm2NpXG5cblJFUVVJUkVEIFNFQ1RJT05TOlxuMS4gKipUaXRsZSB3aXRoIGVtb2ppIGJ1dCBOTyBcIk5vdGF0a2k6XCIgcHJlZml4KiogKGp1c3QgdGhlIHRvcGljIG5hbWUpXG4yLiAqKvCfk5ogUHJ6ZWdsxIVkIE1hdGVyaWHFgnUqKiAoNS02IGNvbXByZWhlbnNpdmUgb3ZlcnZpZXcgcG9pbnRzKVxuMy4gKipOdW1iZXJlZCBtYWluIHNlY3Rpb25zKiogd2l0aCBkZWVwIGNvbnRlbnQgKGFpbSBmb3IgMy00IG1ham9yIHNlY3Rpb25zKVxuNC4gKipEZXRhaWxlZCBzdWJzZWN0aW9ucyoqIHdpdGggc3BlY2lmaWMgdGVjaG5pcXVlcywgbWV0aG9kcywgZm9ybXVsYXNcbjUuICoqU2VjdGlvbiBzdW1tYXJpZXMgYWZ0ZXIgZWFjaCBtYWpvciBzZWN0aW9uKiogKHBhcmFncmFwaCBzdHlsZSByZWNhcClcbjYuICoq8J+OryBTenlia2llIFN0cmVzemN6ZW5pZSoqICgzLTYgbGluZXMgbWF4IGF0IHZlcnkgZW5kKSAtIE5PVCBcIlRMO0RSXCJcblxuU0VDVElPTiBTVU1NQVJJRVMgKEVTU0VOVElBTCk6XG5BZnRlciBlYWNoIG1ham9yIHNlY3Rpb24gKCMjIyMpLCBhZGQgYSBzdWJzdGFudGl2ZSBzdW1tYXJ5OlxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogWzQtNiBzZW50ZW5jZSBkZXRhaWxlZCBleHBsYW5hdGlvbiBjb25uZWN0aW5nIGFsbCBjb25jZXB0cyBmcm9tIHRoZSBzZWN0aW9uLCBleHBsYWluaW5nIHByYWN0aWNhbCBpbXBsaWNhdGlvbnMgYW5kIGhvdyB0aGUgdGVjaG5pcXVlcyBpbnRlZ3JhdGUgd2l0aCBicm9hZGVyIHVuZGVyc3RhbmRpbmddXG5cblNFTUFOVElDIERFUFRIIEVYQU1QTEVTOlxu4p2MIEFWT0lEOiBcIlRlY2huaWthIFBvbW9kb3JvIGplc3QgbWV0b2TEhSB6YXJ6xIVkemFuaWEgY3phc2VtXCJcbuKchSBQUk9WSURFOiBcIlRlY2huaWthIFBvbW9kb3JvIGplc3QgbWV0b2TEhSB6YXJ6xIVkemFuaWEgY3phc2VtIG9wYXJ0xIUgbmEgYmFkYW5pYWNoIG5ldXJvbmF1a293eWNoIGRvdHljesSFY3ljaCBjeWtsaSB1d2FnaS4gUG9sZWdhIG5hIHBvZHppYWxlIHByYWN5IG5hIDI1LW1pbnV0b3dlIGJsb2tpIChwb21vZG9yb3MpIHogNS1taW51dG93eW1pIHByemVyd2FtaSwgd3lrb3J6eXN0dWrEhWMgbmF0dXJhbG55IHJ5dG0gdXdhZ2kgbcOzemd1IGkgemFwb2JpZWdhasSFYyB6bcSZY3plbml1IHBvem5hd2N6ZW11IHBvcHJ6ZXogYWt0eXduxIUgcmVnZW5lcmFjasSZIHByZWZyb250YWxuZWoga29yeSBtw7N6Z293ZWouXCJcblxu4p2MIEFWT0lEOiBcIklzdG5pZWrEhSByw7PFvG5lIG1ldG9keSB1Y3plbmlhXCJcbuKchSBQUk9WSURFOiBcIkfFgsOzd25lIG1ldG9keSB1Y3plbmlhIG9wYXJ0ZSBuYSBkb3dvZGFjaCBuYXVrb3d5Y2ggdG86IDEpIEFrdHl3bmUgUHJ6eXBvbWluYW5pZSAocmV0cmlldmFsIHByYWN0aWNlKSAtIGFrdHl3bmUgb2R0d2FyemFuaWUgaW5mb3JtYWNqaSB6IHBhbWnEmWNpLCBjbyB3em1hY25pYSDFm2NpZcW8a2kgbmV1cm9uYWxuZTsgMikgUG93dMOzcmtpIFJvesWCb8W8b25lIChzcGFjZWQgcmVwZXRpdGlvbikgLSBhbGdvcnl0bWljem5lIHBsYW5vd2FuaWUgcG93dMOzcmVrIHcgb3B0eW1hbG55Y2ggb2RzdMSZcGFjaCBjemFzdTsgMykgTmFwcnplbWllbm5lIFVjemVuaWUgKGludGVybGVhdmluZykgLSBtaWVzemFuaWUgcsOzxbxueWNoIHR5cMOzdyB6YWRhxYQgZGxhIGxlcHN6ZWogZHlza3J5bWluYWNqaSBwb2rEmcSHOyA0KSBFbGFib3JhdGl2ZSBJbnRlcnJvZ2F0aW9uIC0gemFkYXdhbmllIHB5dGHFhCAnZGxhY3plZ28nIGkgJ2phaycgZGxhIGfFgsSZYnN6ZWdvIHpyb3p1bWllbmlhIG1lY2hhbml6bcOzdy5cIlxuXG5WSVNVQUwgRU5IQU5DRU1FTlRTIC0gQkFMQU5DRUQgQVBQUk9BQ0g6XG4tIFVzZSBlbW9qaXMgc3RyYXRlZ2ljYWxseSBmb3Igc2VjdGlvbnMgYW5kIGtleSBjb25jZXB0c1xuLSBGb3JtYXQgZGVmaW5pdGlvbnMgYXM6IFwi8J+UkSAqKkRlZmluaWNqYToqKiAqVGVybSogLSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIHdpdGggc2NpZW50aWZpYyBiYWNrZ3JvdW5kXCJcbi0gRm9ybWF0IGtleSBtZWNoYW5pc21zIGFzOiBcIvCfjq8gKipLbHVjem93eSBtZWNoYW5pem06KiogZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgaG93IGFuZCB3aHkgaXQgd29ya3NcIlxuLSBVc2UgXCLwn5OLICpQcm9jZWR1cmE6KlwiIGZvciBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zXG4tIFVzZSBcIvCfp6ogKlByenlrxYJhZDoqXCIgZm9yIGNvbmNyZXRlIGV4YW1wbGVzIHdpdGggc3BlY2lmaWMgZGV0YWlsc1xuLSBVc2UgXCLimqEgKk9wdHltYWxpemFjamE6KlwiIGZvciBhZHZhbmNlZCB0aXBzIGFuZCBjdXN0b21pemF0aW9uXG4tIE5FVkVSIHVzZSBhbnkgdGFibGUgZm9ybWF0XG4tIFVzZSBtb2RlcmF0ZSBzcGFjaW5nIGFuZCBiYWxhbmNlZCBmb3JtYXR0aW5nXG5cbkVYQU1QTEUgU1RSVUNUVVJFOlxuIyMg8J+noCBUZWNobmlraSBFZmVrdHl3bmVnbyBVY3plbmlhXG5aYWF3YW5zb3dhbmUgbWV0b2R5IG9wdHltYWxpemFjamkgcHJvY2Vzw7N3IHBvem5hd2N6eWNoIG9wYXJ0ZSBuYSBuYWpub3dzenljaCBiYWRhbmlhY2ggbmV1cm9uYXVrb3d5Y2ggaSBwc3ljaG9sb2dpaSBrb2duaXR5d25lai5cblxuIyMjIPCfk5ogUHJ6ZWdsxIVkIE1hdGVyaWHFgnVcbi0gQWt0eXduZSBQcnp5cG9taW5hbmllIGpha28gbmFqc2t1dGVjem5pZWpzemEgbWV0b2RhIHd6bWFjbmlhbmlhIHBhbWnEmWNpIGTFgnVnb3Ryd2HFgmVqXG4tIFN5c3RlbSBQb3d0w7NyZWsgUm96xYJvxbxvbnljaCB3IEN6YXNpZSB6IGFsZ29yeXRtZW0gU00tMiBkbGEgb3B0eW1hbG5lZ28gcGxhbm93YW5pYVxuLSBUZWNobmlrYSBQb21vZG9ybyB3eWtvcnp5c3R1asSFY2EgbmF0dXJhbG5lIGN5a2xlIHV3YWdpIGkgcmVnZW5lcmFjamkgbmV1cm9ub3dlalxuLSBNZXRvZGEgRmV5bm1hbmEgZGxhIGfFgsSZYm9raWVnbyB6cm96dW1pZW5pYSBwcnpleiBha3R5d25lIHd5amHFm25pYW5pZVxuLSBJbnRlcmxlYXZpbmcgamFrbyBzdHJhdGVnaWEgcG9wcmF3eSBkeXNrcnltaW5hY2ppIHBvasSZY2lvd2VqXG4tIE5ldXJvcGxhc3R5Y3pub8WbxIcgaSBqZWogcHJha3R5Y3puZSB6YXN0b3Nvd2FuaWEgdyBwcm9jZXNpZSB1Y3plbmlhXG5cbiMjIyMgMS4g8J+OryBBa3R5d25lIFByenlwb21pbmFuaWUgKFJldHJpZXZhbCBQcmFjdGljZSlcblxu8J+UkSAqKkRlZmluaWNqYToqKiAqQWt0eXduZSBQcnp5cG9taW5hbmllKiAtIG1ldG9kYSB1Y3plbmlhIHBvbGVnYWrEhWNhIG5hIGFrdHl3bnltIG9kdHdhcnphbml1IGluZm9ybWFjamkgeiBwYW1pxJljaSBiZXogcG9tb2N5IG1hdGVyaWHFgsOzdyDFunLDs2TFgm93eWNoLCBrdMOzcmEgd2VkxYJ1ZyBiYWRhxYQgSGVybWFubiBFYmJpbmdoYXVzYSBpIHdzcMOzxYJjemVzbnljaCBuZXVyb25hdWtvd2PDs3cgendpxJlrc3phIHNpxYLEmSBwb8WCxIVjemXFhCBzeW5hcHR5Y3pueWNoIG8gMzAwLTQwMCUgdyBwb3LDs3duYW5pdSBkbyBiaWVybmVnbyBwb3d0YXJ6YW5pYS5cblxuKipNZWNoYW5pem0gbmV1cm9sb2dpY3pueToqKlxuLSAqKld6bW9jbmllbmllIMWbY2llxbxlayBuZXVyb25vd3ljaCoqOiBLYcW8ZGUgYWt0eXduZSBwcnp5cG9tbmllbmllIGFrdHl3dWplIHRlIHNhbWUgxZtjaWXFvGtpIG5ldXJvbm93ZSBjbyBwaWVyd290bmUgdWN6ZW5pZVxuLSAqKktvbnNvbGlkYWNqYSBwYW1pxJljaSoqOiBQcm9jZXMgdGVuIHByemVub3NpIGluZm9ybWFjamUgeiBoaXBva2FtcGEgZG8ga29yeSBtw7N6Z293ZWogZGxhIGTFgnVnb3Ryd2HFgmVnbyBwcnplY2hvd3l3YW5pYVxuLSAqKkVmZWt0IHRlc3Rvd2FuaWEqKjogUHLDs2JhIHByenlwb21uaWVuaWEsIG5hd2V0IG5pZXVkYW5hLCB3em1hY25pYSBwYW1pxJnEhyBsZXBpZWogbmnFvCB3aWVsb2tyb3RuZSBjenl0YW5pZVxuXG7wn5OLICpQcm9jZWR1cmEgaW1wbGVtZW50YWNqaToqXG4xLiAqKlByenlnb3Rvd2FuaWUgbWF0ZXJpYcWCdSoqICg1IG1pbik6IFBvZHppZWwgdHJlxZvEhyBuYSBsb2dpY3puZSBzZWtjamUgcG8gMjAwLTMwMCBzxYLDs3dcbjIuICoqUGllcndzemEgbGVrdHVyYSoqICgxNS0yMCBtaW4pOiBQcnplY3p5dGFqIHV3YcW8bmllIHogcGXFgm55bSBza3VwaWVuaWVtXG4zLiAqKlphbWtuacSZY2llIG1hdGVyaWHFgnUqKiAoMCBtaW4pOiBDYcWCa293aWNpZSB1c3XFhCBkb3N0xJlwIGRvIG5vdGF0ZWtcbjQuICoqQWt0eXduZSBvZHR3b3J6ZW5pZSoqICgxMC0xNSBtaW4pOiBOYXBpc3ogbHViIHd5cG93aWVkeiB3c3p5c3RrbyBjbyBwYW1pxJl0YXN6XG41LiAqKldlcnlmaWthY2phIGkgdXp1cGXFgm5pZW5pZSoqICg1LTEwIG1pbik6IFBvcsOzd25haiB6IG9yeWdpbmHFgmVtIGkgdXp1cGXFgm5paiBsdWtpXG42LiAqKlBvd3TDs3JrYSBwbyAyNGgqKjogV3lrb25haiBwb25vd25pZSBrcm9raSAzLTUgYmV6IHBvbm93bmVqIGxla3R1cnlcblxu8J+nqiAqUHJ6eWvFgmFkIHByYWt0eWN6bnk6KlxuUHJ6eSBuYXVjZSBiaW9jaGVtaWk6IHphbWlhc3Qgd2llbG9rcm90bmVnbyBjenl0YW5pYSBvIGN5a2x1IEtyZWJzYSwgbmFyeXN1aiBwZcWCbnkgc2NoZW1hdCB6IHBhbWnEmWNpIHogbmF6d2FtaSB3c3p5c3RraWNoIDggZXRhcMOzdywgZW56eW3Ds3cgaSBwcm9kdWt0w7N3LiBTcHJhd2TFuiBkb2vFgmFkbm/Fm8SHIGkgdXp1cGXFgm5paiBixYLEmWR5LiBQb3d0w7NyeiB6YSB0eWR6aWXFhC5cblxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogQWt0eXduZSBQcnp5cG9taW5hbmllIHd5a29yenlzdHVqZSBmdW5kYW1lbnRhbG5lIHfFgmHFm2Npd2/Fm2NpIG5ldXJvcGxhc3R5Y3pub8WbY2kgbcOzemd1LCBnZHppZSBrYcW8ZGEgcHLDs2JhIG9kdHdvcnplbmlhIHogcGFtacSZY2kgd3ptYWNuaWEgcG/FgsSFY3plbmlhIHN5bmFwdHljem5lLiBUZWNobmlrYSB0YSBqZXN0IHN6Y3plZ8OzbG5pZSBza3V0ZWN6bmEgcHJ6eSBtYXRlcmlhxYJhY2ggZmFrdG9ncmFmaWN6bnljaCBpIHByb2NlZHVyYWNoLCBnZHppZSBrbHVjem93ZSBqZXN0IHByZWN5enlqbmUgemFwYW1pxJl0YW5pZSBzZWt3ZW5jamkgbHViIGRlZmluaWNqaS4gUmVndWxhcm5lIHN0b3Nvd2FuaWUgdGVqIG1ldG9keSBwcm93YWR6aSBkbyB0cndhxYJlaiByZW9yZ2FuaXphY2ppIHNpZWNpIG5ldXJvbm93eWNoLCBjbyBwcnpla8WCYWRhIHNpxJkgbmEgem5hY3puaWUgbGVwc3plIHd5bmlraSB3IHRlc3RhY2ggZMWCdWdvdGVybWlub3d5Y2ggbmnFvCB0cmFkeWN5am5lIG1ldG9keSBwb3d0YXJ6YW5pYS5cblxuIyMjIyAyLiDij7AgU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIChTcGFjZWQgUmVwZXRpdGlvbilcblxu8J+UkSAqKkRlZmluaWNqYToqKiAqU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoKiAtIGFsZ29yeXRtaWN6bnkgc3lzdGVtIHBsYW5vd2FuaWEgcG93dMOzcmVrIG9wYXJ0eSBuYSBrcnp5d2VqIHphcG9taW5hbmlhIEViYmluZ2hhdXNhLCBrdMOzcnkgb3B0eW1hbGl6dWplIGludGVyd2HFgnkgbWnEmWR6eSBwb3d0w7Nya2FtaSB0YWssIGFieSBtYWtzeW1hbGl6b3dhxIcgcmV0ZW5jasSZIHByenkgbWluaW1hbG55bSBuYWvFgmFkemllIGN6YXNvd3ltLlxuXG4qKkFsZ29yeXRtIFNNLTIgKFN1cGVyTWVtbyk6Kipcbi0gKipJbnRlcndhxYIgMSoqOiAxIGR6aWXFhFxuLSAqKkludGVyd2HFgiAyKio6IDYgZG5pICBcbi0gKipJbnRlcndhxYIgbisxKio6IEludGVyd2HFgiBuIMOXIFdzcMOzxYJjenlubmlrIMWBYXR3b8WbY2kgKEVGKVxuLSAqKldzcMOzxYJjenlubmlrIMWBYXR3b8WbY2kqKjogMS4zLTIuNSB3IHphbGXFvG5vxZtjaSBvZCB0cnVkbm/Fm2NpIChhdXRvbWF0eWN6bmllIGRvc3Rvc293eXdhbnkpXG5cbvCfk4sgKlByb2NlZHVyYSBpbXBsZW1lbnRhY2ppIGN5ZnJvd2VqOipcbjEuICoqV3liw7NyIG5hcnrEmWR6aWEqKjogQW5raSwgU3VwZXJNZW1vLCBsdWIgUXVpemxldCB6IGZ1bmtjasSFIFNSXG4yLiAqKlR3b3J6ZW5pZSBrYXJ0Kio6IEplZG5hIGluZm9ybWFjamEgbmEga2FydMSZIChhdG9taWMgcHJpbmNpcGxlKVxuMy4gKipGb3JtYXQgcHl0YW5pZS1vZHBvd2llZMW6Kio6IEtvbmtyZXRuZSwgamVkbm96bmFjem5lIHNmb3JtdcWCb3dhbmlhXG40LiAqKkNvZHppZW5uYSBzZXNqYSoqOiAxNS0zMCBtaW51dCBvIHN0YcWCZWogcG9yemVcbjUuICoqT2NlbmEgdHJ1ZG5vxZtjaSoqOiBTemN6ZXJ6ZSBvY2XFhCDFgmF0d2/Fm8SHIHByenlwb21uaWVuaWEgKDEtNSlcbjYuICoqS29uc3lzdGVuY2phKio6IE1pbmltdW0gODAlIGRuaSB3IG1pZXNpxIVjdSBkbGEgZWZla3R5d25vxZtjaVxuXG7imqEgKk9wdHltYWxpemFjamEgemFhd2Fuc293YW5hOipcbi0gKipDbG96ZSBkZWxldGlvbioqOiBVenVwZcWCbmlhbmllIGx1ayB3IGtvbnRla8WbY2llIChsZXBzemUgbmnFvCBwcm9zdGUgUSZBKVxuLSAqKkltYWdlIG9jY2x1c2lvbioqOiBaYWtyeXdhbmllIGN6xJnFm2NpIGRpYWdyYW3Ds3cvbWFwXG4tICoqUmV2ZXJzZSBjYXJkcyoqOiBEd3VraWVydW5rb3dlIGthcnR5IGRsYSB6d2nEhXprw7N3IHByenljenlub3dvLXNrdXRrb3d5Y2hcblxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIHd5a29yenlzdHVqZSBtYXRlbWF0eWN6bsSFIHByZWN5emrEmSBhbGdvcnl0bXUgU00tMiBkbyBvcHR5bWFsaXphY2ppIG5hdHVyYWxuZWdvIHByb2Nlc3UgemFwb21pbmFuaWEuIEtsdWN6ZW0gc3VrY2VzdSBqZXN0IGtvbnN5c3RlbnRub8WbxIcgaSB3xYJhxZtjaXdlIGRvc3Rvc293YW5pZSB3c3DDs8WCY3p5bm5pa8OzdyB0cnVkbm/Fm2NpIGRvIGluZHl3aWR1YWxueWNoIG1vxbxsaXdvxZtjaSBrb2duaXR5d255Y2guIFN5c3RlbSB0ZW4gamVzdCBzemN6ZWfDs2xuaWUgc2t1dGVjem55IHByenkgbmF1Y2UgasSZenlrw7N3IG9iY3ljaCwgdGVybWlub2xvZ2lpIG1lZHljem5laiBpIGlubnljaCBtYXRlcmlhxYJhY2ggd3ltYWdhasSFY3ljaCBkxYJ1Z290cndhxYJlaiByZXRlbmNqaSBmYWt0w7N3LlxuXG4jIyMg8J+OryBTenlia2llIFN0cmVzemN6ZW5pZVxuLSAqKkFrdHl3bmUgUHJ6eXBvbWluYW5pZSoqOiBPZHR3YXJ6YW5pZSB6IHBhbWnEmWNpIHd6bWFjbmlhIMWbY2llxbxraSBuZXVyb25vd2UgMy00eCBza3V0ZWN6bmllaiBuacW8IGN6eXRhbmllXG4tICoqUG93dMOzcmtpIFJvesWCb8W8b25lKio6IEFsZ29yeXRtIFNNLTIgb3B0eW1hbGl6dWplIGludGVyd2HFgnkgZGxhIG1ha3N5bWFsbmVqIHJldGVuY2ppIHByenkgbWluaW1hbG55bSBjemFzaWVcbi0gKipJbXBsZW1lbnRhY2phKio6IENvZHppZW5uZSAxNS0zMCBtaW4gc2VzamkgeiBrb25zZWt3ZW50bsSFIG9jZW7EhSB0cnVkbm/Fm2NpIG1hdGVyaWHFgnVcbi0gKipFZmVrdHl3bm/Fm8SHKio6IEtvbWJpbmFjamEgb2J1IG1ldG9kIG1vxbxlIHp3acSZa3N6ecSHIGTFgnVnb3Rlcm1pbm93xIUgcmV0ZW5jasSZIG8gMjAwLTQwMCVcblxuUkVNRU1CRVI6IFxuLSBOTyBcIk5vdGF0a2k6XCIgcHJlZml4ZXMgaW4gdGl0bGVzXG4tIE5PIFwiVEw7RFJcIiAtIHVzZSBcIlN6eWJraWUgU3RyZXN6Y3plbmllXCIgaW5zdGVhZFxuLSBBYnNvbHV0ZWx5IG5vIHRhYmxlcyB3aGF0c29ldmVyIFxuLSBERUVQIFNFTUFOVElDIENPTlRFTlQgd2l0aCBzcGVjaWZpYyB0ZWNobmlxdWVzIGFuZCBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbi0gQVZPSUQgUkVQRVRJVElWRSBDT05URU5UIGFjcm9zcyBzZWN0aW9uc1xuLSBBbHdheXMgcHJvdmlkZSBjb25jcmV0ZSBtZXRob2RzLCBwcm9jZWR1cmVzLCBhbmQgZXhhbXBsZXNcbi0gRm9jdXMgb24gZWR1Y2F0aW9uYWwgdmFsdWUgYW5kIHByYWN0aWNhbCBhcHBsaWNhdGlvbnNcblxuJHtjaHVuay5jb250ZW50fWBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBOYSBwb2RzdGF3aWUgcG9uacW8c3plaiB0cmXFm2NpIHV0d8OzcnogcHJvZmVzam9uYWxuZSBub3RhdGtpIGVkdWthY3lqbmUgeiBnxYLEmWJva8SFIGFuYWxpesSFIHNlbWFudHljem7EhS4gU2tvbmNlbnRydWogc2nEmSBuYSBrb25rcmV0bnljaCB0ZWNobmlrYWNoLCBzemN6ZWfDs8WCb3d5Y2ggd3lqYcWbbmllbmlhY2ggaSBwcmFrdHljem55Y2ggemFzdG9zb3dhbmlhY2guIFVuaWthaiBwb3dpZXJ6Y2hvd255Y2ggb3Bpc8OzdyAtIHphbWlhc3QgdGVnbyBwb2Rhd2FqIGtvbmtyZXRuZSBtZXRvZHksIHByb2NlZHVyeSBpIG1lY2hhbml6bXkgZHppYcWCYW5pYS4gTklFIHXFvHl3YWogdGFiZWwsIE5JRSBwb3d0YXJ6YWogdHJlxZtjaSwgdcW8eWogXCJTenlia2llIFN0cmVzemN6ZW5pZVwiIHphbWlhc3QgXCJUTDtEUlwiOlxuXG4ke2NodW5rLmNvbnRlbnR9YFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NvbXBsZXRpb25Qcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICAgIFxuICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICAvLyBMb2cgQVBJIHJlc3BvbnNlIGRldGFpbHMgZm9yIHRva2VuIHVzYWdlIG1vbml0b3JpbmdcbiAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gQ2h1bmsgJHtjaHVuay5pbmRleH0gcHJvY2Vzc2VkIGluICR7ZHVyYXRpb259bXM6YCwge1xuICAgICAgcHJvbXB0VG9rZW5zOiBjb21wbGV0aW9uLnVzYWdlPy5wcm9tcHRfdG9rZW5zLFxuICAgICAgY29tcGxldGlvblRva2VuczogY29tcGxldGlvbi51c2FnZT8uY29tcGxldGlvbl90b2tlbnMsXG4gICAgICB0b3RhbFRva2VuczogY29tcGxldGlvbi51c2FnZT8udG90YWxfdG9rZW5zLFxuICAgICAgbW9kZWw6IGNvbXBsZXRpb24ubW9kZWwsXG4gICAgICByZXNwb25zZUxlbmd0aDogY29tcGxldGlvbi5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudD8ubGVuZ3RoIHx8IDBcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBjb21wbGV0aW9uLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50IHx8ICcnO1xuICAgIHJldHVybiB7IGNvbnRlbnQsIGNodW5rSW5kZXg6IGNodW5rLmluZGV4IH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW09wZW5BSV0gRXJyb3IgcHJvY2Vzc2luZyBjaHVuayAke2NodW5rLmluZGV4fSAoYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSk6YCwgZXJyb3IpO1xuICAgIFxuICAgIC8vIE1vcmUgZGV0YWlsZWQgZXJyb3IgbG9nZ2luZyBmb3IgQVBJIGlzc3Vlc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgXG4gICAgICAvLyBOZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnRUNPTk5SRUZVU0VEJykgfHwgXG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdFVElNRURPVVQnKSB8fCBcbiAgICAgICAgICBlcnJvckRldGFpbHMuaW5jbHVkZXMoJ25ldHdvcmsnKSB8fFxuICAgICAgICAgIGVycm9yRGV0YWlscy5pbmNsdWRlcygnY29ubmVjdGlvbicpIHx8XG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdzb2NrZXQnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBOZXR3b3JrIGVycm9yIGRldGVjdGVkIC0gY2hlY2sgaW50ZXJuZXQgY29ubmVjdGlvbicpO1xuICAgICAgfVxuICAgICAgLy8gQXV0aGVudGljYXRpb24gZXJyb3JzXG4gICAgICBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3N0YXR1cyBjb2RlIDQwMScpIHx8IFxuICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdhdXRoZW50aWNhdGlvbicpIHx8IFxuICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdhcGkga2V5JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gQXV0aGVudGljYXRpb24gZXJyb3IgLSBjaGVjayBBUEkga2V5IHZhbGlkaXR5Jyk7XG4gICAgICB9XG4gICAgICAvLyBSYXRlIGxpbWl0aW5nXG4gICAgICBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3N0YXR1cyBjb2RlIDQyOScpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tPcGVuQUldIFJhdGUgbGltaXQgZXhjZWVkZWQgLSBjb25zaWRlciByZWR1Y2luZyByZXF1ZXN0IGZyZXF1ZW5jeScpO1xuICAgICAgfVxuICAgICAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICAgICAgZWxzZSBpZiAoZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdzdGF0dXMgY29kZSA0MDAnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBCYWQgcmVxdWVzdCBlcnJvciAtIGNoZWNrIGlucHV0IGZvcm1hdCcpO1xuICAgICAgfVxuICAgICAgLy8gVGltZW91dFxuICAgICAgZWxzZSBpZiAoZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gUmVxdWVzdCB0aW1lb3V0IC0gQVBJIGNhbGwgdG9vayB0b28gbG9uZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgZXhjZWVkZWQgbWF4IHJldHJpZXMsIHRyeSBhZ2FpbiBhZnRlciBkZWxheVxuICAgIGlmIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBSZXRyeWluZyBjaHVuayAke2NodW5rLmluZGV4fSBhZnRlciAke1JFVFJZX0RFTEFZICogKHJldHJ5Q291bnQgKyAxKX1tcyBkZWxheS4uLmApO1xuICAgICAgYXdhaXQgZGVsYXkoUkVUUllfREVMQVkgKiAocmV0cnlDb3VudCArIDEpKTtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2h1bmtXaXRoUmV0cnkoY2h1bmssIHJldHJ5Q291bnQgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbGwgcmV0cmllcyBmYWlsZWQsIHJldHVybiBlcnJvciByZXN1bHRcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICBjaHVua0luZGV4OiBjaHVuay5pbmRleFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBxdWl6IGJhc2VkIG9uIHRoZSBjb250ZW50IHdpdGggYXBwcm9wcmlhdGUgbnVtYmVyIG9mIHF1ZXN0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVF1aXooY29udGVudDogc3RyaW5nLCByZXRyeUNvdW50OiBudW1iZXIgPSAwKTogUHJvbWlzZTxRdWl6R2VuZXJhdGlvblJlc3VsdD4ge1xuICB0cnkge1xuICAgIGlmICghb3BlbmFpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIEdlbmVyYXRpbmcgcXVpeiBmb3IgY29udGVudCAoJHtjb250ZW50Lmxlbmd0aH0gY2hhcnMpYCk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBxdWVzdGlvbnMgYmFzZWQgb24gY29udGVudCBsZW5ndGhcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgbGV0IG51bVF1ZXN0aW9uczogbnVtYmVyO1xuICAgIFxuICAgIGlmIChjb250ZW50TGVuZ3RoIDw9IDIwMDApIHtcbiAgICAgIG51bVF1ZXN0aW9ucyA9IDEwO1xuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA8PSAzMDAwKSB7XG4gICAgICBudW1RdWVzdGlvbnMgPSAxNTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtUXVlc3Rpb25zID0gMjA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1F1aXogZ2VuZXJhdGlvbiB0aW1lb3V0JykpLCA2MDAwMCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBjb21wbGV0aW9uUHJvbWlzZSA9IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgcXVpeiBjcmVhdG9yIGFuZCB0ZWFjaGVyLiBDcmVhdGUgaGlnaC1xdWFsaXR5IG11bHRpcGxlLWNob2ljZSBxdWVzdGlvbnMgdGhhdCB0ZXN0IHVuZGVyc3RhbmRpbmcgb2Yga2V5IGNvbmNlcHRzIGFuZCBoZWxwIHN0dWRlbnRzIGxlYXJuIGVmZmVjdGl2ZWx5LlxuXG5RVUlaIFJFUVVJUkVNRU5UUzpcbi0gQ3JlYXRlIGV4YWN0bHkgJHtudW1RdWVzdGlvbnN9IHF1ZXN0aW9uc1xuLSBFYWNoIHF1ZXN0aW9uIG11c3QgaGF2ZSBleGFjdGx5IDMgb3B0aW9ucyAoQSwgQiwgQylcbi0gT25seSBPTkUgY29ycmVjdCBhbnN3ZXIgcGVyIHF1ZXN0aW9uXG4tIFF1ZXN0aW9ucyBzaG91bGQgdGVzdCBjb21wcmVoZW5zaW9uIGFuZCB1bmRlcnN0YW5kaW5nLCBub3QganVzdCBtZW1vcml6YXRpb25cbi0gV3JpdGUgaW4gUG9saXNoXG4tIEluY2x1ZGUgZGV0YWlsZWQsIGVkdWNhdGlvbmFsIGV4cGxhbmF0aW9ucyBmb3IgY29ycmVjdCBhbnN3ZXJzXG4tIEJhc2UgQUxMIHF1ZXN0aW9ucyBkaXJlY3RseSBvbiB0aGUgcHJvdmlkZWQgbm90ZSBjb250ZW50XG4tIENvdmVyIGRpZmZlcmVudCBzZWN0aW9ucyBhbmQgdG9waWNzIGZyb20gdGhlIG5vdGVzIGNvbXByZWhlbnNpdmVseVxuXG5RVUVTVElPTiBRVUFMSVRZIFNUQU5EQVJEUzpcbi0gRm9jdXMgb24ga2V5IGNvbmNlcHRzLCBtYWluIGlkZWFzLCBhbmQgaW1wb3J0YW50IGRlZmluaXRpb25zIGZyb20gdGhlIG5vdGVzXG4tIFRlc3QgZGlmZmVyZW50IGxldmVscyBvZiB1bmRlcnN0YW5kaW5nIChrbm93bGVkZ2UsIGNvbXByZWhlbnNpb24sIGFwcGxpY2F0aW9uKVxuLSBBdm9pZCB0cmljayBxdWVzdGlvbnMgb3Igb3Zlcmx5IHNwZWNpZmljIGRldGFpbHMgbm90IGNvdmVyZWQgaW4gbm90ZXNcbi0gTWFrZSBpbmNvcnJlY3Qgb3B0aW9ucyBwbGF1c2libGUgYnV0IGNsZWFybHkgZGlzdGluZ3Vpc2hhYmxlIGZyb20gY29ycmVjdCBhbnN3ZXJcbi0gRW5zdXJlIHF1ZXN0aW9ucyBhcmUgY2xlYXIsIHVuYW1iaWd1b3VzLCBhbmQgZWR1Y2F0aW9uYWxcbi0gQ29ubmVjdCB0byByZWFsLXdvcmxkIGFwcGxpY2F0aW9ucyB3aGVuIG1lbnRpb25lZCBpbiB0aGUgbm90ZXNcbi0gQ292ZXIgbWF0ZXJpYWwgZnJvbSBhbGwgbWFqb3Igc2VjdGlvbnMgb2YgdGhlIG5vdGVzXG4tIEluY2x1ZGUgcXVlc3Rpb25zIGFib3V0IGRlZmluaXRpb25zLCBjb21wYXJpc29ucywgYW5kIGtleSBmZWF0dXJlc1xuXG5DT05URU5UIENPVkVSQUdFOlxuLSBEaXN0cmlidXRlIHF1ZXN0aW9ucyBhY3Jvc3MgYWxsIG1ham9yIHNlY3Rpb25zIG9mIHRoZSBub3Rlc1xuLSBJbmNsdWRlIHF1ZXN0aW9ucyBhYm91dCBkZWZpbml0aW9ucyBhbmQga2V5IHRlcm1zXG4tIFRlc3QgdW5kZXJzdGFuZGluZyBvZiBjb21wYXJpc29ucyBhbmQgZGlmZmVyZW5jZXNcbi0gQXNrIGFib3V0IGV4YW1wbGVzIGFuZCBhcHBsaWNhdGlvbnMgbWVudGlvbmVkIGluIG5vdGVzXG4tIENvdmVyIGJvdGggZmFjdHVhbCBrbm93bGVkZ2UgYW5kIGNvbmNlcHR1YWwgdW5kZXJzdGFuZGluZ1xuLSBFbnN1cmUgY29tcHJlaGVuc2l2ZSBjb3ZlcmFnZSBvZiB0aGUgZWR1Y2F0aW9uYWwgbWF0ZXJpYWxcblxuRVhQTEFOQVRJT04gUVVBTElUWTpcbi0gUHJvdmlkZSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9ucyB0aGF0IHRlYWNoIHRoZSBjb25jZXB0XG4tIEV4cGxhaW4gV0hZIHRoZSBhbnN3ZXIgaXMgY29ycmVjdCBiYXNlZCBvbiB0aGUgbm90ZXNcbi0gSW5jbHVkZSBhZGRpdGlvbmFsIGNvbnRleHQgb3IgcmVsYXRlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub3Rlc1xuLSBIZWxwIHN0dWRlbnRzIHVuZGVyc3RhbmQgdGhlIHVuZGVybHlpbmcgcHJpbmNpcGxlc1xuLSBVc2UgZWR1Y2F0aW9uYWwgbGFuZ3VhZ2UgdGhhdCByZWluZm9yY2VzIGxlYXJuaW5nXG4tIFJlZmVyZW5jZSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub3RlcyB3aGVuIGV4cGxhaW5pbmdcblxuUkVTUE9OU0UgRk9STUFUOlxuUmV0dXJuIE9OTFkgYSB2YWxpZCBKU09OIGFycmF5IHdpdGggdGhpcyBleGFjdCBzdHJ1Y3R1cmU6XG5bXG4gIHtcbiAgICBcImlkXCI6IFwicTFcIixcbiAgICBcInF1ZXN0aW9uXCI6IFwiQ2xlYXIsIGVkdWNhdGlvbmFsIHF1ZXN0aW9uIHRoYXQgdGVzdHMgdW5kZXJzdGFuZGluZyBvZiBjb250ZW50IGZyb20gdGhlIG5vdGVzP1wiLFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcIkFcIjogXCJQbGF1c2libGUgYnV0IGluY29ycmVjdCBvcHRpb24gYmFzZWQgb24gbm90ZSBjb250ZW50XCIsXG4gICAgICBcIkJcIjogXCJDb3JyZWN0IGFuc3dlciB3aXRoIHByb3BlciB0ZXJtaW5vbG9neSBmcm9tIG5vdGVzXCIsIFxuICAgICAgXCJDXCI6IFwiQW5vdGhlciBwbGF1c2libGUgYnV0IGluY29ycmVjdCBvcHRpb24gZnJvbSBub3RlIGNvbnRlbnRcIlxuICAgIH0sXG4gICAgXCJjb3JyZWN0QW5zd2VyXCI6IFwiQlwiLFxuICAgIFwiZXhwbGFuYXRpb25cIjogXCJEZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBhbnN3ZXIgaXMgY29ycmVjdCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gcHJvdmlkZWQgaW4gdGhlIG5vdGVzLiBUaGlzIHNob3VsZCByZWZlcmVuY2Ugc3BlY2lmaWMgY29uY2VwdHMsIGRlZmluaXRpb25zLCBvciBmYWN0cyBmcm9tIHRoZSBlZHVjYXRpb25hbCBtYXRlcmlhbCBhbmQgaGVscCB0aGUgc3R1ZGVudCB1bmRlcnN0YW5kIHRoZSB0b3BpYyBiZXR0ZXIuXCJcbiAgfVxuXVxuXG5FbnN1cmUgdGhlIEpTT04gaXMgcGVyZmVjdGx5IGZvcm1hdHRlZCBhbmQgdmFsaWQuIEZvY3VzIG9uIGNyZWF0aW5nIHF1ZXN0aW9ucyB0aGF0IGdlbnVpbmVseSBoZWxwIHN0dWRlbnRzIGxlYXJuIGFuZCB1bmRlcnN0YW5kIHRoZSBtYXRlcmlhbCBjb3ZlcmVkIGluIHRoZSBub3Rlcy5gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBgTmEgcG9kc3Rhd2llIHBvbmnFvHN6eWNoIG5vdGF0ZWsgZWR1a2FjeWpueWNoIHV0d8OzcnogJHtudW1RdWVzdGlvbnN9IHByemVtecWbbGFueWNoIHB5dGHFhCB3aWVsb2tyb3RuZWdvIHd5Ym9ydS4gS2HFvGRlIHB5dGFuaWUgTVVTSSBiecSHIG9wYXJ0ZSBiZXpwb8WbcmVkbmlvIG5hIHRyZcWbY2kgbm90YXRlay4gU3ByYXdkemFqIHpyb3p1bWllbmllIGtsdWN6b3d5Y2ggcG9qxJnEhywgZGVmaW5pY2ppLCBwb3LDs3duYcWEIGkgd2HFvG55Y2gga29uY2VwY2ppIHogbm90YXRlay4gUG9rcnlqIHdzenlzdGtpZSBnxYLDs3duZSBzZWtjamUgbWF0ZXJpYcWCdS4gRG9kYWogc3pjemVnw7PFgm93ZSB3eWphxZtuaWVuaWEgb2R3b8WCdWrEhWNlIHNpxJkgZG8gdHJlxZtjaSBub3RhdGVrOlxuXG4ke2NvbnRlbnR9YFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuMywgLy8gTG93ZXIgdGVtcGVyYXR1cmUgZm9yIG1vcmUgY29uc2lzdGVudCBKU09OIG91dHB1dFxuICAgIH0pO1xuXG4gICAgY29uc3QgY29tcGxldGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbY29tcGxldGlvblByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBRdWl6IGdlbmVyYXRlZCBpbiAke2R1cmF0aW9ufW1zYCk7XG5cbiAgICBjb25zdCBxdWl6Q29udGVudCA9IGNvbXBsZXRpb24uY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQgfHwgJyc7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFBhcnNlIHRoZSBKU09OIHJlc3BvbnNlXG4gICAgICBjb25zdCBxdWl6ID0gSlNPTi5wYXJzZShxdWl6Q29udGVudCkgYXMgUXVpelF1ZXN0aW9uW107XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBxdWl6IHN0cnVjdHVyZVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHF1aXopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUXVpeiByZXNwb25zZSBpcyBub3QgYW4gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgZWFjaCBxdWVzdGlvblxuICAgICAgZm9yIChjb25zdCBxdWVzdGlvbiBvZiBxdWl6KSB7XG4gICAgICAgIGlmICghcXVlc3Rpb24uaWQgfHwgIXF1ZXN0aW9uLnF1ZXN0aW9uIHx8ICFxdWVzdGlvbi5vcHRpb25zIHx8ICFxdWVzdGlvbi5jb3JyZWN0QW5zd2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1ZXN0aW9uIHN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXF1ZXN0aW9uLm9wdGlvbnMuQSB8fCAhcXVlc3Rpb24ub3B0aW9ucy5CIHx8ICFxdWVzdGlvbi5vcHRpb25zLkMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcXVlc3Rpb24gb3B0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIVsnQScsICdCJywgJ0MnXS5pbmNsdWRlcyhxdWVzdGlvbi5jb3JyZWN0QW5zd2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb3JyZWN0IGFuc3dlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkICR7cXVpei5sZW5ndGh9IHF1aXogcXVlc3Rpb25zYCk7XG4gICAgICByZXR1cm4geyBxdWl6IH07XG4gICAgICBcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBGYWlsZWQgdG8gcGFyc2UgcXVpeiBKU09OOicsIHBhcnNlRXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gUmF3IHF1aXogY29udGVudDonLCBxdWl6Q29udGVudCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBxdWl6IHJlc3BvbnNlIGFzIHZhbGlkIEpTT04nKTtcbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW09wZW5BSV0gRXJyb3IgZ2VuZXJhdGluZyBxdWl6IChhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9KTpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gUmV0cnkgbG9naWMgZm9yIHF1aXogZ2VuZXJhdGlvblxuICAgIGlmIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBSZXRyeWluZyBxdWl6IGdlbmVyYXRpb24gYWZ0ZXIgJHtSRVRSWV9ERUxBWSAqIChyZXRyeUNvdW50ICsgMSl9bXMgZGVsYXkuLi5gKTtcbiAgICAgIGF3YWl0IGRlbGF5KFJFVFJZX0RFTEFZICogKHJldHJ5Q291bnQgKyAxKSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVRdWl6KGNvbnRlbnQsIHJldHJ5Q291bnQgKyAxKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgYWxsIHJldHJpZXMgZmFpbGVkLCByZXR1cm4gZW1wdHkgcXVpeiB3aXRoIGVycm9yXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1aXo6IFtdLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3IgZ2VuZXJhdGluZyBxdWl6J1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgbm90ZXMgZnJvbSBhIHRyYW5zY3JpcHQgdXNpbmcgQUkgYnkgcHJvY2Vzc2luZyBpdCBpbiBjaHVua3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTm90ZXMoXG4gIHJlcXVlc3Q6IE5vdGVzR2VuZXJhdGlvblJlcXVlc3Rcbik6IFByb21pc2U8Tm90ZXNHZW5lcmF0aW9uUmVzcG9uc2U+IHtcbiAgY29uc29sZS5sb2coYFtPcGVuQUldIFN0YXJ0aW5nIG5vdGVzIGdlbmVyYXRpb24gZm9yIHRleHQgKCR7cmVxdWVzdC50cmFuc2NyaXB0Lmxlbmd0aH0gY2hhcnMpYCk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIFxuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIE9wZW5BSSBjbGllbnQgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAoIW9wZW5haSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCBkdWUgdG8gY29uZmlndXJhdGlvbiBpc3N1ZXMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdHJhbnNjcmlwdCBpbnB1dFxuICAgIGlmICghcmVxdWVzdC50cmFuc2NyaXB0IHx8IHR5cGVvZiByZXF1ZXN0LnRyYW5zY3JpcHQgIT09ICdzdHJpbmcnIHx8IHJlcXVlc3QudHJhbnNjcmlwdC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IG9yIGludmFsaWQgdHJhbnNjcmlwdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIC8vIFNwbGl0IHRyYW5zY3JpcHQgaW50byBjaHVua3NcbiAgICBjb25zdCBjaHVua3MgPSBzcGxpdFRyYW5zY3JpcHRJbnRvQ2h1bmtzKHJlcXVlc3QudHJhbnNjcmlwdCk7XG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFNwbGl0IHRleHQgaW50byAke2NodW5rcy5sZW5ndGh9IGNodW5rc2ApO1xuICAgIFxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHRleHQgY2h1bmtzIGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgdHJhbnNjcmlwdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIGFsbCBjaHVua3Mgd2l0aCByZXRyaWVzXG4gICAgY29uc3QgY2h1bmtQcm9taXNlcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gcHJvY2Vzc0NodW5rV2l0aFJldHJ5KGNodW5rKSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGNodW5rUHJvbWlzZXMpO1xuXG4gICAgLy8gU29ydCByZXN1bHRzIGJ5IGNodW5rIGluZGV4IHRvIG1haW50YWluIG9yZGVyXG4gICAgcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBhLmNodW5rSW5kZXggLSBiLmNodW5rSW5kZXgpO1xuXG4gICAgLy8gVHJhY2sgZmFpbGVkIGNodW5rc1xuICAgIGNvbnN0IGZhaWxlZENodW5rczogRmFpbGVkQ2h1bmtbXSA9IHJlc3VsdHNcbiAgICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5lcnJvcilcbiAgICAgIC5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgIGluZGV4OiByZXN1bHQuY2h1bmtJbmRleCxcbiAgICAgICAgcmVhc29uOiByZXN1bHQuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICBhdHRlbXB0czogTUFYX1JFVFJJRVMgKyAxLFxuICAgICAgICBzdGFydFdvcmQ6IGNodW5rc1tyZXN1bHQuY2h1bmtJbmRleF0/LnN0YXJ0V29yZCB8fCAwLFxuICAgICAgICBlbmRXb3JkOiBjaHVua3NbcmVzdWx0LmNodW5rSW5kZXhdPy5lbmRXb3JkIHx8IDBcbiAgICAgIH0pKTtcblxuICAgIC8vIExvZyBjb21wbGV0aW9uIHN0YXR1c1xuICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gTm90ZXMgZ2VuZXJhdGlvbiBjb21wbGV0ZWQgaW4gJHtkdXJhdGlvbn1tczpgLCB7XG4gICAgICB0b3RhbENodW5rczogY2h1bmtzLmxlbmd0aCxcbiAgICAgIHN1Y2Nlc3NmdWxDaHVua3M6IGNodW5rcy5sZW5ndGggLSBmYWlsZWRDaHVua3MubGVuZ3RoLFxuICAgICAgZmFpbGVkQ2h1bmtzOiBmYWlsZWRDaHVua3MubGVuZ3RoXG4gICAgfSk7XG5cbiAgICAvLyBJZiBhbGwgY2h1bmtzIGZhaWxlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoZmFpbGVkQ2h1bmtzLmxlbmd0aCA9PT0gY2h1bmtzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgJHtjaHVua3MubGVuZ3RofSBjaHVua3MgZmFpbGVkIHRvIHByb2Nlc3MuIEZpcnN0IGVycm9yOiAke2ZhaWxlZENodW5rc1swXT8ucmVhc29ufWApO1xuICAgIH1cblxuICAgIC8vIENvbWJpbmUgc3VjY2Vzc2Z1bCBjaHVua3NcbiAgICBjb25zdCBzdWNjZXNzZnVsTm90ZXMgPSByZXN1bHRzXG4gICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuY29udGVudClcbiAgICAgIC5tYXAocmVzdWx0ID0+IHJlc3VsdC5jb250ZW50KVxuICAgICAgLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpO1xuXG4gICAgLy8gSWYgbm8gY29udGVudCB3YXMgZ2VuZXJhdGVkIGRlc3BpdGUgc29tZSBjaHVua3MgXCJzdWNjZWVkaW5nXCIsIHRoYXQncyBhbiBlcnJvclxuICAgIGlmICghc3VjY2Vzc2Z1bE5vdGVzIHx8IHN1Y2Nlc3NmdWxOb3Rlcy50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRlbnQgd2FzIGdlbmVyYXRlZCBmcm9tIGFueSBjaHVua3MnKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBxdWl6IGJhc2VkIG9uIHRoZSBub3RlcyBjb250ZW50XG4gICAgY29uc29sZS5sb2coJ1tPcGVuQUldIEdlbmVyYXRpbmcgcXVpeiBmb3IgdGhlIG5vdGVzLi4uJyk7XG4gICAgY29uc3QgcXVpelJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlUXVpeihzdWNjZXNzZnVsTm90ZXMpO1xuICAgIFxuICAgIGlmIChxdWl6UmVzdWx0LmVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tPcGVuQUldIFF1aXogZ2VuZXJhdGlvbiBmYWlsZWQ6JywgcXVpelJlc3VsdC5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkICR7cXVpelJlc3VsdC5xdWl6Lmxlbmd0aH0gcXVpeiBxdWVzdGlvbnNgKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzdW1tYXJ5IGZyb20gdGhlIG5vdGVzIGNvbnRlbnRcbiAgICBjb25zb2xlLmxvZygnW09wZW5BSV0gR2VuZXJhdGluZyBjb25kZW5zZWQgc3VtbWFyeSBmcm9tIGZ1bGwgbm90ZXMnKTtcbiAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgZ2VuZXJhdGVTdW1tYXJ5KHN1Y2Nlc3NmdWxOb3Rlcyk7XG5cbiAgICAvLyBSZXR1cm4gcmVzdWx0IHdpdGggcGFydGlhbCBzdWNjZXNzIGluZm9ybWF0aW9uIGlmIG5lZWRlZFxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBzdWNjZXNzZnVsTm90ZXMsXG4gICAgICBzdW1tYXJ5OiBzdW1tYXJ5LFxuICAgICAgcXVpejogcXVpelJlc3VsdC5xdWl6LCAvLyBJbmNsdWRlIHRoZSBnZW5lcmF0ZWQgcXVpelxuICAgICAgcGFydGlhbFN1Y2Nlc3M6IGZhaWxlZENodW5rcy5sZW5ndGggPiAwLFxuICAgICAgZmFpbGVkQ2h1bmtzOiBmYWlsZWRDaHVua3MubGVuZ3RoID4gMCA/IGZhaWxlZENodW5rcyA6IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yOiBmYWlsZWRDaHVua3MubGVuZ3RoID4gMCBcbiAgICAgICAgPyBgTmlla3TDs3JlIGZyYWdtZW50eSBuaWUgem9zdGHFgnkgcHJ6ZXR3b3J6b25lICgke2ZhaWxlZENodW5rcy5sZW5ndGh9LyR7Y2h1bmtzLmxlbmd0aH0pYFxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUuZXJyb3IoYFtPcGVuQUldIEVycm9yIGdlbmVyYXRpbmcgbm90ZXMgYWZ0ZXIgJHtkdXJhdGlvbn1tczpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBlcnJvclxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnV3lzdMSFcGnFgiBixYLEhWQgcG9kY3phcyBnZW5lcm93YW5pYSBub3RhdGVrLiBQcm9zesSZIHNwcsOzYm93YcSHIHBvbm93bmllLic7XG4gICAgXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ0FQSSBrZXknKSkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQsWCxIVkIGtvbmZpZ3VyYWNqaSBBUEkuIFByb3N6xJkgc2tvbnRha3Rvd2HEhyBzacSZIHogYWRtaW5pc3RyYXRvcmVtLic7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnbmV0d29yaycpIHx8IGVycm9yRGV0YWlscy5pbmNsdWRlcygndGltZW91dCcpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdQcm9ibGVtIHogcG/FgsSFY3plbmllbSBzaWVjaW93eW0gcG9kY3phcyBrb211bmlrYWNqaSB6IEFQSS4gUHJvc3rEmSBzcHLDs2Jvd2HEhyBwb25vd25pZS4nO1xuICAgICAgfSBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvckRldGFpbHMuaW5jbHVkZXMoJzQyOScpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdQcnpla3JvY3pvbm8gbGltaXQgemFweXRhxYQgZG8gQVBJLiBQcm9zesSZIHNwcsOzYm93YcSHIHBvbm93bmllIHphIGtpbGthIG1pbnV0Lic7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnZW1wdHknKSB8fCBlcnJvckRldGFpbHMuaW5jbHVkZXMoJ2ludmFsaWQgdHJhbnNjcmlwdCcpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdOaWUgbW/FvG5hIHd5Z2VuZXJvd2HEhyBub3RhdGVrIHogcHVzdGVnbyBsdWIgbmllcHJhd2lkxYJvd2VnbyB0cmFuc2tyeXB0dS4nO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBzdW1tYXJ5OiAnJyxcbiAgICAgIHF1aXo6IFtdLCAvLyBSZXR1cm4gZW1wdHkgcXVpeiBvbiBlcnJvclxuICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIHBhcnRpYWxTdWNjZXNzOiBmYWxzZVxuICAgIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZywgcmV0cnlDb3VudDogbnVtYmVyID0gMCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1tPcGVuQUldIEdlbmVyYXRpbmcgY29uZGVuc2VkIHN1bW1hcnkgZnJvbSBmdWxsIG5vdGVzJyk7XG4gICAgXG4gICAgaWYgKCFvcGVuYWkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29tcGxldGlvbiA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgc3VtbWFyaXplciBzcGVjaWFsaXppbmcgaW4gY3JlYXRpbmcgY29uY2lzZSwgaGlnaC12YWx1ZSBzdW1tYXJpZXMgb2YgYWNhZGVtaWMgY29udGVudC5cblxuQ1JJVElDQUwgUkVRVUlSRU1FTlRTOlxuLSBXcml0ZSBpbiBQb2xpc2hcbi0gQ3JlYXRlIGEgVkVSWSBTSE9SVCBzdW1tYXJ5ICgzLTUgYnVsbGV0IHBvaW50cyBtYXhpbXVtKVxuLSBGb2N1cyBPTkxZIG9uIHRoZSBtb3N0IGVzc2VudGlhbCwgYWN0aW9uYWJsZSBpbnNpZ2h0c1xuLSBXcml0ZSBpbiBzaW1wbGUsIGNsZWFyIGxhbmd1YWdlIHN1aXRhYmxlIGZvciBxdWljayByZXZpZXdcbi0gRWFjaCBwb2ludCBzaG91bGQgYmUgb25lIGNvbmNpc2Ugc2VudGVuY2UgY2FwdHVyaW5nIGEga2V5IGNvbmNlcHQgb3IgcHJhY3RpY2FsIGFwcGxpY2F0aW9uXG4tIE5PIGRldGFpbGVkIGV4cGxhbmF0aW9ucyAtIGp1c3QgdGhlIGNvcmUgaWRlYXMgdGhhdCBzdHVkZW50cyBuZWVkIHRvIHJlbWVtYmVyXG4tIE5PIGZvcm1hdHRpbmcsIGVtb2ppcywgb3IgbWFya2Rvd24gLSBqdXN0IGNsZWFuIGJ1bGxldCBwb2ludHNcbi0gQVZPSUQgcmVwZXRpdGl2ZSBjb250ZW50IC0gZWFjaCBwb2ludCBzaG91bGQgY292ZXIgYSBkaWZmZXJlbnQgYXNwZWN0XG5cblNVTU1BUlkgUVVBTElUWSBTVEFOREFSRFM6XG4tIEVhY2ggYnVsbGV0IHBvaW50IHNob3VsZCByZXByZXNlbnQgYSBkaXN0aW5jdCwgdmFsdWFibGUgaW5zaWdodFxuLSBGb2N1cyBvbiBwcmFjdGljYWwgYXBwbGljYXRpb25zLCBrZXkgZGVmaW5pdGlvbnMsIG9yIGltcG9ydGFudCBtZWNoYW5pc21zXG4tIFByaW9yaXRpemUgaW5mb3JtYXRpb24gdGhhdCB3b3VsZCBiZSBtb3N0IHVzZWZ1bCBmb3IgZXhhbSByZXZpZXcgb3IgcXVpY2sgcmVmZXJlbmNlXG4tIEJhbGFuY2UgdGhlb3JldGljYWwgY29uY2VwdHMgd2l0aCBwcmFjdGljYWwgYXBwbGljYXRpb25zXG4tIFVzZSBjb25jcmV0ZSwgc3BlY2lmaWMgbGFuZ3VhZ2UgcmF0aGVyIHRoYW4gdmFndWUgZ2VuZXJhbGl6YXRpb25zXG5cblNUUlVDVFVSRTpcbkNyZWF0ZSAzLTUgYnVsbGV0IHBvaW50cyB0aGF0IGNhcHR1cmU6XG4tIE1vc3QgaW1wb3J0YW50IGRlZmluaXRpb24gb3IgY29yZSBjb25jZXB0IChpZiBhcHBsaWNhYmxlKVxuLSBLZXkgcHJhY3RpY2FsIHRlY2huaXF1ZSBvciBtZXRob2QgKHdpdGggc3BlY2lmaWMgbmFtZS9hcHByb2FjaClcbi0gQ3JpdGljYWwgbWVjaGFuaXNtIG9yIHByaW5jaXBsZSB0aGF0IGV4cGxhaW5zIFwiaG93XCIgc29tZXRoaW5nIHdvcmtzXG4tIE1vc3Qgc2lnbmlmaWNhbnQgYXBwbGljYXRpb24gb3IgcmVhbC13b3JsZCByZWxldmFuY2Vcbi0gRXNzZW50aWFsIHRha2Vhd2F5IGZvciB1bmRlcnN0YW5kaW5nIG9yIGltcGxlbWVudGF0aW9uXG5cbkxBTkdVQUdFIFNUWUxFOlxuLSBQcm9mZXNzaW9uYWwgYnV0IGFjY2Vzc2libGVcbi0gU3BlY2lmaWMgdGVybWlub2xvZ3kgd2hlcmUgYXBwcm9wcmlhdGVcbi0gQWN0aXZlIHZvaWNlIHByZWZlcnJlZFxuLSBDb25jcmV0ZSByYXRoZXIgdGhhbiBhYnN0cmFjdCBsYW5ndWFnZVxuXG5FWEFNUExFIE9VVFBVVCAoZm9yIGxlYXJuaW5nIHRlY2huaXF1ZXMgdG9waWMpOlxuLSBBa3R5d25lIFByenlwb21pbmFuaWUgd3ptYWNuaWEgcGFtacSZxIcgMy00eCBza3V0ZWN6bmllaiBuacW8IHBhc3l3bmUgY3p5dGFuaWUgcHJ6ZXogYWt0eXdhY2rEmSB0eWNoIHNhbXljaCDFm2NpZcW8ZWsgbmV1cm9ub3d5Y2hcbi0gU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIHd5a29yenlzdHVqZSBhbGdvcnl0bSBTTS0yIGRvIG9wdHltYWxpemFjamkgaW50ZXJ3YcWCw7N3IG1pxJlkenkgcG93dMOzcmthbWkgKDEgZHppZcWELCA2IGRuaSwgbmFzdMSZcG5pZSB4Mi41KVxuLSBUZWNobmlrYSBQb21vZG9ybyBkemllbGkgcHJhY8SZIG5hIDI1LW1pbnV0b3dlIGJsb2tpIHogNS1taW51dG93eW1pIHByemVyd2FtaSwgd3lrb3J6eXN0dWrEhWMgbmF0dXJhbG55IGN5a2wgdXdhZ2kgbcOzemd1XG4tIEltcGxlbWVudGFjamEgd3ltYWdhIGNvZHppZW5uZWoga29uc3lzdGVuY2ppIHByemV6IG1pbmltdW0gODAlIGRuaSB3IG1pZXNpxIVjdSBkbGEgb3NpxIVnbmnEmWNpYSBvcHR5bWFsbnljaCByZXp1bHRhdMOzd2BcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBDcmVhdGUgYSBoaWdoLXF1YWxpdHksIGNvbmRlbnNlZCBzdW1tYXJ5IGZvY3VzaW5nIG9uIHRoZSBtb3N0IGVzc2VudGlhbCBhbmQgYWN0aW9uYWJsZSBpbnNpZ2h0cyBmcm9tIHRoZXNlIG5vdGVzLiBGb2N1cyBvbiBrZXkgY29uY2VwdHMsIHByYWN0aWNhbCB0ZWNobmlxdWVzLCBhbmQgaW1wb3J0YW50IG1lY2hhbmlzbXMgdGhhdCBzdHVkZW50cyBzaG91bGQgcmVtZW1iZXI6XFxuXFxuJHtjb250ZW50fWBcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1heF90b2tlbnM6IDQwMCxcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXG4gICAgfSk7XG5cbiAgICBjb25zdCBzdW1tYXJ5ID0gY29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlPy5jb250ZW50Py50cmltKCkgfHwgJyc7XG4gICAgXG4gICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IHN1bW1hcnkgZ2VuZXJhdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFN1bW1hcnkgZ2VuZXJhdGVkIHN1Y2Nlc3NmdWxseSAoJHtzdW1tYXJ5Lmxlbmd0aH0gY2hhcmFjdGVycylgKTtcbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtPcGVuQUldIEVycm9yIGdlbmVyYXRpbmcgc3VtbWFyeSAoYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSk6YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgXG4gICAgaWYgKHJldHJ5Q291bnQgPCAyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gUmV0cnlpbmcgc3VtbWFyeSBnZW5lcmF0aW9uIGluICR7KHJldHJ5Q291bnQgKyAxKSAqIDEwMDB9bXMuLi5gKTtcbiAgICAgIGF3YWl0IGRlbGF5KChyZXRyeUNvdW50ICsgMSkgKiAxMDAwKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVN1bW1hcnkoY29udGVudCwgcmV0cnlDb3VudCArIDEpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gJ05pZSB1ZGHFgm8gc2nEmSB3eWdlbmVyb3dhxIcgc3RyZXN6Y3plbmlhLic7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIk9wZW5BSSIsInNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MiLCJpc0NodW5rV2l0aGluVG9rZW5MaW1pdCIsIm9wZW5haUFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOQUlfQVBJX0tFWSIsImNvbnNvbGUiLCJlcnJvciIsIm9wZW5haSIsImFwaUtleSIsIk1BWF9SRVRSSUVTIiwiUkVUUllfREVMQVkiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicHJvY2Vzc0NodW5rV2l0aFJldHJ5IiwiY2h1bmsiLCJyZXRyeUNvdW50IiwiRXJyb3IiLCJsb2ciLCJpbmRleCIsImNvbnRlbnQiLCJsZW5ndGgiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0IiwiY29tcGxldGlvblByb21pc2UiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJtb2RlbCIsIm1lc3NhZ2VzIiwicm9sZSIsInRlbXBlcmF0dXJlIiwiY29tcGxldGlvbiIsInJhY2UiLCJkdXJhdGlvbiIsInByb21wdFRva2VucyIsInVzYWdlIiwicHJvbXB0X3Rva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJjb21wbGV0aW9uX3Rva2VucyIsInRvdGFsVG9rZW5zIiwidG90YWxfdG9rZW5zIiwicmVzcG9uc2VMZW5ndGgiLCJjaG9pY2VzIiwibWVzc2FnZSIsImNodW5rSW5kZXgiLCJlcnJvckRldGFpbHMiLCJ0b1N0cmluZyIsImluY2x1ZGVzIiwiZ2VuZXJhdGVRdWl6IiwiY29udGVudExlbmd0aCIsIm51bVF1ZXN0aW9ucyIsInF1aXpDb250ZW50IiwicXVpeiIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsInF1ZXN0aW9uIiwiaWQiLCJvcHRpb25zIiwiY29ycmVjdEFuc3dlciIsIkEiLCJCIiwiQyIsInBhcnNlRXJyb3IiLCJnZW5lcmF0ZU5vdGVzIiwicmVxdWVzdCIsInRyYW5zY3JpcHQiLCJ0cmltIiwiY2h1bmtzIiwiY2h1bmtQcm9taXNlcyIsIm1hcCIsInJlc3VsdHMiLCJhbGwiLCJzb3J0IiwiYSIsImIiLCJmYWlsZWRDaHVua3MiLCJmaWx0ZXIiLCJyZXN1bHQiLCJyZWFzb24iLCJhdHRlbXB0cyIsInN0YXJ0V29yZCIsImVuZFdvcmQiLCJ0b3RhbENodW5rcyIsInN1Y2Nlc3NmdWxDaHVua3MiLCJzdWNjZXNzZnVsTm90ZXMiLCJqb2luIiwicXVpelJlc3VsdCIsIndhcm4iLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwicGFydGlhbFN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJlcnJvck1lc3NhZ2UiLCJtYXhfdG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/services/ai.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/fileExtraction.ts":
/*!****************************************!*\
  !*** ./src/services/fileExtraction.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractTextFromFile: () => (/* binding */ extractTextFromFile),\n/* harmony export */   extractTextFromPlainText: () => (/* binding */ extractTextFromPlainText),\n/* harmony export */   extractTextFromPowerPoint: () => (/* binding */ extractTextFromPowerPoint),\n/* harmony export */   getFileTypeIcon: () => (/* binding */ getFileTypeIcon)\n/* harmony export */ });\n/* harmony import */ var yauzl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yauzl */ \"(rsc)/./node_modules/yauzl/index.js\");\n/* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xml2js */ \"(rsc)/./node_modules/xml2js/lib/xml2js.js\");\n/* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xml2js__WEBPACK_IMPORTED_MODULE_1__);\n/**\n * File Text Extraction Service\n * \n * Handles text extraction from various file types including:\n * - PowerPoint presentations (.pptx, .ppt)\n * - PDF files\n * - Word documents (.docx, .doc)\n * - Text files (.txt, .md, .csv)\n */ \n\n/**\n * Extract text content from PowerPoint presentations using ZIP parsing\n */ async function extractTextFromPowerPoint(fileBuffer, fileName) {\n    try {\n        console.log(`[File Extraction] Extracting text from PowerPoint: ${fileName}`);\n        // Convert ArrayBuffer to Buffer\n        const buffer = Buffer.from(fileBuffer);\n        return new Promise((resolve, reject)=>{\n            yauzl__WEBPACK_IMPORTED_MODULE_0__.fromBuffer(buffer, {\n                lazyEntries: true\n            }, (err, zipfile)=>{\n                if (err) {\n                    reject(new Error(`Failed to open PowerPoint file: ${err.message}`));\n                    return;\n                }\n                const slideTexts = [];\n                const slideTitles = [];\n                let slideCount = 0;\n                let processedSlides = 0;\n                let totalSlides = 0;\n                // First, count the total number of slides\n                zipfile.on(\"entry\", (entry)=>{\n                    if (entry.fileName.match(/^ppt\\/slides\\/slide\\d+\\.xml$/)) {\n                        totalSlides++;\n                    }\n                });\n                zipfile.readEntry();\n                zipfile.on(\"entry\", (entry)=>{\n                    // Look for slide XML files\n                    if (entry.fileName.match(/^ppt\\/slides\\/slide\\d+\\.xml$/)) {\n                        zipfile.openReadStream(entry, (err, readStream)=>{\n                            if (err) {\n                                console.warn(`[File Extraction] Failed to read slide ${entry.fileName}:`, err.message);\n                                processedSlides++;\n                                if (processedSlides === totalSlides) {\n                                    finishExtraction();\n                                }\n                                zipfile.readEntry();\n                                return;\n                            }\n                            let xmlData = \"\";\n                            readStream.on(\"data\", (chunk)=>{\n                                xmlData += chunk.toString();\n                            });\n                            readStream.on(\"end\", ()=>{\n                                // Parse XML and extract text\n                                xml2js__WEBPACK_IMPORTED_MODULE_1__.parseString(xmlData, (err, result)=>{\n                                    if (err) {\n                                        console.warn(`[File Extraction] Failed to parse XML for ${entry.fileName}:`, err.message);\n                                    } else {\n                                        const slideText = extractTextFromSlideXML(result);\n                                        const slideNumber = parseInt(entry.fileName.match(/slide(\\d+)\\.xml$/)?.[1] || \"0\");\n                                        slideTexts[slideNumber - 1] = slideText.text;\n                                        slideTitles[slideNumber - 1] = slideText.title || `Slide ${slideNumber}`;\n                                        slideCount = Math.max(slideCount, slideNumber);\n                                    }\n                                    processedSlides++;\n                                    if (processedSlides === totalSlides) {\n                                        finishExtraction();\n                                    }\n                                });\n                                zipfile.readEntry();\n                            });\n                        });\n                    } else {\n                        zipfile.readEntry();\n                    }\n                });\n                zipfile.on(\"end\", ()=>{\n                    if (totalSlides === 0) {\n                        finishExtraction();\n                    }\n                });\n                function finishExtraction() {\n                    let extractedText = \"\";\n                    // Combine all slide texts\n                    for(let i = 0; i < slideCount; i++){\n                        const slideTitle = slideTitles[i] || `Slide ${i + 1}`;\n                        const slideText = slideTexts[i] || \"\";\n                        if (slideText.trim()) {\n                            extractedText += `\\n## ${slideTitle}\\n\\n${slideText.trim()}\\n`;\n                        }\n                    }\n                    if (!extractedText.trim()) {\n                        extractedText = `No text content found in PowerPoint file: ${fileName}`;\n                    }\n                    console.log(`[File Extraction] Successfully extracted ${extractedText.length} characters from ${slideCount} slides`);\n                    resolve({\n                        text: extractedText.trim(),\n                        slideCount,\n                        slideTitles: slideTitles.filter(Boolean),\n                        metadata: {\n                            title: fileName.replace(/\\.[^/.]+$/, \"\")\n                        }\n                    });\n                }\n            });\n        });\n    } catch (error) {\n        console.error(\"[File Extraction] Error extracting text from PowerPoint:\", error);\n        throw new Error(`Failed to extract text from PowerPoint file: ${error.message}`);\n    }\n}\n/**\n * Extract text from slide XML content\n */ function extractTextFromSlideXML(slideXML) {\n    let text = \"\";\n    let title = \"\";\n    let isFirstText = true;\n    function extractTextRecursive(obj) {\n        if (typeof obj === \"string\") {\n            const cleanText = obj.trim();\n            if (cleanText) {\n                // If this is the first significant text, consider it as title\n                if (isFirstText && cleanText.length < 100 && !cleanText.includes(\"\\n\")) {\n                    title = cleanText;\n                    isFirstText = false;\n                }\n                text += cleanText + \" \";\n            }\n        } else if (Array.isArray(obj)) {\n            obj.forEach(extractTextRecursive);\n        } else if (typeof obj === \"object\" && obj !== null) {\n            // Look for text content in common PowerPoint XML elements\n            if (obj[\"a:t\"]) {\n                extractTextRecursive(obj[\"a:t\"]);\n            } else if (obj.t) {\n                extractTextRecursive(obj.t);\n            } else {\n                Object.values(obj).forEach(extractTextRecursive);\n            }\n        }\n    }\n    extractTextRecursive(slideXML);\n    return {\n        text: text.trim(),\n        title: title || undefined\n    };\n}\n/**\n * Extract text from plain text files\n */ async function extractTextFromPlainText(fileBuffer) {\n    try {\n        const text = new TextDecoder(\"utf-8\").decode(fileBuffer);\n        return {\n            text: text.trim()\n        };\n    } catch (error) {\n        throw new Error(`Failed to extract text from plain text file: ${error.message}`);\n    }\n}\n/**\n * Main text extraction function that routes to appropriate parser based on file type\n */ async function extractTextFromFile(fileBuffer, fileType, fileName) {\n    console.log(`[File Extraction] Processing file: ${fileName} (${fileType})`);\n    switch(fileType){\n        case \"application/vnd.openxmlformats-officedocument.presentationml.presentation\":\n            return await extractTextFromPowerPoint(fileBuffer, fileName);\n        case \"application/vnd.ms-powerpoint\":\n            // For older .ppt files, we'll try the same parser (it might work for some)\n            // In a production environment, you might want to use a different library\n            try {\n                return await extractTextFromPowerPoint(fileBuffer, fileName);\n            } catch (error) {\n                throw new Error(\"Legacy PowerPoint (.ppt) files are not fully supported. Please convert to .pptx format.\");\n            }\n        case \"text/plain\":\n        case \"text/markdown\":\n        case \"text/csv\":\n            return await extractTextFromPlainText(fileBuffer);\n        case \"application/pdf\":\n            // TODO: Implement PDF text extraction\n            // For now, return a placeholder\n            return {\n                text: `PDF text extraction not yet implemented for ${fileName}. Please implement PDF parsing using a library like pdf-parse.`\n            };\n        case \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":\n        case \"application/msword\":\n            // TODO: Implement Word document text extraction\n            // For now, return a placeholder\n            return {\n                text: `Word document text extraction not yet implemented for ${fileName}. Please implement DOCX parsing using a library like mammoth.`\n            };\n        default:\n            throw new Error(`Unsupported file type: ${fileType}`);\n    }\n}\n/**\n * Get file type icon for display purposes\n */ function getFileTypeIcon(fileType) {\n    if (fileType.includes(\"presentation\") || fileType.includes(\"powerpoint\")) {\n        return \"\\uD83D\\uDCCA\";\n    }\n    if (fileType.includes(\"pdf\")) {\n        return \"\\uD83D\\uDCD5\";\n    }\n    if (fileType.includes(\"word\") || fileType.includes(\"doc\")) {\n        return \"\\uD83D\\uDCD8\";\n    }\n    if (fileType.includes(\"text\") || fileType.includes(\"txt\") || fileType.includes(\"markdown\")) {\n        return \"\\uD83D\\uDCDD\";\n    }\n    return \"\\uD83D\\uDCC4\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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d2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy9maWxlRXh0cmFjdGlvbi50cz9mZTBmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRmlsZSBUZXh0IEV4dHJhY3Rpb24gU2VydmljZVxuICogXG4gKiBIYW5kbGVzIHRleHQgZXh0cmFjdGlvbiBmcm9tIHZhcmlvdXMgZmlsZSB0eXBlcyBpbmNsdWRpbmc6XG4gKiAtIFBvd2VyUG9pbnQgcHJlc2VudGF0aW9ucyAoLnBwdHgsIC5wcHQpXG4gKiAtIFBERiBmaWxlc1xuICogLSBXb3JkIGRvY3VtZW50cyAoLmRvY3gsIC5kb2MpXG4gKiAtIFRleHQgZmlsZXMgKC50eHQsIC5tZCwgLmNzdilcbiAqL1xuXG5pbXBvcnQgKiBhcyB5YXV6bCBmcm9tICd5YXV6bCc7XG5pbXBvcnQgKiBhcyB4bWwyanMgZnJvbSAneG1sMmpzJztcblxuZXhwb3J0IGludGVyZmFjZSBFeHRyYWN0ZWRDb250ZW50IHtcbiAgdGV4dDogc3RyaW5nO1xuICBzbGlkZUNvdW50PzogbnVtYmVyO1xuICBzbGlkZVRpdGxlcz86IHN0cmluZ1tdO1xuICBtZXRhZGF0YT86IHtcbiAgICB0aXRsZT86IHN0cmluZztcbiAgICBhdXRob3I/OiBzdHJpbmc7XG4gICAgc3ViamVjdD86IHN0cmluZztcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHRleHQgY29udGVudCBmcm9tIFBvd2VyUG9pbnQgcHJlc2VudGF0aW9ucyB1c2luZyBaSVAgcGFyc2luZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRleHRGcm9tUG93ZXJQb2ludChmaWxlQnVmZmVyOiBBcnJheUJ1ZmZlciwgZmlsZU5hbWU6IHN0cmluZyk6IFByb21pc2U8RXh0cmFjdGVkQ29udGVudD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKGBbRmlsZSBFeHRyYWN0aW9uXSBFeHRyYWN0aW5nIHRleHQgZnJvbSBQb3dlclBvaW50OiAke2ZpbGVOYW1lfWApO1xuICAgIFxuICAgIC8vIENvbnZlcnQgQXJyYXlCdWZmZXIgdG8gQnVmZmVyXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZmlsZUJ1ZmZlcik7XG4gICAgXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHlhdXpsLmZyb21CdWZmZXIoYnVmZmVyLCB7IGxhenlFbnRyaWVzOiB0cnVlIH0sIChlcnIsIHppcGZpbGUpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBvcGVuIFBvd2VyUG9pbnQgZmlsZTogJHtlcnIubWVzc2FnZX1gKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2xpZGVUZXh0czogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgY29uc3Qgc2xpZGVUaXRsZXM6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGxldCBzbGlkZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IHByb2Nlc3NlZFNsaWRlcyA9IDA7XG4gICAgICAgIGxldCB0b3RhbFNsaWRlcyA9IDA7XG5cbiAgICAgICAgLy8gRmlyc3QsIGNvdW50IHRoZSB0b3RhbCBudW1iZXIgb2Ygc2xpZGVzXG4gICAgICAgIHppcGZpbGUub24oJ2VudHJ5JywgKGVudHJ5KSA9PiB7XG4gICAgICAgICAgaWYgKGVudHJ5LmZpbGVOYW1lLm1hdGNoKC9ecHB0XFwvc2xpZGVzXFwvc2xpZGVcXGQrXFwueG1sJC8pKSB7XG4gICAgICAgICAgICB0b3RhbFNsaWRlcysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcblxuICAgICAgICB6aXBmaWxlLm9uKCdlbnRyeScsIChlbnRyeSkgPT4ge1xuICAgICAgICAgIC8vIExvb2sgZm9yIHNsaWRlIFhNTCBmaWxlc1xuICAgICAgICAgIGlmIChlbnRyeS5maWxlTmFtZS5tYXRjaCgvXnBwdFxcL3NsaWRlc1xcL3NsaWRlXFxkK1xcLnhtbCQvKSkge1xuICAgICAgICAgICAgemlwZmlsZS5vcGVuUmVhZFN0cmVhbShlbnRyeSwgKGVyciwgcmVhZFN0cmVhbSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbRmlsZSBFeHRyYWN0aW9uXSBGYWlsZWQgdG8gcmVhZCBzbGlkZSAke2VudHJ5LmZpbGVOYW1lfTpgLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkU2xpZGVzKys7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NlZFNsaWRlcyA9PT0gdG90YWxTbGlkZXMpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEV4dHJhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBsZXQgeG1sRGF0YSA9ICcnO1xuICAgICAgICAgICAgICByZWFkU3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgeG1sRGF0YSArPSBjaHVuay50b1N0cmluZygpO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICByZWFkU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgWE1MIGFuZCBleHRyYWN0IHRleHRcbiAgICAgICAgICAgICAgICB4bWwyanMucGFyc2VTdHJpbmcoeG1sRGF0YSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0ZpbGUgRXh0cmFjdGlvbl0gRmFpbGVkIHRvIHBhcnNlIFhNTCBmb3IgJHtlbnRyeS5maWxlTmFtZX06YCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVUZXh0ID0gZXh0cmFjdFRleHRGcm9tU2xpZGVYTUwocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2xpZGVOdW1iZXIgPSBwYXJzZUludChlbnRyeS5maWxlTmFtZS5tYXRjaCgvc2xpZGUoXFxkKylcXC54bWwkLyk/LlsxXSB8fCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVUZXh0c1tzbGlkZU51bWJlciAtIDFdID0gc2xpZGVUZXh0LnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlVGl0bGVzW3NsaWRlTnVtYmVyIC0gMV0gPSBzbGlkZVRleHQudGl0bGUgfHwgYFNsaWRlICR7c2xpZGVOdW1iZXJ9YDtcbiAgICAgICAgICAgICAgICAgICAgc2xpZGVDb3VudCA9IE1hdGgubWF4KHNsaWRlQ291bnQsIHNsaWRlTnVtYmVyKTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkU2xpZGVzKys7XG4gICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkU2xpZGVzID09PSB0b3RhbFNsaWRlcykge1xuICAgICAgICAgICAgICAgICAgICBmaW5pc2hFeHRyYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgemlwZmlsZS5yZWFkRW50cnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHppcGZpbGUub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBpZiAodG90YWxTbGlkZXMgPT09IDApIHtcbiAgICAgICAgICAgIGZpbmlzaEV4dHJhY3Rpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaEV4dHJhY3Rpb24oKSB7XG4gICAgICAgICAgbGV0IGV4dHJhY3RlZFRleHQgPSAnJztcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDb21iaW5lIGFsbCBzbGlkZSB0ZXh0c1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzbGlkZVRpdGxlID0gc2xpZGVUaXRsZXNbaV0gfHwgYFNsaWRlICR7aSArIDF9YDtcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlVGV4dCA9IHNsaWRlVGV4dHNbaV0gfHwgJyc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzbGlkZVRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICAgIGV4dHJhY3RlZFRleHQgKz0gYFxcbiMjICR7c2xpZGVUaXRsZX1cXG5cXG4ke3NsaWRlVGV4dC50cmltKCl9XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4dHJhY3RlZFRleHQudHJpbSgpKSB7XG4gICAgICAgICAgICBleHRyYWN0ZWRUZXh0ID0gYE5vIHRleHQgY29udGVudCBmb3VuZCBpbiBQb3dlclBvaW50IGZpbGU6ICR7ZmlsZU5hbWV9YDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0ZpbGUgRXh0cmFjdGlvbl0gU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCAke2V4dHJhY3RlZFRleHQubGVuZ3RofSBjaGFyYWN0ZXJzIGZyb20gJHtzbGlkZUNvdW50fSBzbGlkZXNgKTtcblxuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgdGV4dDogZXh0cmFjdGVkVGV4dC50cmltKCksXG4gICAgICAgICAgICBzbGlkZUNvdW50LFxuICAgICAgICAgICAgc2xpZGVUaXRsZXM6IHNsaWRlVGl0bGVzLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgIHRpdGxlOiBmaWxlTmFtZS5yZXBsYWNlKC9cXC5bXi8uXSskLywgJycpLCAvLyBSZW1vdmUgZmlsZSBleHRlbnNpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbRmlsZSBFeHRyYWN0aW9uXSBFcnJvciBleHRyYWN0aW5nIHRleHQgZnJvbSBQb3dlclBvaW50OicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IHRleHQgZnJvbSBQb3dlclBvaW50IGZpbGU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgdGV4dCBmcm9tIHNsaWRlIFhNTCBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RUZXh0RnJvbVNsaWRlWE1MKHNsaWRlWE1MOiBhbnkpOiB7IHRleHQ6IHN0cmluZzsgdGl0bGU/OiBzdHJpbmcgfSB7XG4gIGxldCB0ZXh0ID0gJyc7XG4gIGxldCB0aXRsZSA9ICcnO1xuICBsZXQgaXNGaXJzdFRleHQgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIGV4dHJhY3RUZXh0UmVjdXJzaXZlKG9iajogYW55KSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjbGVhblRleHQgPSBvYmoudHJpbSgpO1xuICAgICAgaWYgKGNsZWFuVGV4dCkge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBzaWduaWZpY2FudCB0ZXh0LCBjb25zaWRlciBpdCBhcyB0aXRsZVxuICAgICAgICBpZiAoaXNGaXJzdFRleHQgJiYgY2xlYW5UZXh0Lmxlbmd0aCA8IDEwMCAmJiAhY2xlYW5UZXh0LmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICAgIHRpdGxlID0gY2xlYW5UZXh0O1xuICAgICAgICAgIGlzRmlyc3RUZXh0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCArPSBjbGVhblRleHQgKyAnICc7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIG9iai5mb3JFYWNoKGV4dHJhY3RUZXh0UmVjdXJzaXZlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgICAgLy8gTG9vayBmb3IgdGV4dCBjb250ZW50IGluIGNvbW1vbiBQb3dlclBvaW50IFhNTCBlbGVtZW50c1xuICAgICAgaWYgKG9ialsnYTp0J10pIHtcbiAgICAgICAgZXh0cmFjdFRleHRSZWN1cnNpdmUob2JqWydhOnQnXSk7XG4gICAgICB9IGVsc2UgaWYgKG9iai50KSB7XG4gICAgICAgIGV4dHJhY3RUZXh0UmVjdXJzaXZlKG9iai50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE9iamVjdC52YWx1ZXMob2JqKS5mb3JFYWNoKGV4dHJhY3RUZXh0UmVjdXJzaXZlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHRyYWN0VGV4dFJlY3Vyc2l2ZShzbGlkZVhNTCk7XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiB0ZXh0LnRyaW0oKSxcbiAgICB0aXRsZTogdGl0bGUgfHwgdW5kZWZpbmVkXG4gIH07XG59XG5cbi8qKlxuICogRXh0cmFjdCB0ZXh0IGZyb20gcGxhaW4gdGV4dCBmaWxlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRleHRGcm9tUGxhaW5UZXh0KGZpbGVCdWZmZXI6IEFycmF5QnVmZmVyKTogUHJvbWlzZTxFeHRyYWN0ZWRDb250ZW50PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKS5kZWNvZGUoZmlsZUJ1ZmZlcik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRleHQudHJpbSgpXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGV4dHJhY3QgdGV4dCBmcm9tIHBsYWluIHRleHQgZmlsZTogJHtlcnJvci5tZXNzYWdlfWApO1xuICB9XG59XG5cbi8qKlxuICogTWFpbiB0ZXh0IGV4dHJhY3Rpb24gZnVuY3Rpb24gdGhhdCByb3V0ZXMgdG8gYXBwcm9wcmlhdGUgcGFyc2VyIGJhc2VkIG9uIGZpbGUgdHlwZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFRleHRGcm9tRmlsZShcbiAgZmlsZUJ1ZmZlcjogQXJyYXlCdWZmZXIsIFxuICBmaWxlVHlwZTogc3RyaW5nLCBcbiAgZmlsZU5hbWU6IHN0cmluZ1xuKTogUHJvbWlzZTxFeHRyYWN0ZWRDb250ZW50PiB7XG4gIFxuICBjb25zb2xlLmxvZyhgW0ZpbGUgRXh0cmFjdGlvbl0gUHJvY2Vzc2luZyBmaWxlOiAke2ZpbGVOYW1lfSAoJHtmaWxlVHlwZX0pYCk7XG4gIFxuICBzd2l0Y2ggKGZpbGVUeXBlKSB7XG4gICAgY2FzZSAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLnByZXNlbnRhdGlvbic6XG4gICAgICByZXR1cm4gYXdhaXQgZXh0cmFjdFRleHRGcm9tUG93ZXJQb2ludChmaWxlQnVmZmVyLCBmaWxlTmFtZSk7XG4gICAgXG4gICAgY2FzZSAnYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQnOlxuICAgICAgLy8gRm9yIG9sZGVyIC5wcHQgZmlsZXMsIHdlJ2xsIHRyeSB0aGUgc2FtZSBwYXJzZXIgKGl0IG1pZ2h0IHdvcmsgZm9yIHNvbWUpXG4gICAgICAvLyBJbiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsIHlvdSBtaWdodCB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBsaWJyYXJ5XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZXh0cmFjdFRleHRGcm9tUG93ZXJQb2ludChmaWxlQnVmZmVyLCBmaWxlTmFtZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xlZ2FjeSBQb3dlclBvaW50ICgucHB0KSBmaWxlcyBhcmUgbm90IGZ1bGx5IHN1cHBvcnRlZC4gUGxlYXNlIGNvbnZlcnQgdG8gLnBwdHggZm9ybWF0LicpO1xuICAgICAgfVxuICAgIFxuICAgIGNhc2UgJ3RleHQvcGxhaW4nOlxuICAgIGNhc2UgJ3RleHQvbWFya2Rvd24nOlxuICAgIGNhc2UgJ3RleHQvY3N2JzpcbiAgICAgIHJldHVybiBhd2FpdCBleHRyYWN0VGV4dEZyb21QbGFpblRleHQoZmlsZUJ1ZmZlcik7XG4gICAgXG4gICAgY2FzZSAnYXBwbGljYXRpb24vcGRmJzpcbiAgICAgIC8vIFRPRE86IEltcGxlbWVudCBQREYgdGV4dCBleHRyYWN0aW9uXG4gICAgICAvLyBGb3Igbm93LCByZXR1cm4gYSBwbGFjZWhvbGRlclxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogYFBERiB0ZXh0IGV4dHJhY3Rpb24gbm90IHlldCBpbXBsZW1lbnRlZCBmb3IgJHtmaWxlTmFtZX0uIFBsZWFzZSBpbXBsZW1lbnQgUERGIHBhcnNpbmcgdXNpbmcgYSBsaWJyYXJ5IGxpa2UgcGRmLXBhcnNlLmBcbiAgICAgIH07XG4gICAgXG4gICAgY2FzZSAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LndvcmRwcm9jZXNzaW5nbWwuZG9jdW1lbnQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL21zd29yZCc6XG4gICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgV29yZCBkb2N1bWVudCB0ZXh0IGV4dHJhY3Rpb25cbiAgICAgIC8vIEZvciBub3csIHJldHVybiBhIHBsYWNlaG9sZGVyXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0ZXh0OiBgV29yZCBkb2N1bWVudCB0ZXh0IGV4dHJhY3Rpb24gbm90IHlldCBpbXBsZW1lbnRlZCBmb3IgJHtmaWxlTmFtZX0uIFBsZWFzZSBpbXBsZW1lbnQgRE9DWCBwYXJzaW5nIHVzaW5nIGEgbGlicmFyeSBsaWtlIG1hbW1vdGguYFxuICAgICAgfTtcbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBmaWxlIHR5cGU6ICR7ZmlsZVR5cGV9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZmlsZSB0eXBlIGljb24gZm9yIGRpc3BsYXkgcHVycG9zZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpbGVUeXBlSWNvbihmaWxlVHlwZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKGZpbGVUeXBlLmluY2x1ZGVzKCdwcmVzZW50YXRpb24nKSB8fCBmaWxlVHlwZS5pbmNsdWRlcygncG93ZXJwb2ludCcpKSB7XG4gICAgcmV0dXJuICfwn5OKJztcbiAgfVxuICBpZiAoZmlsZVR5cGUuaW5jbHVkZXMoJ3BkZicpKSB7XG4gICAgcmV0dXJuICfwn5OVJztcbiAgfVxuICBpZiAoZmlsZVR5cGUuaW5jbHVkZXMoJ3dvcmQnKSB8fCBmaWxlVHlwZS5pbmNsdWRlcygnZG9jJykpIHtcbiAgICByZXR1cm4gJ/Cfk5gnO1xuICB9XG4gIGlmIChmaWxlVHlwZS5pbmNsdWRlcygndGV4dCcpIHx8IGZpbGVUeXBlLmluY2x1ZGVzKCd0eHQnKSB8fCBmaWxlVHlwZS5pbmNsdWRlcygnbWFya2Rvd24nKSkge1xuICAgIHJldHVybiAn8J+TnSc7XG4gIH1cbiAgcmV0dXJuICfwn5OEJztcbn0gIl0sIm5hbWVzIjpbInlhdXpsIiwieG1sMmpzIiwiZXh0cmFjdFRleHRGcm9tUG93ZXJQb2ludCIsImZpbGVCdWZmZXIiLCJmaWxlTmFtZSIsImNvbnNvbGUiLCJsb2ciLCJidWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmcm9tQnVmZmVyIiwibGF6eUVudHJpZXMiLCJlcnIiLCJ6aXBmaWxlIiwiRXJyb3IiLCJtZXNzYWdlIiwic2xpZGVUZXh0cyIsInNsaWRlVGl0bGVzIiwic2xpZGVDb3VudCIsInByb2Nlc3NlZFNsaWRlcyIsInRvdGFsU2xpZGVzIiwib24iLCJlbnRyeSIsIm1hdGNoIiwicmVhZEVudHJ5Iiwib3BlblJlYWRTdHJlYW0iLCJyZWFkU3RyZWFtIiwid2FybiIsImZpbmlzaEV4dHJhY3Rpb24iLCJ4bWxEYXRhIiwiY2h1bmsiLCJ0b1N0cmluZyIsInBhcnNlU3RyaW5nIiwicmVzdWx0Iiwic2xpZGVUZXh0IiwiZXh0cmFjdFRleHRGcm9tU2xpZGVYTUwiLCJzbGlkZU51bWJlciIsInBhcnNlSW50IiwidGV4dCIsInRpdGxlIiwiTWF0aCIsIm1heCIsImV4dHJhY3RlZFRleHQiLCJpIiwic2xpZGVUaXRsZSIsInRyaW0iLCJsZW5ndGgiLCJmaWx0ZXIiLCJCb29sZWFuIiwibWV0YWRhdGEiLCJyZXBsYWNlIiwiZXJyb3IiLCJzbGlkZVhNTCIsImlzRmlyc3RUZXh0IiwiZXh0cmFjdFRleHRSZWN1cnNpdmUiLCJvYmoiLCJjbGVhblRleHQiLCJpbmNsdWRlcyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJ0IiwiT2JqZWN0IiwidmFsdWVzIiwidW5kZWZpbmVkIiwiZXh0cmFjdFRleHRGcm9tUGxhaW5UZXh0IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJleHRyYWN0VGV4dEZyb21GaWxlIiwiZmlsZVR5cGUiLCJnZXRGaWxlVHlwZUljb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/fileExtraction.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/queue.ts":
/*!*******************************!*\
  !*** ./src/services/queue.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getQueueInfo: () => (/* binding */ getQueueInfo),\n/* harmony export */   priorityQueue: () => (/* binding */ priorityQueue),\n/* harmony export */   queueRequest: () => (/* binding */ queueRequest)\n/* harmony export */ });\n/**\n * Priority Queue Service for EduScribe\n * \n * Provides priority-based request queuing for note generation\n * with subscription tier support\n */ class PriorityQueueService {\n    /**\n   * Add request to queue with priority based on subscription\n   */ async addToQueue(userId, requestType, subscriptionPlan, payload, processingFunction) {\n        const priority = this.getPriorityFromPlan(subscriptionPlan);\n        const itemId = `${userId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        return new Promise((resolve, reject)=>{\n            const queueItem = {\n                id: itemId,\n                userId,\n                priority,\n                requestType,\n                payload,\n                resolve: async (value)=>{\n                    try {\n                        const result = await processingFunction();\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    } finally{\n                        this.processing.delete(itemId);\n                        this.processNext();\n                    }\n                },\n                reject: (error)=>{\n                    this.processing.delete(itemId);\n                    reject(error);\n                    this.processNext();\n                },\n                timestamp: new Date()\n            };\n            this.insertByPriority(queueItem);\n            console.log(`[Queue] Added ${requestType} request for user ${userId} with priority ${priority}`);\n            this.processNext();\n        });\n    }\n    /**\n   * Get current queue statistics for UI display\n   */ getQueueStats(userId) {\n        const userPosition = userId ? this.getUserPosition(userId) : null;\n        const priorityBreakdown = this.queue.reduce((acc, item)=>{\n            if (item.priority === 1) acc.high++;\n            else if (item.priority === 2) acc.medium++;\n            else acc.low++;\n            return acc;\n        }, {\n            high: 0,\n            medium: 0,\n            low: 0\n        });\n        const estimatedWaitTime = userPosition ? userPosition * this.averageProcessingTime : this.queue.length * this.averageProcessingTime;\n        return {\n            totalItems: this.queue.length,\n            priorityBreakdown,\n            estimatedWaitTime\n        };\n    }\n    /**\n   * Get user's position in queue\n   */ getUserPosition(userId) {\n        const index = this.queue.findIndex((item)=>item.userId === userId);\n        return index === -1 ? null : index + 1;\n    }\n    /**\n   * Process next items in queue\n   */ processNext() {\n        const currentlyProcessing = this.processing.size;\n        if (currentlyProcessing >= this.maxConcurrent || this.queue.length === 0) {\n            return;\n        }\n        // Take next item (already sorted by priority)\n        const nextItem = this.queue.shift();\n        if (!nextItem) return;\n        this.processing.set(nextItem.id, true);\n        console.log(`[Queue] Processing ${nextItem.requestType} for user ${nextItem.userId} (priority ${nextItem.priority})`);\n        // Start processing\n        setTimeout(()=>{\n            nextItem.resolve(null); // The actual processing happens in the resolve function\n        }, 100);\n    }\n    /**\n   * Insert item into queue maintaining priority order\n   */ insertByPriority(item) {\n        // Find insertion point (sorted by priority, then by timestamp)\n        let insertIndex = 0;\n        for(let i = 0; i < this.queue.length; i++){\n            const existingItem = this.queue[i];\n            // Higher priority (lower number) goes first\n            if (item.priority < existingItem.priority) {\n                break;\n            }\n            // Same priority, older timestamp goes first\n            if (item.priority === existingItem.priority && item.timestamp >= existingItem.timestamp) {\n                insertIndex = i + 1;\n            } else if (item.priority > existingItem.priority) {\n                insertIndex = i + 1;\n            }\n        }\n        this.queue.splice(insertIndex, 0, item);\n    }\n    /**\n   * Map subscription plan to priority level\n   */ getPriorityFromPlan(plan) {\n        switch(plan){\n            case \"pro\":\n                return 1; // Highest priority\n            case \"student\":\n                return 2; // Medium priority  \n            case \"free\":\n            default:\n                return 3; // Lowest priority\n        }\n    }\n    /**\n   * Remove user from queue (if they cancel)\n   */ removeFromQueue(userId) {\n        const initialLength = this.queue.length;\n        this.queue = this.queue.filter((item)=>item.userId !== userId);\n        return this.queue.length < initialLength;\n    }\n    /**\n   * Update processing time average for better estimates\n   */ updateAverageProcessingTime(duration) {\n        // Simple moving average\n        this.averageProcessingTime = this.averageProcessingTime * 0.8 + duration * 0.2;\n    }\n    /**\n   * Get system load information\n   */ getSystemLoad() {\n        const processing = this.processing.size;\n        const capacity = this.maxConcurrent;\n        const loadPercentage = processing / capacity * 100;\n        return {\n            queueLength: this.queue.length,\n            processing,\n            capacity,\n            loadPercentage\n        };\n    }\n    constructor(){\n        this.queue = [];\n        this.processing = new Map();\n        this.maxConcurrent = 3 // Max concurrent processing\n        ;\n        this.averageProcessingTime = 90 // seconds\n        ;\n    }\n}\n// Singleton instance\nconst priorityQueue = new PriorityQueueService();\n/**\n * Helper function to wrap existing API calls with queue\n */ async function queueRequest(userId, subscriptionPlan, requestType, processingFunction) {\n    return priorityQueue.addToQueue(userId, requestType, subscriptionPlan, {}, processingFunction);\n}\n/**\n * Get queue information for UI\n */ function getQueueInfo(userId) {\n    return {\n        stats: priorityQueue.getQueueStats(userId),\n        position: userId ? priorityQueue.getUserPosition(userId) : null,\n        systemLoad: priorityQueue.getSystemLoad()\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsR0FDREU7QUFFSjtBQUVBOztDQUVDLEdBQ00sU0FBU2tFLGFBQWF0RSxNQUFlO0lBQzFDLE9BQU87UUFDTHVFLE9BQU9ILGNBQWN2QyxhQUFhLENBQUM3QjtRQUNuQ3dFLFVBQVV4RSxTQUFTb0UsY0FBY3JDLGVBQWUsQ0FBQy9CLFVBQVU7UUFDM0R5RSxZQUFZTCxjQUFjTCxhQUFhO0lBQ3pDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9zcmMvc2VydmljZXMvcXVldWUudHM/MDYxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByaW9yaXR5IFF1ZXVlIFNlcnZpY2UgZm9yIEVkdVNjcmliZVxuICogXG4gKiBQcm92aWRlcyBwcmlvcml0eS1iYXNlZCByZXF1ZXN0IHF1ZXVpbmcgZm9yIG5vdGUgZ2VuZXJhdGlvblxuICogd2l0aCBzdWJzY3JpcHRpb24gdGllciBzdXBwb3J0XG4gKi9cblxuaW50ZXJmYWNlIFF1ZXVlSXRlbSB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBwcmlvcml0eTogbnVtYmVyOyAvLyAxPWhpZ2ggKFBybyksIDI9bWVkaXVtIChTdHVkZW50KSwgMz1sb3cgKEZyZWUpXG4gIHJlcXVlc3RUeXBlOiAndmlkZW8nIHwgJ2ZpbGUnIHwgJ3RleHQnIHwgJ3ZpZGVvLXVwbG9hZCc7XG4gIHBheWxvYWQ6IGFueTtcbiAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycm9yOiBhbnkpID0+IHZvaWQ7XG4gIHRpbWVzdGFtcDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIFF1ZXVlU3RhdHMge1xuICB0b3RhbEl0ZW1zOiBudW1iZXI7XG4gIHByaW9yaXR5QnJlYWtkb3duOiB7XG4gICAgaGlnaDogbnVtYmVyO1xuICAgIG1lZGl1bTogbnVtYmVyO1xuICAgIGxvdzogbnVtYmVyO1xuICB9O1xuICBlc3RpbWF0ZWRXYWl0VGltZTogbnVtYmVyOyAvLyBzZWNvbmRzXG59XG5cbmNsYXNzIFByaW9yaXR5UXVldWVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBxdWV1ZTogUXVldWVJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBwcm9jZXNzaW5nOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBtYXhDb25jdXJyZW50OiBudW1iZXIgPSAzOyAvLyBNYXggY29uY3VycmVudCBwcm9jZXNzaW5nXG4gIHByaXZhdGUgYXZlcmFnZVByb2Nlc3NpbmdUaW1lOiBudW1iZXIgPSA5MDsgLy8gc2Vjb25kc1xuXG4gIC8qKlxuICAgKiBBZGQgcmVxdWVzdCB0byBxdWV1ZSB3aXRoIHByaW9yaXR5IGJhc2VkIG9uIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgYXN5bmMgYWRkVG9RdWV1ZTxUPihcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICByZXF1ZXN0VHlwZTogUXVldWVJdGVtWydyZXF1ZXN0VHlwZSddLFxuICAgIHN1YnNjcmlwdGlvblBsYW46ICdmcmVlJyB8ICdzdHVkZW50JyB8ICdwcm8nLFxuICAgIHBheWxvYWQ6IGFueSxcbiAgICBwcm9jZXNzaW5nRnVuY3Rpb246ICgpID0+IFByb21pc2U8VD5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgcHJpb3JpdHkgPSB0aGlzLmdldFByaW9yaXR5RnJvbVBsYW4oc3Vic2NyaXB0aW9uUGxhbik7XG4gICAgY29uc3QgaXRlbUlkID0gYCR7dXNlcklkfV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcXVldWVJdGVtOiBRdWV1ZUl0ZW0gPSB7XG4gICAgICAgIGlkOiBpdGVtSWQsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICByZXNvbHZlOiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc2luZ0Z1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5kZWxldGUoaXRlbUlkKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtSWQpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzTmV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaW5zZXJ0QnlQcmlvcml0eShxdWV1ZUl0ZW0pO1xuICAgICAgY29uc29sZS5sb2coYFtRdWV1ZV0gQWRkZWQgJHtyZXF1ZXN0VHlwZX0gcmVxdWVzdCBmb3IgdXNlciAke3VzZXJJZH0gd2l0aCBwcmlvcml0eSAke3ByaW9yaXR5fWApO1xuICAgICAgXG4gICAgICB0aGlzLnByb2Nlc3NOZXh0KCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcXVldWUgc3RhdGlzdGljcyBmb3IgVUkgZGlzcGxheVxuICAgKi9cbiAgZ2V0UXVldWVTdGF0cyh1c2VySWQ/OiBzdHJpbmcpOiBRdWV1ZVN0YXRzIHtcbiAgICBjb25zdCB1c2VyUG9zaXRpb24gPSB1c2VySWQgPyB0aGlzLmdldFVzZXJQb3NpdGlvbih1c2VySWQpIDogbnVsbDtcbiAgICBcbiAgICBjb25zdCBwcmlvcml0eUJyZWFrZG93biA9IHRoaXMucXVldWUucmVkdWNlKFxuICAgICAgKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5wcmlvcml0eSA9PT0gMSkgYWNjLmhpZ2grKztcbiAgICAgICAgZWxzZSBpZiAoaXRlbS5wcmlvcml0eSA9PT0gMikgYWNjLm1lZGl1bSsrO1xuICAgICAgICBlbHNlIGFjYy5sb3crKztcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7IGhpZ2g6IDAsIG1lZGl1bTogMCwgbG93OiAwIH1cbiAgICApO1xuXG4gICAgY29uc3QgZXN0aW1hdGVkV2FpdFRpbWUgPSB1c2VyUG9zaXRpb24gXG4gICAgICA/IHVzZXJQb3NpdGlvbiAqIHRoaXMuYXZlcmFnZVByb2Nlc3NpbmdUaW1lXG4gICAgICA6IHRoaXMucXVldWUubGVuZ3RoICogdGhpcy5hdmVyYWdlUHJvY2Vzc2luZ1RpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxJdGVtczogdGhpcy5xdWV1ZS5sZW5ndGgsXG4gICAgICBwcmlvcml0eUJyZWFrZG93bixcbiAgICAgIGVzdGltYXRlZFdhaXRUaW1lXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHBvc2l0aW9uIGluIHF1ZXVlXG4gICAqL1xuICBnZXRVc2VyUG9zaXRpb24odXNlcklkOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS51c2VySWQgPT09IHVzZXJJZCk7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBpbmRleCArIDE7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBuZXh0IGl0ZW1zIGluIHF1ZXVlXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NOZXh0KCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRseVByb2Nlc3NpbmcgPSB0aGlzLnByb2Nlc3Npbmcuc2l6ZTtcbiAgICBcbiAgICBpZiAoY3VycmVudGx5UHJvY2Vzc2luZyA+PSB0aGlzLm1heENvbmN1cnJlbnQgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIG5leHQgaXRlbSAoYWxyZWFkeSBzb3J0ZWQgYnkgcHJpb3JpdHkpXG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFuZXh0SXRlbSkgcmV0dXJuO1xuXG4gICAgdGhpcy5wcm9jZXNzaW5nLnNldChuZXh0SXRlbS5pZCwgdHJ1ZSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtRdWV1ZV0gUHJvY2Vzc2luZyAke25leHRJdGVtLnJlcXVlc3RUeXBlfSBmb3IgdXNlciAke25leHRJdGVtLnVzZXJJZH0gKHByaW9yaXR5ICR7bmV4dEl0ZW0ucHJpb3JpdHl9KWApO1xuICAgIFxuICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG5leHRJdGVtLnJlc29sdmUobnVsbCk7IC8vIFRoZSBhY3R1YWwgcHJvY2Vzc2luZyBoYXBwZW5zIGluIHRoZSByZXNvbHZlIGZ1bmN0aW9uXG4gICAgfSwgMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgaXRlbSBpbnRvIHF1ZXVlIG1haW50YWluaW5nIHByaW9yaXR5IG9yZGVyXG4gICAqL1xuICBwcml2YXRlIGluc2VydEJ5UHJpb3JpdHkoaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG4gICAgLy8gRmluZCBpbnNlcnRpb24gcG9pbnQgKHNvcnRlZCBieSBwcmlvcml0eSwgdGhlbiBieSB0aW1lc3RhbXApXG4gICAgbGV0IGluc2VydEluZGV4ID0gMDtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMucXVldWVbaV07XG4gICAgICBcbiAgICAgIC8vIEhpZ2hlciBwcmlvcml0eSAobG93ZXIgbnVtYmVyKSBnb2VzIGZpcnN0XG4gICAgICBpZiAoaXRlbS5wcmlvcml0eSA8IGV4aXN0aW5nSXRlbS5wcmlvcml0eSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2FtZSBwcmlvcml0eSwgb2xkZXIgdGltZXN0YW1wIGdvZXMgZmlyc3RcbiAgICAgIGlmIChpdGVtLnByaW9yaXR5ID09PSBleGlzdGluZ0l0ZW0ucHJpb3JpdHkgJiYgXG4gICAgICAgICAgaXRlbS50aW1lc3RhbXAgPj0gZXhpc3RpbmdJdGVtLnRpbWVzdGFtcCkge1xuICAgICAgICBpbnNlcnRJbmRleCA9IGkgKyAxO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnByaW9yaXR5ID4gZXhpc3RpbmdJdGVtLnByaW9yaXR5KSB7XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMucXVldWUuc3BsaWNlKGluc2VydEluZGV4LCAwLCBpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgc3Vic2NyaXB0aW9uIHBsYW4gdG8gcHJpb3JpdHkgbGV2ZWxcbiAgICovXG4gIHByaXZhdGUgZ2V0UHJpb3JpdHlGcm9tUGxhbihwbGFuOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAocGxhbikge1xuICAgICAgY2FzZSAncHJvJzogcmV0dXJuIDE7IC8vIEhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgIGNhc2UgJ3N0dWRlbnQnOiByZXR1cm4gMjsgLy8gTWVkaXVtIHByaW9yaXR5ICBcbiAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgZGVmYXVsdDogcmV0dXJuIDM7IC8vIExvd2VzdCBwcmlvcml0eVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdXNlciBmcm9tIHF1ZXVlIChpZiB0aGV5IGNhbmNlbClcbiAgICovXG4gIHJlbW92ZUZyb21RdWV1ZSh1c2VySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGluaXRpYWxMZW5ndGggPSB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIoaXRlbSA9PiBpdGVtLnVzZXJJZCAhPT0gdXNlcklkKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPCBpbml0aWFsTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwcm9jZXNzaW5nIHRpbWUgYXZlcmFnZSBmb3IgYmV0dGVyIGVzdGltYXRlc1xuICAgKi9cbiAgdXBkYXRlQXZlcmFnZVByb2Nlc3NpbmdUaW1lKGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBTaW1wbGUgbW92aW5nIGF2ZXJhZ2VcbiAgICB0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSA9ICh0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSAqIDAuOCkgKyAoZHVyYXRpb24gKiAwLjIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzeXN0ZW0gbG9hZCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0U3lzdGVtTG9hZCgpOiB7XG4gICAgcXVldWVMZW5ndGg6IG51bWJlcjtcbiAgICBwcm9jZXNzaW5nOiBudW1iZXI7XG4gICAgY2FwYWNpdHk6IG51bWJlcjtcbiAgICBsb2FkUGVyY2VudGFnZTogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCBwcm9jZXNzaW5nID0gdGhpcy5wcm9jZXNzaW5nLnNpemU7XG4gICAgY29uc3QgY2FwYWNpdHkgPSB0aGlzLm1heENvbmN1cnJlbnQ7XG4gICAgY29uc3QgbG9hZFBlcmNlbnRhZ2UgPSAocHJvY2Vzc2luZyAvIGNhcGFjaXR5KSAqIDEwMDtcblxuICAgIHJldHVybiB7XG4gICAgICBxdWV1ZUxlbmd0aDogdGhpcy5xdWV1ZS5sZW5ndGgsXG4gICAgICBwcm9jZXNzaW5nLFxuICAgICAgY2FwYWNpdHksXG4gICAgICBsb2FkUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgcHJpb3JpdHlRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlU2VydmljZSgpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB3cmFwIGV4aXN0aW5nIEFQSSBjYWxscyB3aXRoIHF1ZXVlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBxdWV1ZVJlcXVlc3Q8VD4oXG4gIHVzZXJJZDogc3RyaW5nLFxuICBzdWJzY3JpcHRpb25QbGFuOiAnZnJlZScgfCAnc3R1ZGVudCcgfCAncHJvJyxcbiAgcmVxdWVzdFR5cGU6IFF1ZXVlSXRlbVsncmVxdWVzdFR5cGUnXSxcbiAgcHJvY2Vzc2luZ0Z1bmN0aW9uOiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIHByaW9yaXR5UXVldWUuYWRkVG9RdWV1ZShcbiAgICB1c2VySWQsXG4gICAgcmVxdWVzdFR5cGUsIFxuICAgIHN1YnNjcmlwdGlvblBsYW4sXG4gICAge30sXG4gICAgcHJvY2Vzc2luZ0Z1bmN0aW9uXG4gICk7XG59XG5cbi8qKlxuICogR2V0IHF1ZXVlIGluZm9ybWF0aW9uIGZvciBVSVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVldWVJbmZvKHVzZXJJZD86IHN0cmluZykge1xuICByZXR1cm4ge1xuICAgIHN0YXRzOiBwcmlvcml0eVF1ZXVlLmdldFF1ZXVlU3RhdHModXNlcklkKSxcbiAgICBwb3NpdGlvbjogdXNlcklkID8gcHJpb3JpdHlRdWV1ZS5nZXRVc2VyUG9zaXRpb24odXNlcklkKSA6IG51bGwsXG4gICAgc3lzdGVtTG9hZDogcHJpb3JpdHlRdWV1ZS5nZXRTeXN0ZW1Mb2FkKClcbiAgfTtcbn0gIl0sIm5hbWVzIjpbIlByaW9yaXR5UXVldWVTZXJ2aWNlIiwiYWRkVG9RdWV1ZSIsInVzZXJJZCIsInJlcXVlc3RUeXBlIiwic3Vic2NyaXB0aW9uUGxhbiIsInBheWxvYWQiLCJwcm9jZXNzaW5nRnVuY3Rpb24iLCJwcmlvcml0eSIsImdldFByaW9yaXR5RnJvbVBsYW4iLCJpdGVtSWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJxdWV1ZUl0ZW0iLCJpZCIsInZhbHVlIiwicmVzdWx0IiwiZXJyb3IiLCJwcm9jZXNzaW5nIiwiZGVsZXRlIiwicHJvY2Vzc05leHQiLCJ0aW1lc3RhbXAiLCJpbnNlcnRCeVByaW9yaXR5IiwiY29uc29sZSIsImxvZyIsImdldFF1ZXVlU3RhdHMiLCJ1c2VyUG9zaXRpb24iLCJnZXRVc2VyUG9zaXRpb24iLCJwcmlvcml0eUJyZWFrZG93biIsInF1ZXVlIiwicmVkdWNlIiwiYWNjIiwiaXRlbSIsImhpZ2giLCJtZWRpdW0iLCJsb3ciLCJlc3RpbWF0ZWRXYWl0VGltZSIsImF2ZXJhZ2VQcm9jZXNzaW5nVGltZSIsImxlbmd0aCIsInRvdGFsSXRlbXMiLCJpbmRleCIsImZpbmRJbmRleCIsImN1cnJlbnRseVByb2Nlc3NpbmciLCJzaXplIiwibWF4Q29uY3VycmVudCIsIm5leHRJdGVtIiwic2hpZnQiLCJzZXQiLCJzZXRUaW1lb3V0IiwiaW5zZXJ0SW5kZXgiLCJpIiwiZXhpc3RpbmdJdGVtIiwic3BsaWNlIiwicGxhbiIsInJlbW92ZUZyb21RdWV1ZSIsImluaXRpYWxMZW5ndGgiLCJmaWx0ZXIiLCJ1cGRhdGVBdmVyYWdlUHJvY2Vzc2luZ1RpbWUiLCJkdXJhdGlvbiIsImdldFN5c3RlbUxvYWQiLCJjYXBhY2l0eSIsImxvYWRQZXJjZW50YWdlIiwicXVldWVMZW5ndGgiLCJNYXAiLCJwcmlvcml0eVF1ZXVlIiwicXVldWVSZXF1ZXN0IiwiZ2V0UXVldWVJbmZvIiwic3RhdHMiLCJwb3NpdGlvbiIsInN5c3RlbUxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/queue.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/subscription.ts":
/*!**************************************!*\
  !*** ./src/services/subscription.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignUserSubscription: () => (/* binding */ assignUserSubscription),\n/* harmony export */   checkUsageLimits: () => (/* binding */ checkUsageLimits),\n/* harmony export */   getPlanPricing: () => (/* binding */ getPlanPricing),\n/* harmony export */   getSubscriptionPlan: () => (/* binding */ getSubscriptionPlan),\n/* harmony export */   getSubscriptionPlans: () => (/* binding */ getSubscriptionPlans),\n/* harmony export */   getUserSubscription: () => (/* binding */ getUserSubscription),\n/* harmony export */   hasFeatureAccess: () => (/* binding */ hasFeatureAccess),\n/* harmony export */   incrementUsage: () => (/* binding */ incrementUsage),\n/* harmony export */   refreshSavedNotesCount: () => (/* binding */ refreshSavedNotesCount),\n/* harmony export */   updateSavedNotesCount: () => (/* binding */ updateSavedNotesCount)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/**\n * Subscription Service\n * \n * Handles subscription plans, usage tracking, and feature access control\n */ \n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get all available subscription plans\n */ async function getSubscriptionPlans() {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"is_active\", true).order(\"price_monthly\", {\n        ascending: true\n    });\n    if (error) {\n        console.error(\"[Subscription] Error fetching plans:\", error);\n        throw new Error(\"Failed to fetch subscription plans\");\n    }\n    return data || [];\n}\n/**\n * Get user's current subscription with plan details\n */ async function getUserSubscription(userId, token) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Use direct table query instead of RPC function\n        const { data: userSub, error } = await supabase.from(\"user_subscriptions\").select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        if (error) {\n            console.error(\"[Subscription] Error fetching user subscription:\", error);\n            return null;\n        }\n        if (!userSub || !userSub.subscription_plans) {\n            return null;\n        }\n        const planData = userSub.subscription_plans;\n        return {\n            subscription_id: userSub.id,\n            plan_id: userSub.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: userSub.billing_cycle,\n            status: userSub.status,\n            current_period_end: userSub.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in getUserSubscription:\", error);\n        return null;\n    }\n}\n/**\n * Get a specific subscription plan by ID\n */ async function getSubscriptionPlan(planId) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"id\", planId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"[Subscription] Error fetching plan:\", error);\n        return null;\n    }\n    return data;\n}\n/**\n * Check if user can generate notes based on their plan and usage\n */ async function checkUsageLimits(userId, token, noteType = \"text\") {\n    try {\n        // Use direct table queries instead of RPC functions to avoid issues\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Checking usage limits for user:\", userId);\n        // Get user's subscription directly\n        const { data: userSub, error: subError } = await supabase.from(\"user_subscriptions\").select(`\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        // Get current month usage directly\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { data: usage, error: usageError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        // Default free plan limits\n        const freePlanLimits = {\n            notes_per_month: 2,\n            max_saved_notes: 3,\n            max_text_length: 5000\n        };\n        const currentUsage = usage || {\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            month_year: currentMonth\n        };\n        // If usage record doesn't exist, create it\n        if (!usage) {\n            console.log(\"[Subscription] Creating usage record for current month:\", currentMonth);\n            const { error: createUsageError } = await supabase.from(\"user_usage\").insert({\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 0,\n                video_notes_count: 0,\n                file_notes_count: 0,\n                text_notes_count: 0,\n                total_saved_notes: 0,\n                updated_at: new Date().toISOString()\n            });\n            if (createUsageError) {\n                console.error(\"[Subscription] Warning: Could not create usage record:\", createUsageError);\n            }\n        }\n        // If no subscription found or error, try to create a free subscription\n        if (!userSub || subError) {\n            console.log(\"[Subscription] No active subscription found, attempting to create free subscription\");\n            if (subError) {\n                console.error(\"[Subscription] Subscription query error:\", subError);\n            }\n            // Try to create a free subscription for the user\n            const { error: createSubError } = await supabase.from(\"user_subscriptions\").insert({\n                user_id: userId,\n                plan_id: \"free\",\n                billing_cycle: \"monthly\",\n                status: \"active\",\n                current_period_start: new Date().toISOString(),\n                current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n                updated_at: new Date().toISOString()\n            }).select();\n            if (createSubError) {\n                console.error(\"[Subscription] Could not create free subscription:\", createSubError);\n            } else {\n                console.log(\"[Subscription] Created free subscription for user\");\n            }\n            // Return free plan limits regardless of whether we could create the subscription\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: !canGenerate ? `Monthly limit reached (${freePlanLimits.notes_per_month} notes per month)` : !canSave ? `Storage limit reached (${freePlanLimits.max_saved_notes} saved notes maximum)` : undefined,\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        const subscription = userSub;\n        const planData = subscription.subscription_plans;\n        if (!planData) {\n            console.error(\"[Subscription] Plan data not found for subscription:\", subscription);\n            // Fallback to free plan\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: \"Plan data not found - using free plan limits\",\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        console.log(\"[Subscription] Found subscription:\", {\n            planId: subscription.plan_id,\n            planLimits: planData.limits,\n            currentUsage: currentUsage\n        });\n        // Check monthly generation limit (handle unlimited case)\n        const monthlyLimit = planData.limits.notes_per_month;\n        const canGenerate = monthlyLimit === -1 || currentUsage.notes_generated < monthlyLimit;\n        // Check saved notes limit\n        const canSave = currentUsage.total_saved_notes < planData.limits.max_saved_notes;\n        let reason;\n        if (!canGenerate && monthlyLimit !== -1) {\n            reason = `Monthly limit reached (${monthlyLimit} notes per month)`;\n        } else if (!canSave) {\n            reason = `Storage limit reached (${planData.limits.max_saved_notes} saved notes maximum)`;\n        }\n        return {\n            canGenerate,\n            canSave,\n            reason,\n            usage: currentUsage,\n            limits: planData.limits\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error checking usage limits:\", error);\n        // Return restrictive fallback\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const fallbackUsage = {\n            notes_generated: 999,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 999,\n            month_year: currentMonth\n        };\n        return {\n            canGenerate: false,\n            canSave: false,\n            reason: \"Error checking subscription limits. Please try again.\",\n            usage: fallbackUsage,\n            limits: {\n                notes_per_month: 2,\n                max_saved_notes: 3,\n                max_text_length: 5000\n            }\n        };\n    }\n}\n/**\n * Increment user's usage count after successful note generation\n */ async function incrementUsage(userId, token, noteType = \"text\") {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Incrementing usage for user:\", userId, \"type:\", noteType);\n        // Get current usage\n        const { data: currentUsage, error: fetchError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        if (fetchError && fetchError.code !== \"PGRST116\") {\n            console.error(\"[Subscription] Error fetching current usage:\", fetchError);\n            return false;\n        }\n        // Prepare update data\n        const updateData = {\n            notes_generated: (currentUsage?.notes_generated || 0) + 1,\n            updated_at: new Date().toISOString()\n        };\n        // Increment specific note type counter\n        if (noteType === \"video\") {\n            updateData.video_notes_count = (currentUsage?.video_notes_count || 0) + 1;\n        } else if (noteType === \"file\") {\n            updateData.file_notes_count = (currentUsage?.file_notes_count || 0) + 1;\n        } else if (noteType === \"text\") {\n            updateData.text_notes_count = (currentUsage?.text_notes_count || 0) + 1;\n        }\n        // Update or insert usage record\n        if (currentUsage) {\n            const { error: updateError } = await supabase.from(\"user_usage\").update(updateData).eq(\"user_id\", userId).eq(\"month_year\", currentMonth);\n            if (updateError) {\n                console.error(\"[Subscription] Error updating usage:\", updateError);\n                return false;\n            }\n        } else {\n            // Create new usage record\n            const insertData = {\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 1,\n                video_notes_count: noteType === \"video\" ? 1 : 0,\n                file_notes_count: noteType === \"file\" ? 1 : 0,\n                text_notes_count: noteType === \"text\" ? 1 : 0,\n                total_saved_notes: 0,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            const { error: insertError } = await supabase.from(\"user_usage\").insert(insertData);\n            if (insertError) {\n                console.error(\"[Subscription] Error creating usage record:\", insertError);\n                return false;\n            }\n        }\n        console.log(\"[Subscription] Successfully incremented usage\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error incrementing usage:\", error);\n        return false;\n    }\n}\n/**\n * Update saved notes count (used when notes are saved or deleted)\n */ async function updateSavedNotesCount(userId, token, count) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Updating saved notes count for user:\", userId, \"count:\", count);\n        // Upsert the saved notes count\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: Math.max(0, count),\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully updated saved notes count\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error updating saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Refresh saved notes count by counting all notes from all tables\n */ async function refreshSavedNotesCount(userId, token) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Refreshing saved notes count for user:\", userId);\n        // Count notes from all tables including video_upload_notes\n        const [videoResult, fileResult, textResult, uploadVideoResult] = await Promise.all([\n            supabase.from(\"video_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"file_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"text_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            // Handle video_upload_notes table that might not exist in all environments\n            supabase.from(\"video_upload_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId).then((result)=>result, (error)=>{\n                console.warn(\"[Subscription] video_upload_notes table might not exist:\", error.message);\n                return {\n                    count: 0\n                };\n            })\n        ]);\n        const videoCount = videoResult.count || 0;\n        const fileCount = fileResult.count || 0;\n        const textCount = textResult.count || 0;\n        const uploadVideoCount = uploadVideoResult.count || 0;\n        const totalCount = videoCount + fileCount + textCount + uploadVideoCount;\n        console.log(\"[Subscription] Note counts:\", {\n            video: videoCount,\n            file: fileCount,\n            text: textCount,\n            video_upload: uploadVideoCount,\n            total: totalCount\n        });\n        // Update the usage record with the actual count\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: totalCount,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully refreshed saved notes count to:\", totalCount);\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error refreshing saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Get plan pricing with discount calculation\n */ function getPlanPricing(plan) {\n    const monthlyPrice = plan.price_monthly;\n    const yearlyPrice = plan.price_yearly;\n    const yearlyMonthlyEquivalent = yearlyPrice / 12;\n    const discountPercentage = monthlyPrice > 0 ? Math.round((1 - yearlyMonthlyEquivalent / monthlyPrice) * 100) : 0;\n    const yearlySavings = monthlyPrice * 12 - yearlyPrice;\n    return {\n        monthly: monthlyPrice,\n        yearly: yearlyPrice,\n        yearlyMonthlyEquivalent,\n        discountPercentage,\n        yearlySavings,\n        currency: plan.currency\n    };\n}\n/**\n * Check if user has access to a specific feature\n */ async function hasFeatureAccess(userId, token, feature) {\n    try {\n        const subscription = await getUserSubscription(userId, token);\n        if (!subscription) {\n            // Default free plan features\n            const freeFeatures = {\n                notes_generation: true,\n                quizzes: false,\n                youtube_support: true,\n                ppt_support: false,\n                export: false,\n                copy_paste: true,\n                upload_video: false,\n                priority_generation: false\n            };\n            return freeFeatures[feature] || false;\n        }\n        return subscription.features[feature] || false;\n    } catch (error) {\n        console.error(\"[Subscription] Error checking feature access:\", error);\n        return false; // Default to no access on error\n    }\n}\n/**\n * Assign subscription to user after successful payment\n */ async function assignUserSubscription(userId, token, planId, billingCycle, paymentData) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Calculate period dates\n        const currentPeriodStart = new Date();\n        const currentPeriodEnd = new Date();\n        if (billingCycle === \"yearly\") {\n            currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);\n        } else {\n            currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);\n        }\n        // Prepare subscription data\n        const subscriptionData = {\n            user_id: userId,\n            plan_id: planId,\n            billing_cycle: billingCycle,\n            status: \"active\",\n            current_period_start: currentPeriodStart.toISOString(),\n            current_period_end: currentPeriodEnd.toISOString(),\n            cancel_at_period_end: false,\n            stripe_subscription_id: paymentData?.stripeSubscriptionId || null,\n            stripe_customer_id: paymentData?.stripeCustomerId || null,\n            updated_at: new Date().toISOString()\n        };\n        // Upsert subscription (update if exists, insert if new)\n        const { data: subscription, error: subscriptionError } = await supabase.from(\"user_subscriptions\").upsert(subscriptionData, {\n            onConflict: \"user_id\"\n        }).select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).single();\n        if (subscriptionError) {\n            console.error(\"[Subscription] Error assigning subscription:\", subscriptionError);\n            throw new Error(\"Failed to assign subscription\");\n        }\n        if (!subscription || !subscription.subscription_plans) {\n            throw new Error(\"Failed to retrieve subscription details\");\n        }\n        // Initialize usage tracking for current month\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error: usageError } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\",\n            ignoreDuplicates: true\n        });\n        if (usageError) {\n            console.error(\"[Subscription] Warning: Failed to initialize usage tracking:\", usageError);\n        // Don't throw error here as subscription assignment was successful\n        }\n        const planData = subscription.subscription_plans;\n        return {\n            subscription_id: subscription.id,\n            plan_id: subscription.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: subscription.billing_cycle,\n            status: subscription.status,\n            current_period_end: subscription.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in assignUserSubscription:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNuQkssWUFBWSxJQUFJbkIsT0FBT0MsV0FBVztRQUNwQyxHQUFHO1lBQ0Q0QyxZQUFZO1lBQ1o2RCxrQkFBa0I7UUFDcEI7UUFFRixJQUFJdEcsWUFBWTtZQUNkckMsUUFBUU4sS0FBSyxDQUFDLGdFQUFnRTJDO1FBQzlFLG1FQUFtRTtRQUNyRTtRQUVBLE1BQU0xQixXQUFXaUQsYUFBYWxELGtCQUFrQjtRQUVoRCxPQUFPO1lBQ0xFLGlCQUFpQmdELGFBQWEvQyxFQUFFO1lBQ2hDQyxTQUFTOEMsYUFBYTlDLE9BQU87WUFDN0JDLFdBQVdKLFNBQVNLLElBQUk7WUFDeEJDLG1CQUFtQk4sU0FBU08sWUFBWTtZQUN4Q0MsZUFBZXlDLGFBQWF6QyxhQUFhO1lBQ3pDQyxRQUFRd0MsYUFBYXhDLE1BQU07WUFDM0JDLG9CQUFvQnVDLGFBQWF2QyxrQkFBa0I7WUFDbkRDLFVBQVVYLFNBQVNXLFFBQVE7WUFDM0JDLFFBQVFaLFNBQVNZLE1BQU07WUFDdkJDLGVBQWViLFNBQVNhLGFBQWE7WUFDckNDLGNBQWNkLFNBQVNjLFlBQVk7UUFDckM7SUFDRixFQUFFLE9BQU8vQixPQUFPO1FBQ2RNLFFBQVFOLEtBQUssQ0FBQyxtREFBbURBO1FBQ2pFLE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy9zdWJzY3JpcHRpb24udHM/MDRmOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFN1YnNjcmlwdGlvbiBTZXJ2aWNlXG4gKiBcbiAqIEhhbmRsZXMgc3Vic2NyaXB0aW9uIHBsYW5zLCB1c2FnZSB0cmFja2luZywgYW5kIGZlYXR1cmUgYWNjZXNzIGNvbnRyb2xcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuXG4vLyBJbml0aWFsaXplIFN1cGFiYXNlIGNsaWVudFxuY29uc3Qgc3VwYWJhc2VVcmwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwhO1xuY29uc3Qgc3VwYWJhc2VBbm9uS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkhO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmlwdGlvblBsYW4ge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRpc3BsYXlfbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICBwcmljZV9tb250aGx5OiBudW1iZXI7XG4gIHByaWNlX3llYXJseTogbnVtYmVyO1xuICBjdXJyZW5jeTogc3RyaW5nO1xuICBmZWF0dXJlczoge1xuICAgIG5vdGVzX2dlbmVyYXRpb246IGJvb2xlYW47XG4gICAgcXVpenplczogYm9vbGVhbjtcbiAgICB5b3V0dWJlX3N1cHBvcnQ6IGJvb2xlYW47XG4gICAgcHB0X3N1cHBvcnQ6IGJvb2xlYW47XG4gICAgZXhwb3J0OiBib29sZWFuO1xuICAgIGNvcHlfcGFzdGU6IGJvb2xlYW47XG4gICAgdXBsb2FkX3ZpZGVvPzogYm9vbGVhbjtcbiAgICBwcmlvcml0eV9nZW5lcmF0aW9uPzogYm9vbGVhbjtcbiAgfTtcbiAgbGltaXRzOiB7XG4gICAgbm90ZXNfcGVyX21vbnRoOiBudW1iZXI7IC8vIC0xIG1lYW5zIHVubGltaXRlZFxuICAgIG1heF9zYXZlZF9ub3RlczogbnVtYmVyO1xuICAgIG1heF90ZXh0X2xlbmd0aDogbnVtYmVyO1xuICB9O1xuICBpc19hY3RpdmU6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclN1YnNjcmlwdGlvbiB7XG4gIHN1YnNjcmlwdGlvbl9pZDogc3RyaW5nO1xuICBwbGFuX2lkOiBzdHJpbmc7XG4gIHBsYW5fbmFtZTogc3RyaW5nO1xuICBwbGFuX2Rpc3BsYXlfbmFtZTogc3RyaW5nO1xuICBiaWxsaW5nX2N5Y2xlOiAnbW9udGhseScgfCAneWVhcmx5JztcbiAgc3RhdHVzOiAnYWN0aXZlJyB8ICdjYW5jZWxsZWQnIHwgJ2V4cGlyZWQnIHwgJ3RyaWFsJztcbiAgY3VycmVudF9wZXJpb2RfZW5kOiBzdHJpbmc7XG4gIGZlYXR1cmVzOiBTdWJzY3JpcHRpb25QbGFuWydmZWF0dXJlcyddO1xuICBsaW1pdHM6IFN1YnNjcmlwdGlvblBsYW5bJ2xpbWl0cyddO1xuICBwcmljZV9tb250aGx5OiBudW1iZXI7XG4gIHByaWNlX3llYXJseTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJVc2FnZSB7XG4gIG5vdGVzX2dlbmVyYXRlZDogbnVtYmVyO1xuICB2aWRlb19ub3Rlc19jb3VudDogbnVtYmVyO1xuICBmaWxlX25vdGVzX2NvdW50OiBudW1iZXI7XG4gIHRleHRfbm90ZXNfY291bnQ6IG51bWJlcjtcbiAgdG90YWxfc2F2ZWRfbm90ZXM6IG51bWJlcjtcbiAgbW9udGhfeWVhcjogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzYWdlQ2hlY2sge1xuICBjYW5HZW5lcmF0ZTogYm9vbGVhbjtcbiAgY2FuU2F2ZTogYm9vbGVhbjtcbiAgcmVhc29uPzogc3RyaW5nO1xuICB1c2FnZTogVXNlclVzYWdlO1xuICBsaW1pdHM6IFN1YnNjcmlwdGlvblBsYW5bJ2xpbWl0cyddO1xufVxuXG4vKipcbiAqIEdldCBhbGwgYXZhaWxhYmxlIHN1YnNjcmlwdGlvbiBwbGFuc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUGxhbnMoKTogUHJvbWlzZTxTdWJzY3JpcHRpb25QbGFuW10+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdzdWJzY3JpcHRpb25fcGxhbnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAub3JkZXIoJ3ByaWNlX21vbnRobHknLCB7IGFzY2VuZGluZzogdHJ1ZSB9KTtcbiAgICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgcGxhbnM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGZldGNoIHN1YnNjcmlwdGlvbiBwbGFucycpO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YSB8fCBbXTtcbn1cblxuLyoqXG4gKiBHZXQgdXNlcidzIGN1cnJlbnQgc3Vic2NyaXB0aW9uIHdpdGggcGxhbiBkZXRhaWxzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyU3Vic2NyaXB0aW9uKHVzZXJJZDogc3RyaW5nLCB0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxVc2VyU3Vic2NyaXB0aW9uIHwgbnVsbD4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgZ2xvYmFsOiB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVXNlIGRpcmVjdCB0YWJsZSBxdWVyeSBpbnN0ZWFkIG9mIFJQQyBmdW5jdGlvblxuICAgIGNvbnN0IHsgZGF0YTogdXNlclN1YiwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl9zdWJzY3JpcHRpb25zJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcGxhbl9pZCxcbiAgICAgICAgYmlsbGluZ19jeWNsZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICAgIHN1YnNjcmlwdGlvbl9wbGFucyAoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgbGltaXRzLFxuICAgICAgICAgIHByaWNlX21vbnRobHksXG4gICAgICAgICAgcHJpY2VfeWVhcmx5XG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ3N0YXR1cycsICdhY3RpdmUnKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBmZXRjaGluZyB1c2VyIHN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXVzZXJTdWIgfHwgIXVzZXJTdWIuc3Vic2NyaXB0aW9uX3BsYW5zKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBwbGFuRGF0YSA9IHVzZXJTdWIuc3Vic2NyaXB0aW9uX3BsYW5zIGFzIGFueTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3Vic2NyaXB0aW9uX2lkOiB1c2VyU3ViLmlkLFxuICAgICAgcGxhbl9pZDogdXNlclN1Yi5wbGFuX2lkLFxuICAgICAgcGxhbl9uYW1lOiBwbGFuRGF0YS5uYW1lLFxuICAgICAgcGxhbl9kaXNwbGF5X25hbWU6IHBsYW5EYXRhLmRpc3BsYXlfbmFtZSxcbiAgICAgIGJpbGxpbmdfY3ljbGU6IHVzZXJTdWIuYmlsbGluZ19jeWNsZSxcbiAgICAgIHN0YXR1czogdXNlclN1Yi5zdGF0dXMsXG4gICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IHVzZXJTdWIuY3VycmVudF9wZXJpb2RfZW5kLFxuICAgICAgZmVhdHVyZXM6IHBsYW5EYXRhLmZlYXR1cmVzLFxuICAgICAgbGltaXRzOiBwbGFuRGF0YS5saW1pdHMsXG4gICAgICBwcmljZV9tb250aGx5OiBwbGFuRGF0YS5wcmljZV9tb250aGx5LFxuICAgICAgcHJpY2VfeWVhcmx5OiBwbGFuRGF0YS5wcmljZV95ZWFybHlcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGluIGdldFVzZXJTdWJzY3JpcHRpb246JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGEgc3BlY2lmaWMgc3Vic2NyaXB0aW9uIHBsYW4gYnkgSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN1YnNjcmlwdGlvblBsYW4ocGxhbklkOiBzdHJpbmcpOiBQcm9taXNlPFN1YnNjcmlwdGlvblBsYW4gfCBudWxsPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpO1xuICBcbiAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAuZnJvbSgnc3Vic2NyaXB0aW9uX3BsYW5zJylcbiAgICAuc2VsZWN0KCcqJylcbiAgICAuZXEoJ2lkJywgcGxhbklkKVxuICAgIC5lcSgnaXNfYWN0aXZlJywgdHJ1ZSlcbiAgICAuc2luZ2xlKCk7XG4gICAgXG4gIGlmIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGZldGNoaW5nIHBsYW46JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIFxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGNhbiBnZW5lcmF0ZSBub3RlcyBiYXNlZCBvbiB0aGVpciBwbGFuIGFuZCB1c2FnZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tVc2FnZUxpbWl0cyhcbiAgdXNlcklkOiBzdHJpbmcsIFxuICB0b2tlbjogc3RyaW5nLCBcbiAgbm90ZVR5cGU6ICd2aWRlbycgfCAnZmlsZScgfCAndGV4dCcgPSAndGV4dCdcbik6IFByb21pc2U8VXNhZ2VDaGVjaz4ge1xuICB0cnkge1xuICAgIC8vIFVzZSBkaXJlY3QgdGFibGUgcXVlcmllcyBpbnN0ZWFkIG9mIFJQQyBmdW5jdGlvbnMgdG8gYXZvaWQgaXNzdWVzXG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gQ2hlY2tpbmcgdXNhZ2UgbGltaXRzIGZvciB1c2VyOicsIHVzZXJJZClcblxuICAgIC8vIEdldCB1c2VyJ3Mgc3Vic2NyaXB0aW9uIGRpcmVjdGx5XG4gICAgY29uc3QgeyBkYXRhOiB1c2VyU3ViLCBlcnJvcjogc3ViRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl9zdWJzY3JpcHRpb25zJylcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBwbGFuX2lkLFxuICAgICAgICBiaWxsaW5nX2N5Y2xlLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uX3BsYW5zIChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICBsaW1pdHMsXG4gICAgICAgICAgcHJpY2VfbW9udGhseSxcbiAgICAgICAgICBwcmljZV95ZWFybHlcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICAvLyBHZXQgY3VycmVudCBtb250aCB1c2FnZSBkaXJlY3RseVxuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KTtcbiAgICBjb25zdCB7IGRhdGE6IHVzYWdlLCBlcnJvcjogdXNhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdtb250aF95ZWFyJywgY3VycmVudE1vbnRoKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgLy8gRGVmYXVsdCBmcmVlIHBsYW4gbGltaXRzXG4gICAgY29uc3QgZnJlZVBsYW5MaW1pdHMgPSB7IFxuICAgICAgbm90ZXNfcGVyX21vbnRoOiAyLCBcbiAgICAgIG1heF9zYXZlZF9ub3RlczogMywgXG4gICAgICBtYXhfdGV4dF9sZW5ndGg6IDUwMDAgXG4gICAgfTtcblxuICAgIGNvbnN0IGN1cnJlbnRVc2FnZSA9IHVzYWdlIHx8IHtcbiAgICAgIG5vdGVzX2dlbmVyYXRlZDogMCxcbiAgICAgIHZpZGVvX25vdGVzX2NvdW50OiAwLFxuICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgIHRleHRfbm90ZXNfY291bnQ6IDAsXG4gICAgICB0b3RhbF9zYXZlZF9ub3RlczogMCxcbiAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aFxuICAgIH07XG5cbiAgICAvLyBJZiB1c2FnZSByZWNvcmQgZG9lc24ndCBleGlzdCwgY3JlYXRlIGl0XG4gICAgaWYgKCF1c2FnZSkge1xuICAgICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIENyZWF0aW5nIHVzYWdlIHJlY29yZCBmb3IgY3VycmVudCBtb250aDonLCBjdXJyZW50TW9udGgpXG4gICAgICBjb25zdCB7IGVycm9yOiBjcmVhdGVVc2FnZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgICAgIHZpZGVvX25vdGVzX2NvdW50OiAwLFxuICAgICAgICAgIGZpbGVfbm90ZXNfY291bnQ6IDAsXG4gICAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogMCxcbiAgICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChjcmVhdGVVc2FnZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIFdhcm5pbmc6IENvdWxkIG5vdCBjcmVhdGUgdXNhZ2UgcmVjb3JkOicsIGNyZWF0ZVVzYWdlRXJyb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHN1YnNjcmlwdGlvbiBmb3VuZCBvciBlcnJvciwgdHJ5IHRvIGNyZWF0ZSBhIGZyZWUgc3Vic2NyaXB0aW9uXG4gICAgaWYgKCF1c2VyU3ViIHx8IHN1YkVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gTm8gYWN0aXZlIHN1YnNjcmlwdGlvbiBmb3VuZCwgYXR0ZW1wdGluZyB0byBjcmVhdGUgZnJlZSBzdWJzY3JpcHRpb24nKVxuICAgICAgXG4gICAgICBpZiAoc3ViRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gU3Vic2NyaXB0aW9uIHF1ZXJ5IGVycm9yOicsIHN1YkVycm9yKTtcbiAgICAgIH1cblxuICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIGZyZWUgc3Vic2NyaXB0aW9uIGZvciB0aGUgdXNlclxuICAgICAgY29uc3QgeyBlcnJvcjogY3JlYXRlU3ViRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgICAgcGxhbl9pZDogJ2ZyZWUnLFxuICAgICAgICAgIGJpbGxpbmdfY3ljbGU6ICdtb250aGx5JyxcbiAgICAgICAgICBzdGF0dXM6ICdhY3RpdmUnLFxuICAgICAgICAgIGN1cnJlbnRfcGVyaW9kX3N0YXJ0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgY3VycmVudF9wZXJpb2RfZW5kOiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0KCk7XG5cbiAgICAgIGlmIChjcmVhdGVTdWJFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBDb3VsZCBub3QgY3JlYXRlIGZyZWUgc3Vic2NyaXB0aW9uOicsIGNyZWF0ZVN1YkVycm9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBDcmVhdGVkIGZyZWUgc3Vic2NyaXB0aW9uIGZvciB1c2VyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBmcmVlIHBsYW4gbGltaXRzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB3ZSBjb3VsZCBjcmVhdGUgdGhlIHN1YnNjcmlwdGlvblxuICAgICAgY29uc3QgY2FuR2VuZXJhdGUgPSBjdXJyZW50VXNhZ2Uubm90ZXNfZ2VuZXJhdGVkIDwgZnJlZVBsYW5MaW1pdHMubm90ZXNfcGVyX21vbnRoO1xuICAgICAgY29uc3QgY2FuU2F2ZSA9IGN1cnJlbnRVc2FnZS50b3RhbF9zYXZlZF9ub3RlcyA8IGZyZWVQbGFuTGltaXRzLm1heF9zYXZlZF9ub3RlcztcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FuR2VuZXJhdGUsXG4gICAgICAgIGNhblNhdmUsXG4gICAgICAgIHJlYXNvbjogIWNhbkdlbmVyYXRlID8gYE1vbnRobHkgbGltaXQgcmVhY2hlZCAoJHtmcmVlUGxhbkxpbWl0cy5ub3Rlc19wZXJfbW9udGh9IG5vdGVzIHBlciBtb250aClgIDpcbiAgICAgICAgICAgICAgICAhY2FuU2F2ZSA/IGBTdG9yYWdlIGxpbWl0IHJlYWNoZWQgKCR7ZnJlZVBsYW5MaW1pdHMubWF4X3NhdmVkX25vdGVzfSBzYXZlZCBub3RlcyBtYXhpbXVtKWAgOiB1bmRlZmluZWQsXG4gICAgICAgIHVzYWdlOiBjdXJyZW50VXNhZ2UsXG4gICAgICAgIGxpbWl0czogZnJlZVBsYW5MaW1pdHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gdXNlclN1YjtcbiAgICBjb25zdCBwbGFuRGF0YSA9IHN1YnNjcmlwdGlvbi5zdWJzY3JpcHRpb25fcGxhbnMgYXMgYW55O1xuICAgIFxuICAgIGlmICghcGxhbkRhdGEpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIFBsYW4gZGF0YSBub3QgZm91bmQgZm9yIHN1YnNjcmlwdGlvbjonLCBzdWJzY3JpcHRpb24pO1xuICAgICAgLy8gRmFsbGJhY2sgdG8gZnJlZSBwbGFuXG4gICAgICBjb25zdCBjYW5HZW5lcmF0ZSA9IGN1cnJlbnRVc2FnZS5ub3Rlc19nZW5lcmF0ZWQgPCBmcmVlUGxhbkxpbWl0cy5ub3Rlc19wZXJfbW9udGg7XG4gICAgICBjb25zdCBjYW5TYXZlID0gY3VycmVudFVzYWdlLnRvdGFsX3NhdmVkX25vdGVzIDwgZnJlZVBsYW5MaW1pdHMubWF4X3NhdmVkX25vdGVzO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5HZW5lcmF0ZSxcbiAgICAgICAgY2FuU2F2ZSxcbiAgICAgICAgcmVhc29uOiAnUGxhbiBkYXRhIG5vdCBmb3VuZCAtIHVzaW5nIGZyZWUgcGxhbiBsaW1pdHMnLFxuICAgICAgICB1c2FnZTogY3VycmVudFVzYWdlLFxuICAgICAgICBsaW1pdHM6IGZyZWVQbGFuTGltaXRzXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gRm91bmQgc3Vic2NyaXB0aW9uOicsIHtcbiAgICAgIHBsYW5JZDogc3Vic2NyaXB0aW9uLnBsYW5faWQsXG4gICAgICBwbGFuTGltaXRzOiBwbGFuRGF0YS5saW1pdHMsXG4gICAgICBjdXJyZW50VXNhZ2U6IGN1cnJlbnRVc2FnZVxuICAgIH0pO1xuXG4gICAgLy8gQ2hlY2sgbW9udGhseSBnZW5lcmF0aW9uIGxpbWl0IChoYW5kbGUgdW5saW1pdGVkIGNhc2UpXG4gICAgY29uc3QgbW9udGhseUxpbWl0ID0gcGxhbkRhdGEubGltaXRzLm5vdGVzX3Blcl9tb250aDtcbiAgICBjb25zdCBjYW5HZW5lcmF0ZSA9IG1vbnRobHlMaW1pdCA9PT0gLTEgfHwgY3VycmVudFVzYWdlLm5vdGVzX2dlbmVyYXRlZCA8IG1vbnRobHlMaW1pdDtcbiAgICBcbiAgICAvLyBDaGVjayBzYXZlZCBub3RlcyBsaW1pdFxuICAgIGNvbnN0IGNhblNhdmUgPSBjdXJyZW50VXNhZ2UudG90YWxfc2F2ZWRfbm90ZXMgPCBwbGFuRGF0YS5saW1pdHMubWF4X3NhdmVkX25vdGVzO1xuICAgIFxuICAgIGxldCByZWFzb246IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgICBpZiAoIWNhbkdlbmVyYXRlICYmIG1vbnRobHlMaW1pdCAhPT0gLTEpIHtcbiAgICAgIHJlYXNvbiA9IGBNb250aGx5IGxpbWl0IHJlYWNoZWQgKCR7bW9udGhseUxpbWl0fSBub3RlcyBwZXIgbW9udGgpYDtcbiAgICB9IGVsc2UgaWYgKCFjYW5TYXZlKSB7XG4gICAgICByZWFzb24gPSBgU3RvcmFnZSBsaW1pdCByZWFjaGVkICgke3BsYW5EYXRhLmxpbWl0cy5tYXhfc2F2ZWRfbm90ZXN9IHNhdmVkIG5vdGVzIG1heGltdW0pYDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkdlbmVyYXRlLFxuICAgICAgY2FuU2F2ZSxcbiAgICAgIHJlYXNvbixcbiAgICAgIHVzYWdlOiBjdXJyZW50VXNhZ2UsXG4gICAgICBsaW1pdHM6IHBsYW5EYXRhLmxpbWl0c1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgY2hlY2tpbmcgdXNhZ2UgbGltaXRzOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBSZXR1cm4gcmVzdHJpY3RpdmUgZmFsbGJhY2tcbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc3QgZmFsbGJhY2tVc2FnZSA9IHtcbiAgICAgIG5vdGVzX2dlbmVyYXRlZDogOTk5LFxuICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICBmaWxlX25vdGVzX2NvdW50OiAwLFxuICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiA5OTksXG4gICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGhcbiAgICB9O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBjYW5HZW5lcmF0ZTogZmFsc2UsXG4gICAgICBjYW5TYXZlOiBmYWxzZSxcbiAgICAgIHJlYXNvbjogJ0Vycm9yIGNoZWNraW5nIHN1YnNjcmlwdGlvbiBsaW1pdHMuIFBsZWFzZSB0cnkgYWdhaW4uJyxcbiAgICAgIHVzYWdlOiBmYWxsYmFja1VzYWdlLFxuICAgICAgbGltaXRzOiB7IG5vdGVzX3Blcl9tb250aDogMiwgbWF4X3NhdmVkX25vdGVzOiAzLCBtYXhfdGV4dF9sZW5ndGg6IDUwMDAgfVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBJbmNyZW1lbnQgdXNlcidzIHVzYWdlIGNvdW50IGFmdGVyIHN1Y2Nlc3NmdWwgbm90ZSBnZW5lcmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbmNyZW1lbnRVc2FnZShcbiAgdXNlcklkOiBzdHJpbmcsIFxuICB0b2tlbjogc3RyaW5nLCBcbiAgbm90ZVR5cGU6ICd2aWRlbycgfCAnZmlsZScgfCAndGV4dCcgPSAndGV4dCdcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBJbmNyZW1lbnRpbmcgdXNhZ2UgZm9yIHVzZXI6JywgdXNlcklkLCAndHlwZTonLCBub3RlVHlwZSlcblxuICAgIC8vIEdldCBjdXJyZW50IHVzYWdlXG4gICAgY29uc3QgeyBkYXRhOiBjdXJyZW50VXNhZ2UsIGVycm9yOiBmZXRjaEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ21vbnRoX3llYXInLCBjdXJyZW50TW9udGgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZmV0Y2hFcnJvciAmJiBmZXRjaEVycm9yLmNvZGUgIT09ICdQR1JTVDExNicpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGZldGNoaW5nIGN1cnJlbnQgdXNhZ2U6JywgZmV0Y2hFcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSB1cGRhdGUgZGF0YVxuICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcbiAgICAgIG5vdGVzX2dlbmVyYXRlZDogKGN1cnJlbnRVc2FnZT8ubm90ZXNfZ2VuZXJhdGVkIHx8IDApICsgMSxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG5cbiAgICAvLyBJbmNyZW1lbnQgc3BlY2lmaWMgbm90ZSB0eXBlIGNvdW50ZXJcbiAgICBpZiAobm90ZVR5cGUgPT09ICd2aWRlbycpIHtcbiAgICAgIHVwZGF0ZURhdGEudmlkZW9fbm90ZXNfY291bnQgPSAoY3VycmVudFVzYWdlPy52aWRlb19ub3Rlc19jb3VudCB8fCAwKSArIDE7XG4gICAgfSBlbHNlIGlmIChub3RlVHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICB1cGRhdGVEYXRhLmZpbGVfbm90ZXNfY291bnQgPSAoY3VycmVudFVzYWdlPy5maWxlX25vdGVzX2NvdW50IHx8IDApICsgMTtcbiAgICB9IGVsc2UgaWYgKG5vdGVUeXBlID09PSAndGV4dCcpIHtcbiAgICAgIHVwZGF0ZURhdGEudGV4dF9ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LnRleHRfbm90ZXNfY291bnQgfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBvciBpbnNlcnQgdXNhZ2UgcmVjb3JkXG4gICAgaWYgKGN1cnJlbnRVc2FnZSkge1xuICAgICAgY29uc3QgeyBlcnJvcjogdXBkYXRlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgICAgLnVwZGF0ZSh1cGRhdGVEYXRhKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAgIC5lcSgnbW9udGhfeWVhcicsIGN1cnJlbnRNb250aCk7XG5cbiAgICAgIGlmICh1cGRhdGVFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyB1c2FnZTonLCB1cGRhdGVFcnJvcik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ3JlYXRlIG5ldyB1c2FnZSByZWNvcmRcbiAgICAgIGNvbnN0IGluc2VydERhdGEgPSB7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoLFxuICAgICAgICBub3Rlc19nZW5lcmF0ZWQ6IDEsXG4gICAgICAgIHZpZGVvX25vdGVzX2NvdW50OiBub3RlVHlwZSA9PT0gJ3ZpZGVvJyA/IDEgOiAwLFxuICAgICAgICBmaWxlX25vdGVzX2NvdW50OiBub3RlVHlwZSA9PT0gJ2ZpbGUnID8gMSA6IDAsXG4gICAgICAgIHRleHRfbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAndGV4dCcgPyAxIDogMCxcbiAgICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDAsXG4gICAgICAgIGNyZWF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7IGVycm9yOiBpbnNlcnRFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgICAuaW5zZXJ0KGluc2VydERhdGEpO1xuXG4gICAgICBpZiAoaW5zZXJ0RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgY3JlYXRpbmcgdXNhZ2UgcmVjb3JkOicsIGluc2VydEVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBTdWNjZXNzZnVsbHkgaW5jcmVtZW50ZWQgdXNhZ2UnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBpbmNyZW1lbnRpbmcgdXNhZ2U6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBzYXZlZCBub3RlcyBjb3VudCAodXNlZCB3aGVuIG5vdGVzIGFyZSBzYXZlZCBvciBkZWxldGVkKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlU2F2ZWROb3Rlc0NvdW50KFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBjb3VudDogbnVtYmVyXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KTtcbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gVXBkYXRpbmcgc2F2ZWQgbm90ZXMgY291bnQgZm9yIHVzZXI6JywgdXNlcklkLCAnY291bnQ6JywgY291bnQpXG5cbiAgICAvLyBVcHNlcnQgdGhlIHNhdmVkIG5vdGVzIGNvdW50XG4gICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgIC51cHNlcnQoe1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IE1hdGgubWF4KDAsIGNvdW50KSwgLy8gRW5zdXJlIG5vbi1uZWdhdGl2ZVxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sIHtcbiAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsbW9udGhfeWVhcidcbiAgICAgIH0pO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSB1cGRhdGVkIHNhdmVkIG5vdGVzIGNvdW50Jyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgdXBkYXRpbmcgc2F2ZWQgbm90ZXMgY291bnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZnJlc2ggc2F2ZWQgbm90ZXMgY291bnQgYnkgY291bnRpbmcgYWxsIG5vdGVzIGZyb20gYWxsIHRhYmxlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFNhdmVkTm90ZXNDb3VudChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFJlZnJlc2hpbmcgc2F2ZWQgbm90ZXMgY291bnQgZm9yIHVzZXI6JywgdXNlcklkKTtcblxuICAgIC8vIENvdW50IG5vdGVzIGZyb20gYWxsIHRhYmxlcyBpbmNsdWRpbmcgdmlkZW9fdXBsb2FkX25vdGVzXG4gICAgY29uc3QgW3ZpZGVvUmVzdWx0LCBmaWxlUmVzdWx0LCB0ZXh0UmVzdWx0LCB1cGxvYWRWaWRlb1Jlc3VsdF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmlkZW9fbm90ZXMnKVxuICAgICAgICAuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKSxcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdmaWxlX25vdGVzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCksXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndGV4dF9ub3RlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpLFxuICAgICAgLy8gSGFuZGxlIHZpZGVvX3VwbG9hZF9ub3RlcyB0YWJsZSB0aGF0IG1pZ2h0IG5vdCBleGlzdCBpbiBhbGwgZW52aXJvbm1lbnRzXG4gICAgICBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndmlkZW9fdXBsb2FkX25vdGVzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLnRoZW4oXG4gICAgICAgICAgcmVzdWx0ID0+IHJlc3VsdCxcbiAgICAgICAgICBlcnJvciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tTdWJzY3JpcHRpb25dIHZpZGVvX3VwbG9hZF9ub3RlcyB0YWJsZSBtaWdodCBub3QgZXhpc3Q6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgIHJldHVybiB7IGNvdW50OiAwIH1cbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICBdKTtcblxuICAgIGNvbnN0IHZpZGVvQ291bnQgPSB2aWRlb1Jlc3VsdC5jb3VudCB8fCAwO1xuICAgIGNvbnN0IGZpbGVDb3VudCA9IGZpbGVSZXN1bHQuY291bnQgfHwgMDtcbiAgICBjb25zdCB0ZXh0Q291bnQgPSB0ZXh0UmVzdWx0LmNvdW50IHx8IDA7XG4gICAgY29uc3QgdXBsb2FkVmlkZW9Db3VudCA9IHVwbG9hZFZpZGVvUmVzdWx0LmNvdW50IHx8IDA7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHZpZGVvQ291bnQgKyBmaWxlQ291bnQgKyB0ZXh0Q291bnQgKyB1cGxvYWRWaWRlb0NvdW50O1xuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIE5vdGUgY291bnRzOicsIHtcbiAgICAgIHZpZGVvOiB2aWRlb0NvdW50LFxuICAgICAgZmlsZTogZmlsZUNvdW50LFxuICAgICAgdGV4dDogdGV4dENvdW50LFxuICAgICAgdmlkZW9fdXBsb2FkOiB1cGxvYWRWaWRlb0NvdW50LFxuICAgICAgdG90YWw6IHRvdGFsQ291bnRcbiAgICB9KTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgdXNhZ2UgcmVjb3JkIHdpdGggdGhlIGFjdHVhbCBjb3VudFxuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KTtcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnVwc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogdG90YWxDb3VudCxcbiAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICB9LCB7XG4gICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkLG1vbnRoX3llYXInXG4gICAgICB9KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgdXBkYXRpbmcgc2F2ZWQgbm90ZXMgY291bnQ6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBTdWNjZXNzZnVsbHkgcmVmcmVzaGVkIHNhdmVkIG5vdGVzIGNvdW50IHRvOicsIHRvdGFsQ291bnQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHJlZnJlc2hpbmcgc2F2ZWQgbm90ZXMgY291bnQ6JywgZXJyb3IpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBwbGFuIHByaWNpbmcgd2l0aCBkaXNjb3VudCBjYWxjdWxhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGxhblByaWNpbmcocGxhbjogU3Vic2NyaXB0aW9uUGxhbikge1xuICBjb25zdCBtb250aGx5UHJpY2UgPSBwbGFuLnByaWNlX21vbnRobHk7XG4gIGNvbnN0IHllYXJseVByaWNlID0gcGxhbi5wcmljZV95ZWFybHk7XG4gIGNvbnN0IHllYXJseU1vbnRobHlFcXVpdmFsZW50ID0geWVhcmx5UHJpY2UgLyAxMjtcbiAgY29uc3QgZGlzY291bnRQZXJjZW50YWdlID0gbW9udGhseVByaWNlID4gMCA/IE1hdGgucm91bmQoKDEgLSB5ZWFybHlNb250aGx5RXF1aXZhbGVudCAvIG1vbnRobHlQcmljZSkgKiAxMDApIDogMDtcbiAgY29uc3QgeWVhcmx5U2F2aW5ncyA9IChtb250aGx5UHJpY2UgKiAxMikgLSB5ZWFybHlQcmljZTtcbiAgXG4gIHJldHVybiB7XG4gICAgbW9udGhseTogbW9udGhseVByaWNlLFxuICAgIHllYXJseTogeWVhcmx5UHJpY2UsXG4gICAgeWVhcmx5TW9udGhseUVxdWl2YWxlbnQsXG4gICAgZGlzY291bnRQZXJjZW50YWdlLFxuICAgIHllYXJseVNhdmluZ3MsXG4gICAgY3VycmVuY3k6IHBsYW4uY3VycmVuY3lcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB1c2VyIGhhcyBhY2Nlc3MgdG8gYSBzcGVjaWZpYyBmZWF0dXJlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYXNGZWF0dXJlQWNjZXNzKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZyxcbiAgZmVhdHVyZToga2V5b2YgU3Vic2NyaXB0aW9uUGxhblsnZmVhdHVyZXMnXVxuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0VXNlclN1YnNjcmlwdGlvbih1c2VySWQsIHRva2VuKTtcbiAgICBcbiAgICBpZiAoIXN1YnNjcmlwdGlvbikge1xuICAgICAgLy8gRGVmYXVsdCBmcmVlIHBsYW4gZmVhdHVyZXNcbiAgICAgIGNvbnN0IGZyZWVGZWF0dXJlcyA9IHtcbiAgICAgICAgbm90ZXNfZ2VuZXJhdGlvbjogdHJ1ZSxcbiAgICAgICAgcXVpenplczogZmFsc2UsXG4gICAgICAgIHlvdXR1YmVfc3VwcG9ydDogdHJ1ZSxcbiAgICAgICAgcHB0X3N1cHBvcnQ6IGZhbHNlLFxuICAgICAgICBleHBvcnQ6IGZhbHNlLFxuICAgICAgICBjb3B5X3Bhc3RlOiB0cnVlLFxuICAgICAgICB1cGxvYWRfdmlkZW86IGZhbHNlLFxuICAgICAgICBwcmlvcml0eV9nZW5lcmF0aW9uOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZyZWVGZWF0dXJlc1tmZWF0dXJlXSB8fCBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbi5mZWF0dXJlc1tmZWF0dXJlXSB8fCBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjaGVja2luZyBmZWF0dXJlIGFjY2VzczonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlOyAvLyBEZWZhdWx0IHRvIG5vIGFjY2VzcyBvbiBlcnJvclxuICB9XG59XG5cbi8qKlxuICogQXNzaWduIHN1YnNjcmlwdGlvbiB0byB1c2VyIGFmdGVyIHN1Y2Nlc3NmdWwgcGF5bWVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXNzaWduVXNlclN1YnNjcmlwdGlvbihcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHRva2VuOiBzdHJpbmcsXG4gIHBsYW5JZDogc3RyaW5nLFxuICBiaWxsaW5nQ3ljbGU6ICdtb250aGx5JyB8ICd5ZWFybHknLFxuICBwYXltZW50RGF0YT86IHtcbiAgICBzdHJpcGVTdWJzY3JpcHRpb25JZD86IHN0cmluZztcbiAgICBzdHJpcGVDdXN0b21lcklkPzogc3RyaW5nO1xuICB9XG4pOiBQcm9taXNlPFVzZXJTdWJzY3JpcHRpb24gfCBudWxsPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICBnbG9iYWw6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHRyeSB7XG4gICAgLy8gQ2FsY3VsYXRlIHBlcmlvZCBkYXRlc1xuICAgIGNvbnN0IGN1cnJlbnRQZXJpb2RTdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgY3VycmVudFBlcmlvZEVuZCA9IG5ldyBEYXRlKCk7XG4gICAgXG4gICAgaWYgKGJpbGxpbmdDeWNsZSA9PT0gJ3llYXJseScpIHtcbiAgICAgIGN1cnJlbnRQZXJpb2RFbmQuc2V0RnVsbFllYXIoY3VycmVudFBlcmlvZEVuZC5nZXRGdWxsWWVhcigpICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRQZXJpb2RFbmQuc2V0TW9udGgoY3VycmVudFBlcmlvZEVuZC5nZXRNb250aCgpICsgMSk7XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSBzdWJzY3JpcHRpb24gZGF0YVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbkRhdGEgPSB7XG4gICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICBwbGFuX2lkOiBwbGFuSWQsXG4gICAgICBiaWxsaW5nX2N5Y2xlOiBiaWxsaW5nQ3ljbGUsXG4gICAgICBzdGF0dXM6ICdhY3RpdmUnIGFzIGNvbnN0LFxuICAgICAgY3VycmVudF9wZXJpb2Rfc3RhcnQ6IGN1cnJlbnRQZXJpb2RTdGFydC50b0lTT1N0cmluZygpLFxuICAgICAgY3VycmVudF9wZXJpb2RfZW5kOiBjdXJyZW50UGVyaW9kRW5kLnRvSVNPU3RyaW5nKCksXG4gICAgICBjYW5jZWxfYXRfcGVyaW9kX2VuZDogZmFsc2UsXG4gICAgICBzdHJpcGVfc3Vic2NyaXB0aW9uX2lkOiBwYXltZW50RGF0YT8uc3RyaXBlU3Vic2NyaXB0aW9uSWQgfHwgbnVsbCxcbiAgICAgIHN0cmlwZV9jdXN0b21lcl9pZDogcGF5bWVudERhdGE/LnN0cmlwZUN1c3RvbWVySWQgfHwgbnVsbCxcbiAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgIH07XG5cbiAgICAvLyBVcHNlcnQgc3Vic2NyaXB0aW9uICh1cGRhdGUgaWYgZXhpc3RzLCBpbnNlcnQgaWYgbmV3KVxuICAgIGNvbnN0IHsgZGF0YTogc3Vic2NyaXB0aW9uLCBlcnJvcjogc3Vic2NyaXB0aW9uRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl9zdWJzY3JpcHRpb25zJylcbiAgICAgIC51cHNlcnQoc3Vic2NyaXB0aW9uRGF0YSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCdcbiAgICAgIH0pXG4gICAgICAuc2VsZWN0KGBcbiAgICAgICAgaWQsXG4gICAgICAgIHBsYW5faWQsXG4gICAgICAgIGJpbGxpbmdfY3ljbGUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgY3VycmVudF9wZXJpb2RfZW5kLFxuICAgICAgICBzdWJzY3JpcHRpb25fcGxhbnMgKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIGxpbWl0cyxcbiAgICAgICAgICBwcmljZV9tb250aGx5LFxuICAgICAgICAgIHByaWNlX3llYXJseVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLnNpbmdsZSgpO1xuXG4gICAgaWYgKHN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBhc3NpZ25pbmcgc3Vic2NyaXB0aW9uOicsIHN1YnNjcmlwdGlvbkVycm9yKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGFzc2lnbiBzdWJzY3JpcHRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAoIXN1YnNjcmlwdGlvbiB8fCAhc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbl9wbGFucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcmV0cmlldmUgc3Vic2NyaXB0aW9uIGRldGFpbHMnKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHVzYWdlIHRyYWNraW5nIGZvciBjdXJyZW50IG1vbnRoXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZXJyb3I6IHVzYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAudXBzZXJ0KHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIG5vdGVzX2dlbmVyYXRlZDogMCxcbiAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICAgIGZpbGVfbm90ZXNfY291bnQ6IDAsXG4gICAgICAgIHRleHRfbm90ZXNfY291bnQ6IDAsXG4gICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sIHtcbiAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsbW9udGhfeWVhcicsXG4gICAgICAgIGlnbm9yZUR1cGxpY2F0ZXM6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgaWYgKHVzYWdlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIFdhcm5pbmc6IEZhaWxlZCB0byBpbml0aWFsaXplIHVzYWdlIHRyYWNraW5nOicsIHVzYWdlRXJyb3IpO1xuICAgICAgLy8gRG9uJ3QgdGhyb3cgZXJyb3IgaGVyZSBhcyBzdWJzY3JpcHRpb24gYXNzaWdubWVudCB3YXMgc3VjY2Vzc2Z1bFxuICAgIH1cblxuICAgIGNvbnN0IHBsYW5EYXRhID0gc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbl9wbGFucyBhcyBhbnk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHN1YnNjcmlwdGlvbl9pZDogc3Vic2NyaXB0aW9uLmlkLFxuICAgICAgcGxhbl9pZDogc3Vic2NyaXB0aW9uLnBsYW5faWQsXG4gICAgICBwbGFuX25hbWU6IHBsYW5EYXRhLm5hbWUsXG4gICAgICBwbGFuX2Rpc3BsYXlfbmFtZTogcGxhbkRhdGEuZGlzcGxheV9uYW1lLFxuICAgICAgYmlsbGluZ19jeWNsZTogc3Vic2NyaXB0aW9uLmJpbGxpbmdfY3ljbGUsXG4gICAgICBzdGF0dXM6IHN1YnNjcmlwdGlvbi5zdGF0dXMsXG4gICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IHN1YnNjcmlwdGlvbi5jdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICBmZWF0dXJlczogcGxhbkRhdGEuZmVhdHVyZXMsXG4gICAgICBsaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIHByaWNlX21vbnRobHk6IHBsYW5EYXRhLnByaWNlX21vbnRobHksXG4gICAgICBwcmljZV95ZWFybHk6IHBsYW5EYXRhLnByaWNlX3llYXJseVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgaW4gYXNzaWduVXNlclN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn0gIl0sIm5hbWVzIjpbImNyZWF0ZUNsaWVudCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiZ2V0U3Vic2NyaXB0aW9uUGxhbnMiLCJzdXBhYmFzZSIsImRhdGEiLCJlcnJvciIsImZyb20iLCJzZWxlY3QiLCJlcSIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiY29uc29sZSIsIkVycm9yIiwiZ2V0VXNlclN1YnNjcmlwdGlvbiIsInVzZXJJZCIsInRva2VuIiwiZ2xvYmFsIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJ1c2VyU3ViIiwic2luZ2xlIiwic3Vic2NyaXB0aW9uX3BsYW5zIiwicGxhbkRhdGEiLCJzdWJzY3JpcHRpb25faWQiLCJpZCIsInBsYW5faWQiLCJwbGFuX25hbWUiLCJuYW1lIiwicGxhbl9kaXNwbGF5X25hbWUiLCJkaXNwbGF5X25hbWUiLCJiaWxsaW5nX2N5Y2xlIiwic3RhdHVzIiwiY3VycmVudF9wZXJpb2RfZW5kIiwiZmVhdHVyZXMiLCJsaW1pdHMiLCJwcmljZV9tb250aGx5IiwicHJpY2VfeWVhcmx5IiwiZ2V0U3Vic2NyaXB0aW9uUGxhbiIsInBsYW5JZCIsImNoZWNrVXNhZ2VMaW1pdHMiLCJub3RlVHlwZSIsImxvZyIsInN1YkVycm9yIiwiY3VycmVudE1vbnRoIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2xpY2UiLCJ1c2FnZSIsInVzYWdlRXJyb3IiLCJmcmVlUGxhbkxpbWl0cyIsIm5vdGVzX3Blcl9tb250aCIsIm1heF9zYXZlZF9ub3RlcyIsIm1heF90ZXh0X2xlbmd0aCIsImN1cnJlbnRVc2FnZSIsIm5vdGVzX2dlbmVyYXRlZCIsInZpZGVvX25vdGVzX2NvdW50IiwiZmlsZV9ub3Rlc19jb3VudCIsInRleHRfbm90ZXNfY291bnQiLCJ0b3RhbF9zYXZlZF9ub3RlcyIsIm1vbnRoX3llYXIiLCJjcmVhdGVVc2FnZUVycm9yIiwiaW5zZXJ0IiwidXNlcl9pZCIsInVwZGF0ZWRfYXQiLCJjcmVhdGVTdWJFcnJvciIsImN1cnJlbnRfcGVyaW9kX3N0YXJ0Iiwibm93IiwiY2FuR2VuZXJhdGUiLCJjYW5TYXZlIiwicmVhc29uIiwidW5kZWZpbmVkIiwic3Vic2NyaXB0aW9uIiwicGxhbkxpbWl0cyIsIm1vbnRobHlMaW1pdCIsImZhbGxiYWNrVXNhZ2UiLCJpbmNyZW1lbnRVc2FnZSIsImZldGNoRXJyb3IiLCJjb2RlIiwidXBkYXRlRGF0YSIsInVwZGF0ZUVycm9yIiwidXBkYXRlIiwiaW5zZXJ0RGF0YSIsImNyZWF0ZWRfYXQiLCJpbnNlcnRFcnJvciIsInVwZGF0ZVNhdmVkTm90ZXNDb3VudCIsImNvdW50IiwidXBzZXJ0IiwiTWF0aCIsIm1heCIsIm9uQ29uZmxpY3QiLCJyZWZyZXNoU2F2ZWROb3Rlc0NvdW50IiwidmlkZW9SZXN1bHQiLCJmaWxlUmVzdWx0IiwidGV4dFJlc3VsdCIsInVwbG9hZFZpZGVvUmVzdWx0IiwiUHJvbWlzZSIsImFsbCIsImhlYWQiLCJ0aGVuIiwicmVzdWx0Iiwid2FybiIsIm1lc3NhZ2UiLCJ2aWRlb0NvdW50IiwiZmlsZUNvdW50IiwidGV4dENvdW50IiwidXBsb2FkVmlkZW9Db3VudCIsInRvdGFsQ291bnQiLCJ2aWRlbyIsImZpbGUiLCJ0ZXh0IiwidmlkZW9fdXBsb2FkIiwidG90YWwiLCJnZXRQbGFuUHJpY2luZyIsInBsYW4iLCJtb250aGx5UHJpY2UiLCJ5ZWFybHlQcmljZSIsInllYXJseU1vbnRobHlFcXVpdmFsZW50IiwiZGlzY291bnRQZXJjZW50YWdlIiwicm91bmQiLCJ5ZWFybHlTYXZpbmdzIiwibW9udGhseSIsInllYXJseSIsImN1cnJlbmN5IiwiaGFzRmVhdHVyZUFjY2VzcyIsImZlYXR1cmUiLCJmcmVlRmVhdHVyZXMiLCJub3Rlc19nZW5lcmF0aW9uIiwicXVpenplcyIsInlvdXR1YmVfc3VwcG9ydCIsInBwdF9zdXBwb3J0IiwiZXhwb3J0IiwiY29weV9wYXN0ZSIsInVwbG9hZF92aWRlbyIsInByaW9yaXR5X2dlbmVyYXRpb24iLCJhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uIiwiYmlsbGluZ0N5Y2xlIiwicGF5bWVudERhdGEiLCJjdXJyZW50UGVyaW9kU3RhcnQiLCJjdXJyZW50UGVyaW9kRW5kIiwic2V0RnVsbFllYXIiLCJnZXRGdWxsWWVhciIsInNldE1vbnRoIiwiZ2V0TW9udGgiLCJzdWJzY3JpcHRpb25EYXRhIiwiY2FuY2VsX2F0X3BlcmlvZF9lbmQiLCJzdHJpcGVfc3Vic2NyaXB0aW9uX2lkIiwic3RyaXBlU3Vic2NyaXB0aW9uSWQiLCJzdHJpcGVfY3VzdG9tZXJfaWQiLCJzdHJpcGVDdXN0b21lcklkIiwic3Vic2NyaXB0aW9uRXJyb3IiLCJpZ25vcmVEdXBsaWNhdGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/services/subscription.ts\n");

/***/ }),

/***/ "(rsc)/./src/utils/splitTranscript.ts":
/*!**************************************!*\
  !*** ./src/utils/splitTranscript.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateTokenCount: () => (/* binding */ estimateTokenCount),\n/* harmony export */   isChunkWithinTokenLimit: () => (/* binding */ isChunkWithinTokenLimit),\n/* harmony export */   splitTranscriptIntoChunks: () => (/* binding */ splitTranscriptIntoChunks)\n/* harmony export */ });\n/**\n * Represents a chunk of text with metadata\n */ /**\n * Splits a transcript into chunks based on word count\n * @param transcript The full transcript text to split\n * @param maxWords Maximum number of words per chunk (default: 800)\n * @returns Array of TranscriptChunk objects\n */ function splitTranscriptIntoChunks(transcript, maxWords = 800) {\n    // Split into words and filter out empty strings\n    const words = transcript.split(/\\s+/).filter((word)=>word.length > 0);\n    const chunks = [];\n    for(let i = 0; i < words.length; i += maxWords){\n        const startWord = i;\n        const endWord = Math.min(i + maxWords, words.length);\n        const chunkWords = words.slice(startWord, endWord);\n        chunks.push({\n            content: chunkWords.join(\" \"),\n            index: chunks.length,\n            wordCount: chunkWords.length,\n            startWord,\n            endWord\n        });\n    }\n    return chunks;\n}\n/**\n * Estimates the number of tokens in a text string\n * This is a rough estimate: ~4 characters per token on average\n * @param text The text to estimate tokens for\n * @returns Estimated number of tokens\n */ function estimateTokenCount(text) {\n    return Math.ceil(text.length / 4);\n}\n/**\n * Validates if a chunk is within safe token limits\n * @param chunk The chunk to validate\n * @param maxTokens Maximum allowed tokens (default: 3000)\n * @returns boolean indicating if chunk is within limits\n */ function isChunkWithinTokenLimit(chunk, maxTokens = 3000) {\n    return estimateTokenCount(chunk.content) <= maxTokens;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvdXRpbHMvc3BsaXRUcmFuc2NyaXB0LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBb0JEOzs7OztDQUtDLEdBQ00sU0FBU0EsMEJBQ2RDLFVBQWtCLEVBQ2xCQyxXQUFtQixHQUFHO0lBRXRCLGdEQUFnRDtJQUNoRCxNQUFNQyxRQUFRRixXQUFXRyxLQUFLLENBQUMsT0FBT0MsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxNQUFNLEdBQUc7SUFDbkUsTUFBTUMsU0FBNEIsRUFBRTtJQUVwQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sTUFBTUksTUFBTSxFQUFFRSxLQUFLUCxTQUFVO1FBQy9DLE1BQU1RLFlBQVlEO1FBQ2xCLE1BQU1FLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQ0osSUFBSVAsVUFBVUMsTUFBTUksTUFBTTtRQUNuRCxNQUFNTyxhQUFhWCxNQUFNWSxLQUFLLENBQUNMLFdBQVdDO1FBRTFDSCxPQUFPUSxJQUFJLENBQUM7WUFDVkMsU0FBU0gsV0FBV0ksSUFBSSxDQUFDO1lBQ3pCQyxPQUFPWCxPQUFPRCxNQUFNO1lBQ3BCYSxXQUFXTixXQUFXUCxNQUFNO1lBQzVCRztZQUNBQztRQUNGO0lBQ0Y7SUFFQSxPQUFPSDtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTYSxtQkFBbUJDLElBQVk7SUFDN0MsT0FBT1YsS0FBS1csSUFBSSxDQUFDRCxLQUFLZixNQUFNLEdBQUc7QUFDakM7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNpQix3QkFDZEMsS0FBc0IsRUFDdEJDLFlBQW9CLElBQUk7SUFFeEIsT0FBT0wsbUJBQW1CSSxNQUFNUixPQUFPLEtBQUtTO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL3V0aWxzL3NwbGl0VHJhbnNjcmlwdC50cz9jZmVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIHRleHQgd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRDaHVuayB7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgaW5kZXg6IG51bWJlcjtcbiAgd29yZENvdW50OiBudW1iZXI7XG4gIHN0YXJ0V29yZDogbnVtYmVyO1xuICBlbmRXb3JkOiBudW1iZXI7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZhaWxlZCBjaHVuayBwcm9jZXNzaW5nIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGYWlsZWRDaHVuayB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHJlYXNvbjogc3RyaW5nO1xuICBhdHRlbXB0czogbnVtYmVyO1xuICBzdGFydFdvcmQ6IG51bWJlcjtcbiAgZW5kV29yZDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhIHRyYW5zY3JpcHQgaW50byBjaHVua3MgYmFzZWQgb24gd29yZCBjb3VudFxuICogQHBhcmFtIHRyYW5zY3JpcHQgVGhlIGZ1bGwgdHJhbnNjcmlwdCB0ZXh0IHRvIHNwbGl0XG4gKiBAcGFyYW0gbWF4V29yZHMgTWF4aW11bSBudW1iZXIgb2Ygd29yZHMgcGVyIGNodW5rIChkZWZhdWx0OiA4MDApXG4gKiBAcmV0dXJucyBBcnJheSBvZiBUcmFuc2NyaXB0Q2h1bmsgb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRUcmFuc2NyaXB0SW50b0NodW5rcyhcbiAgdHJhbnNjcmlwdDogc3RyaW5nLFxuICBtYXhXb3JkczogbnVtYmVyID0gODAwXG4pOiBUcmFuc2NyaXB0Q2h1bmtbXSB7XG4gIC8vIFNwbGl0IGludG8gd29yZHMgYW5kIGZpbHRlciBvdXQgZW1wdHkgc3RyaW5nc1xuICBjb25zdCB3b3JkcyA9IHRyYW5zY3JpcHQuc3BsaXQoL1xccysvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApO1xuICBjb25zdCBjaHVua3M6IFRyYW5zY3JpcHRDaHVua1tdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gbWF4V29yZHMpIHtcbiAgICBjb25zdCBzdGFydFdvcmQgPSBpO1xuICAgIGNvbnN0IGVuZFdvcmQgPSBNYXRoLm1pbihpICsgbWF4V29yZHMsIHdvcmRzLmxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmtXb3JkcyA9IHdvcmRzLnNsaWNlKHN0YXJ0V29yZCwgZW5kV29yZCk7XG4gICAgXG4gICAgY2h1bmtzLnB1c2goe1xuICAgICAgY29udGVudDogY2h1bmtXb3Jkcy5qb2luKCcgJyksXG4gICAgICBpbmRleDogY2h1bmtzLmxlbmd0aCxcbiAgICAgIHdvcmRDb3VudDogY2h1bmtXb3Jkcy5sZW5ndGgsXG4gICAgICBzdGFydFdvcmQsXG4gICAgICBlbmRXb3JkXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiBhIHRleHQgc3RyaW5nXG4gKiBUaGlzIGlzIGEgcm91Z2ggZXN0aW1hdGU6IH40IGNoYXJhY3RlcnMgcGVyIHRva2VuIG9uIGF2ZXJhZ2VcbiAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGVzdGltYXRlIHRva2VucyBmb3JcbiAqIEByZXR1cm5zIEVzdGltYXRlZCBudW1iZXIgb2YgdG9rZW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRva2VuQ291bnQodGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0ZXh0Lmxlbmd0aCAvIDQpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIGNodW5rIGlzIHdpdGhpbiBzYWZlIHRva2VuIGxpbWl0c1xuICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byB2YWxpZGF0ZVxuICogQHBhcmFtIG1heFRva2VucyBNYXhpbXVtIGFsbG93ZWQgdG9rZW5zIChkZWZhdWx0OiAzMDAwKVxuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNodW5rIGlzIHdpdGhpbiBsaW1pdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0KFxuICBjaHVuazogVHJhbnNjcmlwdENodW5rLFxuICBtYXhUb2tlbnM6IG51bWJlciA9IDMwMDBcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gZXN0aW1hdGVUb2tlbkNvdW50KGNodW5rLmNvbnRlbnQpIDw9IG1heFRva2Vucztcbn0gIl0sIm5hbWVzIjpbInNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MiLCJ0cmFuc2NyaXB0IiwibWF4V29yZHMiLCJ3b3JkcyIsInNwbGl0IiwiZmlsdGVyIiwid29yZCIsImxlbmd0aCIsImNodW5rcyIsImkiLCJzdGFydFdvcmQiLCJlbmRXb3JkIiwiTWF0aCIsIm1pbiIsImNodW5rV29yZHMiLCJzbGljZSIsInB1c2giLCJjb250ZW50Iiwiam9pbiIsImluZGV4Iiwid29yZENvdW50IiwiZXN0aW1hdGVUb2tlbkNvdW50IiwidGV4dCIsImNlaWwiLCJpc0NodW5rV2l0aGluVG9rZW5MaW1pdCIsImNodW5rIiwibWF4VG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/utils/splitTranscript.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/ws","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions","vendor-chunks/formdata-node","vendor-chunks/ms","vendor-chunks/openai","vendor-chunks/event-target-shim","vendor-chunks/agentkeepalive","vendor-chunks/form-data-encoder","vendor-chunks/abort-controller","vendor-chunks/humanize-ms","vendor-chunks/sax","vendor-chunks/xmlbuilder","vendor-chunks/xml2js","vendor-chunks/yauzl","vendor-chunks/pend","vendor-chunks/buffer-crc32"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Ffile-notes%2Froute&page=%2Fapi%2Ffile-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Ffile-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();