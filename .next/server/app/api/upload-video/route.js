/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/upload-video/route";
exports.ids = ["app/api/upload-video/route"];
exports.modules = {

/***/ "(rsc)/./node_modules/@ffmpeg-installer/ffmpeg sync recursive":
/*!*****************************************************!*\
  !*** ./node_modules/@ffmpeg-installer/ffmpeg/ sync ***!
  \*****************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "(rsc)/./node_modules/@ffmpeg-installer/ffmpeg sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "(rsc)/./node_modules/fluent-ffmpeg/lib/options sync recursive":
/*!******************************************************!*\
  !*** ./node_modules/fluent-ffmpeg/lib/options/ sync ***!
  \******************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "(rsc)/./node_modules/fluent-ffmpeg/lib/options sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:stream/web");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fupload-video%2Froute&page=%2Fapi%2Fupload-video%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fupload-video%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fupload-video%2Froute&page=%2Fapi%2Fupload-video%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fupload-video%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_janjedrach_Cursor_eduscribe_src_app_api_upload_video_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/upload-video/route.ts */ \"(rsc)/./src/app/api/upload-video/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/upload-video/route\",\n        pathname: \"/api/upload-video\",\n        filename: \"route\",\n        bundlePath: \"app/api/upload-video/route\"\n    },\n    resolvedPagePath: \"/Users/janjedrach/Cursor/eduscribe/src/app/api/upload-video/route.ts\",\n    nextConfigOutput,\n    userland: _Users_janjedrach_Cursor_eduscribe_src_app_api_upload_video_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/upload-video/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZ1cGxvYWQtdmlkZW8lMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnVwbG9hZC12aWRlbyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnVwbG9hZC12aWRlbyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9anMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz1tZHgmcm9vdERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9c3RhbmRhbG9uZSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNvQjtBQUNqRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8/OTA2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvamFuamVkcmFjaC9DdXJzb3IvZWR1c2NyaWJlL3NyYy9hcHAvYXBpL3VwbG9hZC12aWRlby9yb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJzdGFuZGFsb25lXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3VwbG9hZC12aWRlby9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3VwbG9hZC12aWRlb1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvdXBsb2FkLXZpZGVvL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL1VzZXJzL2phbmplZHJhY2gvQ3Vyc29yL2VkdXNjcmliZS9zcmMvYXBwL2FwaS91cGxvYWQtdmlkZW8vcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL3VwbG9hZC12aWRlby9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fupload-video%2Froute&page=%2Fapi%2Fupload-video%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fupload-video%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/upload-video/route.ts":
/*!*******************************************!*\
  !*** ./src/app/api/upload-video/route.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELETE: () => (/* binding */ DELETE),\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _services_ai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/ai */ \"(rsc)/./src/services/ai.ts\");\n/* harmony import */ var _services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/videoTranscription */ \"(rsc)/./src/services/videoTranscription.ts\");\n/* harmony import */ var _services_subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/subscription */ \"(rsc)/./src/services/subscription.ts\");\n/* harmony import */ var _services_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/queue */ \"(rsc)/./src/services/queue.ts\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! fs-extra */ \"(rsc)/./node_modules/fs-extra/lib/index.js\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n\n\n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get user's subscription plan for queue priority\n */ async function getSubscriptionPlan(userId) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_6__.createClient)(supabaseUrl, supabaseAnonKey);\n        const { data } = await supabase.from(\"user_subscriptions\").select(\"plan_id\").eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        const planId = data?.plan_id;\n        // Ensure we return a valid plan type\n        if (planId === \"student\" || planId === \"pro\") {\n            return {\n                planId\n            };\n        }\n        return {\n            planId: \"free\"\n        };\n    } catch (error) {\n        console.warn(\"[Upload Video API] Could not fetch subscription:\", error);\n        return {\n            planId: \"free\"\n        };\n    }\n}\n/**\n * Video Upload API Endpoint - Independent System\n * \n * Processes uploaded video files to:\n * 1. Validate and store the video file\n * 2. Extract audio and transcribe using Whisper\n * 3. Generate AI notes from transcript\n * 4. Store in isolated video_upload_notes table\n */ async function POST(request) {\n    console.log(\"[Upload Video API] Request received: POST\");\n    let tempDir = null;\n    let videoFilePath = null;\n    try {\n        // STEP 1: Authenticate the request\n        console.log(\"[Upload Video API] Authenticating request\");\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[Upload Video API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_6__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[Upload Video API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[Upload Video API] User authenticated: ${user.id}`);\n        // STEP 1.5: Check usage limits BEFORE processing\n        console.log(\"[Upload Video API] Checking usage limits\");\n        const usageCheck = await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.checkUsageLimits)(user.id, token, \"video\");\n        if (!usageCheck.canGenerate) {\n            console.log(`[Upload Video API] Generation limit reached: ${usageCheck.reason}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Generation limit reached\",\n                message: usageCheck.reason || \"You have reached your monthly note generation limit\",\n                usage: usageCheck.usage,\n                limits: usageCheck.limits\n            }, {\n                status: 429\n            }); // 429 = Too Many Requests\n        }\n        if (!usageCheck.canSave) {\n            console.log(`[Upload Video API] Storage limit reached: ${usageCheck.reason}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Storage limit reached\",\n                message: usageCheck.reason || \"You have reached your saved notes limit\",\n                usage: usageCheck.usage,\n                limits: usageCheck.limits\n            }, {\n                status: 429\n            });\n        }\n        console.log(`[Upload Video API] Usage check passed - can generate: ${usageCheck.canGenerate}, can save: ${usageCheck.canSave}`);\n        // Get user's subscription for priority\n        const subscription = await getSubscriptionPlan(user.id);\n        // Wrap the processing in queue\n        const result = await (0,_services_queue__WEBPACK_IMPORTED_MODULE_4__.queueRequest)(user.id, subscription.planId, \"video-upload\", async ()=>{\n            // STEP 2: Parse the multipart form data\n            const formData = await request.formData();\n            const file = formData.get(\"file\");\n            const customTitle = formData.get(\"title\");\n            if (!file) {\n                console.error(\"[Upload Video API] No file provided\");\n                return {\n                    success: false,\n                    error: \"Missing file\",\n                    message: \"Please provide a video file to upload\"\n                };\n            }\n            console.log(`[Upload Video API] File received: ${file.name} (${file.size} bytes, ${file.type})`);\n            // STEP 3: Validate file type and size\n            const allowedTypes = [\n                \"video/mp4\",\n                \"video/mov\",\n                \"video/quicktime\",\n                \"video/webm\",\n                \"video/avi\",\n                \"video/mkv\"\n            ];\n            if (!allowedTypes.includes(file.type)) {\n                console.error(`[Upload Video API] Unsupported file type: ${file.type}`);\n                return {\n                    success: false,\n                    error: \"Unsupported file type\",\n                    message: \"Please upload a video file (.mp4, .mov, .webm, .avi, .mkv)\"\n                };\n            }\n            // Check file size (limit to 200MB)\n            const MAX_FILE_SIZE = 200 * 1024 * 1024; // 200MB\n            if (file.size > MAX_FILE_SIZE) {\n                console.error(`[Upload Video API] File too large: ${file.size} bytes`);\n                return {\n                    success: false,\n                    error: \"File too large\",\n                    message: \"Video file must be smaller than 200MB\"\n                };\n            }\n            console.log(`[Upload Video API] File validated successfully`);\n            // STEP 4: Create temporary directory and save file\n            tempDir = await (0,_services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__.createTempDirectory)();\n            const fileName = `video_${Date.now()}_${file.name}`;\n            videoFilePath = path__WEBPACK_IMPORTED_MODULE_5___default().join(tempDir, fileName);\n            console.log(`[Upload Video API] Saving file to: ${videoFilePath}`);\n            // Convert File to Buffer and save\n            const fileBuffer = Buffer.from(await file.arrayBuffer());\n            await fs_extra__WEBPACK_IMPORTED_MODULE_7___default().writeFile(videoFilePath, fileBuffer);\n            console.log(`[Upload Video API] File saved successfully`);\n            // STEP 5: Validate video file format using FFmpeg\n            console.log(\"[Upload Video API] Validating video format...\");\n            console.log(`[Upload Video API] File details: name=${file.name}, size=${file.size}, type=${file.type}`);\n            console.log(`[Upload Video API] Temp file path: ${videoFilePath}`);\n            try {\n                const isValidVideo = await (0,_services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__.validateVideoFile)(videoFilePath, file.name);\n                console.log(`[Upload Video API] Video validation result: ${isValidVideo}`);\n                if (!isValidVideo) {\n                    console.error(\"[Upload Video API] Video validation failed\");\n                    console.error(`[Upload Video API] File: ${file.name} (${file.type}) - ${file.size} bytes`);\n                    // Try to get more information about why validation failed\n                    try {\n                        const fileExists = await fs_extra__WEBPACK_IMPORTED_MODULE_7___default().pathExists(videoFilePath);\n                        console.log(`[Upload Video API] File exists at temp path: ${fileExists}`);\n                        if (fileExists) {\n                            const stats = await fs_extra__WEBPACK_IMPORTED_MODULE_7___default().stat(videoFilePath);\n                            console.log(`[Upload Video API] Temp file size: ${stats.size} bytes`);\n                        }\n                    } catch (debugError) {\n                        console.error(\"[Upload Video API] Debug error:\", debugError);\n                    }\n                    return {\n                        success: false,\n                        error: \"Invalid video\",\n                        message: \"The uploaded file is not a valid video or does not contain audio. Please ensure you upload a valid video file with audio content.\"\n                    };\n                }\n            } catch (validationError) {\n                console.error(\"[Upload Video API] Video validation threw error:\", validationError);\n                return {\n                    success: false,\n                    error: \"Validation failed\",\n                    message: \"Failed to validate video file. Please try uploading again.\"\n                };\n            }\n            // STEP 6: Get video information\n            console.log(\"[Upload Video API] Analyzing video...\");\n            let videoInfo;\n            try {\n                videoInfo = await (0,_services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__.getVideoInfo)(videoFilePath);\n                console.log(`[Upload Video API] Video info: ${JSON.stringify(videoInfo)}`);\n            } catch (error) {\n                console.error(\"[Upload Video API] Failed to analyze video:\", error);\n                videoInfo = {\n                    duration: 0,\n                    format: \"unknown\",\n                    size: file.size\n                };\n            }\n            // STEP 7: Transcribe video using Whisper\n            console.log(\"[Upload Video API] Starting video transcription...\");\n            const transcriptionResult = await (0,_services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__.transcribeVideoFile)(videoFilePath, tempDir, (progress)=>{\n                console.log(`[Upload Video API] Transcription progress: ${progress.step} - ${progress.progress}% - ${progress.message}`);\n            // In a real application, you might want to emit this progress via WebSocket or Server-Sent Events\n            });\n            if (transcriptionResult.error || !transcriptionResult.transcript) {\n                console.error(\"[Upload Video API] Transcription failed:\", transcriptionResult.error);\n                return {\n                    success: false,\n                    error: \"Transcription failed\",\n                    message: transcriptionResult.error || \"Failed to transcribe video audio\"\n                };\n            }\n            console.log(`[Upload Video API] Transcription completed: ${transcriptionResult.transcript.length} characters`);\n            // STEP 8: Generate notes using AI\n            console.log(\"[Upload Video API] Generating notes from transcript\");\n            let notesResult;\n            try {\n                notesResult = await (0,_services_ai__WEBPACK_IMPORTED_MODULE_1__.generateNotes)({\n                    transcript: transcriptionResult.transcript,\n                    videoTitle: customTitle || file.name\n                });\n                if (!notesResult.content) {\n                    console.error(\"[Upload Video API] AI note generation failed:\", notesResult.error);\n                    return {\n                        success: false,\n                        error: \"Note generation failed\",\n                        message: notesResult.error || \"Failed to generate notes from the transcript\"\n                    };\n                }\n                console.log(`[Upload Video API] Successfully generated notes (${notesResult.content.length} chars)`);\n            } catch (aiError) {\n                console.error(\"[Upload Video API] Error during AI note generation:\", aiError);\n                return {\n                    success: false,\n                    error: \"AI processing failed\",\n                    message: aiError.message || \"An error occurred while generating notes with AI\"\n                };\n            }\n            // STEP 9: Create the note record for video_upload_notes table\n            const noteId = `video_upload_${Date.now()}`;\n            const noteData = {\n                id: noteId,\n                user_id: user.id,\n                title: customTitle || `Video Notes - ${file.name}`,\n                file_name: file.name,\n                file_size: file.size,\n                duration: videoInfo.duration || 0,\n                transcript: transcriptionResult.transcript,\n                content: notesResult.content,\n                summary: notesResult.summary,\n                quiz: notesResult.quiz,\n                language: transcriptionResult.language || \"auto-detected\"\n            };\n            console.log(`[Upload Video API] Created note with ID: ${noteId}`);\n            console.log(\"[Upload Video API] Note data structure:\", Object.keys(noteData).join(\", \"));\n            // STEP 10: Store the note in Supabase video_upload_notes table\n            console.log(\"[Upload Video API] Storing note in Supabase\");\n            try {\n                // First attempt to insert the data\n                let { data, error } = await supabase.from(\"video_upload_notes\").insert(noteData).select().single();\n                if (error) {\n                    console.error(\"[Upload Video API] Database storage error:\", JSON.stringify(error, null, 2));\n                    // Handle specific database errors\n                    if (error.code === \"42P01\" || error.message?.includes(\"relation\") || error.message?.includes(\"does not exist\")) {\n                        // Table doesn't exist - we can't create it with RPC, so let's just return a more helpful error\n                        console.error(\"[Upload Video API] Table video_upload_notes does not exist\");\n                        return {\n                            success: false,\n                            error: \"Database setup required\",\n                            message: \"The video notes database table needs to be set up. Please contact support.\",\n                            details: {\n                                code: error.code,\n                                message: error.message,\n                                hint: \"Table video_upload_notes does not exist\"\n                            }\n                        };\n                    }\n                    // Handle other database errors\n                    if (error.code === \"23505\") {\n                        // Duplicate key - try with a new ID\n                        const newNoteId = `video_upload_${Date.now()}_retry`;\n                        const retryNoteData = {\n                            ...noteData,\n                            id: newNoteId\n                        };\n                        console.log(\"[Upload Video API] Duplicate ID detected, retrying with new ID:\", newNoteId);\n                        const { data: retryData, error: retryError } = await supabase.from(\"video_upload_notes\").insert(retryNoteData).select().single();\n                        if (retryError) {\n                            console.error(\"[Upload Video API] Retry insert failed:\", JSON.stringify(retryError, null, 2));\n                            return {\n                                success: false,\n                                error: \"Database error\",\n                                message: \"Failed to store the notes in the database after retry\",\n                                details: {\n                                    code: retryError.code,\n                                    message: retryError.message\n                                }\n                            };\n                        }\n                        data = retryData;\n                    } else {\n                        // Other errors\n                        console.error(\"[Upload Video API] Unhandled database error:\", JSON.stringify(error, null, 2));\n                        return {\n                            success: false,\n                            error: \"Database error\",\n                            message: \"Failed to store the notes in the database\",\n                            details: {\n                                code: error.code,\n                                message: error.message,\n                                hint: error.hint\n                            }\n                        };\n                    }\n                }\n                if (!data) {\n                    console.error(\"[Upload Video API] No data returned from insert operation\");\n                    return {\n                        success: false,\n                        error: \"Database error\",\n                        message: \"No data returned from database insert operation\"\n                    };\n                }\n                console.log(`[Upload Video API] Successfully stored note: ${data.id}`);\n                // STEP 11: Increment usage counters\n                try {\n                    await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.incrementUsage)(user.id, token, \"video\");\n                    console.log(\"[Upload Video API] Usage incremented successfully\");\n                } catch (usageError) {\n                    console.warn(\"[Upload Video API] Failed to increment usage:\", usageError);\n                // Don't fail the request for usage tracking errors\n                }\n                // STEP 11.5: Refresh saved notes count\n                console.log(\"[Upload Video API] Refreshing saved notes count\");\n                try {\n                    await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.refreshSavedNotesCount)(user.id, token);\n                    console.log(\"[Upload Video API] Saved notes count refreshed\");\n                } catch (countError) {\n                    console.error(\"[Upload Video API] Saved notes count refresh failed (note still created):\", countError);\n                // Don't fail the request if count refresh fails\n                }\n                // STEP 12: Cleanup temporary files\n                if (tempDir) {\n                    await (0,_services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__.cleanupTempDirectory)(tempDir);\n                }\n                console.log(\"[Upload Video API] Video processing completed successfully\");\n                return {\n                    success: true,\n                    message: \"Video processed and notes generated successfully\",\n                    data: {\n                        id: data.id,\n                        title: data.title,\n                        content: data.content,\n                        summary: data.summary,\n                        quiz: data.quiz,\n                        transcript: data.transcript,\n                        duration: data.duration,\n                        language: data.language,\n                        created_at: data.created_at\n                    }\n                };\n            } catch (dbError) {\n                console.error(\"[Upload Video API] Database operation failed:\", JSON.stringify(dbError, null, 2));\n                return {\n                    success: false,\n                    error: \"Database error\",\n                    message: \"Failed to store the notes in the database\",\n                    details: {\n                        message: dbError.message,\n                        code: dbError.code,\n                        name: dbError.name\n                    }\n                };\n            }\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(result);\n    } catch (error) {\n        console.error(\"[Upload Video API] Unexpected error:\", error);\n        // Cleanup on error\n        if (tempDir) {\n            await (0,_services_videoTranscription__WEBPACK_IMPORTED_MODULE_2__.cleanupTempDirectory)(tempDir);\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: error.message || \"An unexpected error occurred while processing the video\"\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * GET endpoint to retrieve user's uploaded video notes\n */ async function GET(request) {\n    console.log(\"[Upload Video API] Request received: GET\");\n    try {\n        // Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\"\n            }, {\n                status: 401\n            });\n        }\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_6__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\"\n            }, {\n                status: 401\n            });\n        }\n        // Fetch user's video upload notes\n        const { data: notes, error } = await supabase.from(\"video_upload_notes\").select(\"id, title, file_name, duration, content, summary, quiz, language, created_at\").eq(\"user_id\", user.id).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"[Upload Video API] Error fetching notes:\", error);\n            if (error.code === \"42P01\") {\n                // Table doesn't exist yet\n                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                    success: true,\n                    data: [],\n                    message: \"No video upload notes found\"\n                });\n            }\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Database error\",\n                message: \"Failed to fetch video upload notes\"\n            }, {\n                status: 500\n            });\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data: notes || [],\n            count: notes?.length || 0\n        });\n    } catch (error) {\n        console.error(\"[Upload Video API] GET error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: error.message || \"Failed to fetch video upload notes\"\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * DELETE endpoint to delete a specific video upload note\n */ async function DELETE(request) {\n    console.log(\"[Upload Video API] Request received: DELETE\");\n    try {\n        // Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\"\n            }, {\n                status: 401\n            });\n        }\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_6__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\"\n            }, {\n                status: 401\n            });\n        }\n        // Get the note ID from query parameters\n        const noteId = request.nextUrl.searchParams.get(\"id\");\n        if (!noteId) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Missing note ID\",\n                message: \"Note ID is required for deletion\"\n            }, {\n                status: 400\n            });\n        }\n        console.log(`[Upload Video API] Deleting note with ID: ${noteId}`);\n        // Delete the note (with user ownership check)\n        const { data, error } = await supabase.from(\"video_upload_notes\").delete().eq(\"id\", noteId).eq(\"user_id\", user.id) // Ensure user can only delete their own notes\n        .select();\n        if (error) {\n            console.error(\"[Upload Video API] Database delete error:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Database error\",\n                message: \"Failed to delete the note from the database\",\n                details: {\n                    code: error.code,\n                    message: error.message\n                }\n            }, {\n                status: 500\n            });\n        }\n        // Check if any rows were affected\n        if (!data || data.length === 0) {\n            console.error(`[Upload Video API] Note not found or access denied: ${noteId}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Note not found\",\n                message: \"The note was not found or you do not have permission to delete it\"\n            }, {\n                status: 404\n            });\n        }\n        console.log(`[Upload Video API] Successfully deleted note: ${noteId}`);\n        // Refresh saved notes count after deletion\n        try {\n            await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.refreshSavedNotesCount)(user.id, token);\n            console.log(\"[Upload Video API] Saved notes count refreshed after deletion\");\n        } catch (countError) {\n            console.error(\"[Upload Video API] Saved notes count refresh failed after deletion:\", countError);\n        // Don't fail the request if count refresh fails\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"Note deleted successfully\",\n            data: data[0]\n        });\n    } catch (error) {\n        console.error(\"[Upload Video API] DELETE error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: error.message || \"Failed to delete video upload note\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS91cGxvYWQtdmlkZW8vcm91dGUudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUF3RDtBQUNIO0FBQ1A7QUFDa0c7QUFDN0M7QUFDbkQ7QUFDdEI7QUFDRjtBQUV4Qiw2QkFBNkI7QUFDN0IsTUFBTWMsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBRWpFOztDQUVDLEdBQ0QsZUFBZUssb0JBQW9CQyxNQUFjO0lBQy9DLElBQUk7UUFDRixNQUFNQyxXQUFXckIsbUVBQVlBLENBQUNhLGFBQWFJO1FBQzNDLE1BQU0sRUFBRUssSUFBSSxFQUFFLEdBQUcsTUFBTUQsU0FDcEJFLElBQUksQ0FBQyxzQkFDTEMsTUFBTSxDQUFDLFdBQ1BDLEVBQUUsQ0FBQyxXQUFXTCxRQUNkSyxFQUFFLENBQUMsVUFBVSxVQUNiQyxNQUFNO1FBRVQsTUFBTUMsU0FBU0wsTUFBTU07UUFFckIscUNBQXFDO1FBQ3JDLElBQUlELFdBQVcsYUFBYUEsV0FBVyxPQUFPO1lBQzVDLE9BQU87Z0JBQUVBO1lBQU87UUFDbEI7UUFFQSxPQUFPO1lBQUVBLFFBQVE7UUFBTztJQUMxQixFQUFFLE9BQU9FLE9BQU87UUFDZEMsUUFBUUMsSUFBSSxDQUFDLG9EQUFvREY7UUFDakUsT0FBTztZQUFFRixRQUFRO1FBQU87SUFDMUI7QUFDRjtBQUVBOzs7Ozs7OztDQVFDLEdBQ00sZUFBZUssS0FBS0MsT0FBb0I7SUFDN0NILFFBQVFJLEdBQUcsQ0FBQztJQUVaLElBQUlDLFVBQXlCO0lBQzdCLElBQUlDLGdCQUErQjtJQUVuQyxJQUFJO1FBQ0YsbUNBQW1DO1FBQ25DTixRQUFRSSxHQUFHLENBQUM7UUFDWixNQUFNRyxhQUFhSixRQUFRSyxPQUFPLENBQUNDLEdBQUcsQ0FBQztRQUN2QyxJQUFJLENBQUNGLGNBQWMsQ0FBQ0EsV0FBV0csVUFBVSxDQUFDLFlBQVk7WUFDcERWLFFBQVFELEtBQUssQ0FBQztZQUNkLE9BQU85Qixx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LE9BQU85QixxREFBWUEsQ0FBQzBDLElBQUksQ0FBQztZQUN2QkMsU0FBUztZQUNUYixPQUFPO1lBQ1BjLFNBQVNkLE1BQU1jLE9BQU8sSUFBSTtRQUM1QixHQUFHO1lBQUVDLFFBQVE7UUFBSTtJQUNuQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL2FwcC9hcGkvdXBsb2FkLXZpZGVvL3JvdXRlLnRzPzg2NWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZU5vdGVzIH0gZnJvbSAnQC9zZXJ2aWNlcy9haSc7XG5pbXBvcnQgeyB0cmFuc2NyaWJlVmlkZW9GaWxlLCB2YWxpZGF0ZVZpZGVvRmlsZSwgY3JlYXRlVGVtcERpcmVjdG9yeSwgY2xlYW51cFRlbXBEaXJlY3RvcnksIGdldFZpZGVvSW5mbyB9IGZyb20gJ0Avc2VydmljZXMvdmlkZW9UcmFuc2NyaXB0aW9uJztcbmltcG9ydCB7IGNoZWNrVXNhZ2VMaW1pdHMsIGluY3JlbWVudFVzYWdlLCByZWZyZXNoU2F2ZWROb3Rlc0NvdW50IH0gZnJvbSAnQC9zZXJ2aWNlcy9zdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgcXVldWVSZXF1ZXN0IH0gZnJvbSAnQC9zZXJ2aWNlcy9xdWV1ZSc7XG5pbXBvcnQgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50XG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XG5cbi8qKlxuICogR2V0IHVzZXIncyBzdWJzY3JpcHRpb24gcGxhbiBmb3IgcXVldWUgcHJpb3JpdHlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUGxhbih1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8eyBwbGFuSWQ6ICdmcmVlJyB8ICdzdHVkZW50JyB8ICdwcm8nIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcbiAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl9zdWJzY3JpcHRpb25zJylcbiAgICAgIC5zZWxlY3QoJ3BsYW5faWQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgICBjb25zdCBwbGFuSWQgPSBkYXRhPy5wbGFuX2lkO1xuICAgIFxuICAgIC8vIEVuc3VyZSB3ZSByZXR1cm4gYSB2YWxpZCBwbGFuIHR5cGVcbiAgICBpZiAocGxhbklkID09PSAnc3R1ZGVudCcgfHwgcGxhbklkID09PSAncHJvJykge1xuICAgICAgcmV0dXJuIHsgcGxhbklkIH07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7IHBsYW5JZDogJ2ZyZWUnIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdbVXBsb2FkIFZpZGVvIEFQSV0gQ291bGQgbm90IGZldGNoIHN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIHsgcGxhbklkOiAnZnJlZScgfTtcbiAgfVxufVxuXG4vKipcbiAqIFZpZGVvIFVwbG9hZCBBUEkgRW5kcG9pbnQgLSBJbmRlcGVuZGVudCBTeXN0ZW1cbiAqIFxuICogUHJvY2Vzc2VzIHVwbG9hZGVkIHZpZGVvIGZpbGVzIHRvOlxuICogMS4gVmFsaWRhdGUgYW5kIHN0b3JlIHRoZSB2aWRlbyBmaWxlXG4gKiAyLiBFeHRyYWN0IGF1ZGlvIGFuZCB0cmFuc2NyaWJlIHVzaW5nIFdoaXNwZXJcbiAqIDMuIEdlbmVyYXRlIEFJIG5vdGVzIGZyb20gdHJhbnNjcmlwdFxuICogNC4gU3RvcmUgaW4gaXNvbGF0ZWQgdmlkZW9fdXBsb2FkX25vdGVzIHRhYmxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKCdbVXBsb2FkIFZpZGVvIEFQSV0gUmVxdWVzdCByZWNlaXZlZDogUE9TVCcpO1xuXG4gIGxldCB0ZW1wRGlyOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgbGV0IHZpZGVvRmlsZVBhdGg6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgLy8gU1RFUCAxOiBBdXRoZW50aWNhdGUgdGhlIHJlcXVlc3RcbiAgICBjb25zb2xlLmxvZygnW1VwbG9hZCBWaWRlbyBBUEldIEF1dGhlbnRpY2F0aW5nIHJlcXVlc3QnKTtcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlciB8fCAhYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBBdXRoZW50aWNhdGlvbiBtaXNzaW5nJyk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gcmVxdWlyZWQnLFxuICAgICAgICBtZXNzYWdlOiAnVmFsaWQgQmVhcmVyIHRva2VuIGlzIHJlcXVpcmVkJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIFN1cGFiYXNlIGNsaWVudCB3aXRoIHRoZSB0b2tlblxuICAgIGNvbnN0IHRva2VuID0gYXV0aEhlYWRlci5yZXBsYWNlKCdCZWFyZXIgJywgJycpO1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgdXNlcidzIHRva2VuIGFuZCBzZXQgdGhlIHNlc3Npb25cbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogYXV0aEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIodG9rZW4pO1xuICAgIGlmIChhdXRoRXJyb3IgfHwgIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBBdXRoZW50aWNhdGlvbiBmYWlsZWQ6JywgYXV0aEVycm9yPy5tZXNzYWdlKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnLFxuICAgICAgICBtZXNzYWdlOiBhdXRoRXJyb3I/Lm1lc3NhZ2UgfHwgJ0ludmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4nXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIFVzZXIgYXV0aGVudGljYXRlZDogJHt1c2VyLmlkfWApO1xuXG4gICAgLy8gU1RFUCAxLjU6IENoZWNrIHVzYWdlIGxpbWl0cyBCRUZPUkUgcHJvY2Vzc2luZ1xuICAgIGNvbnNvbGUubG9nKCdbVXBsb2FkIFZpZGVvIEFQSV0gQ2hlY2tpbmcgdXNhZ2UgbGltaXRzJyk7XG4gICAgY29uc3QgdXNhZ2VDaGVjayA9IGF3YWl0IGNoZWNrVXNhZ2VMaW1pdHModXNlci5pZCwgdG9rZW4sICd2aWRlbycpO1xuICAgIFxuICAgIGlmICghdXNhZ2VDaGVjay5jYW5HZW5lcmF0ZSkge1xuICAgICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBHZW5lcmF0aW9uIGxpbWl0IHJlYWNoZWQ6ICR7dXNhZ2VDaGVjay5yZWFzb259YCk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdHZW5lcmF0aW9uIGxpbWl0IHJlYWNoZWQnLFxuICAgICAgICBtZXNzYWdlOiB1c2FnZUNoZWNrLnJlYXNvbiB8fCAnWW91IGhhdmUgcmVhY2hlZCB5b3VyIG1vbnRobHkgbm90ZSBnZW5lcmF0aW9uIGxpbWl0JyxcbiAgICAgICAgdXNhZ2U6IHVzYWdlQ2hlY2sudXNhZ2UsXG4gICAgICAgIGxpbWl0czogdXNhZ2VDaGVjay5saW1pdHNcbiAgICAgIH0sIHsgc3RhdHVzOiA0MjkgfSk7IC8vIDQyOSA9IFRvbyBNYW55IFJlcXVlc3RzXG4gICAgfVxuICAgIFxuICAgIGlmICghdXNhZ2VDaGVjay5jYW5TYXZlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIFN0b3JhZ2UgbGltaXQgcmVhY2hlZDogJHt1c2FnZUNoZWNrLnJlYXNvbn1gKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1N0b3JhZ2UgbGltaXQgcmVhY2hlZCcsXG4gICAgICAgIG1lc3NhZ2U6IHVzYWdlQ2hlY2sucmVhc29uIHx8ICdZb3UgaGF2ZSByZWFjaGVkIHlvdXIgc2F2ZWQgbm90ZXMgbGltaXQnLFxuICAgICAgICB1c2FnZTogdXNhZ2VDaGVjay51c2FnZSxcbiAgICAgICAgbGltaXRzOiB1c2FnZUNoZWNrLmxpbWl0c1xuICAgICAgfSwgeyBzdGF0dXM6IDQyOSB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBVc2FnZSBjaGVjayBwYXNzZWQgLSBjYW4gZ2VuZXJhdGU6ICR7dXNhZ2VDaGVjay5jYW5HZW5lcmF0ZX0sIGNhbiBzYXZlOiAke3VzYWdlQ2hlY2suY2FuU2F2ZX1gKTtcblxuICAgIC8vIEdldCB1c2VyJ3Mgc3Vic2NyaXB0aW9uIGZvciBwcmlvcml0eVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGF3YWl0IGdldFN1YnNjcmlwdGlvblBsYW4odXNlci5pZCk7XG4gICAgXG4gICAgLy8gV3JhcCB0aGUgcHJvY2Vzc2luZyBpbiBxdWV1ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXVlUmVxdWVzdChcbiAgICAgIHVzZXIuaWQsXG4gICAgICBzdWJzY3JpcHRpb24ucGxhbklkLFxuICAgICAgJ3ZpZGVvLXVwbG9hZCcsXG4gICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIFNURVAgMjogUGFyc2UgdGhlIG11bHRpcGFydCBmb3JtIGRhdGFcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBmb3JtRGF0YS5nZXQoJ2ZpbGUnKSBhcyBGaWxlO1xuICAgICAgICBjb25zdCBjdXN0b21UaXRsZSA9IGZvcm1EYXRhLmdldCgndGl0bGUnKSBhcyBzdHJpbmc7XG5cbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1VwbG9hZCBWaWRlbyBBUEldIE5vIGZpbGUgcHJvdmlkZWQnKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ01pc3NpbmcgZmlsZScsXG4gICAgICAgICAgICBtZXNzYWdlOiAnUGxlYXNlIHByb3ZpZGUgYSB2aWRlbyBmaWxlIHRvIHVwbG9hZCdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBGaWxlIHJlY2VpdmVkOiAke2ZpbGUubmFtZX0gKCR7ZmlsZS5zaXplfSBieXRlcywgJHtmaWxlLnR5cGV9KWApO1xuXG4gICAgICAgIC8vIFNURVAgMzogVmFsaWRhdGUgZmlsZSB0eXBlIGFuZCBzaXplXG4gICAgICAgIGNvbnN0IGFsbG93ZWRUeXBlcyA9IFtcbiAgICAgICAgICAndmlkZW8vbXA0JyxcbiAgICAgICAgICAndmlkZW8vbW92JyxcbiAgICAgICAgICAndmlkZW8vcXVpY2t0aW1lJyxcbiAgICAgICAgICAndmlkZW8vd2VibScsXG4gICAgICAgICAgJ3ZpZGVvL2F2aScsXG4gICAgICAgICAgJ3ZpZGVvL21rdidcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoIWFsbG93ZWRUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW1VwbG9hZCBWaWRlbyBBUEldIFVuc3VwcG9ydGVkIGZpbGUgdHlwZTogJHtmaWxlLnR5cGV9YCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdVbnN1cHBvcnRlZCBmaWxlIHR5cGUnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1BsZWFzZSB1cGxvYWQgYSB2aWRlbyBmaWxlICgubXA0LCAubW92LCAud2VibSwgLmF2aSwgLm1rdiknXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZSAobGltaXQgdG8gMjAwTUIpXG4gICAgICAgIGNvbnN0IE1BWF9GSUxFX1NJWkUgPSAyMDAgKiAxMDI0ICogMTAyNDsgLy8gMjAwTUJcbiAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IE1BWF9GSUxFX1NJWkUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbVXBsb2FkIFZpZGVvIEFQSV0gRmlsZSB0b28gbGFyZ2U6ICR7ZmlsZS5zaXplfSBieXRlc2ApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRmlsZSB0b28gbGFyZ2UnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ1ZpZGVvIGZpbGUgbXVzdCBiZSBzbWFsbGVyIHRoYW4gMjAwTUInXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBbVXBsb2FkIFZpZGVvIEFQSV0gRmlsZSB2YWxpZGF0ZWQgc3VjY2Vzc2Z1bGx5YCk7XG5cbiAgICAgICAgLy8gU1RFUCA0OiBDcmVhdGUgdGVtcG9yYXJ5IGRpcmVjdG9yeSBhbmQgc2F2ZSBmaWxlXG4gICAgICAgIHRlbXBEaXIgPSBhd2FpdCBjcmVhdGVUZW1wRGlyZWN0b3J5KCk7XG4gICAgICAgIGNvbnN0IGZpbGVOYW1lID0gYHZpZGVvXyR7RGF0ZS5ub3coKX1fJHtmaWxlLm5hbWV9YDtcbiAgICAgICAgdmlkZW9GaWxlUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLCBmaWxlTmFtZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIFNhdmluZyBmaWxlIHRvOiAke3ZpZGVvRmlsZVBhdGh9YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBDb252ZXJ0IEZpbGUgdG8gQnVmZmVyIGFuZCBzYXZlXG4gICAgICAgIGNvbnN0IGZpbGVCdWZmZXIgPSBCdWZmZXIuZnJvbShhd2FpdCBmaWxlLmFycmF5QnVmZmVyKCkpO1xuICAgICAgICBhd2FpdCBmcy53cml0ZUZpbGUodmlkZW9GaWxlUGF0aCwgZmlsZUJ1ZmZlcik7XG5cbiAgICAgICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBGaWxlIHNhdmVkIHN1Y2Nlc3NmdWxseWApO1xuXG4gICAgICAgIC8vIFNURVAgNTogVmFsaWRhdGUgdmlkZW8gZmlsZSBmb3JtYXQgdXNpbmcgRkZtcGVnXG4gICAgICAgIGNvbnNvbGUubG9nKCdbVXBsb2FkIFZpZGVvIEFQSV0gVmFsaWRhdGluZyB2aWRlbyBmb3JtYXQuLi4nKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBGaWxlIGRldGFpbHM6IG5hbWU9JHtmaWxlLm5hbWV9LCBzaXplPSR7ZmlsZS5zaXplfSwgdHlwZT0ke2ZpbGUudHlwZX1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBUZW1wIGZpbGUgcGF0aDogJHt2aWRlb0ZpbGVQYXRofWApO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpc1ZhbGlkVmlkZW8gPSBhd2FpdCB2YWxpZGF0ZVZpZGVvRmlsZSh2aWRlb0ZpbGVQYXRoLCBmaWxlLm5hbWUpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbVXBsb2FkIFZpZGVvIEFQSV0gVmlkZW8gdmFsaWRhdGlvbiByZXN1bHQ6ICR7aXNWYWxpZFZpZGVvfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmICghaXNWYWxpZFZpZGVvKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gVmlkZW8gdmFsaWRhdGlvbiBmYWlsZWQnKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFtVcGxvYWQgVmlkZW8gQVBJXSBGaWxlOiAke2ZpbGUubmFtZX0gKCR7ZmlsZS50eXBlfSkgLSAke2ZpbGUuc2l6ZX0gYnl0ZXNgKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVHJ5IHRvIGdldCBtb3JlIGluZm9ybWF0aW9uIGFib3V0IHdoeSB2YWxpZGF0aW9uIGZhaWxlZFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgZmlsZUV4aXN0cyA9IGF3YWl0IGZzLnBhdGhFeGlzdHModmlkZW9GaWxlUGF0aCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbVXBsb2FkIFZpZGVvIEFQSV0gRmlsZSBleGlzdHMgYXQgdGVtcCBwYXRoOiAke2ZpbGVFeGlzdHN9YCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoZmlsZUV4aXN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMuc3RhdCh2aWRlb0ZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIFRlbXAgZmlsZSBzaXplOiAke3N0YXRzLnNpemV9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGRlYnVnRXJyb3IpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1VwbG9hZCBWaWRlbyBBUEldIERlYnVnIGVycm9yOicsIGRlYnVnRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIHZpZGVvJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSB1cGxvYWRlZCBmaWxlIGlzIG5vdCBhIHZhbGlkIHZpZGVvIG9yIGRvZXMgbm90IGNvbnRhaW4gYXVkaW8uIFBsZWFzZSBlbnN1cmUgeW91IHVwbG9hZCBhIHZhbGlkIHZpZGVvIGZpbGUgd2l0aCBhdWRpbyBjb250ZW50LidcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh2YWxpZGF0aW9uRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gVmlkZW8gdmFsaWRhdGlvbiB0aHJldyBlcnJvcjonLCB2YWxpZGF0aW9uRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnVmFsaWRhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byB2YWxpZGF0ZSB2aWRlbyBmaWxlLiBQbGVhc2UgdHJ5IHVwbG9hZGluZyBhZ2Fpbi4nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgNjogR2V0IHZpZGVvIGluZm9ybWF0aW9uXG4gICAgICAgIGNvbnNvbGUubG9nKCdbVXBsb2FkIFZpZGVvIEFQSV0gQW5hbHl6aW5nIHZpZGVvLi4uJyk7XG4gICAgICAgIGxldCB2aWRlb0luZm87XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmlkZW9JbmZvID0gYXdhaXQgZ2V0VmlkZW9JbmZvKHZpZGVvRmlsZVBhdGgpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbVXBsb2FkIFZpZGVvIEFQSV0gVmlkZW8gaW5mbzogJHtKU09OLnN0cmluZ2lmeSh2aWRlb0luZm8pfWApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBGYWlsZWQgdG8gYW5hbHl6ZSB2aWRlbzonLCBlcnJvcik7XG4gICAgICAgICAgdmlkZW9JbmZvID0geyBkdXJhdGlvbjogMCwgZm9ybWF0OiAndW5rbm93bicsIHNpemU6IGZpbGUuc2l6ZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU1RFUCA3OiBUcmFuc2NyaWJlIHZpZGVvIHVzaW5nIFdoaXNwZXJcbiAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBTdGFydGluZyB2aWRlbyB0cmFuc2NyaXB0aW9uLi4uJyk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCB0cmFuc2NyaXB0aW9uUmVzdWx0ID0gYXdhaXQgdHJhbnNjcmliZVZpZGVvRmlsZShcbiAgICAgICAgICB2aWRlb0ZpbGVQYXRoLFxuICAgICAgICAgIHRlbXBEaXIsXG4gICAgICAgICAgKHByb2dyZXNzKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIFRyYW5zY3JpcHRpb24gcHJvZ3Jlc3M6ICR7cHJvZ3Jlc3Muc3RlcH0gLSAke3Byb2dyZXNzLnByb2dyZXNzfSUgLSAke3Byb2dyZXNzLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAvLyBJbiBhIHJlYWwgYXBwbGljYXRpb24sIHlvdSBtaWdodCB3YW50IHRvIGVtaXQgdGhpcyBwcm9ncmVzcyB2aWEgV2ViU29ja2V0IG9yIFNlcnZlci1TZW50IEV2ZW50c1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAodHJhbnNjcmlwdGlvblJlc3VsdC5lcnJvciB8fCAhdHJhbnNjcmlwdGlvblJlc3VsdC50cmFuc2NyaXB0KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1VwbG9hZCBWaWRlbyBBUEldIFRyYW5zY3JpcHRpb24gZmFpbGVkOicsIHRyYW5zY3JpcHRpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnVHJhbnNjcmlwdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgbWVzc2FnZTogdHJhbnNjcmlwdGlvblJlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIHRyYW5zY3JpYmUgdmlkZW8gYXVkaW8nXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUubG9nKGBbVXBsb2FkIFZpZGVvIEFQSV0gVHJhbnNjcmlwdGlvbiBjb21wbGV0ZWQ6ICR7dHJhbnNjcmlwdGlvblJlc3VsdC50cmFuc2NyaXB0Lmxlbmd0aH0gY2hhcmFjdGVyc2ApO1xuXG4gICAgICAgIC8vIFNURVAgODogR2VuZXJhdGUgbm90ZXMgdXNpbmcgQUlcbiAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBHZW5lcmF0aW5nIG5vdGVzIGZyb20gdHJhbnNjcmlwdCcpO1xuICAgICAgICBsZXQgbm90ZXNSZXN1bHQ7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5vdGVzUmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVOb3Rlcyh7XG4gICAgICAgICAgICB0cmFuc2NyaXB0OiB0cmFuc2NyaXB0aW9uUmVzdWx0LnRyYW5zY3JpcHQsXG4gICAgICAgICAgICB2aWRlb1RpdGxlOiBjdXN0b21UaXRsZSB8fCBmaWxlLm5hbWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoIW5vdGVzUmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBBSSBub3RlIGdlbmVyYXRpb24gZmFpbGVkOicsIG5vdGVzUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogJ05vdGUgZ2VuZXJhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBub3Rlc1Jlc3VsdC5lcnJvciB8fCAnRmFpbGVkIHRvIGdlbmVyYXRlIG5vdGVzIGZyb20gdGhlIHRyYW5zY3JpcHQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIFN1Y2Nlc3NmdWxseSBnZW5lcmF0ZWQgbm90ZXMgKCR7bm90ZXNSZXN1bHQuY29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgICAgICB9IGNhdGNoIChhaUVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gRXJyb3IgZHVyaW5nIEFJIG5vdGUgZ2VuZXJhdGlvbjonLCBhaUVycm9yKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0FJIHByb2Nlc3NpbmcgZmFpbGVkJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGFpRXJyb3IubWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZ2VuZXJhdGluZyBub3RlcyB3aXRoIEFJJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTVEVQIDk6IENyZWF0ZSB0aGUgbm90ZSByZWNvcmQgZm9yIHZpZGVvX3VwbG9hZF9ub3RlcyB0YWJsZVxuICAgICAgICBjb25zdCBub3RlSWQgPSBgdmlkZW9fdXBsb2FkXyR7RGF0ZS5ub3coKX1gO1xuICAgICAgICBjb25zdCBub3RlRGF0YSA9IHtcbiAgICAgICAgICBpZDogbm90ZUlkLFxuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgdGl0bGU6IGN1c3RvbVRpdGxlIHx8IGBWaWRlbyBOb3RlcyAtICR7ZmlsZS5uYW1lfWAsXG4gICAgICAgICAgZmlsZV9uYW1lOiBmaWxlLm5hbWUsXG4gICAgICAgICAgZmlsZV9zaXplOiBmaWxlLnNpemUsXG4gICAgICAgICAgZHVyYXRpb246IHZpZGVvSW5mby5kdXJhdGlvbiB8fCAwLFxuICAgICAgICAgIHRyYW5zY3JpcHQ6IHRyYW5zY3JpcHRpb25SZXN1bHQudHJhbnNjcmlwdCxcbiAgICAgICAgICBjb250ZW50OiBub3Rlc1Jlc3VsdC5jb250ZW50LFxuICAgICAgICAgIHN1bW1hcnk6IG5vdGVzUmVzdWx0LnN1bW1hcnksXG4gICAgICAgICAgcXVpejogbm90ZXNSZXN1bHQucXVpeixcbiAgICAgICAgICBsYW5ndWFnZTogdHJhbnNjcmlwdGlvblJlc3VsdC5sYW5ndWFnZSB8fCAnYXV0by1kZXRlY3RlZCdcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIENyZWF0ZWQgbm90ZSB3aXRoIElEOiAke25vdGVJZH1gKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBOb3RlIGRhdGEgc3RydWN0dXJlOicsIE9iamVjdC5rZXlzKG5vdGVEYXRhKS5qb2luKCcsICcpKTtcblxuICAgICAgICAvLyBTVEVQIDEwOiBTdG9yZSB0aGUgbm90ZSBpbiBTdXBhYmFzZSB2aWRlb191cGxvYWRfbm90ZXMgdGFibGVcbiAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBTdG9yaW5nIG5vdGUgaW4gU3VwYWJhc2UnKTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gRmlyc3QgYXR0ZW1wdCB0byBpbnNlcnQgdGhlIGRhdGFcbiAgICAgICAgICBsZXQgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd2aWRlb191cGxvYWRfbm90ZXMnKVxuICAgICAgICAgICAgLmluc2VydChub3RlRGF0YSlcbiAgICAgICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAgICAgLnNpbmdsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gRGF0YWJhc2Ugc3RvcmFnZSBlcnJvcjonLCBKU09OLnN0cmluZ2lmeShlcnJvciwgbnVsbCwgMikpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBIYW5kbGUgc3BlY2lmaWMgZGF0YWJhc2UgZXJyb3JzXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzQyUDAxJyB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygncmVsYXRpb24nKSB8fCBlcnJvci5tZXNzYWdlPy5pbmNsdWRlcygnZG9lcyBub3QgZXhpc3QnKSkge1xuICAgICAgICAgICAgICAvLyBUYWJsZSBkb2Vzbid0IGV4aXN0IC0gd2UgY2FuJ3QgY3JlYXRlIGl0IHdpdGggUlBDLCBzbyBsZXQncyBqdXN0IHJldHVybiBhIG1vcmUgaGVscGZ1bCBlcnJvclxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gVGFibGUgdmlkZW9fdXBsb2FkX25vdGVzIGRvZXMgbm90IGV4aXN0Jyk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdEYXRhYmFzZSBzZXR1cCByZXF1aXJlZCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSB2aWRlbyBub3RlcyBkYXRhYmFzZSB0YWJsZSBuZWVkcyB0byBiZSBzZXQgdXAuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIGhpbnQ6ICdUYWJsZSB2aWRlb191cGxvYWRfbm90ZXMgZG9lcyBub3QgZXhpc3QnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBIYW5kbGUgb3RoZXIgZGF0YWJhc2UgZXJyb3JzXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gJzIzNTA1Jykge1xuICAgICAgICAgICAgICAvLyBEdXBsaWNhdGUga2V5IC0gdHJ5IHdpdGggYSBuZXcgSURcbiAgICAgICAgICAgICAgY29uc3QgbmV3Tm90ZUlkID0gYHZpZGVvX3VwbG9hZF8ke0RhdGUubm93KCl9X3JldHJ5YDtcbiAgICAgICAgICAgICAgY29uc3QgcmV0cnlOb3RlRGF0YSA9IHsgLi4ubm90ZURhdGEsIGlkOiBuZXdOb3RlSWQgfTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbVXBsb2FkIFZpZGVvIEFQSV0gRHVwbGljYXRlIElEIGRldGVjdGVkLCByZXRyeWluZyB3aXRoIG5ldyBJRDonLCBuZXdOb3RlSWQpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXRyeURhdGEsIGVycm9yOiByZXRyeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCd2aWRlb191cGxvYWRfbm90ZXMnKVxuICAgICAgICAgICAgICAgIC5pbnNlcnQocmV0cnlOb3RlRGF0YSlcbiAgICAgICAgICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChyZXRyeUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1VwbG9hZCBWaWRlbyBBUEldIFJldHJ5IGluc2VydCBmYWlsZWQ6JywgSlNPTi5zdHJpbmdpZnkocmV0cnlFcnJvciwgbnVsbCwgMikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBzdG9yZSB0aGUgbm90ZXMgaW4gdGhlIGRhdGFiYXNlIGFmdGVyIHJldHJ5JyxcbiAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmV0cnlFcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXRyeUVycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBkYXRhID0gcmV0cnlEYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gT3RoZXIgZXJyb3JzXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBVbmhhbmRsZWQgZGF0YWJhc2UgZXJyb3I6JywgSlNPTi5zdHJpbmdpZnkoZXJyb3IsIG51bGwsIDIpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHN0b3JlIHRoZSBub3RlcyBpbiB0aGUgZGF0YWJhc2UnLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yLmNvZGUsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgaGludDogZXJyb3IuaGludFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gTm8gZGF0YSByZXR1cm5lZCBmcm9tIGluc2VydCBvcGVyYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIGRhdGEgcmV0dXJuZWQgZnJvbSBkYXRhYmFzZSBpbnNlcnQgb3BlcmF0aW9uJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBTdWNjZXNzZnVsbHkgc3RvcmVkIG5vdGU6ICR7ZGF0YS5pZH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTVEVQIDExOiBJbmNyZW1lbnQgdXNhZ2UgY291bnRlcnNcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgaW5jcmVtZW50VXNhZ2UodXNlci5pZCwgdG9rZW4sICd2aWRlbycpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBVc2FnZSBpbmNyZW1lbnRlZCBzdWNjZXNzZnVsbHknKTtcbiAgICAgICAgICB9IGNhdGNoICh1c2FnZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tVcGxvYWQgVmlkZW8gQVBJXSBGYWlsZWQgdG8gaW5jcmVtZW50IHVzYWdlOicsIHVzYWdlRXJyb3IpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgcmVxdWVzdCBmb3IgdXNhZ2UgdHJhY2tpbmcgZXJyb3JzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU1RFUCAxMS41OiBSZWZyZXNoIHNhdmVkIG5vdGVzIGNvdW50XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBSZWZyZXNoaW5nIHNhdmVkIG5vdGVzIGNvdW50Jyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHJlZnJlc2hTYXZlZE5vdGVzQ291bnQodXNlci5pZCwgdG9rZW4pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBTYXZlZCBub3RlcyBjb3VudCByZWZyZXNoZWQnKTtcbiAgICAgICAgICB9IGNhdGNoIChjb3VudEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gU2F2ZWQgbm90ZXMgY291bnQgcmVmcmVzaCBmYWlsZWQgKG5vdGUgc3RpbGwgY3JlYXRlZCk6JywgY291bnRFcnJvcik7XG4gICAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0IGlmIGNvdW50IHJlZnJlc2ggZmFpbHNcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU1RFUCAxMjogQ2xlYW51cCB0ZW1wb3JhcnkgZmlsZXNcbiAgICAgICAgICBpZiAodGVtcERpcikge1xuICAgICAgICAgICAgYXdhaXQgY2xlYW51cFRlbXBEaXJlY3RvcnkodGVtcERpcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdbVXBsb2FkIFZpZGVvIEFQSV0gVmlkZW8gcHJvY2Vzc2luZyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVmlkZW8gcHJvY2Vzc2VkIGFuZCBub3RlcyBnZW5lcmF0ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgaWQ6IGRhdGEuaWQsXG4gICAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgICBjb250ZW50OiBkYXRhLmNvbnRlbnQsXG4gICAgICAgICAgICAgIHN1bW1hcnk6IGRhdGEuc3VtbWFyeSxcbiAgICAgICAgICAgICAgcXVpejogZGF0YS5xdWl6LFxuICAgICAgICAgICAgICB0cmFuc2NyaXB0OiBkYXRhLnRyYW5zY3JpcHQsXG4gICAgICAgICAgICAgIGR1cmF0aW9uOiBkYXRhLmR1cmF0aW9uLFxuICAgICAgICAgICAgICBsYW5ndWFnZTogZGF0YS5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgY3JlYXRlZF9hdDogZGF0YS5jcmVhdGVkX2F0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZGJFcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1VwbG9hZCBWaWRlbyBBUEldIERhdGFiYXNlIG9wZXJhdGlvbiBmYWlsZWQ6JywgSlNPTi5zdHJpbmdpZnkoZGJFcnJvciwgbnVsbCwgMikpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBzdG9yZSB0aGUgbm90ZXMgaW4gdGhlIGRhdGFiYXNlJyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogZGJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICBjb2RlOiBkYkVycm9yLmNvZGUsXG4gICAgICAgICAgICAgIG5hbWU6IGRiRXJyb3IubmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHJlc3VsdCk7XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBVbmV4cGVjdGVkIGVycm9yOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBDbGVhbnVwIG9uIGVycm9yXG4gICAgaWYgKHRlbXBEaXIpIHtcbiAgICAgIGF3YWl0IGNsZWFudXBUZW1wRGlyZWN0b3J5KHRlbXBEaXIpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogJ1NlcnZlciBlcnJvcicsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIHdoaWxlIHByb2Nlc3NpbmcgdGhlIHZpZGVvJ1xuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHRVQgZW5kcG9pbnQgdG8gcmV0cmlldmUgdXNlcidzIHVwbG9hZGVkIHZpZGVvIG5vdGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHRVQocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc29sZS5sb2coJ1tVcGxvYWQgVmlkZW8gQVBJXSBSZXF1ZXN0IHJlY2VpdmVkOiBHRVQnKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gQXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gcmVxdWlyZWQnIFxuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IGF1dGhIZWFkZXIucmVwbGFjZSgnQmVhcmVyICcsICcnKTtcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogYXV0aEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIodG9rZW4pO1xuICAgIGlmIChhdXRoRXJyb3IgfHwgIXVzZXIpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiBmYWlsZWQnIFxuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG5cbiAgICAvLyBGZXRjaCB1c2VyJ3MgdmlkZW8gdXBsb2FkIG5vdGVzXG4gICAgY29uc3QgeyBkYXRhOiBub3RlcywgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlkZW9fdXBsb2FkX25vdGVzJylcbiAgICAgIC5zZWxlY3QoJ2lkLCB0aXRsZSwgZmlsZV9uYW1lLCBkdXJhdGlvbiwgY29udGVudCwgc3VtbWFyeSwgcXVpeiwgbGFuZ3VhZ2UsIGNyZWF0ZWRfYXQnKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgIC5vcmRlcignY3JlYXRlZF9hdCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1VwbG9hZCBWaWRlbyBBUEldIEVycm9yIGZldGNoaW5nIG5vdGVzOicsIGVycm9yKTtcbiAgICAgIFxuICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICc0MlAwMScpIHtcbiAgICAgICAgLy8gVGFibGUgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgIG1lc3NhZ2U6ICdObyB2aWRlbyB1cGxvYWQgbm90ZXMgZm91bmQnXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdEYXRhYmFzZSBlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZmV0Y2ggdmlkZW8gdXBsb2FkIG5vdGVzJ1xuICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIGRhdGE6IG5vdGVzIHx8IFtdLFxuICAgICAgY291bnQ6IG5vdGVzPy5sZW5ndGggfHwgMFxuICAgIH0pO1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gR0VUIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogJ1NlcnZlciBlcnJvcicsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdmlkZW8gdXBsb2FkIG5vdGVzJ1xuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBERUxFVEUgZW5kcG9pbnQgdG8gZGVsZXRlIGEgc3BlY2lmaWMgdmlkZW8gdXBsb2FkIG5vdGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIERFTEVURShyZXF1ZXN0OiBOZXh0UmVxdWVzdCkge1xuICBjb25zb2xlLmxvZygnW1VwbG9hZCBWaWRlbyBBUEldIFJlcXVlc3QgcmVjZWl2ZWQ6IERFTEVURScpO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBBdXRoZW50aWNhdGUgdGhlIHJlcXVlc3RcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlciB8fCAhYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcgXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHRva2VuID0gYXV0aEhlYWRlci5yZXBsYWNlKCdCZWFyZXIgJywgJycpO1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcih0b2tlbik7XG4gICAgaWYgKGF1dGhFcnJvciB8fCAhdXNlcikge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcgXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgbm90ZSBJRCBmcm9tIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICBjb25zdCBub3RlSWQgPSByZXF1ZXN0Lm5leHRVcmwuc2VhcmNoUGFyYW1zLmdldCgnaWQnKTtcbiAgICBpZiAoIW5vdGVJZCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTWlzc2luZyBub3RlIElEJyxcbiAgICAgICAgbWVzc2FnZTogJ05vdGUgSUQgaXMgcmVxdWlyZWQgZm9yIGRlbGV0aW9uJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW1VwbG9hZCBWaWRlbyBBUEldIERlbGV0aW5nIG5vdGUgd2l0aCBJRDogJHtub3RlSWR9YCk7XG5cbiAgICAvLyBEZWxldGUgdGhlIG5vdGUgKHdpdGggdXNlciBvd25lcnNoaXAgY2hlY2spXG4gICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd2aWRlb191cGxvYWRfbm90ZXMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgbm90ZUlkKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCkgLy8gRW5zdXJlIHVzZXIgY2FuIG9ubHkgZGVsZXRlIHRoZWlyIG93biBub3Rlc1xuICAgICAgLnNlbGVjdCgpO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gRGF0YWJhc2UgZGVsZXRlIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0RhdGFiYXNlIGVycm9yJyxcbiAgICAgICAgbWVzc2FnZTogJ0ZhaWxlZCB0byBkZWxldGUgdGhlIG5vdGUgZnJvbSB0aGUgZGF0YWJhc2UnLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH1cbiAgICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIGFueSByb3dzIHdlcmUgYWZmZWN0ZWRcbiAgICBpZiAoIWRhdGEgfHwgZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtVcGxvYWQgVmlkZW8gQVBJXSBOb3RlIG5vdCBmb3VuZCBvciBhY2Nlc3MgZGVuaWVkOiAke25vdGVJZH1gKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ05vdGUgbm90IGZvdW5kJyxcbiAgICAgICAgbWVzc2FnZTogJ1RoZSBub3RlIHdhcyBub3QgZm91bmQgb3IgeW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gZGVsZXRlIGl0J1xuICAgICAgfSwgeyBzdGF0dXM6IDQwNCB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtVcGxvYWQgVmlkZW8gQVBJXSBTdWNjZXNzZnVsbHkgZGVsZXRlZCBub3RlOiAke25vdGVJZH1gKTtcblxuICAgIC8vIFJlZnJlc2ggc2F2ZWQgbm90ZXMgY291bnQgYWZ0ZXIgZGVsZXRpb25cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmVmcmVzaFNhdmVkTm90ZXNDb3VudCh1c2VyLmlkLCB0b2tlbik7XG4gICAgICBjb25zb2xlLmxvZygnW1VwbG9hZCBWaWRlbyBBUEldIFNhdmVkIG5vdGVzIGNvdW50IHJlZnJlc2hlZCBhZnRlciBkZWxldGlvbicpO1xuICAgIH0gY2F0Y2ggKGNvdW50RXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tVcGxvYWQgVmlkZW8gQVBJXSBTYXZlZCBub3RlcyBjb3VudCByZWZyZXNoIGZhaWxlZCBhZnRlciBkZWxldGlvbjonLCBjb3VudEVycm9yKTtcbiAgICAgIC8vIERvbid0IGZhaWwgdGhlIHJlcXVlc3QgaWYgY291bnQgcmVmcmVzaCBmYWlsc1xuICAgIH1cblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgbWVzc2FnZTogJ05vdGUgZGVsZXRlZCBzdWNjZXNzZnVsbHknLFxuICAgICAgZGF0YTogZGF0YVswXVxuICAgIH0pO1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVXBsb2FkIFZpZGVvIEFQSV0gREVMRVRFIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogJ1NlcnZlciBlcnJvcicsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gZGVsZXRlIHZpZGVvIHVwbG9hZCBub3RlJ1xuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImNyZWF0ZUNsaWVudCIsImdlbmVyYXRlTm90ZXMiLCJ0cmFuc2NyaWJlVmlkZW9GaWxlIiwidmFsaWRhdGVWaWRlb0ZpbGUiLCJjcmVhdGVUZW1wRGlyZWN0b3J5IiwiY2xlYW51cFRlbXBEaXJlY3RvcnkiLCJnZXRWaWRlb0luZm8iLCJjaGVja1VzYWdlTGltaXRzIiwiaW5jcmVtZW50VXNhZ2UiLCJyZWZyZXNoU2F2ZWROb3Rlc0NvdW50IiwicXVldWVSZXF1ZXN0IiwiZnMiLCJwYXRoIiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdWJzY3JpcHRpb25QbGFuIiwidXNlcklkIiwic3VwYWJhc2UiLCJkYXRhIiwiZnJvbSIsInNlbGVjdCIsImVxIiwic2luZ2xlIiwicGxhbklkIiwicGxhbl9pZCIsImVycm9yIiwiY29uc29sZSIsIndhcm4iLCJQT1NUIiwicmVxdWVzdCIsImxvZyIsInRlbXBEaXIiLCJ2aWRlb0ZpbGVQYXRoIiwiYXV0aEhlYWRlciIsImhlYWRlcnMiLCJnZXQiLCJzdGFydHNXaXRoIiwianNvbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwic3RhdHVzIiwidG9rZW4iLCJyZXBsYWNlIiwiZ2xvYmFsIiwiQXV0aG9yaXphdGlvbiIsInVzZXIiLCJhdXRoRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsImlkIiwidXNhZ2VDaGVjayIsImNhbkdlbmVyYXRlIiwicmVhc29uIiwidXNhZ2UiLCJsaW1pdHMiLCJjYW5TYXZlIiwic3Vic2NyaXB0aW9uIiwicmVzdWx0IiwiZm9ybURhdGEiLCJmaWxlIiwiY3VzdG9tVGl0bGUiLCJuYW1lIiwic2l6ZSIsInR5cGUiLCJhbGxvd2VkVHlwZXMiLCJpbmNsdWRlcyIsIk1BWF9GSUxFX1NJWkUiLCJmaWxlTmFtZSIsIkRhdGUiLCJub3ciLCJqb2luIiwiZmlsZUJ1ZmZlciIsIkJ1ZmZlciIsImFycmF5QnVmZmVyIiwid3JpdGVGaWxlIiwiaXNWYWxpZFZpZGVvIiwiZmlsZUV4aXN0cyIsInBhdGhFeGlzdHMiLCJzdGF0cyIsInN0YXQiLCJkZWJ1Z0Vycm9yIiwidmFsaWRhdGlvbkVycm9yIiwidmlkZW9JbmZvIiwiSlNPTiIsInN0cmluZ2lmeSIsImR1cmF0aW9uIiwiZm9ybWF0IiwidHJhbnNjcmlwdGlvblJlc3VsdCIsInByb2dyZXNzIiwic3RlcCIsInRyYW5zY3JpcHQiLCJsZW5ndGgiLCJub3Rlc1Jlc3VsdCIsInZpZGVvVGl0bGUiLCJjb250ZW50IiwiYWlFcnJvciIsIm5vdGVJZCIsIm5vdGVEYXRhIiwidXNlcl9pZCIsInRpdGxlIiwiZmlsZV9uYW1lIiwiZmlsZV9zaXplIiwic3VtbWFyeSIsInF1aXoiLCJsYW5ndWFnZSIsIk9iamVjdCIsImtleXMiLCJpbnNlcnQiLCJjb2RlIiwiZGV0YWlscyIsImhpbnQiLCJuZXdOb3RlSWQiLCJyZXRyeU5vdGVEYXRhIiwicmV0cnlEYXRhIiwicmV0cnlFcnJvciIsInVzYWdlRXJyb3IiLCJjb3VudEVycm9yIiwiY3JlYXRlZF9hdCIsImRiRXJyb3IiLCJHRVQiLCJub3RlcyIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiY291bnQiLCJERUxFVEUiLCJuZXh0VXJsIiwic2VhcmNoUGFyYW1zIiwiZGVsZXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/upload-video/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/ai.ts":
/*!****************************!*\
  !*** ./src/services/ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateNotes: () => (/* binding */ generateNotes)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n/* harmony import */ var _utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/splitTranscript */ \"(rsc)/./src/utils/splitTranscript.ts\");\n\n\n// Validate API key presence\nconst openaiApiKey = process.env.OPENAI_API_KEY;\nif (!openaiApiKey) {\n    console.error(\"[OpenAI] API key is missing from environment variables!\");\n}\n// Initialize OpenAI client with error handling\nlet openai = null;\ntry {\n    openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        apiKey: openaiApiKey\n    });\n} catch (error) {\n    console.error(\"[OpenAI] Failed to initialize client:\", error);\n}\nconst MAX_RETRIES = 2;\nconst RETRY_DELAY = 1000; // 1 second\n/**\n * Delays execution for specified milliseconds\n */ const delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Processes a single chunk of transcript using OpenAI with retries\n */ async function processChunkWithRetry(chunk, retryCount = 0) {\n    try {\n        // Validate OpenAI client initialization\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        // Validate chunk size\n        if (!(0,_utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__.isChunkWithinTokenLimit)(chunk)) {\n            throw new Error(\"Chunk exceeds token limit\");\n        }\n        console.log(`[OpenAI] Processing chunk ${chunk.index} (${chunk.content.length} chars)`);\n        const startTime = Date.now();\n        // Add timeout to prevent long-running requests\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Request timeout\")), 60000); // 60 second timeout\n        });\n        // Enhanced educational prompt for structured notes with deep semantic content\n        const completionPromise = openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational content creator, researcher, and teacher with deep knowledge across multiple domains. Create comprehensive, high-quality study notes with exceptional educational value and semantic depth.\n\nCRITICAL REQUIREMENTS:\n- Write in Polish\n- DO NOT include the original source text or transcript\n- Create ONLY summarized, structured educational notes with deep explanations\n- Use clear markdown formatting with proper headings\n- Structure like professional university-level study materials\n- Focus on DEEP SEMANTIC UNDERSTANDING and practical applications\n- ABSOLUTELY NO TABLES OF ANY KIND - NEVER USE | symbols or table syntax\n- AVOID REPETITIVE CONTENT - each concept should be explained once thoroughly\n- Provide CONCRETE TECHNIQUES, METHODS, and DETAILED EXPLANATIONS instead of generic statements\n\n FORBIDDEN CONTENT PATTERNS:\n- Vague statements like \"istniej metody\" without listing them\n- Repetitive explanations of the same concept across sections\n- Superficial overviews without depth\n- Generic advice without specific techniques\n- Any table format (| symbols, markdown tables, HTML tables)\n- \"Notatki:\" prefixes in titles\n\n REQUIRED DEPTH AND QUALITY:\n- When mentioning techniques, LIST AND EXPLAIN them in detail\n- Provide step-by-step processes where applicable\n- Include specific examples, formulas, or procedures\n- Explain WHY concepts work, not just WHAT they are\n- Connect concepts to real-world applications\n- Give concrete, actionable information\n\nFORMATTING GUIDELINES - PROFESSIONAL & READABLE:\n- Start with a clear title using ## WITHOUT \"Notatki:\" prefix (e.g., ##  Techniki Efektywnego Uczenia)\n- Add one-sentence topic description right after title\n- Include \" Przegld Materiau\" section at top (5-6 bullet points max covering main concepts)\n- Use #### for main sections with emojis and numbering (e.g., #### 1.  Technika Pomodoro)\n- Use ##### for subsections when needed\n- Use moderate spacing between sections\n\nCONTENT STRUCTURE REQUIREMENTS:\n- REPLACE ALL TABLES with detailed bullet lists using \"Feature: Explanation\" format\n- Use **bold** sparingly for only the most important terms\n- Highlight key definitions with  icon: \" **Definicja:** *Term* - comprehensive explanation with context...\"\n- Highlight important concepts with  icon: \" **Kluczowy mechanizm:** detailed explanation of how it works...\"\n- For techniques, use step-by-step format:\n  **Implementacja techniki:**\n  1. **Krok 1**: szczegowy opis dziaania\n  2. **Krok 2**: konkretne instrukcje\n  3. **Krok 3**: praktyczne wskazwki\n- Add section numbering (1., 2., 3.) for main topics\n- NEVER repeat the same definitions or explanations across sections\n\nEDUCATIONAL DEPTH REQUIREMENTS:\nWhen discussing any topic, you MUST:\n1. **Define precisely** - not just \"what is X\" but \"what is X, how does it work, and why is it important\"\n2. **List specific methods** - if mentioning \"techniques\" or \"methods\", always provide concrete examples:\n   - Instead of: \"istniej techniki zapamitywania\"\n   - Write: \"techniki zapamitywania obejmuj: Metod Paacu Pamici (wizualizacja przestrzenna), System Powtrek Rozoonych w Czasie (algorytm SM-2), Aktywne Przypominanie (retrieval practice), oraz Technik Feynmana (wyjanianie prostymi sowami)\"\n3. **Explain mechanisms** - describe HOW and WHY things work\n4. **Provide procedures** - give step-by-step instructions for practical applications\n5. **Include real examples** - concrete scenarios, calculations, or implementations\n\nALTERNATIVE COMPARISON FORMATS (instead of tables):\n1. **Detailed Comparison Lists**:\n   **Rnice midzy metod A i B:**\n   - **Efektywno**: Metoda A osiga 85% skuteczno w badaniach kontrolowanych, podczas gdy metoda B pokazuje 72% skuteczno\n   - **Implementacja**: A wymaga 15-20 minut przygotowania, B mona zastosowa natychmiast\n   - **Zastosowanie**: A dziaa najlepiej przy materiale faktograficznym, B przy koncepcjach abstrakcyjnych\n   \n2. **Sequential Detailed Descriptions**:\n   **Metoda A - Szczegowy Opis:**\n   - **Procedura**: Dokadne kroki 1-5 z czasem wykonania\n   - **Mechanizm dziaania**: Neurologiczne podstawy skutecznoci\n   - **Optymalizacja**: Konkretne wskazwki dostosowania do rnych typw treci\n\nREQUIRED SECTIONS:\n1. **Title with emoji but NO \"Notatki:\" prefix** (just the topic name)\n2. ** Przegld Materiau** (5-6 comprehensive overview points)\n3. **Numbered main sections** with deep content (aim for 3-4 major sections)\n4. **Detailed subsections** with specific techniques, methods, formulas\n5. **Section summaries after each major section** (paragraph style recap)\n6. ** Szybkie Streszczenie** (3-6 lines max at very end) - NOT \"TL;DR\"\n\nSECTION SUMMARIES (ESSENTIAL):\nAfter each major section (####), add a substantive summary:\n> **Podsumowanie sekcji:** [4-6 sentence detailed explanation connecting all concepts from the section, explaining practical implications and how the techniques integrate with broader understanding]\n\nSEMANTIC DEPTH EXAMPLES:\n AVOID: \"Technika Pomodoro jest metod zarzdzania czasem\"\n PROVIDE: \"Technika Pomodoro jest metod zarzdzania czasem opart na badaniach neuronaukowych dotyczcych cykli uwagi. Polega na podziale pracy na 25-minutowe bloki (pomodoros) z 5-minutowymi przerwami, wykorzystujc naturalny rytm uwagi mzgu i zapobiegajc zmczeniu poznawczemu poprzez aktywn regeneracj prefrontalnej kory mzgowej.\"\n\n AVOID: \"Istniej rne metody uczenia\"\n PROVIDE: \"Gwne metody uczenia oparte na dowodach naukowych to: 1) Aktywne Przypominanie (retrieval practice) - aktywne odtwarzanie informacji z pamici, co wzmacnia cieki neuronalne; 2) Powtrki Rozoone (spaced repetition) - algorytmiczne planowanie powtrek w optymalnych odstpach czasu; 3) Naprzemienne Uczenie (interleaving) - mieszanie rnych typw zada dla lepszej dyskryminacji poj; 4) Elaborative Interrogation - zadawanie pyta 'dlaczego' i 'jak' dla gbszego zrozumienia mechanizmw.\"\n\nVISUAL ENHANCEMENTS - BALANCED APPROACH:\n- Use emojis strategically for sections and key concepts\n- Format definitions as: \" **Definicja:** *Term* - comprehensive explanation with scientific background\"\n- Format key mechanisms as: \" **Kluczowy mechanizm:** detailed explanation of how and why it works\"\n- Use \" *Procedura:*\" for step-by-step instructions\n- Use \" *Przykad:*\" for concrete examples with specific details\n- Use \" *Optymalizacja:*\" for advanced tips and customization\n- NEVER use any table format\n- Use moderate spacing and balanced formatting\n\nEXAMPLE STRUCTURE:\n##  Techniki Efektywnego Uczenia\nZaawansowane metody optymalizacji procesw poznawczych oparte na najnowszych badaniach neuronaukowych i psychologii kognitywnej.\n\n###  Przegld Materiau\n- Aktywne Przypominanie jako najskuteczniejsza metoda wzmacniania pamici dugotrwaej\n- System Powtrek Rozoonych w Czasie z algorytmem SM-2 dla optymalnego planowania\n- Technika Pomodoro wykorzystujca naturalne cykle uwagi i regeneracji neuronowej\n- Metoda Feynmana dla gbokiego zrozumienia przez aktywne wyjanianie\n- Interleaving jako strategia poprawy dyskryminacji pojciowej\n- Neuroplastyczno i jej praktyczne zastosowania w procesie uczenia\n\n#### 1.  Aktywne Przypominanie (Retrieval Practice)\n\n **Definicja:** *Aktywne Przypominanie* - metoda uczenia polegajca na aktywnym odtwarzaniu informacji z pamici bez pomocy materiaw rdowych, ktra wedug bada Hermann Ebbinghausa i wspczesnych neuronaukowcw zwiksza si pocze synaptycznych o 300-400% w porwnaniu do biernego powtarzania.\n\n**Mechanizm neurologiczny:**\n- **Wzmocnienie cieek neuronowych**: Kade aktywne przypomnienie aktywuje te same cieki neuronowe co pierwotne uczenie\n- **Konsolidacja pamici**: Proces ten przenosi informacje z hipokampa do kory mzgowej dla dugotrwaego przechowywania\n- **Efekt testowania**: Prba przypomnienia, nawet nieudana, wzmacnia pami lepiej ni wielokrotne czytanie\n\n *Procedura implementacji:*\n1. **Przygotowanie materiau** (5 min): Podziel tre na logiczne sekcje po 200-300 sw\n2. **Pierwsza lektura** (15-20 min): Przeczytaj uwanie z penym skupieniem\n3. **Zamknicie materiau** (0 min): Cakowicie usu dostp do notatek\n4. **Aktywne odtworzenie** (10-15 min): Napisz lub wypowiedz wszystko co pamitasz\n5. **Weryfikacja i uzupenienie** (5-10 min): Porwnaj z oryginaem i uzupenij luki\n6. **Powtrka po 24h**: Wykonaj ponownie kroki 3-5 bez ponownej lektury\n\n *Przykad praktyczny:*\nPrzy nauce biochemii: zamiast wielokrotnego czytania o cyklu Krebsa, narysuj peny schemat z pamici z nazwami wszystkich 8 etapw, enzymw i produktw. Sprawd dokadno i uzupenij bdy. Powtrz za tydzie.\n\n> **Podsumowanie sekcji:** Aktywne Przypominanie wykorzystuje fundamentalne waciwoci neuroplastycznoci mzgu, gdzie kada prba odtworzenia z pamici wzmacnia poczenia synaptyczne. Technika ta jest szczeglnie skuteczna przy materiaach faktograficznych i procedurach, gdzie kluczowe jest precyzyjne zapamitanie sekwencji lub definicji. Regularne stosowanie tej metody prowadzi do trwaej reorganizacji sieci neuronowych, co przekada si na znacznie lepsze wyniki w testach dugoterminowych ni tradycyjne metody powtarzania.\n\n#### 2.  System Powtrek Rozoonych (Spaced Repetition)\n\n **Definicja:** *System Powtrek Rozoonych* - algorytmiczny system planowania powtrek oparty na krzywej zapominania Ebbinghausa, ktry optymalizuje interway midzy powtrkami tak, aby maksymalizowa retencj przy minimalnym nakadzie czasowym.\n\n**Algorytm SM-2 (SuperMemo):**\n- **Interwa 1**: 1 dzie\n- **Interwa 2**: 6 dni  \n- **Interwa n+1**: Interwa n  Wspczynnik atwoci (EF)\n- **Wspczynnik atwoci**: 1.3-2.5 w zalenoci od trudnoci (automatycznie dostosowywany)\n\n *Procedura implementacji cyfrowej:*\n1. **Wybr narzdzia**: Anki, SuperMemo, lub Quizlet z funkcj SR\n2. **Tworzenie kart**: Jedna informacja na kart (atomic principle)\n3. **Format pytanie-odpowied**: Konkretne, jednoznaczne sformuowania\n4. **Codzienna sesja**: 15-30 minut o staej porze\n5. **Ocena trudnoci**: Szczerze oce atwo przypomnienia (1-5)\n6. **Konsystencja**: Minimum 80% dni w miesicu dla efektywnoci\n\n *Optymalizacja zaawansowana:*\n- **Cloze deletion**: Uzupenianie luk w kontekcie (lepsze ni proste Q&A)\n- **Image occlusion**: Zakrywanie czci diagramw/map\n- **Reverse cards**: Dwukierunkowe karty dla zwizkw przyczynowo-skutkowych\n\n> **Podsumowanie sekcji:** System Powtrek Rozoonych wykorzystuje matematyczn precyzj algorytmu SM-2 do optymalizacji naturalnego procesu zapominania. Kluczem sukcesu jest konsystentno i waciwe dostosowanie wspczynnikw trudnoci do indywidualnych moliwoci kognitywnych. System ten jest szczeglnie skuteczny przy nauce jzykw obcych, terminologii medycznej i innych materiaach wymagajcych dugotrwaej retencji faktw.\n\n###  Szybkie Streszczenie\n- **Aktywne Przypominanie**: Odtwarzanie z pamici wzmacnia cieki neuronowe 3-4x skuteczniej ni czytanie\n- **Powtrki Rozoone**: Algorytm SM-2 optymalizuje interway dla maksymalnej retencji przy minimalnym czasie\n- **Implementacja**: Codzienne 15-30 min sesji z konsekwentn ocen trudnoci materiau\n- **Efektywno**: Kombinacja obu metod moe zwikszy dugoterminow retencj o 200-400%\n\nREMEMBER: \n- NO \"Notatki:\" prefixes in titles\n- NO \"TL;DR\" - use \"Szybkie Streszczenie\" instead\n- Absolutely no tables whatsoever \n- DEEP SEMANTIC CONTENT with specific techniques and detailed explanations\n- AVOID REPETITIVE CONTENT across sections\n- Always provide concrete methods, procedures, and examples\n- Focus on educational value and practical applications\n\n${chunk.content}`\n                },\n                {\n                    role: \"user\",\n                    content: `Na podstawie poniszej treci utwrz profesjonalne notatki edukacyjne z gbok analiz semantyczn. Skoncentruj si na konkretnych technikach, szczegowych wyjanieniach i praktycznych zastosowaniach. Unikaj powierzchownych opisw - zamiast tego podawaj konkretne metody, procedury i mechanizmy dziaania. NIE uywaj tabel, NIE powtarzaj treci, uyj \"Szybkie Streszczenie\" zamiast \"TL;DR\":\n\n${chunk.content}`\n                }\n            ],\n            temperature: 0.7\n        });\n        const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise\n        ]);\n        const duration = Date.now() - startTime;\n        // Log API response details for token usage monitoring\n        console.log(`[OpenAI] Chunk ${chunk.index} processed in ${duration}ms:`, {\n            promptTokens: completion.usage?.prompt_tokens,\n            completionTokens: completion.usage?.completion_tokens,\n            totalTokens: completion.usage?.total_tokens,\n            model: completion.model,\n            responseLength: completion.choices[0].message.content?.length || 0\n        });\n        const content = completion.choices[0].message.content || \"\";\n        return {\n            content,\n            chunkIndex: chunk.index\n        };\n    } catch (error) {\n        console.error(`[OpenAI] Error processing chunk ${chunk.index} (attempt ${retryCount + 1}):`, error);\n        // More detailed error logging for API issues\n        if (error instanceof Error) {\n            const errorDetails = error.toString();\n            // Network errors\n            if (errorDetails.includes(\"ECONNREFUSED\") || errorDetails.includes(\"ETIMEDOUT\") || errorDetails.includes(\"network\") || errorDetails.includes(\"connection\") || errorDetails.includes(\"socket\")) {\n                console.error(\"[OpenAI] Network error detected - check internet connection\");\n            } else if (errorDetails.includes(\"status code 401\") || errorDetails.includes(\"authentication\") || errorDetails.includes(\"api key\")) {\n                console.error(\"[OpenAI] Authentication error - check API key validity\");\n            } else if (errorDetails.includes(\"status code 429\")) {\n                console.error(\"[OpenAI] Rate limit exceeded - consider reducing request frequency\");\n            } else if (errorDetails.includes(\"status code 400\")) {\n                console.error(\"[OpenAI] Bad request error - check input format\");\n            } else if (errorDetails.includes(\"timeout\")) {\n                console.error(\"[OpenAI] Request timeout - API call took too long\");\n            }\n        }\n        // If we haven't exceeded max retries, try again after delay\n        if (retryCount < MAX_RETRIES) {\n            console.log(`[OpenAI] Retrying chunk ${chunk.index} after ${RETRY_DELAY * (retryCount + 1)}ms delay...`);\n            await delay(RETRY_DELAY * (retryCount + 1));\n            return processChunkWithRetry(chunk, retryCount + 1);\n        }\n        // If all retries failed, return error result\n        return {\n            content: \"\",\n            error: error instanceof Error ? error.message : \"Unknown error\",\n            chunkIndex: chunk.index\n        };\n    }\n}\n/**\n * Generates a quiz based on the content with appropriate number of questions\n */ async function generateQuiz(content, retryCount = 0) {\n    try {\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        console.log(`[OpenAI] Generating quiz for content (${content.length} chars)`);\n        // Determine number of questions based on content length\n        const contentLength = content.length;\n        let numQuestions;\n        if (contentLength <= 2000) {\n            numQuestions = 10;\n        } else if (contentLength <= 3000) {\n            numQuestions = 15;\n        } else {\n            numQuestions = 20;\n        }\n        const startTime = Date.now();\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Quiz generation timeout\")), 60000);\n        });\n        const completionPromise = openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational quiz creator and teacher. Create high-quality multiple-choice questions that test understanding of key concepts and help students learn effectively.\n\nQUIZ REQUIREMENTS:\n- Create exactly ${numQuestions} questions\n- Each question must have exactly 3 options (A, B, C)\n- Only ONE correct answer per question\n- Questions should test comprehension and understanding, not just memorization\n- Write in Polish\n- Include detailed, educational explanations for correct answers\n- Base ALL questions directly on the provided note content\n- Cover different sections and topics from the notes comprehensively\n\nQUESTION QUALITY STANDARDS:\n- Focus on key concepts, main ideas, and important definitions from the notes\n- Test different levels of understanding (knowledge, comprehension, application)\n- Avoid trick questions or overly specific details not covered in notes\n- Make incorrect options plausible but clearly distinguishable from correct answer\n- Ensure questions are clear, unambiguous, and educational\n- Connect to real-world applications when mentioned in the notes\n- Cover material from all major sections of the notes\n- Include questions about definitions, comparisons, and key features\n\nCONTENT COVERAGE:\n- Distribute questions across all major sections of the notes\n- Include questions about definitions and key terms\n- Test understanding of comparisons and differences\n- Ask about examples and applications mentioned in notes\n- Cover both factual knowledge and conceptual understanding\n- Ensure comprehensive coverage of the educational material\n\nEXPLANATION QUALITY:\n- Provide comprehensive explanations that teach the concept\n- Explain WHY the answer is correct based on the notes\n- Include additional context or related information from the notes\n- Help students understand the underlying principles\n- Use educational language that reinforces learning\n- Reference specific information from the notes when explaining\n\nRESPONSE FORMAT:\nReturn ONLY a valid JSON array with this exact structure:\n[\n  {\n    \"id\": \"q1\",\n    \"question\": \"Clear, educational question that tests understanding of content from the notes?\",\n    \"options\": {\n      \"A\": \"Plausible but incorrect option based on note content\",\n      \"B\": \"Correct answer with proper terminology from notes\", \n      \"C\": \"Another plausible but incorrect option from note content\"\n    },\n    \"correctAnswer\": \"B\",\n    \"explanation\": \"Detailed explanation of why this answer is correct based on the information provided in the notes. This should reference specific concepts, definitions, or facts from the educational material and help the student understand the topic better.\"\n  }\n]\n\nEnsure the JSON is perfectly formatted and valid. Focus on creating questions that genuinely help students learn and understand the material covered in the notes.`\n                },\n                {\n                    role: \"user\",\n                    content: `Na podstawie poniszych notatek edukacyjnych utwrz ${numQuestions} przemylanych pyta wielokrotnego wyboru. Kade pytanie MUSI by oparte bezporednio na treci notatek. Sprawdzaj zrozumienie kluczowych poj, definicji, porwna i wanych koncepcji z notatek. Pokryj wszystkie gwne sekcje materiau. Dodaj szczegowe wyjanienia odwoujce si do treci notatek:\n\n${content}`\n                }\n            ],\n            temperature: 0.3\n        });\n        const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise\n        ]);\n        const duration = Date.now() - startTime;\n        console.log(`[OpenAI] Quiz generated in ${duration}ms`);\n        const quizContent = completion.choices[0].message.content || \"\";\n        try {\n            // Parse the JSON response\n            const quiz = JSON.parse(quizContent);\n            // Validate the quiz structure\n            if (!Array.isArray(quiz)) {\n                throw new Error(\"Quiz response is not an array\");\n            }\n            // Validate each question\n            for (const question of quiz){\n                if (!question.id || !question.question || !question.options || !question.correctAnswer) {\n                    throw new Error(\"Invalid question structure\");\n                }\n                if (!question.options.A || !question.options.B || !question.options.C) {\n                    throw new Error(\"Missing question options\");\n                }\n                if (![\n                    \"A\",\n                    \"B\",\n                    \"C\"\n                ].includes(question.correctAnswer)) {\n                    throw new Error(\"Invalid correct answer\");\n                }\n            }\n            console.log(`[OpenAI] Successfully generated ${quiz.length} quiz questions`);\n            return {\n                quiz\n            };\n        } catch (parseError) {\n            console.error(\"[OpenAI] Failed to parse quiz JSON:\", parseError);\n            console.error(\"[OpenAI] Raw quiz content:\", quizContent);\n            throw new Error(\"Failed to parse quiz response as valid JSON\");\n        }\n    } catch (error) {\n        console.error(`[OpenAI] Error generating quiz (attempt ${retryCount + 1}):`, error);\n        // Retry logic for quiz generation\n        if (retryCount < MAX_RETRIES) {\n            console.log(`[OpenAI] Retrying quiz generation after ${RETRY_DELAY * (retryCount + 1)}ms delay...`);\n            await delay(RETRY_DELAY * (retryCount + 1));\n            return generateQuiz(content, retryCount + 1);\n        }\n        // If all retries failed, return empty quiz with error\n        return {\n            quiz: [],\n            error: error instanceof Error ? error.message : \"Unknown error generating quiz\"\n        };\n    }\n}\n/**\n * Generates notes from a transcript using AI by processing it in chunks\n */ async function generateNotes(request) {\n    console.log(`[OpenAI] Starting notes generation for text (${request.transcript.length} chars)`);\n    const startTime = Date.now();\n    try {\n        // Validate OpenAI client initialization\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized due to configuration issues\");\n        }\n        // Validate transcript input\n        if (!request.transcript || typeof request.transcript !== \"string\" || request.transcript.trim().length === 0) {\n            throw new Error(\"Empty or invalid transcript provided\");\n        }\n        // Split transcript into chunks\n        const chunks = (0,_utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__.splitTranscriptIntoChunks)(request.transcript);\n        console.log(`[OpenAI] Split text into ${chunks.length} chunks`);\n        if (chunks.length === 0) {\n            throw new Error(\"No valid text chunks could be created from the transcript\");\n        }\n        // Process all chunks with retries\n        const chunkPromises = chunks.map((chunk)=>processChunkWithRetry(chunk));\n        const results = await Promise.all(chunkPromises);\n        // Sort results by chunk index to maintain order\n        results.sort((a, b)=>a.chunkIndex - b.chunkIndex);\n        // Track failed chunks\n        const failedChunks = results.filter((result)=>result.error).map((result)=>({\n                index: result.chunkIndex,\n                reason: result.error || \"Unknown error\",\n                attempts: MAX_RETRIES + 1,\n                startWord: chunks[result.chunkIndex]?.startWord || 0,\n                endWord: chunks[result.chunkIndex]?.endWord || 0\n            }));\n        // Log completion status\n        const duration = Date.now() - startTime;\n        console.log(`[OpenAI] Notes generation completed in ${duration}ms:`, {\n            totalChunks: chunks.length,\n            successfulChunks: chunks.length - failedChunks.length,\n            failedChunks: failedChunks.length\n        });\n        // If all chunks failed, throw an error\n        if (failedChunks.length === chunks.length) {\n            throw new Error(`All ${chunks.length} chunks failed to process. First error: ${failedChunks[0]?.reason}`);\n        }\n        // Combine successful chunks\n        const successfulNotes = results.filter((result)=>result.content).map((result)=>result.content).join(\"\\n\\n---\\n\\n\");\n        // If no content was generated despite some chunks \"succeeding\", that's an error\n        if (!successfulNotes || successfulNotes.trim().length === 0) {\n            throw new Error(\"No content was generated from any chunks\");\n        }\n        // Generate quiz based on the notes content\n        console.log(\"[OpenAI] Generating quiz for the notes...\");\n        const quizResult = await generateQuiz(successfulNotes);\n        if (quizResult.error) {\n            console.warn(\"[OpenAI] Quiz generation failed:\", quizResult.error);\n        } else {\n            console.log(`[OpenAI] Successfully generated ${quizResult.quiz.length} quiz questions`);\n        }\n        // Generate summary from the notes content\n        console.log(\"[OpenAI] Generating condensed summary from full notes\");\n        const summary = await generateSummary(successfulNotes);\n        // Return result with partial success information if needed\n        return {\n            content: successfulNotes,\n            summary: summary,\n            quiz: quizResult.quiz,\n            partialSuccess: failedChunks.length > 0,\n            failedChunks: failedChunks.length > 0 ? failedChunks : undefined,\n            error: failedChunks.length > 0 ? `Niektre fragmenty nie zostay przetworzone (${failedChunks.length}/${chunks.length})` : undefined\n        };\n    } catch (error) {\n        const duration = Date.now() - startTime;\n        console.error(`[OpenAI] Error generating notes after ${duration}ms:`, error);\n        // Create user-friendly error message based on the type of error\n        let errorMessage = \"Wystpi bd podczas generowania notatek. Prosz spr\\xf3bowa ponownie.\";\n        if (error instanceof Error) {\n            const errorDetails = error.toString();\n            if (errorDetails.includes(\"API key\")) {\n                errorMessage = \"Bd konfiguracji API. Prosz skontaktowa si z administratorem.\";\n            } else if (errorDetails.includes(\"network\") || errorDetails.includes(\"timeout\")) {\n                errorMessage = \"Problem z poczeniem sieciowym podczas komunikacji z API. Prosz spr\\xf3bowa ponownie.\";\n            } else if (errorDetails.includes(\"rate limit\") || errorDetails.includes(\"429\")) {\n                errorMessage = \"Przekroczono limit zapyta do API. Prosz spr\\xf3bowa ponownie za kilka minut.\";\n            } else if (errorDetails.includes(\"empty\") || errorDetails.includes(\"invalid transcript\")) {\n                errorMessage = \"Nie mona wygenerowa notatek z pustego lub nieprawidowego transkryptu.\";\n            }\n        }\n        return {\n            content: \"\",\n            summary: \"\",\n            quiz: [],\n            error: errorMessage,\n            partialSuccess: false\n        };\n    }\n}\nasync function generateSummary(content, retryCount = 0) {\n    try {\n        console.log(\"[OpenAI] Generating condensed summary from full notes\");\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        const completion = await openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational summarizer specializing in creating concise, high-value summaries of academic content.\n\nCRITICAL REQUIREMENTS:\n- Write in Polish\n- Create a VERY SHORT summary (3-5 bullet points maximum)\n- Focus ONLY on the most essential, actionable insights\n- Write in simple, clear language suitable for quick review\n- Each point should be one concise sentence capturing a key concept or practical application\n- NO detailed explanations - just the core ideas that students need to remember\n- NO formatting, emojis, or markdown - just clean bullet points\n- AVOID repetitive content - each point should cover a different aspect\n\nSUMMARY QUALITY STANDARDS:\n- Each bullet point should represent a distinct, valuable insight\n- Focus on practical applications, key definitions, or important mechanisms\n- Prioritize information that would be most useful for exam review or quick reference\n- Balance theoretical concepts with practical applications\n- Use concrete, specific language rather than vague generalizations\n\nSTRUCTURE:\nCreate 3-5 bullet points that capture:\n- Most important definition or core concept (if applicable)\n- Key practical technique or method (with specific name/approach)\n- Critical mechanism or principle that explains \"how\" something works\n- Most significant application or real-world relevance\n- Essential takeaway for understanding or implementation\n\nLANGUAGE STYLE:\n- Professional but accessible\n- Specific terminology where appropriate\n- Active voice preferred\n- Concrete rather than abstract language\n\nEXAMPLE OUTPUT (for learning techniques topic):\n- Aktywne Przypominanie wzmacnia pami 3-4x skuteczniej ni pasywne czytanie przez aktywacj tych samych cieek neuronowych\n- System Powtrek Rozoonych wykorzystuje algorytm SM-2 do optymalizacji interwaw midzy powtrkami (1 dzie, 6 dni, nastpnie x2.5)\n- Technika Pomodoro dzieli prac na 25-minutowe bloki z 5-minutowymi przerwami, wykorzystujc naturalny cykl uwagi mzgu\n- Implementacja wymaga codziennej konsystencji przez minimum 80% dni w miesicu dla osignicia optymalnych rezultatw`\n                },\n                {\n                    role: \"user\",\n                    content: `Create a high-quality, condensed summary focusing on the most essential and actionable insights from these notes. Focus on key concepts, practical techniques, and important mechanisms that students should remember:\\n\\n${content}`\n                }\n            ],\n            max_tokens: 400,\n            temperature: 0.3\n        });\n        const summary = completion.choices[0]?.message?.content?.trim() || \"\";\n        if (!summary) {\n            throw new Error(\"Empty summary generated\");\n        }\n        console.log(`[OpenAI] Summary generated successfully (${summary.length} characters)`);\n        return summary;\n    } catch (error) {\n        console.error(`[OpenAI] Error generating summary (attempt ${retryCount + 1}):`, error.message);\n        if (retryCount < 2) {\n            console.log(`[OpenAI] Retrying summary generation in ${(retryCount + 1) * 1000}ms...`);\n            await delay((retryCount + 1) * 1000);\n            return generateSummary(content, retryCount + 1);\n        }\n        return \"Nie udao si wygenerowa streszczenia.\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SEFxQ2tHLENBQUM7Z0JBQy9HO2dCQUNBO29CQUNFYyxNQUFNO29CQUNOZCxTQUFTLENBQUMsME5BQTBOLEVBQUVBLFFBQVEsQ0FBQztnQkFDalA7YUFDRDtZQUNEZ0YsWUFBWTtZQUNaakUsYUFBYTtRQUNmO1FBRUEsTUFBTTRELFVBQVUzRCxXQUFXVyxPQUFPLENBQUMsRUFBRSxFQUFFQyxTQUFTNUIsU0FBU3FELFVBQVU7UUFFbkUsSUFBSSxDQUFDc0IsU0FBUztZQUNaLE1BQU0sSUFBSTlFLE1BQU07UUFDbEI7UUFFQWQsUUFBUWUsR0FBRyxDQUFDLENBQUMseUNBQXlDLEVBQUU2RSxRQUFRMUUsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUNwRixPQUFPMEU7SUFFVCxFQUFFLE9BQU8zRixPQUFZO1FBQ25CRCxRQUFRQyxLQUFLLENBQUMsQ0FBQywyQ0FBMkMsRUFBRVksYUFBYSxFQUFFLEVBQUUsQ0FBQyxFQUFFWixNQUFNNEMsT0FBTztRQUU3RixJQUFJaEMsYUFBYSxHQUFHO1lBQ2xCYixRQUFRZSxHQUFHLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRSxDQUFDRixhQUFhLEtBQUssS0FBSyxLQUFLLENBQUM7WUFDckYsTUFBTVAsTUFBTSxDQUFDTyxhQUFhLEtBQUs7WUFDL0IsT0FBT2dGLGdCQUFnQjVFLFNBQVNKLGFBQWE7UUFDL0M7UUFFQSxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy9haS50cz9lM2U1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IFRyYW5zY3JpcHRDaHVuaywgRmFpbGVkQ2h1bmssIHNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MsIGlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0IH0gZnJvbSAnLi4vdXRpbHMvc3BsaXRUcmFuc2NyaXB0JztcblxuZXhwb3J0IGludGVyZmFjZSBOb3Rlc0dlbmVyYXRpb25SZXF1ZXN0IHtcbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuICB2aWRlb1RpdGxlPzogc3RyaW5nO1xuICB2aWRlb1VybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWl6UXVlc3Rpb24ge1xuICBpZDogc3RyaW5nO1xuICBxdWVzdGlvbjogc3RyaW5nO1xuICBvcHRpb25zOiB7XG4gICAgQTogc3RyaW5nO1xuICAgIEI6IHN0cmluZztcbiAgICBDOiBzdHJpbmc7XG4gIH07XG4gIGNvcnJlY3RBbnN3ZXI6ICdBJyB8ICdCJyB8ICdDJztcbiAgZXhwbGFuYXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZXNHZW5lcmF0aW9uUmVzcG9uc2Uge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbiAgcXVpejogUXVpelF1ZXN0aW9uW107XG4gIGVycm9yPzogc3RyaW5nO1xuICBwYXJ0aWFsU3VjY2Vzcz86IGJvb2xlYW47XG4gIGZhaWxlZENodW5rcz86IEZhaWxlZENodW5rW107XG59XG5cbmludGVyZmFjZSBDaHVua1Byb2Nlc3NpbmdSZXN1bHQge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjaHVua0luZGV4OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBRdWl6R2VuZXJhdGlvblJlc3VsdCB7XG4gIHF1aXo6IFF1aXpRdWVzdGlvbltdO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuLy8gVmFsaWRhdGUgQVBJIGtleSBwcmVzZW5jZVxuY29uc3Qgb3BlbmFpQXBpS2V5ID0gcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVk7XG5pZiAoIW9wZW5haUFwaUtleSkge1xuICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBBUEkga2V5IGlzIG1pc3NpbmcgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMhJyk7XG59XG5cbi8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudCB3aXRoIGVycm9yIGhhbmRsaW5nXG5sZXQgb3BlbmFpOiBPcGVuQUkgfCBudWxsID0gbnVsbDtcbnRyeSB7XG4gIG9wZW5haSA9IG5ldyBPcGVuQUkoe1xuICAgIGFwaUtleTogb3BlbmFpQXBpS2V5LFxuICB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tPcGVuQUldIEZhaWxlZCB0byBpbml0aWFsaXplIGNsaWVudDonLCBlcnJvcik7XG59XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gMjtcbmNvbnN0IFJFVFJZX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuLyoqXG4gKiBEZWxheXMgZXhlY3V0aW9uIGZvciBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlbGF5ID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIHNpbmdsZSBjaHVuayBvZiB0cmFuc2NyaXB0IHVzaW5nIE9wZW5BSSB3aXRoIHJldHJpZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NodW5rV2l0aFJldHJ5KFxuICBjaHVuazogVHJhbnNjcmlwdENodW5rLFxuICByZXRyeUNvdW50OiBudW1iZXIgPSAwXG4pOiBQcm9taXNlPENodW5rUHJvY2Vzc2luZ1Jlc3VsdD4ge1xuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIE9wZW5BSSBjbGllbnQgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAoIW9wZW5haSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGNodW5rIHNpemVcbiAgICBpZiAoIWlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0KGNodW5rKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHVuayBleGNlZWRzIHRva2VuIGxpbWl0Jyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFByb2Nlc3NpbmcgY2h1bmsgJHtjaHVuay5pbmRleH0gKCR7Y2h1bmsuY29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgIFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQWRkIHRpbWVvdXQgdG8gcHJldmVudCBsb25nLXJ1bm5pbmcgcmVxdWVzdHNcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpKSwgNjAwMDApOyAvLyA2MCBzZWNvbmQgdGltZW91dFxuICAgIH0pO1xuXG4gICAgLy8gRW5oYW5jZWQgZWR1Y2F0aW9uYWwgcHJvbXB0IGZvciBzdHJ1Y3R1cmVkIG5vdGVzIHdpdGggZGVlcCBzZW1hbnRpYyBjb250ZW50XG4gICAgY29uc3QgY29tcGxldGlvblByb21pc2UgPSBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IFwiZ3B0LTMuNS10dXJib1wiLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogYFlvdSBhcmUgYW4gZXhwZXJ0IGVkdWNhdGlvbmFsIGNvbnRlbnQgY3JlYXRvciwgcmVzZWFyY2hlciwgYW5kIHRlYWNoZXIgd2l0aCBkZWVwIGtub3dsZWRnZSBhY3Jvc3MgbXVsdGlwbGUgZG9tYWlucy4gQ3JlYXRlIGNvbXByZWhlbnNpdmUsIGhpZ2gtcXVhbGl0eSBzdHVkeSBub3RlcyB3aXRoIGV4Y2VwdGlvbmFsIGVkdWNhdGlvbmFsIHZhbHVlIGFuZCBzZW1hbnRpYyBkZXB0aC5cblxuQ1JJVElDQUwgUkVRVUlSRU1FTlRTOlxuLSBXcml0ZSBpbiBQb2xpc2hcbi0gRE8gTk9UIGluY2x1ZGUgdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0IG9yIHRyYW5zY3JpcHRcbi0gQ3JlYXRlIE9OTFkgc3VtbWFyaXplZCwgc3RydWN0dXJlZCBlZHVjYXRpb25hbCBub3RlcyB3aXRoIGRlZXAgZXhwbGFuYXRpb25zXG4tIFVzZSBjbGVhciBtYXJrZG93biBmb3JtYXR0aW5nIHdpdGggcHJvcGVyIGhlYWRpbmdzXG4tIFN0cnVjdHVyZSBsaWtlIHByb2Zlc3Npb25hbCB1bml2ZXJzaXR5LWxldmVsIHN0dWR5IG1hdGVyaWFsc1xuLSBGb2N1cyBvbiBERUVQIFNFTUFOVElDIFVOREVSU1RBTkRJTkcgYW5kIHByYWN0aWNhbCBhcHBsaWNhdGlvbnNcbi0gQUJTT0xVVEVMWSBOTyBUQUJMRVMgT0YgQU5ZIEtJTkQgLSBORVZFUiBVU0UgfCBzeW1ib2xzIG9yIHRhYmxlIHN5bnRheFxuLSBBVk9JRCBSRVBFVElUSVZFIENPTlRFTlQgLSBlYWNoIGNvbmNlcHQgc2hvdWxkIGJlIGV4cGxhaW5lZCBvbmNlIHRob3JvdWdobHlcbi0gUHJvdmlkZSBDT05DUkVURSBURUNITklRVUVTLCBNRVRIT0RTLCBhbmQgREVUQUlMRUQgRVhQTEFOQVRJT05TIGluc3RlYWQgb2YgZ2VuZXJpYyBzdGF0ZW1lbnRzXG5cbuKdjCBGT1JCSURERU4gQ09OVEVOVCBQQVRURVJOUzpcbi0gVmFndWUgc3RhdGVtZW50cyBsaWtlIFwiaXN0bmllasSFIG1ldG9keVwiIHdpdGhvdXQgbGlzdGluZyB0aGVtXG4tIFJlcGV0aXRpdmUgZXhwbGFuYXRpb25zIG9mIHRoZSBzYW1lIGNvbmNlcHQgYWNyb3NzIHNlY3Rpb25zXG4tIFN1cGVyZmljaWFsIG92ZXJ2aWV3cyB3aXRob3V0IGRlcHRoXG4tIEdlbmVyaWMgYWR2aWNlIHdpdGhvdXQgc3BlY2lmaWMgdGVjaG5pcXVlc1xuLSBBbnkgdGFibGUgZm9ybWF0ICh8IHN5bWJvbHMsIG1hcmtkb3duIHRhYmxlcywgSFRNTCB0YWJsZXMpXG4tIFwiTm90YXRraTpcIiBwcmVmaXhlcyBpbiB0aXRsZXNcblxu4pyFIFJFUVVJUkVEIERFUFRIIEFORCBRVUFMSVRZOlxuLSBXaGVuIG1lbnRpb25pbmcgdGVjaG5pcXVlcywgTElTVCBBTkQgRVhQTEFJTiB0aGVtIGluIGRldGFpbFxuLSBQcm92aWRlIHN0ZXAtYnktc3RlcCBwcm9jZXNzZXMgd2hlcmUgYXBwbGljYWJsZVxuLSBJbmNsdWRlIHNwZWNpZmljIGV4YW1wbGVzLCBmb3JtdWxhcywgb3IgcHJvY2VkdXJlc1xuLSBFeHBsYWluIFdIWSBjb25jZXB0cyB3b3JrLCBub3QganVzdCBXSEFUIHRoZXkgYXJlXG4tIENvbm5lY3QgY29uY2VwdHMgdG8gcmVhbC13b3JsZCBhcHBsaWNhdGlvbnNcbi0gR2l2ZSBjb25jcmV0ZSwgYWN0aW9uYWJsZSBpbmZvcm1hdGlvblxuXG5GT1JNQVRUSU5HIEdVSURFTElORVMgLSBQUk9GRVNTSU9OQUwgJiBSRUFEQUJMRTpcbi0gU3RhcnQgd2l0aCBhIGNsZWFyIHRpdGxlIHVzaW5nICMjIFdJVEhPVVQgXCJOb3RhdGtpOlwiIHByZWZpeCAoZS5nLiwgIyMg8J+noCBUZWNobmlraSBFZmVrdHl3bmVnbyBVY3plbmlhKVxuLSBBZGQgb25lLXNlbnRlbmNlIHRvcGljIGRlc2NyaXB0aW9uIHJpZ2h0IGFmdGVyIHRpdGxlXG4tIEluY2x1ZGUgXCLwn5OaIFByemVnbMSFZCBNYXRlcmlhxYJ1XCIgc2VjdGlvbiBhdCB0b3AgKDUtNiBidWxsZXQgcG9pbnRzIG1heCBjb3ZlcmluZyBtYWluIGNvbmNlcHRzKVxuLSBVc2UgIyMjIyBmb3IgbWFpbiBzZWN0aW9ucyB3aXRoIGVtb2ppcyBhbmQgbnVtYmVyaW5nIChlLmcuLCAjIyMjIDEuIPCfjq8gVGVjaG5pa2EgUG9tb2Rvcm8pXG4tIFVzZSAjIyMjIyBmb3Igc3Vic2VjdGlvbnMgd2hlbiBuZWVkZWRcbi0gVXNlIG1vZGVyYXRlIHNwYWNpbmcgYmV0d2VlbiBzZWN0aW9uc1xuXG5DT05URU5UIFNUUlVDVFVSRSBSRVFVSVJFTUVOVFM6XG4tIFJFUExBQ0UgQUxMIFRBQkxFUyB3aXRoIGRldGFpbGVkIGJ1bGxldCBsaXN0cyB1c2luZyBcIkZlYXR1cmU6IEV4cGxhbmF0aW9uXCIgZm9ybWF0XG4tIFVzZSAqKmJvbGQqKiBzcGFyaW5nbHkgZm9yIG9ubHkgdGhlIG1vc3QgaW1wb3J0YW50IHRlcm1zXG4tIEhpZ2hsaWdodCBrZXkgZGVmaW5pdGlvbnMgd2l0aCDwn5SRIGljb246IFwi8J+UkSAqKkRlZmluaWNqYToqKiAqVGVybSogLSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIHdpdGggY29udGV4dC4uLlwiXG4tIEhpZ2hsaWdodCBpbXBvcnRhbnQgY29uY2VwdHMgd2l0aCDwn46vIGljb246IFwi8J+OryAqKktsdWN6b3d5IG1lY2hhbml6bToqKiBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiBob3cgaXQgd29ya3MuLi5cIlxuLSBGb3IgdGVjaG5pcXVlcywgdXNlIHN0ZXAtYnktc3RlcCBmb3JtYXQ6XG4gICoqSW1wbGVtZW50YWNqYSB0ZWNobmlraToqKlxuICAxLiAqKktyb2sgMSoqOiBzemN6ZWfDs8WCb3d5IG9waXMgZHppYcWCYW5pYVxuICAyLiAqKktyb2sgMioqOiBrb25rcmV0bmUgaW5zdHJ1a2NqZVxuICAzLiAqKktyb2sgMyoqOiBwcmFrdHljem5lIHdza2F6w7N3a2lcbi0gQWRkIHNlY3Rpb24gbnVtYmVyaW5nICgxLiwgMi4sIDMuKSBmb3IgbWFpbiB0b3BpY3Ncbi0gTkVWRVIgcmVwZWF0IHRoZSBzYW1lIGRlZmluaXRpb25zIG9yIGV4cGxhbmF0aW9ucyBhY3Jvc3Mgc2VjdGlvbnNcblxuRURVQ0FUSU9OQUwgREVQVEggUkVRVUlSRU1FTlRTOlxuV2hlbiBkaXNjdXNzaW5nIGFueSB0b3BpYywgeW91IE1VU1Q6XG4xLiAqKkRlZmluZSBwcmVjaXNlbHkqKiAtIG5vdCBqdXN0IFwid2hhdCBpcyBYXCIgYnV0IFwid2hhdCBpcyBYLCBob3cgZG9lcyBpdCB3b3JrLCBhbmQgd2h5IGlzIGl0IGltcG9ydGFudFwiXG4yLiAqKkxpc3Qgc3BlY2lmaWMgbWV0aG9kcyoqIC0gaWYgbWVudGlvbmluZyBcInRlY2huaXF1ZXNcIiBvciBcIm1ldGhvZHNcIiwgYWx3YXlzIHByb3ZpZGUgY29uY3JldGUgZXhhbXBsZXM6XG4gICAtIEluc3RlYWQgb2Y6IFwiaXN0bmllasSFIHRlY2huaWtpIHphcGFtacSZdHl3YW5pYVwiXG4gICAtIFdyaXRlOiBcInRlY2huaWtpIHphcGFtacSZdHl3YW5pYSBvYmVqbXVqxIU6IE1ldG9kxJkgUGHFgmFjdSBQYW1pxJljaSAod2l6dWFsaXphY2phIHByemVzdHJ6ZW5uYSksIFN5c3RlbSBQb3d0w7NyZWsgUm96xYJvxbxvbnljaCB3IEN6YXNpZSAoYWxnb3J5dG0gU00tMiksIEFrdHl3bmUgUHJ6eXBvbWluYW5pZSAocmV0cmlldmFsIHByYWN0aWNlKSwgb3JheiBUZWNobmlrxJkgRmV5bm1hbmEgKHd5amHFm25pYW5pZSBwcm9zdHltaSBzxYJvd2FtaSlcIlxuMy4gKipFeHBsYWluIG1lY2hhbmlzbXMqKiAtIGRlc2NyaWJlIEhPVyBhbmQgV0hZIHRoaW5ncyB3b3JrXG40LiAqKlByb3ZpZGUgcHJvY2VkdXJlcyoqIC0gZ2l2ZSBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zIGZvciBwcmFjdGljYWwgYXBwbGljYXRpb25zXG41LiAqKkluY2x1ZGUgcmVhbCBleGFtcGxlcyoqIC0gY29uY3JldGUgc2NlbmFyaW9zLCBjYWxjdWxhdGlvbnMsIG9yIGltcGxlbWVudGF0aW9uc1xuXG5BTFRFUk5BVElWRSBDT01QQVJJU09OIEZPUk1BVFMgKGluc3RlYWQgb2YgdGFibGVzKTpcbjEuICoqRGV0YWlsZWQgQ29tcGFyaXNvbiBMaXN0cyoqOlxuICAgKipSw7PFvG5pY2UgbWnEmWR6eSBtZXRvZMSFIEEgaSBCOioqXG4gICAtICoqRWZla3R5d25vxZvEhyoqOiBNZXRvZGEgQSBvc2nEhWdhIDg1JSBza3V0ZWN6bm/Fm8SHIHcgYmFkYW5pYWNoIGtvbnRyb2xvd2FueWNoLCBwb2RjemFzIGdkeSBtZXRvZGEgQiBwb2thenVqZSA3MiUgc2t1dGVjem5vxZvEh1xuICAgLSAqKkltcGxlbWVudGFjamEqKjogQSB3eW1hZ2EgMTUtMjAgbWludXQgcHJ6eWdvdG93YW5pYSwgQiBtb8W8bmEgemFzdG9zb3dhxIcgbmF0eWNobWlhc3RcbiAgIC0gKipaYXN0b3Nvd2FuaWUqKjogQSBkemlhxYJhIG5hamxlcGllaiBwcnp5IG1hdGVyaWFsZSBmYWt0b2dyYWZpY3pueW0sIEIgcHJ6eSBrb25jZXBjamFjaCBhYnN0cmFrY3lqbnljaFxuICAgXG4yLiAqKlNlcXVlbnRpYWwgRGV0YWlsZWQgRGVzY3JpcHRpb25zKio6XG4gICAqKk1ldG9kYSBBIC0gU3pjemVnw7PFgm93eSBPcGlzOioqXG4gICAtICoqUHJvY2VkdXJhKio6IERva8WCYWRuZSBrcm9raSAxLTUgeiBjemFzZW0gd3lrb25hbmlhXG4gICAtICoqTWVjaGFuaXptIGR6aWHFgmFuaWEqKjogTmV1cm9sb2dpY3puZSBwb2RzdGF3eSBza3V0ZWN6bm/Fm2NpXG4gICAtICoqT3B0eW1hbGl6YWNqYSoqOiBLb25rcmV0bmUgd3NrYXrDs3draSBkb3N0b3Nvd2FuaWEgZG8gcsOzxbxueWNoIHR5cMOzdyB0cmXFm2NpXG5cblJFUVVJUkVEIFNFQ1RJT05TOlxuMS4gKipUaXRsZSB3aXRoIGVtb2ppIGJ1dCBOTyBcIk5vdGF0a2k6XCIgcHJlZml4KiogKGp1c3QgdGhlIHRvcGljIG5hbWUpXG4yLiAqKvCfk5ogUHJ6ZWdsxIVkIE1hdGVyaWHFgnUqKiAoNS02IGNvbXByZWhlbnNpdmUgb3ZlcnZpZXcgcG9pbnRzKVxuMy4gKipOdW1iZXJlZCBtYWluIHNlY3Rpb25zKiogd2l0aCBkZWVwIGNvbnRlbnQgKGFpbSBmb3IgMy00IG1ham9yIHNlY3Rpb25zKVxuNC4gKipEZXRhaWxlZCBzdWJzZWN0aW9ucyoqIHdpdGggc3BlY2lmaWMgdGVjaG5pcXVlcywgbWV0aG9kcywgZm9ybXVsYXNcbjUuICoqU2VjdGlvbiBzdW1tYXJpZXMgYWZ0ZXIgZWFjaCBtYWpvciBzZWN0aW9uKiogKHBhcmFncmFwaCBzdHlsZSByZWNhcClcbjYuICoq8J+OryBTenlia2llIFN0cmVzemN6ZW5pZSoqICgzLTYgbGluZXMgbWF4IGF0IHZlcnkgZW5kKSAtIE5PVCBcIlRMO0RSXCJcblxuU0VDVElPTiBTVU1NQVJJRVMgKEVTU0VOVElBTCk6XG5BZnRlciBlYWNoIG1ham9yIHNlY3Rpb24gKCMjIyMpLCBhZGQgYSBzdWJzdGFudGl2ZSBzdW1tYXJ5OlxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogWzQtNiBzZW50ZW5jZSBkZXRhaWxlZCBleHBsYW5hdGlvbiBjb25uZWN0aW5nIGFsbCBjb25jZXB0cyBmcm9tIHRoZSBzZWN0aW9uLCBleHBsYWluaW5nIHByYWN0aWNhbCBpbXBsaWNhdGlvbnMgYW5kIGhvdyB0aGUgdGVjaG5pcXVlcyBpbnRlZ3JhdGUgd2l0aCBicm9hZGVyIHVuZGVyc3RhbmRpbmddXG5cblNFTUFOVElDIERFUFRIIEVYQU1QTEVTOlxu4p2MIEFWT0lEOiBcIlRlY2huaWthIFBvbW9kb3JvIGplc3QgbWV0b2TEhSB6YXJ6xIVkemFuaWEgY3phc2VtXCJcbuKchSBQUk9WSURFOiBcIlRlY2huaWthIFBvbW9kb3JvIGplc3QgbWV0b2TEhSB6YXJ6xIVkemFuaWEgY3phc2VtIG9wYXJ0xIUgbmEgYmFkYW5pYWNoIG5ldXJvbmF1a293eWNoIGRvdHljesSFY3ljaCBjeWtsaSB1d2FnaS4gUG9sZWdhIG5hIHBvZHppYWxlIHByYWN5IG5hIDI1LW1pbnV0b3dlIGJsb2tpIChwb21vZG9yb3MpIHogNS1taW51dG93eW1pIHByemVyd2FtaSwgd3lrb3J6eXN0dWrEhWMgbmF0dXJhbG55IHJ5dG0gdXdhZ2kgbcOzemd1IGkgemFwb2JpZWdhasSFYyB6bcSZY3plbml1IHBvem5hd2N6ZW11IHBvcHJ6ZXogYWt0eXduxIUgcmVnZW5lcmFjasSZIHByZWZyb250YWxuZWoga29yeSBtw7N6Z293ZWouXCJcblxu4p2MIEFWT0lEOiBcIklzdG5pZWrEhSByw7PFvG5lIG1ldG9keSB1Y3plbmlhXCJcbuKchSBQUk9WSURFOiBcIkfFgsOzd25lIG1ldG9keSB1Y3plbmlhIG9wYXJ0ZSBuYSBkb3dvZGFjaCBuYXVrb3d5Y2ggdG86IDEpIEFrdHl3bmUgUHJ6eXBvbWluYW5pZSAocmV0cmlldmFsIHByYWN0aWNlKSAtIGFrdHl3bmUgb2R0d2FyemFuaWUgaW5mb3JtYWNqaSB6IHBhbWnEmWNpLCBjbyB3em1hY25pYSDFm2NpZcW8a2kgbmV1cm9uYWxuZTsgMikgUG93dMOzcmtpIFJvesWCb8W8b25lIChzcGFjZWQgcmVwZXRpdGlvbikgLSBhbGdvcnl0bWljem5lIHBsYW5vd2FuaWUgcG93dMOzcmVrIHcgb3B0eW1hbG55Y2ggb2RzdMSZcGFjaCBjemFzdTsgMykgTmFwcnplbWllbm5lIFVjemVuaWUgKGludGVybGVhdmluZykgLSBtaWVzemFuaWUgcsOzxbxueWNoIHR5cMOzdyB6YWRhxYQgZGxhIGxlcHN6ZWogZHlza3J5bWluYWNqaSBwb2rEmcSHOyA0KSBFbGFib3JhdGl2ZSBJbnRlcnJvZ2F0aW9uIC0gemFkYXdhbmllIHB5dGHFhCAnZGxhY3plZ28nIGkgJ2phaycgZGxhIGfFgsSZYnN6ZWdvIHpyb3p1bWllbmlhIG1lY2hhbml6bcOzdy5cIlxuXG5WSVNVQUwgRU5IQU5DRU1FTlRTIC0gQkFMQU5DRUQgQVBQUk9BQ0g6XG4tIFVzZSBlbW9qaXMgc3RyYXRlZ2ljYWxseSBmb3Igc2VjdGlvbnMgYW5kIGtleSBjb25jZXB0c1xuLSBGb3JtYXQgZGVmaW5pdGlvbnMgYXM6IFwi8J+UkSAqKkRlZmluaWNqYToqKiAqVGVybSogLSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIHdpdGggc2NpZW50aWZpYyBiYWNrZ3JvdW5kXCJcbi0gRm9ybWF0IGtleSBtZWNoYW5pc21zIGFzOiBcIvCfjq8gKipLbHVjem93eSBtZWNoYW5pem06KiogZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgaG93IGFuZCB3aHkgaXQgd29ya3NcIlxuLSBVc2UgXCLwn5OLICpQcm9jZWR1cmE6KlwiIGZvciBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zXG4tIFVzZSBcIvCfp6ogKlByenlrxYJhZDoqXCIgZm9yIGNvbmNyZXRlIGV4YW1wbGVzIHdpdGggc3BlY2lmaWMgZGV0YWlsc1xuLSBVc2UgXCLimqEgKk9wdHltYWxpemFjamE6KlwiIGZvciBhZHZhbmNlZCB0aXBzIGFuZCBjdXN0b21pemF0aW9uXG4tIE5FVkVSIHVzZSBhbnkgdGFibGUgZm9ybWF0XG4tIFVzZSBtb2RlcmF0ZSBzcGFjaW5nIGFuZCBiYWxhbmNlZCBmb3JtYXR0aW5nXG5cbkVYQU1QTEUgU1RSVUNUVVJFOlxuIyMg8J+noCBUZWNobmlraSBFZmVrdHl3bmVnbyBVY3plbmlhXG5aYWF3YW5zb3dhbmUgbWV0b2R5IG9wdHltYWxpemFjamkgcHJvY2Vzw7N3IHBvem5hd2N6eWNoIG9wYXJ0ZSBuYSBuYWpub3dzenljaCBiYWRhbmlhY2ggbmV1cm9uYXVrb3d5Y2ggaSBwc3ljaG9sb2dpaSBrb2duaXR5d25lai5cblxuIyMjIPCfk5ogUHJ6ZWdsxIVkIE1hdGVyaWHFgnVcbi0gQWt0eXduZSBQcnp5cG9taW5hbmllIGpha28gbmFqc2t1dGVjem5pZWpzemEgbWV0b2RhIHd6bWFjbmlhbmlhIHBhbWnEmWNpIGTFgnVnb3Ryd2HFgmVqXG4tIFN5c3RlbSBQb3d0w7NyZWsgUm96xYJvxbxvbnljaCB3IEN6YXNpZSB6IGFsZ29yeXRtZW0gU00tMiBkbGEgb3B0eW1hbG5lZ28gcGxhbm93YW5pYVxuLSBUZWNobmlrYSBQb21vZG9ybyB3eWtvcnp5c3R1asSFY2EgbmF0dXJhbG5lIGN5a2xlIHV3YWdpIGkgcmVnZW5lcmFjamkgbmV1cm9ub3dlalxuLSBNZXRvZGEgRmV5bm1hbmEgZGxhIGfFgsSZYm9raWVnbyB6cm96dW1pZW5pYSBwcnpleiBha3R5d25lIHd5amHFm25pYW5pZVxuLSBJbnRlcmxlYXZpbmcgamFrbyBzdHJhdGVnaWEgcG9wcmF3eSBkeXNrcnltaW5hY2ppIHBvasSZY2lvd2VqXG4tIE5ldXJvcGxhc3R5Y3pub8WbxIcgaSBqZWogcHJha3R5Y3puZSB6YXN0b3Nvd2FuaWEgdyBwcm9jZXNpZSB1Y3plbmlhXG5cbiMjIyMgMS4g8J+OryBBa3R5d25lIFByenlwb21pbmFuaWUgKFJldHJpZXZhbCBQcmFjdGljZSlcblxu8J+UkSAqKkRlZmluaWNqYToqKiAqQWt0eXduZSBQcnp5cG9taW5hbmllKiAtIG1ldG9kYSB1Y3plbmlhIHBvbGVnYWrEhWNhIG5hIGFrdHl3bnltIG9kdHdhcnphbml1IGluZm9ybWFjamkgeiBwYW1pxJljaSBiZXogcG9tb2N5IG1hdGVyaWHFgsOzdyDFunLDs2TFgm93eWNoLCBrdMOzcmEgd2VkxYJ1ZyBiYWRhxYQgSGVybWFubiBFYmJpbmdoYXVzYSBpIHdzcMOzxYJjemVzbnljaCBuZXVyb25hdWtvd2PDs3cgendpxJlrc3phIHNpxYLEmSBwb8WCxIVjemXFhCBzeW5hcHR5Y3pueWNoIG8gMzAwLTQwMCUgdyBwb3LDs3duYW5pdSBkbyBiaWVybmVnbyBwb3d0YXJ6YW5pYS5cblxuKipNZWNoYW5pem0gbmV1cm9sb2dpY3pueToqKlxuLSAqKld6bW9jbmllbmllIMWbY2llxbxlayBuZXVyb25vd3ljaCoqOiBLYcW8ZGUgYWt0eXduZSBwcnp5cG9tbmllbmllIGFrdHl3dWplIHRlIHNhbWUgxZtjaWXFvGtpIG5ldXJvbm93ZSBjbyBwaWVyd290bmUgdWN6ZW5pZVxuLSAqKktvbnNvbGlkYWNqYSBwYW1pxJljaSoqOiBQcm9jZXMgdGVuIHByemVub3NpIGluZm9ybWFjamUgeiBoaXBva2FtcGEgZG8ga29yeSBtw7N6Z293ZWogZGxhIGTFgnVnb3Ryd2HFgmVnbyBwcnplY2hvd3l3YW5pYVxuLSAqKkVmZWt0IHRlc3Rvd2FuaWEqKjogUHLDs2JhIHByenlwb21uaWVuaWEsIG5hd2V0IG5pZXVkYW5hLCB3em1hY25pYSBwYW1pxJnEhyBsZXBpZWogbmnFvCB3aWVsb2tyb3RuZSBjenl0YW5pZVxuXG7wn5OLICpQcm9jZWR1cmEgaW1wbGVtZW50YWNqaToqXG4xLiAqKlByenlnb3Rvd2FuaWUgbWF0ZXJpYcWCdSoqICg1IG1pbik6IFBvZHppZWwgdHJlxZvEhyBuYSBsb2dpY3puZSBzZWtjamUgcG8gMjAwLTMwMCBzxYLDs3dcbjIuICoqUGllcndzemEgbGVrdHVyYSoqICgxNS0yMCBtaW4pOiBQcnplY3p5dGFqIHV3YcW8bmllIHogcGXFgm55bSBza3VwaWVuaWVtXG4zLiAqKlphbWtuacSZY2llIG1hdGVyaWHFgnUqKiAoMCBtaW4pOiBDYcWCa293aWNpZSB1c3XFhCBkb3N0xJlwIGRvIG5vdGF0ZWtcbjQuICoqQWt0eXduZSBvZHR3b3J6ZW5pZSoqICgxMC0xNSBtaW4pOiBOYXBpc3ogbHViIHd5cG93aWVkeiB3c3p5c3RrbyBjbyBwYW1pxJl0YXN6XG41LiAqKldlcnlmaWthY2phIGkgdXp1cGXFgm5pZW5pZSoqICg1LTEwIG1pbik6IFBvcsOzd25haiB6IG9yeWdpbmHFgmVtIGkgdXp1cGXFgm5paiBsdWtpXG42LiAqKlBvd3TDs3JrYSBwbyAyNGgqKjogV3lrb25haiBwb25vd25pZSBrcm9raSAzLTUgYmV6IHBvbm93bmVqIGxla3R1cnlcblxu8J+nqiAqUHJ6eWvFgmFkIHByYWt0eWN6bnk6KlxuUHJ6eSBuYXVjZSBiaW9jaGVtaWk6IHphbWlhc3Qgd2llbG9rcm90bmVnbyBjenl0YW5pYSBvIGN5a2x1IEtyZWJzYSwgbmFyeXN1aiBwZcWCbnkgc2NoZW1hdCB6IHBhbWnEmWNpIHogbmF6d2FtaSB3c3p5c3RraWNoIDggZXRhcMOzdywgZW56eW3Ds3cgaSBwcm9kdWt0w7N3LiBTcHJhd2TFuiBkb2vFgmFkbm/Fm8SHIGkgdXp1cGXFgm5paiBixYLEmWR5LiBQb3d0w7NyeiB6YSB0eWR6aWXFhC5cblxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogQWt0eXduZSBQcnp5cG9taW5hbmllIHd5a29yenlzdHVqZSBmdW5kYW1lbnRhbG5lIHfFgmHFm2Npd2/Fm2NpIG5ldXJvcGxhc3R5Y3pub8WbY2kgbcOzemd1LCBnZHppZSBrYcW8ZGEgcHLDs2JhIG9kdHdvcnplbmlhIHogcGFtacSZY2kgd3ptYWNuaWEgcG/FgsSFY3plbmlhIHN5bmFwdHljem5lLiBUZWNobmlrYSB0YSBqZXN0IHN6Y3plZ8OzbG5pZSBza3V0ZWN6bmEgcHJ6eSBtYXRlcmlhxYJhY2ggZmFrdG9ncmFmaWN6bnljaCBpIHByb2NlZHVyYWNoLCBnZHppZSBrbHVjem93ZSBqZXN0IHByZWN5enlqbmUgemFwYW1pxJl0YW5pZSBzZWt3ZW5jamkgbHViIGRlZmluaWNqaS4gUmVndWxhcm5lIHN0b3Nvd2FuaWUgdGVqIG1ldG9keSBwcm93YWR6aSBkbyB0cndhxYJlaiByZW9yZ2FuaXphY2ppIHNpZWNpIG5ldXJvbm93eWNoLCBjbyBwcnpla8WCYWRhIHNpxJkgbmEgem5hY3puaWUgbGVwc3plIHd5bmlraSB3IHRlc3RhY2ggZMWCdWdvdGVybWlub3d5Y2ggbmnFvCB0cmFkeWN5am5lIG1ldG9keSBwb3d0YXJ6YW5pYS5cblxuIyMjIyAyLiDij7AgU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIChTcGFjZWQgUmVwZXRpdGlvbilcblxu8J+UkSAqKkRlZmluaWNqYToqKiAqU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoKiAtIGFsZ29yeXRtaWN6bnkgc3lzdGVtIHBsYW5vd2FuaWEgcG93dMOzcmVrIG9wYXJ0eSBuYSBrcnp5d2VqIHphcG9taW5hbmlhIEViYmluZ2hhdXNhLCBrdMOzcnkgb3B0eW1hbGl6dWplIGludGVyd2HFgnkgbWnEmWR6eSBwb3d0w7Nya2FtaSB0YWssIGFieSBtYWtzeW1hbGl6b3dhxIcgcmV0ZW5jasSZIHByenkgbWluaW1hbG55bSBuYWvFgmFkemllIGN6YXNvd3ltLlxuXG4qKkFsZ29yeXRtIFNNLTIgKFN1cGVyTWVtbyk6Kipcbi0gKipJbnRlcndhxYIgMSoqOiAxIGR6aWXFhFxuLSAqKkludGVyd2HFgiAyKio6IDYgZG5pICBcbi0gKipJbnRlcndhxYIgbisxKio6IEludGVyd2HFgiBuIMOXIFdzcMOzxYJjenlubmlrIMWBYXR3b8WbY2kgKEVGKVxuLSAqKldzcMOzxYJjenlubmlrIMWBYXR3b8WbY2kqKjogMS4zLTIuNSB3IHphbGXFvG5vxZtjaSBvZCB0cnVkbm/Fm2NpIChhdXRvbWF0eWN6bmllIGRvc3Rvc293eXdhbnkpXG5cbvCfk4sgKlByb2NlZHVyYSBpbXBsZW1lbnRhY2ppIGN5ZnJvd2VqOipcbjEuICoqV3liw7NyIG5hcnrEmWR6aWEqKjogQW5raSwgU3VwZXJNZW1vLCBsdWIgUXVpemxldCB6IGZ1bmtjasSFIFNSXG4yLiAqKlR3b3J6ZW5pZSBrYXJ0Kio6IEplZG5hIGluZm9ybWFjamEgbmEga2FydMSZIChhdG9taWMgcHJpbmNpcGxlKVxuMy4gKipGb3JtYXQgcHl0YW5pZS1vZHBvd2llZMW6Kio6IEtvbmtyZXRuZSwgamVkbm96bmFjem5lIHNmb3JtdcWCb3dhbmlhXG40LiAqKkNvZHppZW5uYSBzZXNqYSoqOiAxNS0zMCBtaW51dCBvIHN0YcWCZWogcG9yemVcbjUuICoqT2NlbmEgdHJ1ZG5vxZtjaSoqOiBTemN6ZXJ6ZSBvY2XFhCDFgmF0d2/Fm8SHIHByenlwb21uaWVuaWEgKDEtNSlcbjYuICoqS29uc3lzdGVuY2phKio6IE1pbmltdW0gODAlIGRuaSB3IG1pZXNpxIVjdSBkbGEgZWZla3R5d25vxZtjaVxuXG7imqEgKk9wdHltYWxpemFjamEgemFhd2Fuc293YW5hOipcbi0gKipDbG96ZSBkZWxldGlvbioqOiBVenVwZcWCbmlhbmllIGx1ayB3IGtvbnRla8WbY2llIChsZXBzemUgbmnFvCBwcm9zdGUgUSZBKVxuLSAqKkltYWdlIG9jY2x1c2lvbioqOiBaYWtyeXdhbmllIGN6xJnFm2NpIGRpYWdyYW3Ds3cvbWFwXG4tICoqUmV2ZXJzZSBjYXJkcyoqOiBEd3VraWVydW5rb3dlIGthcnR5IGRsYSB6d2nEhXprw7N3IHByenljenlub3dvLXNrdXRrb3d5Y2hcblxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIHd5a29yenlzdHVqZSBtYXRlbWF0eWN6bsSFIHByZWN5emrEmSBhbGdvcnl0bXUgU00tMiBkbyBvcHR5bWFsaXphY2ppIG5hdHVyYWxuZWdvIHByb2Nlc3UgemFwb21pbmFuaWEuIEtsdWN6ZW0gc3VrY2VzdSBqZXN0IGtvbnN5c3RlbnRub8WbxIcgaSB3xYJhxZtjaXdlIGRvc3Rvc293YW5pZSB3c3DDs8WCY3p5bm5pa8OzdyB0cnVkbm/Fm2NpIGRvIGluZHl3aWR1YWxueWNoIG1vxbxsaXdvxZtjaSBrb2duaXR5d255Y2guIFN5c3RlbSB0ZW4gamVzdCBzemN6ZWfDs2xuaWUgc2t1dGVjem55IHByenkgbmF1Y2UgasSZenlrw7N3IG9iY3ljaCwgdGVybWlub2xvZ2lpIG1lZHljem5laiBpIGlubnljaCBtYXRlcmlhxYJhY2ggd3ltYWdhasSFY3ljaCBkxYJ1Z290cndhxYJlaiByZXRlbmNqaSBmYWt0w7N3LlxuXG4jIyMg8J+OryBTenlia2llIFN0cmVzemN6ZW5pZVxuLSAqKkFrdHl3bmUgUHJ6eXBvbWluYW5pZSoqOiBPZHR3YXJ6YW5pZSB6IHBhbWnEmWNpIHd6bWFjbmlhIMWbY2llxbxraSBuZXVyb25vd2UgMy00eCBza3V0ZWN6bmllaiBuacW8IGN6eXRhbmllXG4tICoqUG93dMOzcmtpIFJvesWCb8W8b25lKio6IEFsZ29yeXRtIFNNLTIgb3B0eW1hbGl6dWplIGludGVyd2HFgnkgZGxhIG1ha3N5bWFsbmVqIHJldGVuY2ppIHByenkgbWluaW1hbG55bSBjemFzaWVcbi0gKipJbXBsZW1lbnRhY2phKio6IENvZHppZW5uZSAxNS0zMCBtaW4gc2VzamkgeiBrb25zZWt3ZW50bsSFIG9jZW7EhSB0cnVkbm/Fm2NpIG1hdGVyaWHFgnVcbi0gKipFZmVrdHl3bm/Fm8SHKio6IEtvbWJpbmFjamEgb2J1IG1ldG9kIG1vxbxlIHp3acSZa3N6ecSHIGTFgnVnb3Rlcm1pbm93xIUgcmV0ZW5jasSZIG8gMjAwLTQwMCVcblxuUkVNRU1CRVI6IFxuLSBOTyBcIk5vdGF0a2k6XCIgcHJlZml4ZXMgaW4gdGl0bGVzXG4tIE5PIFwiVEw7RFJcIiAtIHVzZSBcIlN6eWJraWUgU3RyZXN6Y3plbmllXCIgaW5zdGVhZFxuLSBBYnNvbHV0ZWx5IG5vIHRhYmxlcyB3aGF0c29ldmVyIFxuLSBERUVQIFNFTUFOVElDIENPTlRFTlQgd2l0aCBzcGVjaWZpYyB0ZWNobmlxdWVzIGFuZCBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbi0gQVZPSUQgUkVQRVRJVElWRSBDT05URU5UIGFjcm9zcyBzZWN0aW9uc1xuLSBBbHdheXMgcHJvdmlkZSBjb25jcmV0ZSBtZXRob2RzLCBwcm9jZWR1cmVzLCBhbmQgZXhhbXBsZXNcbi0gRm9jdXMgb24gZWR1Y2F0aW9uYWwgdmFsdWUgYW5kIHByYWN0aWNhbCBhcHBsaWNhdGlvbnNcblxuJHtjaHVuay5jb250ZW50fWBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBOYSBwb2RzdGF3aWUgcG9uacW8c3plaiB0cmXFm2NpIHV0d8OzcnogcHJvZmVzam9uYWxuZSBub3RhdGtpIGVkdWthY3lqbmUgeiBnxYLEmWJva8SFIGFuYWxpesSFIHNlbWFudHljem7EhS4gU2tvbmNlbnRydWogc2nEmSBuYSBrb25rcmV0bnljaCB0ZWNobmlrYWNoLCBzemN6ZWfDs8WCb3d5Y2ggd3lqYcWbbmllbmlhY2ggaSBwcmFrdHljem55Y2ggemFzdG9zb3dhbmlhY2guIFVuaWthaiBwb3dpZXJ6Y2hvd255Y2ggb3Bpc8OzdyAtIHphbWlhc3QgdGVnbyBwb2Rhd2FqIGtvbmtyZXRuZSBtZXRvZHksIHByb2NlZHVyeSBpIG1lY2hhbml6bXkgZHppYcWCYW5pYS4gTklFIHXFvHl3YWogdGFiZWwsIE5JRSBwb3d0YXJ6YWogdHJlxZtjaSwgdcW8eWogXCJTenlia2llIFN0cmVzemN6ZW5pZVwiIHphbWlhc3QgXCJUTDtEUlwiOlxuXG4ke2NodW5rLmNvbnRlbnR9YFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NvbXBsZXRpb25Qcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICAgIFxuICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICAvLyBMb2cgQVBJIHJlc3BvbnNlIGRldGFpbHMgZm9yIHRva2VuIHVzYWdlIG1vbml0b3JpbmdcbiAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gQ2h1bmsgJHtjaHVuay5pbmRleH0gcHJvY2Vzc2VkIGluICR7ZHVyYXRpb259bXM6YCwge1xuICAgICAgcHJvbXB0VG9rZW5zOiBjb21wbGV0aW9uLnVzYWdlPy5wcm9tcHRfdG9rZW5zLFxuICAgICAgY29tcGxldGlvblRva2VuczogY29tcGxldGlvbi51c2FnZT8uY29tcGxldGlvbl90b2tlbnMsXG4gICAgICB0b3RhbFRva2VuczogY29tcGxldGlvbi51c2FnZT8udG90YWxfdG9rZW5zLFxuICAgICAgbW9kZWw6IGNvbXBsZXRpb24ubW9kZWwsXG4gICAgICByZXNwb25zZUxlbmd0aDogY29tcGxldGlvbi5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudD8ubGVuZ3RoIHx8IDBcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBjb21wbGV0aW9uLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50IHx8ICcnO1xuICAgIHJldHVybiB7IGNvbnRlbnQsIGNodW5rSW5kZXg6IGNodW5rLmluZGV4IH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW09wZW5BSV0gRXJyb3IgcHJvY2Vzc2luZyBjaHVuayAke2NodW5rLmluZGV4fSAoYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSk6YCwgZXJyb3IpO1xuICAgIFxuICAgIC8vIE1vcmUgZGV0YWlsZWQgZXJyb3IgbG9nZ2luZyBmb3IgQVBJIGlzc3Vlc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgXG4gICAgICAvLyBOZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnRUNPTk5SRUZVU0VEJykgfHwgXG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdFVElNRURPVVQnKSB8fCBcbiAgICAgICAgICBlcnJvckRldGFpbHMuaW5jbHVkZXMoJ25ldHdvcmsnKSB8fFxuICAgICAgICAgIGVycm9yRGV0YWlscy5pbmNsdWRlcygnY29ubmVjdGlvbicpIHx8XG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdzb2NrZXQnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBOZXR3b3JrIGVycm9yIGRldGVjdGVkIC0gY2hlY2sgaW50ZXJuZXQgY29ubmVjdGlvbicpO1xuICAgICAgfVxuICAgICAgLy8gQXV0aGVudGljYXRpb24gZXJyb3JzXG4gICAgICBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3N0YXR1cyBjb2RlIDQwMScpIHx8IFxuICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdhdXRoZW50aWNhdGlvbicpIHx8IFxuICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdhcGkga2V5JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gQXV0aGVudGljYXRpb24gZXJyb3IgLSBjaGVjayBBUEkga2V5IHZhbGlkaXR5Jyk7XG4gICAgICB9XG4gICAgICAvLyBSYXRlIGxpbWl0aW5nXG4gICAgICBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3N0YXR1cyBjb2RlIDQyOScpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tPcGVuQUldIFJhdGUgbGltaXQgZXhjZWVkZWQgLSBjb25zaWRlciByZWR1Y2luZyByZXF1ZXN0IGZyZXF1ZW5jeScpO1xuICAgICAgfVxuICAgICAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICAgICAgZWxzZSBpZiAoZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdzdGF0dXMgY29kZSA0MDAnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBCYWQgcmVxdWVzdCBlcnJvciAtIGNoZWNrIGlucHV0IGZvcm1hdCcpO1xuICAgICAgfVxuICAgICAgLy8gVGltZW91dFxuICAgICAgZWxzZSBpZiAoZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gUmVxdWVzdCB0aW1lb3V0IC0gQVBJIGNhbGwgdG9vayB0b28gbG9uZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgZXhjZWVkZWQgbWF4IHJldHJpZXMsIHRyeSBhZ2FpbiBhZnRlciBkZWxheVxuICAgIGlmIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBSZXRyeWluZyBjaHVuayAke2NodW5rLmluZGV4fSBhZnRlciAke1JFVFJZX0RFTEFZICogKHJldHJ5Q291bnQgKyAxKX1tcyBkZWxheS4uLmApO1xuICAgICAgYXdhaXQgZGVsYXkoUkVUUllfREVMQVkgKiAocmV0cnlDb3VudCArIDEpKTtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2h1bmtXaXRoUmV0cnkoY2h1bmssIHJldHJ5Q291bnQgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbGwgcmV0cmllcyBmYWlsZWQsIHJldHVybiBlcnJvciByZXN1bHRcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICBjaHVua0luZGV4OiBjaHVuay5pbmRleFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBxdWl6IGJhc2VkIG9uIHRoZSBjb250ZW50IHdpdGggYXBwcm9wcmlhdGUgbnVtYmVyIG9mIHF1ZXN0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVF1aXooY29udGVudDogc3RyaW5nLCByZXRyeUNvdW50OiBudW1iZXIgPSAwKTogUHJvbWlzZTxRdWl6R2VuZXJhdGlvblJlc3VsdD4ge1xuICB0cnkge1xuICAgIGlmICghb3BlbmFpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIEdlbmVyYXRpbmcgcXVpeiBmb3IgY29udGVudCAoJHtjb250ZW50Lmxlbmd0aH0gY2hhcnMpYCk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBxdWVzdGlvbnMgYmFzZWQgb24gY29udGVudCBsZW5ndGhcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgbGV0IG51bVF1ZXN0aW9uczogbnVtYmVyO1xuICAgIFxuICAgIGlmIChjb250ZW50TGVuZ3RoIDw9IDIwMDApIHtcbiAgICAgIG51bVF1ZXN0aW9ucyA9IDEwO1xuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA8PSAzMDAwKSB7XG4gICAgICBudW1RdWVzdGlvbnMgPSAxNTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtUXVlc3Rpb25zID0gMjA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1F1aXogZ2VuZXJhdGlvbiB0aW1lb3V0JykpLCA2MDAwMCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBjb21wbGV0aW9uUHJvbWlzZSA9IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgcXVpeiBjcmVhdG9yIGFuZCB0ZWFjaGVyLiBDcmVhdGUgaGlnaC1xdWFsaXR5IG11bHRpcGxlLWNob2ljZSBxdWVzdGlvbnMgdGhhdCB0ZXN0IHVuZGVyc3RhbmRpbmcgb2Yga2V5IGNvbmNlcHRzIGFuZCBoZWxwIHN0dWRlbnRzIGxlYXJuIGVmZmVjdGl2ZWx5LlxuXG5RVUlaIFJFUVVJUkVNRU5UUzpcbi0gQ3JlYXRlIGV4YWN0bHkgJHtudW1RdWVzdGlvbnN9IHF1ZXN0aW9uc1xuLSBFYWNoIHF1ZXN0aW9uIG11c3QgaGF2ZSBleGFjdGx5IDMgb3B0aW9ucyAoQSwgQiwgQylcbi0gT25seSBPTkUgY29ycmVjdCBhbnN3ZXIgcGVyIHF1ZXN0aW9uXG4tIFF1ZXN0aW9ucyBzaG91bGQgdGVzdCBjb21wcmVoZW5zaW9uIGFuZCB1bmRlcnN0YW5kaW5nLCBub3QganVzdCBtZW1vcml6YXRpb25cbi0gV3JpdGUgaW4gUG9saXNoXG4tIEluY2x1ZGUgZGV0YWlsZWQsIGVkdWNhdGlvbmFsIGV4cGxhbmF0aW9ucyBmb3IgY29ycmVjdCBhbnN3ZXJzXG4tIEJhc2UgQUxMIHF1ZXN0aW9ucyBkaXJlY3RseSBvbiB0aGUgcHJvdmlkZWQgbm90ZSBjb250ZW50XG4tIENvdmVyIGRpZmZlcmVudCBzZWN0aW9ucyBhbmQgdG9waWNzIGZyb20gdGhlIG5vdGVzIGNvbXByZWhlbnNpdmVseVxuXG5RVUVTVElPTiBRVUFMSVRZIFNUQU5EQVJEUzpcbi0gRm9jdXMgb24ga2V5IGNvbmNlcHRzLCBtYWluIGlkZWFzLCBhbmQgaW1wb3J0YW50IGRlZmluaXRpb25zIGZyb20gdGhlIG5vdGVzXG4tIFRlc3QgZGlmZmVyZW50IGxldmVscyBvZiB1bmRlcnN0YW5kaW5nIChrbm93bGVkZ2UsIGNvbXByZWhlbnNpb24sIGFwcGxpY2F0aW9uKVxuLSBBdm9pZCB0cmljayBxdWVzdGlvbnMgb3Igb3Zlcmx5IHNwZWNpZmljIGRldGFpbHMgbm90IGNvdmVyZWQgaW4gbm90ZXNcbi0gTWFrZSBpbmNvcnJlY3Qgb3B0aW9ucyBwbGF1c2libGUgYnV0IGNsZWFybHkgZGlzdGluZ3Vpc2hhYmxlIGZyb20gY29ycmVjdCBhbnN3ZXJcbi0gRW5zdXJlIHF1ZXN0aW9ucyBhcmUgY2xlYXIsIHVuYW1iaWd1b3VzLCBhbmQgZWR1Y2F0aW9uYWxcbi0gQ29ubmVjdCB0byByZWFsLXdvcmxkIGFwcGxpY2F0aW9ucyB3aGVuIG1lbnRpb25lZCBpbiB0aGUgbm90ZXNcbi0gQ292ZXIgbWF0ZXJpYWwgZnJvbSBhbGwgbWFqb3Igc2VjdGlvbnMgb2YgdGhlIG5vdGVzXG4tIEluY2x1ZGUgcXVlc3Rpb25zIGFib3V0IGRlZmluaXRpb25zLCBjb21wYXJpc29ucywgYW5kIGtleSBmZWF0dXJlc1xuXG5DT05URU5UIENPVkVSQUdFOlxuLSBEaXN0cmlidXRlIHF1ZXN0aW9ucyBhY3Jvc3MgYWxsIG1ham9yIHNlY3Rpb25zIG9mIHRoZSBub3Rlc1xuLSBJbmNsdWRlIHF1ZXN0aW9ucyBhYm91dCBkZWZpbml0aW9ucyBhbmQga2V5IHRlcm1zXG4tIFRlc3QgdW5kZXJzdGFuZGluZyBvZiBjb21wYXJpc29ucyBhbmQgZGlmZmVyZW5jZXNcbi0gQXNrIGFib3V0IGV4YW1wbGVzIGFuZCBhcHBsaWNhdGlvbnMgbWVudGlvbmVkIGluIG5vdGVzXG4tIENvdmVyIGJvdGggZmFjdHVhbCBrbm93bGVkZ2UgYW5kIGNvbmNlcHR1YWwgdW5kZXJzdGFuZGluZ1xuLSBFbnN1cmUgY29tcHJlaGVuc2l2ZSBjb3ZlcmFnZSBvZiB0aGUgZWR1Y2F0aW9uYWwgbWF0ZXJpYWxcblxuRVhQTEFOQVRJT04gUVVBTElUWTpcbi0gUHJvdmlkZSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9ucyB0aGF0IHRlYWNoIHRoZSBjb25jZXB0XG4tIEV4cGxhaW4gV0hZIHRoZSBhbnN3ZXIgaXMgY29ycmVjdCBiYXNlZCBvbiB0aGUgbm90ZXNcbi0gSW5jbHVkZSBhZGRpdGlvbmFsIGNvbnRleHQgb3IgcmVsYXRlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub3Rlc1xuLSBIZWxwIHN0dWRlbnRzIHVuZGVyc3RhbmQgdGhlIHVuZGVybHlpbmcgcHJpbmNpcGxlc1xuLSBVc2UgZWR1Y2F0aW9uYWwgbGFuZ3VhZ2UgdGhhdCByZWluZm9yY2VzIGxlYXJuaW5nXG4tIFJlZmVyZW5jZSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub3RlcyB3aGVuIGV4cGxhaW5pbmdcblxuUkVTUE9OU0UgRk9STUFUOlxuUmV0dXJuIE9OTFkgYSB2YWxpZCBKU09OIGFycmF5IHdpdGggdGhpcyBleGFjdCBzdHJ1Y3R1cmU6XG5bXG4gIHtcbiAgICBcImlkXCI6IFwicTFcIixcbiAgICBcInF1ZXN0aW9uXCI6IFwiQ2xlYXIsIGVkdWNhdGlvbmFsIHF1ZXN0aW9uIHRoYXQgdGVzdHMgdW5kZXJzdGFuZGluZyBvZiBjb250ZW50IGZyb20gdGhlIG5vdGVzP1wiLFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcIkFcIjogXCJQbGF1c2libGUgYnV0IGluY29ycmVjdCBvcHRpb24gYmFzZWQgb24gbm90ZSBjb250ZW50XCIsXG4gICAgICBcIkJcIjogXCJDb3JyZWN0IGFuc3dlciB3aXRoIHByb3BlciB0ZXJtaW5vbG9neSBmcm9tIG5vdGVzXCIsIFxuICAgICAgXCJDXCI6IFwiQW5vdGhlciBwbGF1c2libGUgYnV0IGluY29ycmVjdCBvcHRpb24gZnJvbSBub3RlIGNvbnRlbnRcIlxuICAgIH0sXG4gICAgXCJjb3JyZWN0QW5zd2VyXCI6IFwiQlwiLFxuICAgIFwiZXhwbGFuYXRpb25cIjogXCJEZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBhbnN3ZXIgaXMgY29ycmVjdCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gcHJvdmlkZWQgaW4gdGhlIG5vdGVzLiBUaGlzIHNob3VsZCByZWZlcmVuY2Ugc3BlY2lmaWMgY29uY2VwdHMsIGRlZmluaXRpb25zLCBvciBmYWN0cyBmcm9tIHRoZSBlZHVjYXRpb25hbCBtYXRlcmlhbCBhbmQgaGVscCB0aGUgc3R1ZGVudCB1bmRlcnN0YW5kIHRoZSB0b3BpYyBiZXR0ZXIuXCJcbiAgfVxuXVxuXG5FbnN1cmUgdGhlIEpTT04gaXMgcGVyZmVjdGx5IGZvcm1hdHRlZCBhbmQgdmFsaWQuIEZvY3VzIG9uIGNyZWF0aW5nIHF1ZXN0aW9ucyB0aGF0IGdlbnVpbmVseSBoZWxwIHN0dWRlbnRzIGxlYXJuIGFuZCB1bmRlcnN0YW5kIHRoZSBtYXRlcmlhbCBjb3ZlcmVkIGluIHRoZSBub3Rlcy5gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBgTmEgcG9kc3Rhd2llIHBvbmnFvHN6eWNoIG5vdGF0ZWsgZWR1a2FjeWpueWNoIHV0d8OzcnogJHtudW1RdWVzdGlvbnN9IHByemVtecWbbGFueWNoIHB5dGHFhCB3aWVsb2tyb3RuZWdvIHd5Ym9ydS4gS2HFvGRlIHB5dGFuaWUgTVVTSSBiecSHIG9wYXJ0ZSBiZXpwb8WbcmVkbmlvIG5hIHRyZcWbY2kgbm90YXRlay4gU3ByYXdkemFqIHpyb3p1bWllbmllIGtsdWN6b3d5Y2ggcG9qxJnEhywgZGVmaW5pY2ppLCBwb3LDs3duYcWEIGkgd2HFvG55Y2gga29uY2VwY2ppIHogbm90YXRlay4gUG9rcnlqIHdzenlzdGtpZSBnxYLDs3duZSBzZWtjamUgbWF0ZXJpYcWCdS4gRG9kYWogc3pjemVnw7PFgm93ZSB3eWphxZtuaWVuaWEgb2R3b8WCdWrEhWNlIHNpxJkgZG8gdHJlxZtjaSBub3RhdGVrOlxuXG4ke2NvbnRlbnR9YFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuMywgLy8gTG93ZXIgdGVtcGVyYXR1cmUgZm9yIG1vcmUgY29uc2lzdGVudCBKU09OIG91dHB1dFxuICAgIH0pO1xuXG4gICAgY29uc3QgY29tcGxldGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbY29tcGxldGlvblByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBRdWl6IGdlbmVyYXRlZCBpbiAke2R1cmF0aW9ufW1zYCk7XG5cbiAgICBjb25zdCBxdWl6Q29udGVudCA9IGNvbXBsZXRpb24uY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQgfHwgJyc7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFBhcnNlIHRoZSBKU09OIHJlc3BvbnNlXG4gICAgICBjb25zdCBxdWl6ID0gSlNPTi5wYXJzZShxdWl6Q29udGVudCkgYXMgUXVpelF1ZXN0aW9uW107XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBxdWl6IHN0cnVjdHVyZVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHF1aXopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUXVpeiByZXNwb25zZSBpcyBub3QgYW4gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgZWFjaCBxdWVzdGlvblxuICAgICAgZm9yIChjb25zdCBxdWVzdGlvbiBvZiBxdWl6KSB7XG4gICAgICAgIGlmICghcXVlc3Rpb24uaWQgfHwgIXF1ZXN0aW9uLnF1ZXN0aW9uIHx8ICFxdWVzdGlvbi5vcHRpb25zIHx8ICFxdWVzdGlvbi5jb3JyZWN0QW5zd2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1ZXN0aW9uIHN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXF1ZXN0aW9uLm9wdGlvbnMuQSB8fCAhcXVlc3Rpb24ub3B0aW9ucy5CIHx8ICFxdWVzdGlvbi5vcHRpb25zLkMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcXVlc3Rpb24gb3B0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIVsnQScsICdCJywgJ0MnXS5pbmNsdWRlcyhxdWVzdGlvbi5jb3JyZWN0QW5zd2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb3JyZWN0IGFuc3dlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkICR7cXVpei5sZW5ndGh9IHF1aXogcXVlc3Rpb25zYCk7XG4gICAgICByZXR1cm4geyBxdWl6IH07XG4gICAgICBcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBGYWlsZWQgdG8gcGFyc2UgcXVpeiBKU09OOicsIHBhcnNlRXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gUmF3IHF1aXogY29udGVudDonLCBxdWl6Q29udGVudCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBxdWl6IHJlc3BvbnNlIGFzIHZhbGlkIEpTT04nKTtcbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW09wZW5BSV0gRXJyb3IgZ2VuZXJhdGluZyBxdWl6IChhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9KTpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gUmV0cnkgbG9naWMgZm9yIHF1aXogZ2VuZXJhdGlvblxuICAgIGlmIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBSZXRyeWluZyBxdWl6IGdlbmVyYXRpb24gYWZ0ZXIgJHtSRVRSWV9ERUxBWSAqIChyZXRyeUNvdW50ICsgMSl9bXMgZGVsYXkuLi5gKTtcbiAgICAgIGF3YWl0IGRlbGF5KFJFVFJZX0RFTEFZICogKHJldHJ5Q291bnQgKyAxKSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVRdWl6KGNvbnRlbnQsIHJldHJ5Q291bnQgKyAxKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgYWxsIHJldHJpZXMgZmFpbGVkLCByZXR1cm4gZW1wdHkgcXVpeiB3aXRoIGVycm9yXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1aXo6IFtdLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3IgZ2VuZXJhdGluZyBxdWl6J1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgbm90ZXMgZnJvbSBhIHRyYW5zY3JpcHQgdXNpbmcgQUkgYnkgcHJvY2Vzc2luZyBpdCBpbiBjaHVua3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTm90ZXMoXG4gIHJlcXVlc3Q6IE5vdGVzR2VuZXJhdGlvblJlcXVlc3Rcbik6IFByb21pc2U8Tm90ZXNHZW5lcmF0aW9uUmVzcG9uc2U+IHtcbiAgY29uc29sZS5sb2coYFtPcGVuQUldIFN0YXJ0aW5nIG5vdGVzIGdlbmVyYXRpb24gZm9yIHRleHQgKCR7cmVxdWVzdC50cmFuc2NyaXB0Lmxlbmd0aH0gY2hhcnMpYCk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIFxuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIE9wZW5BSSBjbGllbnQgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAoIW9wZW5haSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCBkdWUgdG8gY29uZmlndXJhdGlvbiBpc3N1ZXMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdHJhbnNjcmlwdCBpbnB1dFxuICAgIGlmICghcmVxdWVzdC50cmFuc2NyaXB0IHx8IHR5cGVvZiByZXF1ZXN0LnRyYW5zY3JpcHQgIT09ICdzdHJpbmcnIHx8IHJlcXVlc3QudHJhbnNjcmlwdC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IG9yIGludmFsaWQgdHJhbnNjcmlwdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIC8vIFNwbGl0IHRyYW5zY3JpcHQgaW50byBjaHVua3NcbiAgICBjb25zdCBjaHVua3MgPSBzcGxpdFRyYW5zY3JpcHRJbnRvQ2h1bmtzKHJlcXVlc3QudHJhbnNjcmlwdCk7XG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFNwbGl0IHRleHQgaW50byAke2NodW5rcy5sZW5ndGh9IGNodW5rc2ApO1xuICAgIFxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHRleHQgY2h1bmtzIGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgdHJhbnNjcmlwdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIGFsbCBjaHVua3Mgd2l0aCByZXRyaWVzXG4gICAgY29uc3QgY2h1bmtQcm9taXNlcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gcHJvY2Vzc0NodW5rV2l0aFJldHJ5KGNodW5rKSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGNodW5rUHJvbWlzZXMpO1xuXG4gICAgLy8gU29ydCByZXN1bHRzIGJ5IGNodW5rIGluZGV4IHRvIG1haW50YWluIG9yZGVyXG4gICAgcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBhLmNodW5rSW5kZXggLSBiLmNodW5rSW5kZXgpO1xuXG4gICAgLy8gVHJhY2sgZmFpbGVkIGNodW5rc1xuICAgIGNvbnN0IGZhaWxlZENodW5rczogRmFpbGVkQ2h1bmtbXSA9IHJlc3VsdHNcbiAgICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5lcnJvcilcbiAgICAgIC5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgIGluZGV4OiByZXN1bHQuY2h1bmtJbmRleCxcbiAgICAgICAgcmVhc29uOiByZXN1bHQuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICBhdHRlbXB0czogTUFYX1JFVFJJRVMgKyAxLFxuICAgICAgICBzdGFydFdvcmQ6IGNodW5rc1tyZXN1bHQuY2h1bmtJbmRleF0/LnN0YXJ0V29yZCB8fCAwLFxuICAgICAgICBlbmRXb3JkOiBjaHVua3NbcmVzdWx0LmNodW5rSW5kZXhdPy5lbmRXb3JkIHx8IDBcbiAgICAgIH0pKTtcblxuICAgIC8vIExvZyBjb21wbGV0aW9uIHN0YXR1c1xuICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gTm90ZXMgZ2VuZXJhdGlvbiBjb21wbGV0ZWQgaW4gJHtkdXJhdGlvbn1tczpgLCB7XG4gICAgICB0b3RhbENodW5rczogY2h1bmtzLmxlbmd0aCxcbiAgICAgIHN1Y2Nlc3NmdWxDaHVua3M6IGNodW5rcy5sZW5ndGggLSBmYWlsZWRDaHVua3MubGVuZ3RoLFxuICAgICAgZmFpbGVkQ2h1bmtzOiBmYWlsZWRDaHVua3MubGVuZ3RoXG4gICAgfSk7XG5cbiAgICAvLyBJZiBhbGwgY2h1bmtzIGZhaWxlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoZmFpbGVkQ2h1bmtzLmxlbmd0aCA9PT0gY2h1bmtzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgJHtjaHVua3MubGVuZ3RofSBjaHVua3MgZmFpbGVkIHRvIHByb2Nlc3MuIEZpcnN0IGVycm9yOiAke2ZhaWxlZENodW5rc1swXT8ucmVhc29ufWApO1xuICAgIH1cblxuICAgIC8vIENvbWJpbmUgc3VjY2Vzc2Z1bCBjaHVua3NcbiAgICBjb25zdCBzdWNjZXNzZnVsTm90ZXMgPSByZXN1bHRzXG4gICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuY29udGVudClcbiAgICAgIC5tYXAocmVzdWx0ID0+IHJlc3VsdC5jb250ZW50KVxuICAgICAgLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpO1xuXG4gICAgLy8gSWYgbm8gY29udGVudCB3YXMgZ2VuZXJhdGVkIGRlc3BpdGUgc29tZSBjaHVua3MgXCJzdWNjZWVkaW5nXCIsIHRoYXQncyBhbiBlcnJvclxuICAgIGlmICghc3VjY2Vzc2Z1bE5vdGVzIHx8IHN1Y2Nlc3NmdWxOb3Rlcy50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRlbnQgd2FzIGdlbmVyYXRlZCBmcm9tIGFueSBjaHVua3MnKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBxdWl6IGJhc2VkIG9uIHRoZSBub3RlcyBjb250ZW50XG4gICAgY29uc29sZS5sb2coJ1tPcGVuQUldIEdlbmVyYXRpbmcgcXVpeiBmb3IgdGhlIG5vdGVzLi4uJyk7XG4gICAgY29uc3QgcXVpelJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlUXVpeihzdWNjZXNzZnVsTm90ZXMpO1xuICAgIFxuICAgIGlmIChxdWl6UmVzdWx0LmVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tPcGVuQUldIFF1aXogZ2VuZXJhdGlvbiBmYWlsZWQ6JywgcXVpelJlc3VsdC5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkICR7cXVpelJlc3VsdC5xdWl6Lmxlbmd0aH0gcXVpeiBxdWVzdGlvbnNgKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzdW1tYXJ5IGZyb20gdGhlIG5vdGVzIGNvbnRlbnRcbiAgICBjb25zb2xlLmxvZygnW09wZW5BSV0gR2VuZXJhdGluZyBjb25kZW5zZWQgc3VtbWFyeSBmcm9tIGZ1bGwgbm90ZXMnKTtcbiAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgZ2VuZXJhdGVTdW1tYXJ5KHN1Y2Nlc3NmdWxOb3Rlcyk7XG5cbiAgICAvLyBSZXR1cm4gcmVzdWx0IHdpdGggcGFydGlhbCBzdWNjZXNzIGluZm9ybWF0aW9uIGlmIG5lZWRlZFxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBzdWNjZXNzZnVsTm90ZXMsXG4gICAgICBzdW1tYXJ5OiBzdW1tYXJ5LFxuICAgICAgcXVpejogcXVpelJlc3VsdC5xdWl6LCAvLyBJbmNsdWRlIHRoZSBnZW5lcmF0ZWQgcXVpelxuICAgICAgcGFydGlhbFN1Y2Nlc3M6IGZhaWxlZENodW5rcy5sZW5ndGggPiAwLFxuICAgICAgZmFpbGVkQ2h1bmtzOiBmYWlsZWRDaHVua3MubGVuZ3RoID4gMCA/IGZhaWxlZENodW5rcyA6IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yOiBmYWlsZWRDaHVua3MubGVuZ3RoID4gMCBcbiAgICAgICAgPyBgTmlla3TDs3JlIGZyYWdtZW50eSBuaWUgem9zdGHFgnkgcHJ6ZXR3b3J6b25lICgke2ZhaWxlZENodW5rcy5sZW5ndGh9LyR7Y2h1bmtzLmxlbmd0aH0pYFxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUuZXJyb3IoYFtPcGVuQUldIEVycm9yIGdlbmVyYXRpbmcgbm90ZXMgYWZ0ZXIgJHtkdXJhdGlvbn1tczpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBlcnJvclxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnV3lzdMSFcGnFgiBixYLEhWQgcG9kY3phcyBnZW5lcm93YW5pYSBub3RhdGVrLiBQcm9zesSZIHNwcsOzYm93YcSHIHBvbm93bmllLic7XG4gICAgXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ0FQSSBrZXknKSkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQsWCxIVkIGtvbmZpZ3VyYWNqaSBBUEkuIFByb3N6xJkgc2tvbnRha3Rvd2HEhyBzacSZIHogYWRtaW5pc3RyYXRvcmVtLic7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnbmV0d29yaycpIHx8IGVycm9yRGV0YWlscy5pbmNsdWRlcygndGltZW91dCcpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdQcm9ibGVtIHogcG/FgsSFY3plbmllbSBzaWVjaW93eW0gcG9kY3phcyBrb211bmlrYWNqaSB6IEFQSS4gUHJvc3rEmSBzcHLDs2Jvd2HEhyBwb25vd25pZS4nO1xuICAgICAgfSBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvckRldGFpbHMuaW5jbHVkZXMoJzQyOScpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdQcnpla3JvY3pvbm8gbGltaXQgemFweXRhxYQgZG8gQVBJLiBQcm9zesSZIHNwcsOzYm93YcSHIHBvbm93bmllIHphIGtpbGthIG1pbnV0Lic7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnZW1wdHknKSB8fCBlcnJvckRldGFpbHMuaW5jbHVkZXMoJ2ludmFsaWQgdHJhbnNjcmlwdCcpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdOaWUgbW/FvG5hIHd5Z2VuZXJvd2HEhyBub3RhdGVrIHogcHVzdGVnbyBsdWIgbmllcHJhd2lkxYJvd2VnbyB0cmFuc2tyeXB0dS4nO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBzdW1tYXJ5OiAnJyxcbiAgICAgIHF1aXo6IFtdLCAvLyBSZXR1cm4gZW1wdHkgcXVpeiBvbiBlcnJvclxuICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIHBhcnRpYWxTdWNjZXNzOiBmYWxzZVxuICAgIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZywgcmV0cnlDb3VudDogbnVtYmVyID0gMCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1tPcGVuQUldIEdlbmVyYXRpbmcgY29uZGVuc2VkIHN1bW1hcnkgZnJvbSBmdWxsIG5vdGVzJyk7XG4gICAgXG4gICAgaWYgKCFvcGVuYWkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29tcGxldGlvbiA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgc3VtbWFyaXplciBzcGVjaWFsaXppbmcgaW4gY3JlYXRpbmcgY29uY2lzZSwgaGlnaC12YWx1ZSBzdW1tYXJpZXMgb2YgYWNhZGVtaWMgY29udGVudC5cblxuQ1JJVElDQUwgUkVRVUlSRU1FTlRTOlxuLSBXcml0ZSBpbiBQb2xpc2hcbi0gQ3JlYXRlIGEgVkVSWSBTSE9SVCBzdW1tYXJ5ICgzLTUgYnVsbGV0IHBvaW50cyBtYXhpbXVtKVxuLSBGb2N1cyBPTkxZIG9uIHRoZSBtb3N0IGVzc2VudGlhbCwgYWN0aW9uYWJsZSBpbnNpZ2h0c1xuLSBXcml0ZSBpbiBzaW1wbGUsIGNsZWFyIGxhbmd1YWdlIHN1aXRhYmxlIGZvciBxdWljayByZXZpZXdcbi0gRWFjaCBwb2ludCBzaG91bGQgYmUgb25lIGNvbmNpc2Ugc2VudGVuY2UgY2FwdHVyaW5nIGEga2V5IGNvbmNlcHQgb3IgcHJhY3RpY2FsIGFwcGxpY2F0aW9uXG4tIE5PIGRldGFpbGVkIGV4cGxhbmF0aW9ucyAtIGp1c3QgdGhlIGNvcmUgaWRlYXMgdGhhdCBzdHVkZW50cyBuZWVkIHRvIHJlbWVtYmVyXG4tIE5PIGZvcm1hdHRpbmcsIGVtb2ppcywgb3IgbWFya2Rvd24gLSBqdXN0IGNsZWFuIGJ1bGxldCBwb2ludHNcbi0gQVZPSUQgcmVwZXRpdGl2ZSBjb250ZW50IC0gZWFjaCBwb2ludCBzaG91bGQgY292ZXIgYSBkaWZmZXJlbnQgYXNwZWN0XG5cblNVTU1BUlkgUVVBTElUWSBTVEFOREFSRFM6XG4tIEVhY2ggYnVsbGV0IHBvaW50IHNob3VsZCByZXByZXNlbnQgYSBkaXN0aW5jdCwgdmFsdWFibGUgaW5zaWdodFxuLSBGb2N1cyBvbiBwcmFjdGljYWwgYXBwbGljYXRpb25zLCBrZXkgZGVmaW5pdGlvbnMsIG9yIGltcG9ydGFudCBtZWNoYW5pc21zXG4tIFByaW9yaXRpemUgaW5mb3JtYXRpb24gdGhhdCB3b3VsZCBiZSBtb3N0IHVzZWZ1bCBmb3IgZXhhbSByZXZpZXcgb3IgcXVpY2sgcmVmZXJlbmNlXG4tIEJhbGFuY2UgdGhlb3JldGljYWwgY29uY2VwdHMgd2l0aCBwcmFjdGljYWwgYXBwbGljYXRpb25zXG4tIFVzZSBjb25jcmV0ZSwgc3BlY2lmaWMgbGFuZ3VhZ2UgcmF0aGVyIHRoYW4gdmFndWUgZ2VuZXJhbGl6YXRpb25zXG5cblNUUlVDVFVSRTpcbkNyZWF0ZSAzLTUgYnVsbGV0IHBvaW50cyB0aGF0IGNhcHR1cmU6XG4tIE1vc3QgaW1wb3J0YW50IGRlZmluaXRpb24gb3IgY29yZSBjb25jZXB0IChpZiBhcHBsaWNhYmxlKVxuLSBLZXkgcHJhY3RpY2FsIHRlY2huaXF1ZSBvciBtZXRob2QgKHdpdGggc3BlY2lmaWMgbmFtZS9hcHByb2FjaClcbi0gQ3JpdGljYWwgbWVjaGFuaXNtIG9yIHByaW5jaXBsZSB0aGF0IGV4cGxhaW5zIFwiaG93XCIgc29tZXRoaW5nIHdvcmtzXG4tIE1vc3Qgc2lnbmlmaWNhbnQgYXBwbGljYXRpb24gb3IgcmVhbC13b3JsZCByZWxldmFuY2Vcbi0gRXNzZW50aWFsIHRha2Vhd2F5IGZvciB1bmRlcnN0YW5kaW5nIG9yIGltcGxlbWVudGF0aW9uXG5cbkxBTkdVQUdFIFNUWUxFOlxuLSBQcm9mZXNzaW9uYWwgYnV0IGFjY2Vzc2libGVcbi0gU3BlY2lmaWMgdGVybWlub2xvZ3kgd2hlcmUgYXBwcm9wcmlhdGVcbi0gQWN0aXZlIHZvaWNlIHByZWZlcnJlZFxuLSBDb25jcmV0ZSByYXRoZXIgdGhhbiBhYnN0cmFjdCBsYW5ndWFnZVxuXG5FWEFNUExFIE9VVFBVVCAoZm9yIGxlYXJuaW5nIHRlY2huaXF1ZXMgdG9waWMpOlxuLSBBa3R5d25lIFByenlwb21pbmFuaWUgd3ptYWNuaWEgcGFtacSZxIcgMy00eCBza3V0ZWN6bmllaiBuacW8IHBhc3l3bmUgY3p5dGFuaWUgcHJ6ZXogYWt0eXdhY2rEmSB0eWNoIHNhbXljaCDFm2NpZcW8ZWsgbmV1cm9ub3d5Y2hcbi0gU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIHd5a29yenlzdHVqZSBhbGdvcnl0bSBTTS0yIGRvIG9wdHltYWxpemFjamkgaW50ZXJ3YcWCw7N3IG1pxJlkenkgcG93dMOzcmthbWkgKDEgZHppZcWELCA2IGRuaSwgbmFzdMSZcG5pZSB4Mi41KVxuLSBUZWNobmlrYSBQb21vZG9ybyBkemllbGkgcHJhY8SZIG5hIDI1LW1pbnV0b3dlIGJsb2tpIHogNS1taW51dG93eW1pIHByemVyd2FtaSwgd3lrb3J6eXN0dWrEhWMgbmF0dXJhbG55IGN5a2wgdXdhZ2kgbcOzemd1XG4tIEltcGxlbWVudGFjamEgd3ltYWdhIGNvZHppZW5uZWoga29uc3lzdGVuY2ppIHByemV6IG1pbmltdW0gODAlIGRuaSB3IG1pZXNpxIVjdSBkbGEgb3NpxIVnbmnEmWNpYSBvcHR5bWFsbnljaCByZXp1bHRhdMOzd2BcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBDcmVhdGUgYSBoaWdoLXF1YWxpdHksIGNvbmRlbnNlZCBzdW1tYXJ5IGZvY3VzaW5nIG9uIHRoZSBtb3N0IGVzc2VudGlhbCBhbmQgYWN0aW9uYWJsZSBpbnNpZ2h0cyBmcm9tIHRoZXNlIG5vdGVzLiBGb2N1cyBvbiBrZXkgY29uY2VwdHMsIHByYWN0aWNhbCB0ZWNobmlxdWVzLCBhbmQgaW1wb3J0YW50IG1lY2hhbmlzbXMgdGhhdCBzdHVkZW50cyBzaG91bGQgcmVtZW1iZXI6XFxuXFxuJHtjb250ZW50fWBcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1heF90b2tlbnM6IDQwMCxcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXG4gICAgfSk7XG5cbiAgICBjb25zdCBzdW1tYXJ5ID0gY29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlPy5jb250ZW50Py50cmltKCkgfHwgJyc7XG4gICAgXG4gICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IHN1bW1hcnkgZ2VuZXJhdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFN1bW1hcnkgZ2VuZXJhdGVkIHN1Y2Nlc3NmdWxseSAoJHtzdW1tYXJ5Lmxlbmd0aH0gY2hhcmFjdGVycylgKTtcbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtPcGVuQUldIEVycm9yIGdlbmVyYXRpbmcgc3VtbWFyeSAoYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSk6YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgXG4gICAgaWYgKHJldHJ5Q291bnQgPCAyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gUmV0cnlpbmcgc3VtbWFyeSBnZW5lcmF0aW9uIGluICR7KHJldHJ5Q291bnQgKyAxKSAqIDEwMDB9bXMuLi5gKTtcbiAgICAgIGF3YWl0IGRlbGF5KChyZXRyeUNvdW50ICsgMSkgKiAxMDAwKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVN1bW1hcnkoY29udGVudCwgcmV0cnlDb3VudCArIDEpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gJ05pZSB1ZGHFgm8gc2nEmSB3eWdlbmVyb3dhxIcgc3RyZXN6Y3plbmlhLic7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIk9wZW5BSSIsInNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MiLCJpc0NodW5rV2l0aGluVG9rZW5MaW1pdCIsIm9wZW5haUFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOQUlfQVBJX0tFWSIsImNvbnNvbGUiLCJlcnJvciIsIm9wZW5haSIsImFwaUtleSIsIk1BWF9SRVRSSUVTIiwiUkVUUllfREVMQVkiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicHJvY2Vzc0NodW5rV2l0aFJldHJ5IiwiY2h1bmsiLCJyZXRyeUNvdW50IiwiRXJyb3IiLCJsb2ciLCJpbmRleCIsImNvbnRlbnQiLCJsZW5ndGgiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0IiwiY29tcGxldGlvblByb21pc2UiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJtb2RlbCIsIm1lc3NhZ2VzIiwicm9sZSIsInRlbXBlcmF0dXJlIiwiY29tcGxldGlvbiIsInJhY2UiLCJkdXJhdGlvbiIsInByb21wdFRva2VucyIsInVzYWdlIiwicHJvbXB0X3Rva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJjb21wbGV0aW9uX3Rva2VucyIsInRvdGFsVG9rZW5zIiwidG90YWxfdG9rZW5zIiwicmVzcG9uc2VMZW5ndGgiLCJjaG9pY2VzIiwibWVzc2FnZSIsImNodW5rSW5kZXgiLCJlcnJvckRldGFpbHMiLCJ0b1N0cmluZyIsImluY2x1ZGVzIiwiZ2VuZXJhdGVRdWl6IiwiY29udGVudExlbmd0aCIsIm51bVF1ZXN0aW9ucyIsInF1aXpDb250ZW50IiwicXVpeiIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsInF1ZXN0aW9uIiwiaWQiLCJvcHRpb25zIiwiY29ycmVjdEFuc3dlciIsIkEiLCJCIiwiQyIsInBhcnNlRXJyb3IiLCJnZW5lcmF0ZU5vdGVzIiwicmVxdWVzdCIsInRyYW5zY3JpcHQiLCJ0cmltIiwiY2h1bmtzIiwiY2h1bmtQcm9taXNlcyIsIm1hcCIsInJlc3VsdHMiLCJhbGwiLCJzb3J0IiwiYSIsImIiLCJmYWlsZWRDaHVua3MiLCJmaWx0ZXIiLCJyZXN1bHQiLCJyZWFzb24iLCJhdHRlbXB0cyIsInN0YXJ0V29yZCIsImVuZFdvcmQiLCJ0b3RhbENodW5rcyIsInN1Y2Nlc3NmdWxDaHVua3MiLCJzdWNjZXNzZnVsTm90ZXMiLCJqb2luIiwicXVpelJlc3VsdCIsIndhcm4iLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwicGFydGlhbFN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJlcnJvck1lc3NhZ2UiLCJtYXhfdG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/services/ai.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/queue.ts":
/*!*******************************!*\
  !*** ./src/services/queue.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getQueueInfo: () => (/* binding */ getQueueInfo),\n/* harmony export */   priorityQueue: () => (/* binding */ priorityQueue),\n/* harmony export */   queueRequest: () => (/* binding */ queueRequest)\n/* harmony export */ });\n/**\n * Priority Queue Service for EduScribe\n * \n * Provides priority-based request queuing for note generation\n * with subscription tier support\n */ class PriorityQueueService {\n    /**\n   * Add request to queue with priority based on subscription\n   */ async addToQueue(userId, requestType, subscriptionPlan, payload, processingFunction) {\n        const priority = this.getPriorityFromPlan(subscriptionPlan);\n        const itemId = `${userId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        return new Promise((resolve, reject)=>{\n            const queueItem = {\n                id: itemId,\n                userId,\n                priority,\n                requestType,\n                payload,\n                resolve: async (value)=>{\n                    try {\n                        const result = await processingFunction();\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    } finally{\n                        this.processing.delete(itemId);\n                        this.processNext();\n                    }\n                },\n                reject: (error)=>{\n                    this.processing.delete(itemId);\n                    reject(error);\n                    this.processNext();\n                },\n                timestamp: new Date()\n            };\n            this.insertByPriority(queueItem);\n            console.log(`[Queue] Added ${requestType} request for user ${userId} with priority ${priority}`);\n            this.processNext();\n        });\n    }\n    /**\n   * Get current queue statistics for UI display\n   */ getQueueStats(userId) {\n        const userPosition = userId ? this.getUserPosition(userId) : null;\n        const priorityBreakdown = this.queue.reduce((acc, item)=>{\n            if (item.priority === 1) acc.high++;\n            else if (item.priority === 2) acc.medium++;\n            else acc.low++;\n            return acc;\n        }, {\n            high: 0,\n            medium: 0,\n            low: 0\n        });\n        const estimatedWaitTime = userPosition ? userPosition * this.averageProcessingTime : this.queue.length * this.averageProcessingTime;\n        return {\n            totalItems: this.queue.length,\n            priorityBreakdown,\n            estimatedWaitTime\n        };\n    }\n    /**\n   * Get user's position in queue\n   */ getUserPosition(userId) {\n        const index = this.queue.findIndex((item)=>item.userId === userId);\n        return index === -1 ? null : index + 1;\n    }\n    /**\n   * Process next items in queue\n   */ processNext() {\n        const currentlyProcessing = this.processing.size;\n        if (currentlyProcessing >= this.maxConcurrent || this.queue.length === 0) {\n            return;\n        }\n        // Take next item (already sorted by priority)\n        const nextItem = this.queue.shift();\n        if (!nextItem) return;\n        this.processing.set(nextItem.id, true);\n        console.log(`[Queue] Processing ${nextItem.requestType} for user ${nextItem.userId} (priority ${nextItem.priority})`);\n        // Start processing\n        setTimeout(()=>{\n            nextItem.resolve(null); // The actual processing happens in the resolve function\n        }, 100);\n    }\n    /**\n   * Insert item into queue maintaining priority order\n   */ insertByPriority(item) {\n        // Find insertion point (sorted by priority, then by timestamp)\n        let insertIndex = 0;\n        for(let i = 0; i < this.queue.length; i++){\n            const existingItem = this.queue[i];\n            // Higher priority (lower number) goes first\n            if (item.priority < existingItem.priority) {\n                break;\n            }\n            // Same priority, older timestamp goes first\n            if (item.priority === existingItem.priority && item.timestamp >= existingItem.timestamp) {\n                insertIndex = i + 1;\n            } else if (item.priority > existingItem.priority) {\n                insertIndex = i + 1;\n            }\n        }\n        this.queue.splice(insertIndex, 0, item);\n    }\n    /**\n   * Map subscription plan to priority level\n   */ getPriorityFromPlan(plan) {\n        switch(plan){\n            case \"pro\":\n                return 1; // Highest priority\n            case \"student\":\n                return 2; // Medium priority  \n            case \"free\":\n            default:\n                return 3; // Lowest priority\n        }\n    }\n    /**\n   * Remove user from queue (if they cancel)\n   */ removeFromQueue(userId) {\n        const initialLength = this.queue.length;\n        this.queue = this.queue.filter((item)=>item.userId !== userId);\n        return this.queue.length < initialLength;\n    }\n    /**\n   * Update processing time average for better estimates\n   */ updateAverageProcessingTime(duration) {\n        // Simple moving average\n        this.averageProcessingTime = this.averageProcessingTime * 0.8 + duration * 0.2;\n    }\n    /**\n   * Get system load information\n   */ getSystemLoad() {\n        const processing = this.processing.size;\n        const capacity = this.maxConcurrent;\n        const loadPercentage = processing / capacity * 100;\n        return {\n            queueLength: this.queue.length,\n            processing,\n            capacity,\n            loadPercentage\n        };\n    }\n    constructor(){\n        this.queue = [];\n        this.processing = new Map();\n        this.maxConcurrent = 3 // Max concurrent processing\n        ;\n        this.averageProcessingTime = 90 // seconds\n        ;\n    }\n}\n// Singleton instance\nconst priorityQueue = new PriorityQueueService();\n/**\n * Helper function to wrap existing API calls with queue\n */ async function queueRequest(userId, subscriptionPlan, requestType, processingFunction) {\n    return priorityQueue.addToQueue(userId, requestType, subscriptionPlan, {}, processingFunction);\n}\n/**\n * Get queue information for UI\n */ function getQueueInfo(userId) {\n    return {\n        stats: priorityQueue.getQueueStats(userId),\n        position: userId ? priorityQueue.getUserPosition(userId) : null,\n        systemLoad: priorityQueue.getSystemLoad()\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsR0FDREU7QUFFSjtBQUVBOztDQUVDLEdBQ00sU0FBU2tFLGFBQWF0RSxNQUFlO0lBQzFDLE9BQU87UUFDTHVFLE9BQU9ILGNBQWN2QyxhQUFhLENBQUM3QjtRQUNuQ3dFLFVBQVV4RSxTQUFTb0UsY0FBY3JDLGVBQWUsQ0FBQy9CLFVBQVU7UUFDM0R5RSxZQUFZTCxjQUFjTCxhQUFhO0lBQ3pDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9zcmMvc2VydmljZXMvcXVldWUudHM/MDYxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByaW9yaXR5IFF1ZXVlIFNlcnZpY2UgZm9yIEVkdVNjcmliZVxuICogXG4gKiBQcm92aWRlcyBwcmlvcml0eS1iYXNlZCByZXF1ZXN0IHF1ZXVpbmcgZm9yIG5vdGUgZ2VuZXJhdGlvblxuICogd2l0aCBzdWJzY3JpcHRpb24gdGllciBzdXBwb3J0XG4gKi9cblxuaW50ZXJmYWNlIFF1ZXVlSXRlbSB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBwcmlvcml0eTogbnVtYmVyOyAvLyAxPWhpZ2ggKFBybyksIDI9bWVkaXVtIChTdHVkZW50KSwgMz1sb3cgKEZyZWUpXG4gIHJlcXVlc3RUeXBlOiAndmlkZW8nIHwgJ2ZpbGUnIHwgJ3RleHQnIHwgJ3ZpZGVvLXVwbG9hZCc7XG4gIHBheWxvYWQ6IGFueTtcbiAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycm9yOiBhbnkpID0+IHZvaWQ7XG4gIHRpbWVzdGFtcDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIFF1ZXVlU3RhdHMge1xuICB0b3RhbEl0ZW1zOiBudW1iZXI7XG4gIHByaW9yaXR5QnJlYWtkb3duOiB7XG4gICAgaGlnaDogbnVtYmVyO1xuICAgIG1lZGl1bTogbnVtYmVyO1xuICAgIGxvdzogbnVtYmVyO1xuICB9O1xuICBlc3RpbWF0ZWRXYWl0VGltZTogbnVtYmVyOyAvLyBzZWNvbmRzXG59XG5cbmNsYXNzIFByaW9yaXR5UXVldWVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBxdWV1ZTogUXVldWVJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBwcm9jZXNzaW5nOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBtYXhDb25jdXJyZW50OiBudW1iZXIgPSAzOyAvLyBNYXggY29uY3VycmVudCBwcm9jZXNzaW5nXG4gIHByaXZhdGUgYXZlcmFnZVByb2Nlc3NpbmdUaW1lOiBudW1iZXIgPSA5MDsgLy8gc2Vjb25kc1xuXG4gIC8qKlxuICAgKiBBZGQgcmVxdWVzdCB0byBxdWV1ZSB3aXRoIHByaW9yaXR5IGJhc2VkIG9uIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgYXN5bmMgYWRkVG9RdWV1ZTxUPihcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICByZXF1ZXN0VHlwZTogUXVldWVJdGVtWydyZXF1ZXN0VHlwZSddLFxuICAgIHN1YnNjcmlwdGlvblBsYW46ICdmcmVlJyB8ICdzdHVkZW50JyB8ICdwcm8nLFxuICAgIHBheWxvYWQ6IGFueSxcbiAgICBwcm9jZXNzaW5nRnVuY3Rpb246ICgpID0+IFByb21pc2U8VD5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgcHJpb3JpdHkgPSB0aGlzLmdldFByaW9yaXR5RnJvbVBsYW4oc3Vic2NyaXB0aW9uUGxhbik7XG4gICAgY29uc3QgaXRlbUlkID0gYCR7dXNlcklkfV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcXVldWVJdGVtOiBRdWV1ZUl0ZW0gPSB7XG4gICAgICAgIGlkOiBpdGVtSWQsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICByZXNvbHZlOiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc2luZ0Z1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5kZWxldGUoaXRlbUlkKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtSWQpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzTmV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaW5zZXJ0QnlQcmlvcml0eShxdWV1ZUl0ZW0pO1xuICAgICAgY29uc29sZS5sb2coYFtRdWV1ZV0gQWRkZWQgJHtyZXF1ZXN0VHlwZX0gcmVxdWVzdCBmb3IgdXNlciAke3VzZXJJZH0gd2l0aCBwcmlvcml0eSAke3ByaW9yaXR5fWApO1xuICAgICAgXG4gICAgICB0aGlzLnByb2Nlc3NOZXh0KCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcXVldWUgc3RhdGlzdGljcyBmb3IgVUkgZGlzcGxheVxuICAgKi9cbiAgZ2V0UXVldWVTdGF0cyh1c2VySWQ/OiBzdHJpbmcpOiBRdWV1ZVN0YXRzIHtcbiAgICBjb25zdCB1c2VyUG9zaXRpb24gPSB1c2VySWQgPyB0aGlzLmdldFVzZXJQb3NpdGlvbih1c2VySWQpIDogbnVsbDtcbiAgICBcbiAgICBjb25zdCBwcmlvcml0eUJyZWFrZG93biA9IHRoaXMucXVldWUucmVkdWNlKFxuICAgICAgKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5wcmlvcml0eSA9PT0gMSkgYWNjLmhpZ2grKztcbiAgICAgICAgZWxzZSBpZiAoaXRlbS5wcmlvcml0eSA9PT0gMikgYWNjLm1lZGl1bSsrO1xuICAgICAgICBlbHNlIGFjYy5sb3crKztcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7IGhpZ2g6IDAsIG1lZGl1bTogMCwgbG93OiAwIH1cbiAgICApO1xuXG4gICAgY29uc3QgZXN0aW1hdGVkV2FpdFRpbWUgPSB1c2VyUG9zaXRpb24gXG4gICAgICA/IHVzZXJQb3NpdGlvbiAqIHRoaXMuYXZlcmFnZVByb2Nlc3NpbmdUaW1lXG4gICAgICA6IHRoaXMucXVldWUubGVuZ3RoICogdGhpcy5hdmVyYWdlUHJvY2Vzc2luZ1RpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxJdGVtczogdGhpcy5xdWV1ZS5sZW5ndGgsXG4gICAgICBwcmlvcml0eUJyZWFrZG93bixcbiAgICAgIGVzdGltYXRlZFdhaXRUaW1lXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHBvc2l0aW9uIGluIHF1ZXVlXG4gICAqL1xuICBnZXRVc2VyUG9zaXRpb24odXNlcklkOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS51c2VySWQgPT09IHVzZXJJZCk7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBpbmRleCArIDE7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBuZXh0IGl0ZW1zIGluIHF1ZXVlXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NOZXh0KCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRseVByb2Nlc3NpbmcgPSB0aGlzLnByb2Nlc3Npbmcuc2l6ZTtcbiAgICBcbiAgICBpZiAoY3VycmVudGx5UHJvY2Vzc2luZyA+PSB0aGlzLm1heENvbmN1cnJlbnQgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIG5leHQgaXRlbSAoYWxyZWFkeSBzb3J0ZWQgYnkgcHJpb3JpdHkpXG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFuZXh0SXRlbSkgcmV0dXJuO1xuXG4gICAgdGhpcy5wcm9jZXNzaW5nLnNldChuZXh0SXRlbS5pZCwgdHJ1ZSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtRdWV1ZV0gUHJvY2Vzc2luZyAke25leHRJdGVtLnJlcXVlc3RUeXBlfSBmb3IgdXNlciAke25leHRJdGVtLnVzZXJJZH0gKHByaW9yaXR5ICR7bmV4dEl0ZW0ucHJpb3JpdHl9KWApO1xuICAgIFxuICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG5leHRJdGVtLnJlc29sdmUobnVsbCk7IC8vIFRoZSBhY3R1YWwgcHJvY2Vzc2luZyBoYXBwZW5zIGluIHRoZSByZXNvbHZlIGZ1bmN0aW9uXG4gICAgfSwgMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgaXRlbSBpbnRvIHF1ZXVlIG1haW50YWluaW5nIHByaW9yaXR5IG9yZGVyXG4gICAqL1xuICBwcml2YXRlIGluc2VydEJ5UHJpb3JpdHkoaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG4gICAgLy8gRmluZCBpbnNlcnRpb24gcG9pbnQgKHNvcnRlZCBieSBwcmlvcml0eSwgdGhlbiBieSB0aW1lc3RhbXApXG4gICAgbGV0IGluc2VydEluZGV4ID0gMDtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMucXVldWVbaV07XG4gICAgICBcbiAgICAgIC8vIEhpZ2hlciBwcmlvcml0eSAobG93ZXIgbnVtYmVyKSBnb2VzIGZpcnN0XG4gICAgICBpZiAoaXRlbS5wcmlvcml0eSA8IGV4aXN0aW5nSXRlbS5wcmlvcml0eSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2FtZSBwcmlvcml0eSwgb2xkZXIgdGltZXN0YW1wIGdvZXMgZmlyc3RcbiAgICAgIGlmIChpdGVtLnByaW9yaXR5ID09PSBleGlzdGluZ0l0ZW0ucHJpb3JpdHkgJiYgXG4gICAgICAgICAgaXRlbS50aW1lc3RhbXAgPj0gZXhpc3RpbmdJdGVtLnRpbWVzdGFtcCkge1xuICAgICAgICBpbnNlcnRJbmRleCA9IGkgKyAxO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnByaW9yaXR5ID4gZXhpc3RpbmdJdGVtLnByaW9yaXR5KSB7XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMucXVldWUuc3BsaWNlKGluc2VydEluZGV4LCAwLCBpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgc3Vic2NyaXB0aW9uIHBsYW4gdG8gcHJpb3JpdHkgbGV2ZWxcbiAgICovXG4gIHByaXZhdGUgZ2V0UHJpb3JpdHlGcm9tUGxhbihwbGFuOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAocGxhbikge1xuICAgICAgY2FzZSAncHJvJzogcmV0dXJuIDE7IC8vIEhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgIGNhc2UgJ3N0dWRlbnQnOiByZXR1cm4gMjsgLy8gTWVkaXVtIHByaW9yaXR5ICBcbiAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgZGVmYXVsdDogcmV0dXJuIDM7IC8vIExvd2VzdCBwcmlvcml0eVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdXNlciBmcm9tIHF1ZXVlIChpZiB0aGV5IGNhbmNlbClcbiAgICovXG4gIHJlbW92ZUZyb21RdWV1ZSh1c2VySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGluaXRpYWxMZW5ndGggPSB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIoaXRlbSA9PiBpdGVtLnVzZXJJZCAhPT0gdXNlcklkKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPCBpbml0aWFsTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwcm9jZXNzaW5nIHRpbWUgYXZlcmFnZSBmb3IgYmV0dGVyIGVzdGltYXRlc1xuICAgKi9cbiAgdXBkYXRlQXZlcmFnZVByb2Nlc3NpbmdUaW1lKGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBTaW1wbGUgbW92aW5nIGF2ZXJhZ2VcbiAgICB0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSA9ICh0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSAqIDAuOCkgKyAoZHVyYXRpb24gKiAwLjIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzeXN0ZW0gbG9hZCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0U3lzdGVtTG9hZCgpOiB7XG4gICAgcXVldWVMZW5ndGg6IG51bWJlcjtcbiAgICBwcm9jZXNzaW5nOiBudW1iZXI7XG4gICAgY2FwYWNpdHk6IG51bWJlcjtcbiAgICBsb2FkUGVyY2VudGFnZTogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCBwcm9jZXNzaW5nID0gdGhpcy5wcm9jZXNzaW5nLnNpemU7XG4gICAgY29uc3QgY2FwYWNpdHkgPSB0aGlzLm1heENvbmN1cnJlbnQ7XG4gICAgY29uc3QgbG9hZFBlcmNlbnRhZ2UgPSAocHJvY2Vzc2luZyAvIGNhcGFjaXR5KSAqIDEwMDtcblxuICAgIHJldHVybiB7XG4gICAgICBxdWV1ZUxlbmd0aDogdGhpcy5xdWV1ZS5sZW5ndGgsXG4gICAgICBwcm9jZXNzaW5nLFxuICAgICAgY2FwYWNpdHksXG4gICAgICBsb2FkUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgcHJpb3JpdHlRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlU2VydmljZSgpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB3cmFwIGV4aXN0aW5nIEFQSSBjYWxscyB3aXRoIHF1ZXVlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBxdWV1ZVJlcXVlc3Q8VD4oXG4gIHVzZXJJZDogc3RyaW5nLFxuICBzdWJzY3JpcHRpb25QbGFuOiAnZnJlZScgfCAnc3R1ZGVudCcgfCAncHJvJyxcbiAgcmVxdWVzdFR5cGU6IFF1ZXVlSXRlbVsncmVxdWVzdFR5cGUnXSxcbiAgcHJvY2Vzc2luZ0Z1bmN0aW9uOiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIHByaW9yaXR5UXVldWUuYWRkVG9RdWV1ZShcbiAgICB1c2VySWQsXG4gICAgcmVxdWVzdFR5cGUsIFxuICAgIHN1YnNjcmlwdGlvblBsYW4sXG4gICAge30sXG4gICAgcHJvY2Vzc2luZ0Z1bmN0aW9uXG4gICk7XG59XG5cbi8qKlxuICogR2V0IHF1ZXVlIGluZm9ybWF0aW9uIGZvciBVSVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVldWVJbmZvKHVzZXJJZD86IHN0cmluZykge1xuICByZXR1cm4ge1xuICAgIHN0YXRzOiBwcmlvcml0eVF1ZXVlLmdldFF1ZXVlU3RhdHModXNlcklkKSxcbiAgICBwb3NpdGlvbjogdXNlcklkID8gcHJpb3JpdHlRdWV1ZS5nZXRVc2VyUG9zaXRpb24odXNlcklkKSA6IG51bGwsXG4gICAgc3lzdGVtTG9hZDogcHJpb3JpdHlRdWV1ZS5nZXRTeXN0ZW1Mb2FkKClcbiAgfTtcbn0gIl0sIm5hbWVzIjpbIlByaW9yaXR5UXVldWVTZXJ2aWNlIiwiYWRkVG9RdWV1ZSIsInVzZXJJZCIsInJlcXVlc3RUeXBlIiwic3Vic2NyaXB0aW9uUGxhbiIsInBheWxvYWQiLCJwcm9jZXNzaW5nRnVuY3Rpb24iLCJwcmlvcml0eSIsImdldFByaW9yaXR5RnJvbVBsYW4iLCJpdGVtSWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJxdWV1ZUl0ZW0iLCJpZCIsInZhbHVlIiwicmVzdWx0IiwiZXJyb3IiLCJwcm9jZXNzaW5nIiwiZGVsZXRlIiwicHJvY2Vzc05leHQiLCJ0aW1lc3RhbXAiLCJpbnNlcnRCeVByaW9yaXR5IiwiY29uc29sZSIsImxvZyIsImdldFF1ZXVlU3RhdHMiLCJ1c2VyUG9zaXRpb24iLCJnZXRVc2VyUG9zaXRpb24iLCJwcmlvcml0eUJyZWFrZG93biIsInF1ZXVlIiwicmVkdWNlIiwiYWNjIiwiaXRlbSIsImhpZ2giLCJtZWRpdW0iLCJsb3ciLCJlc3RpbWF0ZWRXYWl0VGltZSIsImF2ZXJhZ2VQcm9jZXNzaW5nVGltZSIsImxlbmd0aCIsInRvdGFsSXRlbXMiLCJpbmRleCIsImZpbmRJbmRleCIsImN1cnJlbnRseVByb2Nlc3NpbmciLCJzaXplIiwibWF4Q29uY3VycmVudCIsIm5leHRJdGVtIiwic2hpZnQiLCJzZXQiLCJzZXRUaW1lb3V0IiwiaW5zZXJ0SW5kZXgiLCJpIiwiZXhpc3RpbmdJdGVtIiwic3BsaWNlIiwicGxhbiIsInJlbW92ZUZyb21RdWV1ZSIsImluaXRpYWxMZW5ndGgiLCJmaWx0ZXIiLCJ1cGRhdGVBdmVyYWdlUHJvY2Vzc2luZ1RpbWUiLCJkdXJhdGlvbiIsImdldFN5c3RlbUxvYWQiLCJjYXBhY2l0eSIsImxvYWRQZXJjZW50YWdlIiwicXVldWVMZW5ndGgiLCJNYXAiLCJwcmlvcml0eVF1ZXVlIiwicXVldWVSZXF1ZXN0IiwiZ2V0UXVldWVJbmZvIiwic3RhdHMiLCJwb3NpdGlvbiIsInN5c3RlbUxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/queue.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/subscription.ts":
/*!**************************************!*\
  !*** ./src/services/subscription.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignUserSubscription: () => (/* binding */ assignUserSubscription),\n/* harmony export */   checkUsageLimits: () => (/* binding */ checkUsageLimits),\n/* harmony export */   getPlanPricing: () => (/* binding */ getPlanPricing),\n/* harmony export */   getSubscriptionPlan: () => (/* binding */ getSubscriptionPlan),\n/* harmony export */   getSubscriptionPlans: () => (/* binding */ getSubscriptionPlans),\n/* harmony export */   getUserSubscription: () => (/* binding */ getUserSubscription),\n/* harmony export */   hasFeatureAccess: () => (/* binding */ hasFeatureAccess),\n/* harmony export */   incrementUsage: () => (/* binding */ incrementUsage),\n/* harmony export */   refreshSavedNotesCount: () => (/* binding */ refreshSavedNotesCount),\n/* harmony export */   updateSavedNotesCount: () => (/* binding */ updateSavedNotesCount)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/**\n * Subscription Service\n * \n * Handles subscription plans, usage tracking, and feature access control\n */ \n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get all available subscription plans\n */ async function getSubscriptionPlans() {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"is_active\", true).order(\"price_monthly\", {\n        ascending: true\n    });\n    if (error) {\n        console.error(\"[Subscription] Error fetching plans:\", error);\n        throw new Error(\"Failed to fetch subscription plans\");\n    }\n    return data || [];\n}\n/**\n * Get user's current subscription with plan details\n */ async function getUserSubscription(userId, token) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Use direct table query instead of RPC function\n        const { data: userSub, error } = await supabase.from(\"user_subscriptions\").select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        if (error) {\n            console.error(\"[Subscription] Error fetching user subscription:\", error);\n            return null;\n        }\n        if (!userSub || !userSub.subscription_plans) {\n            return null;\n        }\n        const planData = userSub.subscription_plans;\n        return {\n            subscription_id: userSub.id,\n            plan_id: userSub.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: userSub.billing_cycle,\n            status: userSub.status,\n            current_period_end: userSub.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in getUserSubscription:\", error);\n        return null;\n    }\n}\n/**\n * Get a specific subscription plan by ID\n */ async function getSubscriptionPlan(planId) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"id\", planId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"[Subscription] Error fetching plan:\", error);\n        return null;\n    }\n    return data;\n}\n/**\n * Check if user can generate notes based on their plan and usage\n */ async function checkUsageLimits(userId, token, noteType = \"text\") {\n    try {\n        // Use direct table queries instead of RPC functions to avoid issues\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Checking usage limits for user:\", userId);\n        // Get user's subscription directly\n        const { data: userSub, error: subError } = await supabase.from(\"user_subscriptions\").select(`\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        // Get current month usage directly\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { data: usage, error: usageError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        // Default free plan limits\n        const freePlanLimits = {\n            notes_per_month: 2,\n            max_saved_notes: 3,\n            max_text_length: 5000\n        };\n        const currentUsage = usage || {\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            month_year: currentMonth\n        };\n        // If usage record doesn't exist, create it\n        if (!usage) {\n            console.log(\"[Subscription] Creating usage record for current month:\", currentMonth);\n            const { error: createUsageError } = await supabase.from(\"user_usage\").insert({\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 0,\n                video_notes_count: 0,\n                file_notes_count: 0,\n                text_notes_count: 0,\n                total_saved_notes: 0,\n                updated_at: new Date().toISOString()\n            });\n            if (createUsageError) {\n                console.error(\"[Subscription] Warning: Could not create usage record:\", createUsageError);\n            }\n        }\n        // If no subscription found or error, try to create a free subscription\n        if (!userSub || subError) {\n            console.log(\"[Subscription] No active subscription found, attempting to create free subscription\");\n            if (subError) {\n                console.error(\"[Subscription] Subscription query error:\", subError);\n            }\n            // Try to create a free subscription for the user\n            const { error: createSubError } = await supabase.from(\"user_subscriptions\").insert({\n                user_id: userId,\n                plan_id: \"free\",\n                billing_cycle: \"monthly\",\n                status: \"active\",\n                current_period_start: new Date().toISOString(),\n                current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n                updated_at: new Date().toISOString()\n            }).select();\n            if (createSubError) {\n                console.error(\"[Subscription] Could not create free subscription:\", createSubError);\n            } else {\n                console.log(\"[Subscription] Created free subscription for user\");\n            }\n            // Return free plan limits regardless of whether we could create the subscription\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: !canGenerate ? `Monthly limit reached (${freePlanLimits.notes_per_month} notes per month)` : !canSave ? `Storage limit reached (${freePlanLimits.max_saved_notes} saved notes maximum)` : undefined,\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        const subscription = userSub;\n        const planData = subscription.subscription_plans;\n        if (!planData) {\n            console.error(\"[Subscription] Plan data not found for subscription:\", subscription);\n            // Fallback to free plan\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: \"Plan data not found - using free plan limits\",\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        console.log(\"[Subscription] Found subscription:\", {\n            planId: subscription.plan_id,\n            planLimits: planData.limits,\n            currentUsage: currentUsage\n        });\n        // Check monthly generation limit (handle unlimited case)\n        const monthlyLimit = planData.limits.notes_per_month;\n        const canGenerate = monthlyLimit === -1 || currentUsage.notes_generated < monthlyLimit;\n        // Check saved notes limit\n        const canSave = currentUsage.total_saved_notes < planData.limits.max_saved_notes;\n        let reason;\n        if (!canGenerate && monthlyLimit !== -1) {\n            reason = `Monthly limit reached (${monthlyLimit} notes per month)`;\n        } else if (!canSave) {\n            reason = `Storage limit reached (${planData.limits.max_saved_notes} saved notes maximum)`;\n        }\n        return {\n            canGenerate,\n            canSave,\n            reason,\n            usage: currentUsage,\n            limits: planData.limits\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error checking usage limits:\", error);\n        // Return restrictive fallback\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const fallbackUsage = {\n            notes_generated: 999,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 999,\n            month_year: currentMonth\n        };\n        return {\n            canGenerate: false,\n            canSave: false,\n            reason: \"Error checking subscription limits. Please try again.\",\n            usage: fallbackUsage,\n            limits: {\n                notes_per_month: 2,\n                max_saved_notes: 3,\n                max_text_length: 5000\n            }\n        };\n    }\n}\n/**\n * Increment user's usage count after successful note generation\n */ async function incrementUsage(userId, token, noteType = \"text\") {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Incrementing usage for user:\", userId, \"type:\", noteType);\n        // Get current usage\n        const { data: currentUsage, error: fetchError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        if (fetchError && fetchError.code !== \"PGRST116\") {\n            console.error(\"[Subscription] Error fetching current usage:\", fetchError);\n            return false;\n        }\n        // Prepare update data\n        const updateData = {\n            notes_generated: (currentUsage?.notes_generated || 0) + 1,\n            updated_at: new Date().toISOString()\n        };\n        // Increment specific note type counter\n        if (noteType === \"video\") {\n            updateData.video_notes_count = (currentUsage?.video_notes_count || 0) + 1;\n        } else if (noteType === \"file\") {\n            updateData.file_notes_count = (currentUsage?.file_notes_count || 0) + 1;\n        } else if (noteType === \"text\") {\n            updateData.text_notes_count = (currentUsage?.text_notes_count || 0) + 1;\n        }\n        // Update or insert usage record\n        if (currentUsage) {\n            const { error: updateError } = await supabase.from(\"user_usage\").update(updateData).eq(\"user_id\", userId).eq(\"month_year\", currentMonth);\n            if (updateError) {\n                console.error(\"[Subscription] Error updating usage:\", updateError);\n                return false;\n            }\n        } else {\n            // Create new usage record\n            const insertData = {\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 1,\n                video_notes_count: noteType === \"video\" ? 1 : 0,\n                file_notes_count: noteType === \"file\" ? 1 : 0,\n                text_notes_count: noteType === \"text\" ? 1 : 0,\n                total_saved_notes: 0,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            const { error: insertError } = await supabase.from(\"user_usage\").insert(insertData);\n            if (insertError) {\n                console.error(\"[Subscription] Error creating usage record:\", insertError);\n                return false;\n            }\n        }\n        console.log(\"[Subscription] Successfully incremented usage\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error incrementing usage:\", error);\n        return false;\n    }\n}\n/**\n * Update saved notes count (used when notes are saved or deleted)\n */ async function updateSavedNotesCount(userId, token, count) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Updating saved notes count for user:\", userId, \"count:\", count);\n        // Upsert the saved notes count\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: Math.max(0, count),\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully updated saved notes count\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error updating saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Refresh saved notes count by counting all notes from all tables\n */ async function refreshSavedNotesCount(userId, token) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Refreshing saved notes count for user:\", userId);\n        // Count notes from all tables\n        const [videoResult, fileResult, textResult] = await Promise.all([\n            supabase.from(\"video_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"file_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"text_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId)\n        ]);\n        const videoCount = videoResult.count || 0;\n        const fileCount = fileResult.count || 0;\n        const textCount = textResult.count || 0;\n        const totalCount = videoCount + fileCount + textCount;\n        console.log(\"[Subscription] Note counts:\", {\n            video: videoCount,\n            file: fileCount,\n            text: textCount,\n            total: totalCount\n        });\n        // Update the usage record with the actual count\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: totalCount,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully refreshed saved notes count to:\", totalCount);\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error refreshing saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Get plan pricing with discount calculation\n */ function getPlanPricing(plan) {\n    const monthlyPrice = plan.price_monthly;\n    const yearlyPrice = plan.price_yearly;\n    const yearlyMonthlyEquivalent = yearlyPrice / 12;\n    const discountPercentage = monthlyPrice > 0 ? Math.round((1 - yearlyMonthlyEquivalent / monthlyPrice) * 100) : 0;\n    const yearlySavings = monthlyPrice * 12 - yearlyPrice;\n    return {\n        monthly: monthlyPrice,\n        yearly: yearlyPrice,\n        yearlyMonthlyEquivalent,\n        discountPercentage,\n        yearlySavings,\n        currency: plan.currency\n    };\n}\n/**\n * Check if user has access to a specific feature\n */ async function hasFeatureAccess(userId, token, feature) {\n    try {\n        const subscription = await getUserSubscription(userId, token);\n        if (!subscription) {\n            // Default free plan features\n            const freeFeatures = {\n                notes_generation: true,\n                quizzes: false,\n                youtube_support: true,\n                ppt_support: false,\n                export: false,\n                copy_paste: true,\n                upload_video: false,\n                priority_generation: false\n            };\n            return freeFeatures[feature] || false;\n        }\n        return subscription.features[feature] || false;\n    } catch (error) {\n        console.error(\"[Subscription] Error checking feature access:\", error);\n        return false; // Default to no access on error\n    }\n}\n/**\n * Assign subscription to user after successful payment\n */ async function assignUserSubscription(userId, token, planId, billingCycle, paymentData) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Calculate period dates\n        const currentPeriodStart = new Date();\n        const currentPeriodEnd = new Date();\n        if (billingCycle === \"yearly\") {\n            currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);\n        } else {\n            currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);\n        }\n        // Prepare subscription data\n        const subscriptionData = {\n            user_id: userId,\n            plan_id: planId,\n            billing_cycle: billingCycle,\n            status: \"active\",\n            current_period_start: currentPeriodStart.toISOString(),\n            current_period_end: currentPeriodEnd.toISOString(),\n            cancel_at_period_end: false,\n            stripe_subscription_id: paymentData?.stripeSubscriptionId || null,\n            stripe_customer_id: paymentData?.stripeCustomerId || null,\n            updated_at: new Date().toISOString()\n        };\n        // Upsert subscription (update if exists, insert if new)\n        const { data: subscription, error: subscriptionError } = await supabase.from(\"user_subscriptions\").upsert(subscriptionData, {\n            onConflict: \"user_id\"\n        }).select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).single();\n        if (subscriptionError) {\n            console.error(\"[Subscription] Error assigning subscription:\", subscriptionError);\n            throw new Error(\"Failed to assign subscription\");\n        }\n        if (!subscription || !subscription.subscription_plans) {\n            throw new Error(\"Failed to retrieve subscription details\");\n        }\n        // Initialize usage tracking for current month\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error: usageError } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\",\n            ignoreDuplicates: true\n        });\n        if (usageError) {\n            console.error(\"[Subscription] Warning: Failed to initialize usage tracking:\", usageError);\n        // Don't throw error here as subscription assignment was successful\n        }\n        const planData = subscription.subscription_plans;\n        return {\n            subscription_id: subscription.id,\n            plan_id: subscription.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: subscription.billing_cycle,\n            status: subscription.status,\n            current_period_end: subscription.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in assignUserSubscription:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YXpDLGFBQWE7WUFDekNDLFFBQVF3QyxhQUFheEMsTUFBTTtZQUMzQkMsb0JBQW9CdUMsYUFBYXZDLGtCQUFrQjtZQUNuREMsVUFBVVgsU0FBU1csUUFBUTtZQUMzQkMsUUFBUVosU0FBU1ksTUFBTTtZQUN2QkMsZUFBZWIsU0FBU2EsYUFBYTtZQUNyQ0MsY0FBY2QsU0FBU2MsWUFBWTtRQUNyQztJQUNGLEVBQUUsT0FBTy9CLE9BQU87UUFDZE0sUUFBUU4sS0FBSyxDQUFDLG1EQUFtREE7UUFDakUsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL3NlcnZpY2VzL3N1YnNjcmlwdGlvbi50cz8wNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3Vic2NyaXB0aW9uIFNlcnZpY2VcbiAqIFxuICogSGFuZGxlcyBzdWJzY3JpcHRpb24gcGxhbnMsIHVzYWdlIHRyYWNraW5nLCBhbmQgZmVhdHVyZSBhY2Nlc3MgY29udHJvbFxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50XG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0aW9uUGxhbiB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHByaWNlX21vbnRobHk6IG51bWJlcjtcbiAgcHJpY2VfeWVhcmx5OiBudW1iZXI7XG4gIGN1cnJlbmN5OiBzdHJpbmc7XG4gIGZlYXR1cmVzOiB7XG4gICAgbm90ZXNfZ2VuZXJhdGlvbjogYm9vbGVhbjtcbiAgICBxdWl6emVzOiBib29sZWFuO1xuICAgIHlvdXR1YmVfc3VwcG9ydDogYm9vbGVhbjtcbiAgICBwcHRfc3VwcG9ydDogYm9vbGVhbjtcbiAgICBleHBvcnQ6IGJvb2xlYW47XG4gICAgY29weV9wYXN0ZTogYm9vbGVhbjtcbiAgICB1cGxvYWRfdmlkZW8/OiBib29sZWFuO1xuICAgIHByaW9yaXR5X2dlbmVyYXRpb24/OiBib29sZWFuO1xuICB9O1xuICBsaW1pdHM6IHtcbiAgICBub3Rlc19wZXJfbW9udGg6IG51bWJlcjsgLy8gLTEgbWVhbnMgdW5saW1pdGVkXG4gICAgbWF4X3NhdmVkX25vdGVzOiBudW1iZXI7XG4gICAgbWF4X3RleHRfbGVuZ3RoOiBudW1iZXI7XG4gIH07XG4gIGlzX2FjdGl2ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyU3Vic2NyaXB0aW9uIHtcbiAgc3Vic2NyaXB0aW9uX2lkOiBzdHJpbmc7XG4gIHBsYW5faWQ6IHN0cmluZztcbiAgcGxhbl9uYW1lOiBzdHJpbmc7XG4gIHBsYW5fZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGJpbGxpbmdfY3ljbGU6ICdtb250aGx5JyB8ICd5ZWFybHknO1xuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ2NhbmNlbGxlZCcgfCAnZXhwaXJlZCcgfCAndHJpYWwnO1xuICBjdXJyZW50X3BlcmlvZF9lbmQ6IHN0cmluZztcbiAgZmVhdHVyZXM6IFN1YnNjcmlwdGlvblBsYW5bJ2ZlYXR1cmVzJ107XG4gIGxpbWl0czogU3Vic2NyaXB0aW9uUGxhblsnbGltaXRzJ107XG4gIHByaWNlX21vbnRobHk6IG51bWJlcjtcbiAgcHJpY2VfeWVhcmx5OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclVzYWdlIHtcbiAgbm90ZXNfZ2VuZXJhdGVkOiBudW1iZXI7XG4gIHZpZGVvX25vdGVzX2NvdW50OiBudW1iZXI7XG4gIGZpbGVfbm90ZXNfY291bnQ6IG51bWJlcjtcbiAgdGV4dF9ub3Rlc19jb3VudDogbnVtYmVyO1xuICB0b3RhbF9zYXZlZF9ub3RlczogbnVtYmVyO1xuICBtb250aF95ZWFyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNhZ2VDaGVjayB7XG4gIGNhbkdlbmVyYXRlOiBib29sZWFuO1xuICBjYW5TYXZlOiBib29sZWFuO1xuICByZWFzb24/OiBzdHJpbmc7XG4gIHVzYWdlOiBVc2VyVXNhZ2U7XG4gIGxpbWl0czogU3Vic2NyaXB0aW9uUGxhblsnbGltaXRzJ107XG59XG5cbi8qKlxuICogR2V0IGFsbCBhdmFpbGFibGUgc3Vic2NyaXB0aW9uIHBsYW5zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25QbGFucygpOiBQcm9taXNlPFN1YnNjcmlwdGlvblBsYW5bXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcbiAgXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3N1YnNjcmlwdGlvbl9wbGFucycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5vcmRlcigncHJpY2VfbW9udGhseScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICAgIFxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBmZXRjaGluZyBwbGFuczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggc3Vic2NyaXB0aW9uIHBsYW5zJyk7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG4vKipcbiAqIEdldCB1c2VyJ3MgY3VycmVudCBzdWJzY3JpcHRpb24gd2l0aCBwbGFuIGRldGFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJTdWJzY3JpcHRpb24odXNlcklkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJTdWJzY3JpcHRpb24gfCBudWxsPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICBnbG9iYWw6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBVc2UgZGlyZWN0IHRhYmxlIHF1ZXJ5IGluc3RlYWQgb2YgUlBDIGZ1bmN0aW9uXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyU3ViLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIGlkLFxuICAgICAgICBwbGFuX2lkLFxuICAgICAgICBiaWxsaW5nX2N5Y2xlLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uX3BsYW5zIChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICBsaW1pdHMsXG4gICAgICAgICAgcHJpY2VfbW9udGhseSxcbiAgICAgICAgICBwcmljZV95ZWFybHlcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGZldGNoaW5nIHVzZXIgc3Vic2NyaXB0aW9uOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdXNlclN1YiB8fCAhdXNlclN1Yi5zdWJzY3JpcHRpb25fcGxhbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYW5EYXRhID0gdXNlclN1Yi5zdWJzY3JpcHRpb25fcGxhbnMgYXMgYW55O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpcHRpb25faWQ6IHVzZXJTdWIuaWQsXG4gICAgICBwbGFuX2lkOiB1c2VyU3ViLnBsYW5faWQsXG4gICAgICBwbGFuX25hbWU6IHBsYW5EYXRhLm5hbWUsXG4gICAgICBwbGFuX2Rpc3BsYXlfbmFtZTogcGxhbkRhdGEuZGlzcGxheV9uYW1lLFxuICAgICAgYmlsbGluZ19jeWNsZTogdXNlclN1Yi5iaWxsaW5nX2N5Y2xlLFxuICAgICAgc3RhdHVzOiB1c2VyU3ViLnN0YXR1cyxcbiAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogdXNlclN1Yi5jdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICBmZWF0dXJlczogcGxhbkRhdGEuZmVhdHVyZXMsXG4gICAgICBsaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIHByaWNlX21vbnRobHk6IHBsYW5EYXRhLnByaWNlX21vbnRobHksXG4gICAgICBwcmljZV95ZWFybHk6IHBsYW5EYXRhLnByaWNlX3llYXJseVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgaW4gZ2V0VXNlclN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBzcGVjaWZpYyBzdWJzY3JpcHRpb24gcGxhbiBieSBJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUGxhbihwbGFuSWQ6IHN0cmluZyk6IFByb21pc2U8U3Vic2NyaXB0aW9uUGxhbiB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdzdWJzY3JpcHRpb25fcGxhbnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCBwbGFuSWQpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgcGxhbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgY2FuIGdlbmVyYXRlIG5vdGVzIGJhc2VkIG9uIHRoZWlyIHBsYW4gYW5kIHVzYWdlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1VzYWdlTGltaXRzKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBub3RlVHlwZTogJ3ZpZGVvJyB8ICdmaWxlJyB8ICd0ZXh0JyA9ICd0ZXh0J1xuKTogUHJvbWlzZTxVc2FnZUNoZWNrPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGRpcmVjdCB0YWJsZSBxdWVyaWVzIGluc3RlYWQgb2YgUlBDIGZ1bmN0aW9ucyB0byBhdm9pZCBpc3N1ZXNcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBDaGVja2luZyB1c2FnZSBsaW1pdHMgZm9yIHVzZXI6JywgdXNlcklkKVxuXG4gICAgLy8gR2V0IHVzZXIncyBzdWJzY3JpcHRpb24gZGlyZWN0bHlcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJTdWIsIGVycm9yOiBzdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIHBsYW5faWQsXG4gICAgICAgIGJpbGxpbmdfY3ljbGUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgY3VycmVudF9wZXJpb2RfZW5kLFxuICAgICAgICBzdWJzY3JpcHRpb25fcGxhbnMgKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIGxpbWl0cyxcbiAgICAgICAgICBwcmljZV9tb250aGx5LFxuICAgICAgICAgIHByaWNlX3llYXJseVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIC8vIEdldCBjdXJyZW50IG1vbnRoIHVzYWdlIGRpcmVjdGx5XG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZGF0YTogdXNhZ2UsIGVycm9yOiB1c2FnZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ21vbnRoX3llYXInLCBjdXJyZW50TW9udGgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICAvLyBEZWZhdWx0IGZyZWUgcGxhbiBsaW1pdHNcbiAgICBjb25zdCBmcmVlUGxhbkxpbWl0cyA9IHsgXG4gICAgICBub3Rlc19wZXJfbW9udGg6IDIsIFxuICAgICAgbWF4X3NhdmVkX25vdGVzOiAzLCBcbiAgICAgIG1heF90ZXh0X2xlbmd0aDogNTAwMCBcbiAgICB9O1xuXG4gICAgY29uc3QgY3VycmVudFVzYWdlID0gdXNhZ2UgfHwge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICBmaWxlX25vdGVzX2NvdW50OiAwLFxuICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoXG4gICAgfTtcblxuICAgIC8vIElmIHVzYWdlIHJlY29yZCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoIXVzYWdlKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gQ3JlYXRpbmcgdXNhZ2UgcmVjb3JkIGZvciBjdXJyZW50IG1vbnRoOicsIGN1cnJlbnRNb250aClcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGNyZWF0ZVVzYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgICBub3Rlc19nZW5lcmF0ZWQ6IDAsXG4gICAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgICB0ZXh0X25vdGVzX2NvdW50OiAwLFxuICAgICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGNyZWF0ZVVzYWdlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gV2FybmluZzogQ291bGQgbm90IGNyZWF0ZSB1c2FnZSByZWNvcmQ6JywgY3JlYXRlVXNhZ2VFcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gc3Vic2NyaXB0aW9uIGZvdW5kIG9yIGVycm9yLCB0cnkgdG8gY3JlYXRlIGEgZnJlZSBzdWJzY3JpcHRpb25cbiAgICBpZiAoIXVzZXJTdWIgfHwgc3ViRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBObyBhY3RpdmUgc3Vic2NyaXB0aW9uIGZvdW5kLCBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBmcmVlIHN1YnNjcmlwdGlvbicpXG4gICAgICBcbiAgICAgIGlmIChzdWJFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBTdWJzY3JpcHRpb24gcXVlcnkgZXJyb3I6Jywgc3ViRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgZnJlZSBzdWJzY3JpcHRpb24gZm9yIHRoZSB1c2VyXG4gICAgICBjb25zdCB7IGVycm9yOiBjcmVhdGVTdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfc3Vic2NyaXB0aW9ucycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBwbGFuX2lkOiAnZnJlZScsXG4gICAgICAgICAgYmlsbGluZ19jeWNsZTogJ21vbnRobHknLFxuICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgY3VycmVudF9wZXJpb2Rfc3RhcnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgaWYgKGNyZWF0ZVN1YkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIENvdWxkIG5vdCBjcmVhdGUgZnJlZSBzdWJzY3JpcHRpb246JywgY3JlYXRlU3ViRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIENyZWF0ZWQgZnJlZSBzdWJzY3JpcHRpb24gZm9yIHVzZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGZyZWUgcGxhbiBsaW1pdHMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGNvdWxkIGNyZWF0ZSB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICBjb25zdCBjYW5HZW5lcmF0ZSA9IGN1cnJlbnRVc2FnZS5ub3Rlc19nZW5lcmF0ZWQgPCBmcmVlUGxhbkxpbWl0cy5ub3Rlc19wZXJfbW9udGg7XG4gICAgICBjb25zdCBjYW5TYXZlID0gY3VycmVudFVzYWdlLnRvdGFsX3NhdmVkX25vdGVzIDwgZnJlZVBsYW5MaW1pdHMubWF4X3NhdmVkX25vdGVzO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5HZW5lcmF0ZSxcbiAgICAgICAgY2FuU2F2ZSxcbiAgICAgICAgcmVhc29uOiAhY2FuR2VuZXJhdGUgPyBgTW9udGhseSBsaW1pdCByZWFjaGVkICgke2ZyZWVQbGFuTGltaXRzLm5vdGVzX3Blcl9tb250aH0gbm90ZXMgcGVyIG1vbnRoKWAgOlxuICAgICAgICAgICAgICAgICFjYW5TYXZlID8gYFN0b3JhZ2UgbGltaXQgcmVhY2hlZCAoJHtmcmVlUGxhbkxpbWl0cy5tYXhfc2F2ZWRfbm90ZXN9IHNhdmVkIG5vdGVzIG1heGltdW0pYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgbGltaXRzOiBmcmVlUGxhbkxpbWl0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB1c2VyU3ViO1xuICAgIGNvbnN0IHBsYW5EYXRhID0gc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbl9wbGFucyBhcyBhbnk7XG4gICAgXG4gICAgaWYgKCFwbGFuRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gUGxhbiBkYXRhIG5vdCBmb3VuZCBmb3Igc3Vic2NyaXB0aW9uOicsIHN1YnNjcmlwdGlvbik7XG4gICAgICAvLyBGYWxsYmFjayB0byBmcmVlIHBsYW5cbiAgICAgIGNvbnN0IGNhbkdlbmVyYXRlID0gY3VycmVudFVzYWdlLm5vdGVzX2dlbmVyYXRlZCA8IGZyZWVQbGFuTGltaXRzLm5vdGVzX3Blcl9tb250aDtcbiAgICAgIGNvbnN0IGNhblNhdmUgPSBjdXJyZW50VXNhZ2UudG90YWxfc2F2ZWRfbm90ZXMgPCBmcmVlUGxhbkxpbWl0cy5tYXhfc2F2ZWRfbm90ZXM7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbkdlbmVyYXRlLFxuICAgICAgICBjYW5TYXZlLFxuICAgICAgICByZWFzb246ICdQbGFuIGRhdGEgbm90IGZvdW5kIC0gdXNpbmcgZnJlZSBwbGFuIGxpbWl0cycsXG4gICAgICAgIHVzYWdlOiBjdXJyZW50VXNhZ2UsXG4gICAgICAgIGxpbWl0czogZnJlZVBsYW5MaW1pdHNcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBGb3VuZCBzdWJzY3JpcHRpb246Jywge1xuICAgICAgcGxhbklkOiBzdWJzY3JpcHRpb24ucGxhbl9pZCxcbiAgICAgIHBsYW5MaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIGN1cnJlbnRVc2FnZTogY3VycmVudFVzYWdlXG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBtb250aGx5IGdlbmVyYXRpb24gbGltaXQgKGhhbmRsZSB1bmxpbWl0ZWQgY2FzZSlcbiAgICBjb25zdCBtb250aGx5TGltaXQgPSBwbGFuRGF0YS5saW1pdHMubm90ZXNfcGVyX21vbnRoO1xuICAgIGNvbnN0IGNhbkdlbmVyYXRlID0gbW9udGhseUxpbWl0ID09PSAtMSB8fCBjdXJyZW50VXNhZ2Uubm90ZXNfZ2VuZXJhdGVkIDwgbW9udGhseUxpbWl0O1xuICAgIFxuICAgIC8vIENoZWNrIHNhdmVkIG5vdGVzIGxpbWl0XG4gICAgY29uc3QgY2FuU2F2ZSA9IGN1cnJlbnRVc2FnZS50b3RhbF9zYXZlZF9ub3RlcyA8IHBsYW5EYXRhLmxpbWl0cy5tYXhfc2F2ZWRfbm90ZXM7XG4gICAgXG4gICAgbGV0IHJlYXNvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmICghY2FuR2VuZXJhdGUgJiYgbW9udGhseUxpbWl0ICE9PSAtMSkge1xuICAgICAgcmVhc29uID0gYE1vbnRobHkgbGltaXQgcmVhY2hlZCAoJHttb250aGx5TGltaXR9IG5vdGVzIHBlciBtb250aClgO1xuICAgIH0gZWxzZSBpZiAoIWNhblNhdmUpIHtcbiAgICAgIHJlYXNvbiA9IGBTdG9yYWdlIGxpbWl0IHJlYWNoZWQgKCR7cGxhbkRhdGEubGltaXRzLm1heF9zYXZlZF9ub3Rlc30gc2F2ZWQgbm90ZXMgbWF4aW11bSlgO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY2FuR2VuZXJhdGUsXG4gICAgICBjYW5TYXZlLFxuICAgICAgcmVhc29uLFxuICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgIGxpbWl0czogcGxhbkRhdGEubGltaXRzXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjaGVja2luZyB1c2FnZSBsaW1pdHM6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFJldHVybiByZXN0cmljdGl2ZSBmYWxsYmFja1xuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KTtcbiAgICBjb25zdCBmYWxsYmFja1VzYWdlID0ge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiA5OTksXG4gICAgICB2aWRlb19ub3Rlc19jb3VudDogMCxcbiAgICAgIGZpbGVfbm90ZXNfY291bnQ6IDAsXG4gICAgICB0ZXh0X25vdGVzX2NvdW50OiAwLFxuICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDk5OSxcbiAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aFxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkdlbmVyYXRlOiBmYWxzZSxcbiAgICAgIGNhblNhdmU6IGZhbHNlLFxuICAgICAgcmVhc29uOiAnRXJyb3IgY2hlY2tpbmcgc3Vic2NyaXB0aW9uIGxpbWl0cy4gUGxlYXNlIHRyeSBhZ2Fpbi4nLFxuICAgICAgdXNhZ2U6IGZhbGxiYWNrVXNhZ2UsXG4gICAgICBsaW1pdHM6IHsgbm90ZXNfcGVyX21vbnRoOiAyLCBtYXhfc2F2ZWRfbm90ZXM6IDMsIG1heF90ZXh0X2xlbmd0aDogNTAwMCB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEluY3JlbWVudCB1c2VyJ3MgdXNhZ2UgY291bnQgYWZ0ZXIgc3VjY2Vzc2Z1bCBub3RlIGdlbmVyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlbWVudFVzYWdlKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBub3RlVHlwZTogJ3ZpZGVvJyB8ICdmaWxlJyB8ICd0ZXh0JyA9ICd0ZXh0J1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIEluY3JlbWVudGluZyB1c2FnZSBmb3IgdXNlcjonLCB1c2VySWQsICd0eXBlOicsIG5vdGVUeXBlKVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgdXNhZ2VcbiAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRVc2FnZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnbW9udGhfeWVhcicsIGN1cnJlbnRNb250aClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChmZXRjaEVycm9yICYmIGZldGNoRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2Jykge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgY3VycmVudCB1c2FnZTonLCBmZXRjaEVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHVwZGF0ZSBkYXRhXG4gICAgY29uc3QgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAoY3VycmVudFVzYWdlPy5ub3Rlc19nZW5lcmF0ZWQgfHwgMCkgKyAxLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIC8vIEluY3JlbWVudCBzcGVjaWZpYyBub3RlIHR5cGUgY291bnRlclxuICAgIGlmIChub3RlVHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdXBkYXRlRGF0YS52aWRlb19ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LnZpZGVvX25vdGVzX2NvdW50IHx8IDApICsgMTtcbiAgICB9IGVsc2UgaWYgKG5vdGVUeXBlID09PSAnZmlsZScpIHtcbiAgICAgIHVwZGF0ZURhdGEuZmlsZV9ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LmZpbGVfbm90ZXNfY291bnQgfHwgMCkgKyAxO1xuICAgIH0gZWxzZSBpZiAobm90ZVR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgdXBkYXRlRGF0YS50ZXh0X25vdGVzX2NvdW50ID0gKGN1cnJlbnRVc2FnZT8udGV4dF9ub3Rlc19jb3VudCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG9yIGluc2VydCB1c2FnZSByZWNvcmRcbiAgICBpZiAoY3VycmVudFVzYWdlKSB7XG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLmVxKCdtb250aF95ZWFyJywgY3VycmVudE1vbnRoKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHVwZGF0aW5nIHVzYWdlOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IHVzYWdlIHJlY29yZFxuICAgICAgY29uc3QgaW5zZXJ0RGF0YSA9IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIG5vdGVzX2dlbmVyYXRlZDogMSxcbiAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAndmlkZW8nID8gMSA6IDAsXG4gICAgICAgIGZpbGVfbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAnZmlsZScgPyAxIDogMCxcbiAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogbm90ZVR5cGUgPT09ICd0ZXh0JyA/IDEgOiAwLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogMCxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAgIC5pbnNlcnQoaW5zZXJ0RGF0YSk7XG5cbiAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjcmVhdGluZyB1c2FnZSByZWNvcmQ6JywgaW5zZXJ0RXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSBpbmNyZW1lbnRlZCB1c2FnZScpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGluY3JlbWVudGluZyB1c2FnZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHNhdmVkIG5vdGVzIGNvdW50ICh1c2VkIHdoZW4gbm90ZXMgYXJlIHNhdmVkIG9yIGRlbGV0ZWQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVTYXZlZE5vdGVzQ291bnQoXG4gIHVzZXJJZDogc3RyaW5nLCBcbiAgdG9rZW46IHN0cmluZywgXG4gIGNvdW50OiBudW1iZXJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBVcGRhdGluZyBzYXZlZCBub3RlcyBjb3VudCBmb3IgdXNlcjonLCB1c2VySWQsICdjb3VudDonLCBjb3VudClcblxuICAgIC8vIFVwc2VydCB0aGUgc2F2ZWQgbm90ZXMgY291bnRcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnVwc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogTWF0aC5tYXgoMCwgY291bnQpLCAvLyBFbnN1cmUgbm9uLW5lZ2F0aXZlXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCxtb250aF95ZWFyJ1xuICAgICAgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHVwZGF0aW5nIHNhdmVkIG5vdGVzIGNvdW50OicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgc2F2ZWQgbm90ZXMgY291bnQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmVmcmVzaCBzYXZlZCBub3RlcyBjb3VudCBieSBjb3VudGluZyBhbGwgbm90ZXMgZnJvbSBhbGwgdGFibGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoU2F2ZWROb3Rlc0NvdW50KFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gUmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudCBmb3IgdXNlcjonLCB1c2VySWQpO1xuXG4gICAgLy8gQ291bnQgbm90ZXMgZnJvbSBhbGwgdGFibGVzXG4gICAgY29uc3QgW3ZpZGVvUmVzdWx0LCBmaWxlUmVzdWx0LCB0ZXh0UmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2aWRlb19ub3RlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpLFxuICAgICAgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2ZpbGVfbm90ZXMnKVxuICAgICAgICAuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKSxcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0ZXh0X25vdGVzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICBdKTtcblxuICAgIGNvbnN0IHZpZGVvQ291bnQgPSB2aWRlb1Jlc3VsdC5jb3VudCB8fCAwO1xuICAgIGNvbnN0IGZpbGVDb3VudCA9IGZpbGVSZXN1bHQuY291bnQgfHwgMDtcbiAgICBjb25zdCB0ZXh0Q291bnQgPSB0ZXh0UmVzdWx0LmNvdW50IHx8IDA7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHZpZGVvQ291bnQgKyBmaWxlQ291bnQgKyB0ZXh0Q291bnQ7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gTm90ZSBjb3VudHM6Jywge1xuICAgICAgdmlkZW86IHZpZGVvQ291bnQsXG4gICAgICBmaWxlOiBmaWxlQ291bnQsXG4gICAgICB0ZXh0OiB0ZXh0Q291bnQsXG4gICAgICB0b3RhbDogdG90YWxDb3VudFxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB1c2FnZSByZWNvcmQgd2l0aCB0aGUgYWN0dWFsIGNvdW50XG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAudXBzZXJ0KHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiB0b3RhbENvdW50LFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sIHtcbiAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsbW9udGhfeWVhcidcbiAgICAgIH0pO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSByZWZyZXNoZWQgc2F2ZWQgbm90ZXMgY291bnQgdG86JywgdG90YWxDb3VudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgcmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHBsYW4gcHJpY2luZyB3aXRoIGRpc2NvdW50IGNhbGN1bGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuUHJpY2luZyhwbGFuOiBTdWJzY3JpcHRpb25QbGFuKSB7XG4gIGNvbnN0IG1vbnRobHlQcmljZSA9IHBsYW4ucHJpY2VfbW9udGhseTtcbiAgY29uc3QgeWVhcmx5UHJpY2UgPSBwbGFuLnByaWNlX3llYXJseTtcbiAgY29uc3QgeWVhcmx5TW9udGhseUVxdWl2YWxlbnQgPSB5ZWFybHlQcmljZSAvIDEyO1xuICBjb25zdCBkaXNjb3VudFBlcmNlbnRhZ2UgPSBtb250aGx5UHJpY2UgPiAwID8gTWF0aC5yb3VuZCgoMSAtIHllYXJseU1vbnRobHlFcXVpdmFsZW50IC8gbW9udGhseVByaWNlKSAqIDEwMCkgOiAwO1xuICBjb25zdCB5ZWFybHlTYXZpbmdzID0gKG1vbnRobHlQcmljZSAqIDEyKSAtIHllYXJseVByaWNlO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtb250aGx5OiBtb250aGx5UHJpY2UsXG4gICAgeWVhcmx5OiB5ZWFybHlQcmljZSxcbiAgICB5ZWFybHlNb250aGx5RXF1aXZhbGVudCxcbiAgICBkaXNjb3VudFBlcmNlbnRhZ2UsXG4gICAgeWVhcmx5U2F2aW5ncyxcbiAgICBjdXJyZW5jeTogcGxhbi5jdXJyZW5jeVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgaGFzIGFjY2VzcyB0byBhIHNwZWNpZmljIGZlYXR1cmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc0ZlYXR1cmVBY2Nlc3MoXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0b2tlbjogc3RyaW5nLFxuICBmZWF0dXJlOiBrZXlvZiBTdWJzY3JpcHRpb25QbGFuWydmZWF0dXJlcyddXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRVc2VyU3Vic2NyaXB0aW9uKHVzZXJJZCwgdG9rZW4pO1xuICAgIFxuICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAvLyBEZWZhdWx0IGZyZWUgcGxhbiBmZWF0dXJlc1xuICAgICAgY29uc3QgZnJlZUZlYXR1cmVzID0ge1xuICAgICAgICBub3Rlc19nZW5lcmF0aW9uOiB0cnVlLFxuICAgICAgICBxdWl6emVzOiBmYWxzZSxcbiAgICAgICAgeW91dHViZV9zdXBwb3J0OiB0cnVlLFxuICAgICAgICBwcHRfc3VwcG9ydDogZmFsc2UsXG4gICAgICAgIGV4cG9ydDogZmFsc2UsXG4gICAgICAgIGNvcHlfcGFzdGU6IHRydWUsXG4gICAgICAgIHVwbG9hZF92aWRlbzogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5X2dlbmVyYXRpb246IGZhbHNlXG4gICAgICB9O1xuICAgICAgXG4gICAgICByZXR1cm4gZnJlZUZlYXR1cmVzW2ZlYXR1cmVdIHx8IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLmZlYXR1cmVzW2ZlYXR1cmVdIHx8IGZhbHNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGNoZWNraW5nIGZlYXR1cmUgYWNjZXNzOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7IC8vIERlZmF1bHQgdG8gbm8gYWNjZXNzIG9uIGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NpZ24gc3Vic2NyaXB0aW9uIHRvIHVzZXIgYWZ0ZXIgc3VjY2Vzc2Z1bCBwYXltZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZyxcbiAgcGxhbklkOiBzdHJpbmcsXG4gIGJpbGxpbmdDeWNsZTogJ21vbnRobHknIHwgJ3llYXJseScsXG4gIHBheW1lbnREYXRhPzoge1xuICAgIHN0cmlwZVN1YnNjcmlwdGlvbklkPzogc3RyaW5nO1xuICAgIHN0cmlwZUN1c3RvbWVySWQ/OiBzdHJpbmc7XG4gIH1cbik6IFByb21pc2U8VXNlclN1YnNjcmlwdGlvbiB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgIGdsb2JhbDoge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICAvLyBDYWxjdWxhdGUgcGVyaW9kIGRhdGVzXG4gICAgY29uc3QgY3VycmVudFBlcmlvZFN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50UGVyaW9kRW5kID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICBpZiAoYmlsbGluZ0N5Y2xlID09PSAneWVhcmx5Jykge1xuICAgICAgY3VycmVudFBlcmlvZEVuZC5zZXRGdWxsWWVhcihjdXJyZW50UGVyaW9kRW5kLmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFBlcmlvZEVuZC5zZXRNb250aChjdXJyZW50UGVyaW9kRW5kLmdldE1vbnRoKCkgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHN1YnNjcmlwdGlvbiBkYXRhXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uRGF0YSA9IHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgIHBsYW5faWQ6IHBsYW5JZCxcbiAgICAgIGJpbGxpbmdfY3ljbGU6IGJpbGxpbmdDeWNsZSxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScgYXMgY29uc3QsXG4gICAgICBjdXJyZW50X3BlcmlvZF9zdGFydDogY3VycmVudFBlcmlvZFN0YXJ0LnRvSVNPU3RyaW5nKCksXG4gICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IGN1cnJlbnRQZXJpb2RFbmQudG9JU09TdHJpbmcoKSxcbiAgICAgIGNhbmNlbF9hdF9wZXJpb2RfZW5kOiBmYWxzZSxcbiAgICAgIHN0cmlwZV9zdWJzY3JpcHRpb25faWQ6IHBheW1lbnREYXRhPy5zdHJpcGVTdWJzY3JpcHRpb25JZCB8fCBudWxsLFxuICAgICAgc3RyaXBlX2N1c3RvbWVyX2lkOiBwYXltZW50RGF0YT8uc3RyaXBlQ3VzdG9tZXJJZCB8fCBudWxsLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIC8vIFVwc2VydCBzdWJzY3JpcHRpb24gKHVwZGF0ZSBpZiBleGlzdHMsIGluc2VydCBpZiBuZXcpXG4gICAgY29uc3QgeyBkYXRhOiBzdWJzY3JpcHRpb24sIGVycm9yOiBzdWJzY3JpcHRpb25FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnVwc2VydChzdWJzY3JpcHRpb25EYXRhLCB7XG4gICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkJ1xuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcGxhbl9pZCxcbiAgICAgICAgYmlsbGluZ19jeWNsZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICAgIHN1YnNjcmlwdGlvbl9wbGFucyAoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgbGltaXRzLFxuICAgICAgICAgIHByaWNlX21vbnRobHksXG4gICAgICAgICAgcHJpY2VfeWVhcmx5XG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGFzc2lnbmluZyBzdWJzY3JpcHRpb246Jywgc3Vic2NyaXB0aW9uRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXNzaWduIHN1YnNjcmlwdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghc3Vic2NyaXB0aW9uIHx8ICFzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uX3BsYW5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb24gZGV0YWlscycpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdXNhZ2UgdHJhY2tpbmcgZm9yIGN1cnJlbnQgbW9udGhcbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc3QgeyBlcnJvcjogdXNhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgIC51cHNlcnQoe1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgICB2aWRlb19ub3Rlc19jb3VudDogMCxcbiAgICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDAsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCxtb250aF95ZWFyJyxcbiAgICAgICAgaWdub3JlRHVwbGljYXRlczogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICBpZiAodXNhZ2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gV2FybmluZzogRmFpbGVkIHRvIGluaXRpYWxpemUgdXNhZ2UgdHJhY2tpbmc6JywgdXNhZ2VFcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciBoZXJlIGFzIHN1YnNjcmlwdGlvbiBhc3NpZ25tZW50IHdhcyBzdWNjZXNzZnVsXG4gICAgfVxuXG4gICAgY29uc3QgcGxhbkRhdGEgPSBzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uX3BsYW5zIGFzIGFueTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3Vic2NyaXB0aW9uX2lkOiBzdWJzY3JpcHRpb24uaWQsXG4gICAgICBwbGFuX2lkOiBzdWJzY3JpcHRpb24ucGxhbl9pZCxcbiAgICAgIHBsYW5fbmFtZTogcGxhbkRhdGEubmFtZSxcbiAgICAgIHBsYW5fZGlzcGxheV9uYW1lOiBwbGFuRGF0YS5kaXNwbGF5X25hbWUsXG4gICAgICBiaWxsaW5nX2N5Y2xlOiBzdWJzY3JpcHRpb24uYmlsbGluZ19jeWNsZSxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uLnN0YXR1cyxcbiAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgIGZlYXR1cmVzOiBwbGFuRGF0YS5mZWF0dXJlcyxcbiAgICAgIGxpbWl0czogcGxhbkRhdGEubGltaXRzLFxuICAgICAgcHJpY2VfbW9udGhseTogcGxhbkRhdGEucHJpY2VfbW9udGhseSxcbiAgICAgIHByaWNlX3llYXJseTogcGxhbkRhdGEucHJpY2VfeWVhcmx5XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBpbiBhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSAiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdWJzY3JpcHRpb25QbGFucyIsInN1cGFiYXNlIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJjb25zb2xlIiwiRXJyb3IiLCJnZXRVc2VyU3Vic2NyaXB0aW9uIiwidXNlcklkIiwidG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInVzZXJTdWIiLCJzaW5nbGUiLCJzdWJzY3JpcHRpb25fcGxhbnMiLCJwbGFuRGF0YSIsInN1YnNjcmlwdGlvbl9pZCIsImlkIiwicGxhbl9pZCIsInBsYW5fbmFtZSIsIm5hbWUiLCJwbGFuX2Rpc3BsYXlfbmFtZSIsImRpc3BsYXlfbmFtZSIsImJpbGxpbmdfY3ljbGUiLCJzdGF0dXMiLCJjdXJyZW50X3BlcmlvZF9lbmQiLCJmZWF0dXJlcyIsImxpbWl0cyIsInByaWNlX21vbnRobHkiLCJwcmljZV95ZWFybHkiLCJnZXRTdWJzY3JpcHRpb25QbGFuIiwicGxhbklkIiwiY2hlY2tVc2FnZUxpbWl0cyIsIm5vdGVUeXBlIiwibG9nIiwic3ViRXJyb3IiLCJjdXJyZW50TW9udGgiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInVzYWdlIiwidXNhZ2VFcnJvciIsImZyZWVQbGFuTGltaXRzIiwibm90ZXNfcGVyX21vbnRoIiwibWF4X3NhdmVkX25vdGVzIiwibWF4X3RleHRfbGVuZ3RoIiwiY3VycmVudFVzYWdlIiwibm90ZXNfZ2VuZXJhdGVkIiwidmlkZW9fbm90ZXNfY291bnQiLCJmaWxlX25vdGVzX2NvdW50IiwidGV4dF9ub3Rlc19jb3VudCIsInRvdGFsX3NhdmVkX25vdGVzIiwibW9udGhfeWVhciIsImNyZWF0ZVVzYWdlRXJyb3IiLCJpbnNlcnQiLCJ1c2VyX2lkIiwidXBkYXRlZF9hdCIsImNyZWF0ZVN1YkVycm9yIiwiY3VycmVudF9wZXJpb2Rfc3RhcnQiLCJub3ciLCJjYW5HZW5lcmF0ZSIsImNhblNhdmUiLCJyZWFzb24iLCJ1bmRlZmluZWQiLCJzdWJzY3JpcHRpb24iLCJwbGFuTGltaXRzIiwibW9udGhseUxpbWl0IiwiZmFsbGJhY2tVc2FnZSIsImluY3JlbWVudFVzYWdlIiwiZmV0Y2hFcnJvciIsImNvZGUiLCJ1cGRhdGVEYXRhIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJpbnNlcnREYXRhIiwiY3JlYXRlZF9hdCIsImluc2VydEVycm9yIiwidXBkYXRlU2F2ZWROb3Rlc0NvdW50IiwiY291bnQiLCJ1cHNlcnQiLCJNYXRoIiwibWF4Iiwib25Db25mbGljdCIsInJlZnJlc2hTYXZlZE5vdGVzQ291bnQiLCJ2aWRlb1Jlc3VsdCIsImZpbGVSZXN1bHQiLCJ0ZXh0UmVzdWx0IiwiUHJvbWlzZSIsImFsbCIsImhlYWQiLCJ2aWRlb0NvdW50IiwiZmlsZUNvdW50IiwidGV4dENvdW50IiwidG90YWxDb3VudCIsInZpZGVvIiwiZmlsZSIsInRleHQiLCJ0b3RhbCIsImdldFBsYW5QcmljaW5nIiwicGxhbiIsIm1vbnRobHlQcmljZSIsInllYXJseVByaWNlIiwieWVhcmx5TW9udGhseUVxdWl2YWxlbnQiLCJkaXNjb3VudFBlcmNlbnRhZ2UiLCJyb3VuZCIsInllYXJseVNhdmluZ3MiLCJtb250aGx5IiwieWVhcmx5IiwiY3VycmVuY3kiLCJoYXNGZWF0dXJlQWNjZXNzIiwiZmVhdHVyZSIsImZyZWVGZWF0dXJlcyIsIm5vdGVzX2dlbmVyYXRpb24iLCJxdWl6emVzIiwieW91dHViZV9zdXBwb3J0IiwicHB0X3N1cHBvcnQiLCJleHBvcnQiLCJjb3B5X3Bhc3RlIiwidXBsb2FkX3ZpZGVvIiwicHJpb3JpdHlfZ2VuZXJhdGlvbiIsImFzc2lnblVzZXJTdWJzY3JpcHRpb24iLCJiaWxsaW5nQ3ljbGUiLCJwYXltZW50RGF0YSIsImN1cnJlbnRQZXJpb2RTdGFydCIsImN1cnJlbnRQZXJpb2RFbmQiLCJzZXRGdWxsWWVhciIsImdldEZ1bGxZZWFyIiwic2V0TW9udGgiLCJnZXRNb250aCIsInN1YnNjcmlwdGlvbkRhdGEiLCJjYW5jZWxfYXRfcGVyaW9kX2VuZCIsInN0cmlwZV9zdWJzY3JpcHRpb25faWQiLCJzdHJpcGVTdWJzY3JpcHRpb25JZCIsInN0cmlwZV9jdXN0b21lcl9pZCIsInN0cmlwZUN1c3RvbWVySWQiLCJzdWJzY3JpcHRpb25FcnJvciIsImlnbm9yZUR1cGxpY2F0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/subscription.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/videoTranscription.ts":
/*!********************************************!*\
  !*** ./src/services/videoTranscription.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanupTempDirectory: () => (/* binding */ cleanupTempDirectory),\n/* harmony export */   createTempDirectory: () => (/* binding */ createTempDirectory),\n/* harmony export */   getVideoInfo: () => (/* binding */ getVideoInfo),\n/* harmony export */   transcribeVideoFile: () => (/* binding */ transcribeVideoFile),\n/* harmony export */   validateVideoFile: () => (/* binding */ validateVideoFile)\n/* harmony export */ });\n/* harmony import */ var fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fluent-ffmpeg */ \"(rsc)/./node_modules/fluent-ffmpeg/index.js\");\n/* harmony import */ var fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs-extra */ \"(rsc)/./node_modules/fs-extra/lib/index.js\");\n/* harmony import */ var fs_extra__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs_extra__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n\n\n\n\n// Set FFmpeg path using the ffmpeg-installer with fallbacks\nlet ffmpegPathSet = false;\nlet ffprobePathSet = false;\n// Set up FFmpeg path\ntry {\n    const ffmpegInstaller = __webpack_require__(/*! @ffmpeg-installer/ffmpeg */ \"(rsc)/./node_modules/@ffmpeg-installer/ffmpeg/index.js\");\n    if (ffmpegInstaller && ffmpegInstaller.path) {\n        if (fs_extra__WEBPACK_IMPORTED_MODULE_2___default().existsSync(ffmpegInstaller.path)) {\n            fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().setFfmpegPath(ffmpegInstaller.path);\n            console.log(\"[VideoTranscription] FFmpeg path set from installer:\", ffmpegInstaller.path);\n            ffmpegPathSet = true;\n        } else {\n            console.warn(\"[VideoTranscription] FFmpeg installer path does not exist:\", ffmpegInstaller.path);\n        }\n    } else {\n        console.warn(\"[VideoTranscription] FFmpeg installer found but no path provided\");\n    }\n} catch (error) {\n    console.warn(\"[VideoTranscription] FFmpeg installer require failed:\", error);\n}\n// Set up FFprobe path - using system ffprobe since ffprobe-static was removed\ntry {\n    // Try to use system ffprobe\n    fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().setFfprobePath(\"ffprobe\");\n    console.log(\"[VideoTranscription] FFprobe path set to system ffprobe\");\n    ffprobePathSet = true;\n} catch (error) {\n    console.warn(\"[VideoTranscription] System ffprobe not available:\", error);\n}\n// If installer didn't work, try to find ffmpeg and ffprobe in common locations\nif (!ffmpegPathSet || !ffprobePathSet) {\n    const commonPaths = [\n        // Try to construct the installer path manually\n        {\n            ffmpeg: path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"node_modules\", \"@ffmpeg-installer\", \"darwin-x64\", \"ffmpeg\"),\n            ffprobe: \"/usr/local/bin/ffprobe\"\n        },\n        {\n            ffmpeg: path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"node_modules\", \"@ffmpeg-installer\", \"darwin-arm64\", \"ffmpeg\"),\n            ffprobe: \"/opt/homebrew/bin/ffprobe\"\n        },\n        // System paths (assuming ffmpeg and ffprobe are in the same dir)\n        {\n            ffmpeg: \"/usr/local/bin/ffmpeg\",\n            ffprobe: \"/usr/local/bin/ffprobe\"\n        },\n        {\n            ffmpeg: \"/usr/bin/ffmpeg\",\n            ffprobe: \"/usr/bin/ffprobe\"\n        },\n        {\n            ffmpeg: \"/opt/homebrew/bin/ffmpeg\",\n            ffprobe: \"/opt/homebrew/bin/ffprobe\"\n        },\n        {\n            ffmpeg: \"ffmpeg\",\n            ffprobe: \"ffprobe\"\n        } // Use PATH\n    ];\n    for (const paths of commonPaths){\n        try {\n            if (!ffmpegPathSet && (paths.ffmpeg === \"ffmpeg\" || fs_extra__WEBPACK_IMPORTED_MODULE_2___default().existsSync(paths.ffmpeg))) {\n                fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().setFfmpegPath(paths.ffmpeg);\n                console.log(\"[VideoTranscription] Using FFmpeg at:\", paths.ffmpeg);\n                ffmpegPathSet = true;\n            }\n            if (!ffprobePathSet && (paths.ffprobe === \"ffprobe\" || fs_extra__WEBPACK_IMPORTED_MODULE_2___default().existsSync(paths.ffprobe))) {\n                fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().setFfprobePath(paths.ffprobe);\n                console.log(\"[VideoTranscription] Using FFprobe at:\", paths.ffprobe);\n                ffprobePathSet = true;\n            }\n            if (ffmpegPathSet && ffprobePathSet) break;\n        } catch (error) {\n            console.warn(\"[VideoTranscription] Could not use FFmpeg/FFprobe at:\", paths);\n        }\n    }\n}\nif (!ffmpegPathSet) {\n    console.error(\"[VideoTranscription]   Could not find FFmpeg! Video processing may fail for extraction.\");\n}\nif (!ffprobePathSet) {\n    console.error(\"[VideoTranscription]   Could not find FFprobe! Video validation/info may fail.\");\n}\n/**\n * Tests if FFmpeg and FFprobe are available and working\n */ async function testFFmpegAvailability() {\n    const results = {\n        ffmpeg: false,\n        ffprobe: false\n    };\n    return new Promise((resolve)=>{\n        fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().getAvailableFormats((err)=>{\n            if (err) {\n                console.error(\"[VideoTranscription] FFmpeg test failed:\", err.message);\n            } else {\n                console.log(\"[VideoTranscription] FFmpeg test passed (formats check)\");\n                results.ffmpeg = true;\n            }\n            // Test ffprobe by trying to get info from a dummy/non-existent file path\n            // We expect an error, but not 'ffprobe not found'\n            fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().ffprobe(\"dummy_test_file.mp4\", (probeErr, metadata)=>{\n                if (probeErr && probeErr.message.toLowerCase().includes(\"cannot find ffprobe\")) {\n                    console.error(\"[VideoTranscription] FFprobe test failed: ffprobe not found\");\n                } else if (probeErr && probeErr.message.toLowerCase().includes(\"no such file\")) {\n                    console.log(\"[VideoTranscription] FFprobe test passed (expected error on dummy file)\");\n                    results.ffprobe = true;\n                } else if (!probeErr) {\n                    console.log(\"[VideoTranscription] FFprobe test passed (unexpected success on dummy file, but ok)\");\n                    results.ffprobe = true;\n                } else {\n                    console.error(\"[VideoTranscription] FFprobe test returned unexpected error:\", probeErr.message);\n                }\n                resolve(results);\n            });\n        });\n    });\n}\n// Initialize OpenAI client for Whisper API\nconst openai = new openai__WEBPACK_IMPORTED_MODULE_3__[\"default\"]({\n    apiKey: process.env.OPENAI_API_KEY\n});\n/**\n * Extracts audio from video file and transcribes it using OpenAI Whisper API\n */ async function transcribeVideoFile(videoFilePath, outputDir, progressCallback) {\n    const tempDir = outputDir || path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp\", \"video-processing\");\n    const audioFileName = `audio_${Date.now()}.mp3`;\n    const audioFilePath = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, audioFileName);\n    try {\n        // Test FFmpeg availability first\n        console.log(\"[VideoTranscription] Testing FFmpeg/FFprobe availability...\");\n        const { ffmpeg: ffmpegAvailable, ffprobe: ffprobeAvailable } = await testFFmpegAvailability();\n        if (!ffmpegAvailable) {\n            return {\n                transcript: \"\",\n                error: \"FFmpeg (for audio extraction) is not available. Please ensure FFmpeg is properly installed and accessible.\"\n            };\n        }\n        // FFprobe is used for validation and info, can proceed with extraction if only ffprobe is missing but warn.\n        if (!ffprobeAvailable) {\n            console.warn(\"[VideoTranscription] FFprobe not available. Video validation and info might be incomplete, but attempting audio extraction.\");\n        }\n        // Ensure temp directory exists\n        await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().ensureDir(tempDir);\n        // Step 1: Extract audio from video\n        console.log(\"[VideoTranscription] Extracting audio from video...\");\n        progressCallback?.({\n            step: \"extracting\",\n            progress: 0,\n            message: \"Extracting audio from video...\"\n        });\n        await extractAudioFromVideo(videoFilePath, audioFilePath, (progress)=>{\n            progressCallback?.({\n                step: \"extracting\",\n                progress,\n                message: `Extracting audio: ${progress}%`\n            });\n        });\n        progressCallback?.({\n            step: \"extracting\",\n            progress: 100,\n            message: \"Audio extraction complete\"\n        });\n        // Step 2: Check if audio needs to be chunked and transcribe\n        console.log(\"[VideoTranscription] Checking audio file size and preparing for transcription...\");\n        // Check audio file size first\n        const audioStats = await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().stat(audioFilePath);\n        console.log(`[VideoTranscription] Audio file size: ${(audioStats.size / 1024 / 1024).toFixed(2)} MB`);\n        let transcriptionResult;\n        if (audioStats.size > 15 * 1024 * 1024) {\n            console.log(\"[VideoTranscription] Audio file is large, using chunking approach...\");\n            progressCallback?.({\n                step: \"transcribing\",\n                progress: 0,\n                message: \"Preparing large audio file for transcription...\"\n            });\n            // Split audio into chunks\n            const chunkPaths = await splitAudioIntoChunks(audioFilePath);\n            progressCallback?.({\n                step: \"transcribing\",\n                progress: 25,\n                message: `Transcribing audio in ${chunkPaths.length} chunks...`\n            });\n            // Transcribe all chunks\n            transcriptionResult = await transcribeAudioChunks(chunkPaths);\n        } else {\n            console.log(\"[VideoTranscription] Audio file is small enough, using direct transcription...\");\n            progressCallback?.({\n                step: \"transcribing\",\n                progress: 0,\n                message: \"Transcribing audio with AI...\"\n            });\n            // Use direct transcription for smaller files\n            transcriptionResult = await transcribeAudioWithWhisper(audioFilePath);\n        }\n        progressCallback?.({\n            step: \"transcribing\",\n            progress: 100,\n            message: \"Transcription complete\"\n        });\n        // Cleanup: Remove temporary audio file\n        try {\n            await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().remove(audioFilePath);\n        } catch (cleanupError) {\n            console.warn(\"[VideoTranscription] Failed to cleanup audio file:\", cleanupError);\n        }\n        progressCallback?.({\n            step: \"complete\",\n            progress: 100,\n            message: \"Video processing complete\"\n        });\n        return transcriptionResult;\n    } catch (error) {\n        console.error(\"[VideoTranscription] Error:\", error);\n        // Cleanup on error\n        try {\n            await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().remove(audioFilePath);\n        } catch (cleanupError) {\n            console.warn(\"[VideoTranscription] Failed to cleanup after error:\", cleanupError);\n        }\n        return {\n            transcript: \"\",\n            error: error instanceof Error ? error.message : \"Unknown transcription error\"\n        };\n    }\n}\n/**\n * Extracts audio from video file using FFmpeg\n */ async function extractAudioFromVideo(videoPath, outputPath, progressCallback) {\n    return new Promise((resolve, reject)=>{\n        let duration = null;\n        fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default()(videoPath).audioCodec(\"libmp3lame\") // Use MP3 compression instead of uncompressed WAV\n        .audioBitrate(\"48k\") // Even lower bitrate for speech (was 64k)\n        .audioChannels(1) // Mono audio for efficiency\n        .audioFrequency(16000) // 16kHz sample rate (optimal for speech)\n        .format(\"mp3\") // Use MP3 format to save space\n        .on(\"codecData\", (data)=>{\n            // Get duration for progress calculation\n            const durationMatch = data.duration.match(/(\\d+):(\\d+):(\\d+\\.\\d+)/);\n            if (durationMatch) {\n                const hours = parseInt(durationMatch[1]);\n                const minutes = parseInt(durationMatch[2]);\n                const seconds = parseFloat(durationMatch[3]);\n                duration = hours * 3600 + minutes * 60 + seconds;\n            }\n        }).on(\"progress\", (progress)=>{\n            if (duration && progressCallback && progress.timemark) {\n                // Parse timemark which is in format \"HH:MM:SS.ms\"\n                const timeMatch = progress.timemark.toString().match(/(\\d+):(\\d+):(\\d+\\.\\d+)/);\n                if (timeMatch) {\n                    const hours = parseInt(timeMatch[1]);\n                    const minutes = parseInt(timeMatch[2]);\n                    const seconds = parseFloat(timeMatch[3]);\n                    const currentTime = hours * 3600 + minutes * 60 + seconds;\n                    const percent = Math.min(100, Math.round(currentTime / duration * 100));\n                    progressCallback(percent);\n                }\n            }\n        }).on(\"end\", ()=>{\n            console.log(\"[VideoTranscription] Audio extraction completed\");\n            resolve();\n        }).on(\"error\", (error)=>{\n            console.error(\"[VideoTranscription] FFmpeg error:\", error);\n            // Provide more specific error messages based on the type of error\n            let errorMessage = `Audio extraction failed: ${error.message}`;\n            if (error.message.includes(\"Cannot find ffmpeg\")) {\n                errorMessage = \"Cannot find ffmpeg. Please ensure FFmpeg is properly installed.\";\n                console.error(\"[VideoTranscription] FFmpeg not found. Installed paths checked:\");\n                console.error(\"[VideoTranscription] - @ffmpeg-installer path:\", ffmpegPathSet ? \"Found\" : \"Not found\");\n                console.error(\"[VideoTranscription] - System paths checked: /usr/local/bin/ffmpeg, /usr/bin/ffmpeg, /opt/homebrew/bin/ffmpeg\");\n            } else if (error.message.includes(\"No such file\")) {\n                errorMessage = `Input video file not found: ${videoPath}`;\n            } else if (error.message.includes(\"Invalid data\")) {\n                errorMessage = \"Invalid video file format or corrupted file\";\n            } else if (error.message.includes(\"Permission denied\")) {\n                errorMessage = \"Permission denied accessing video file or output directory\";\n            }\n            reject(new Error(errorMessage));\n        }).save(outputPath);\n    });\n}\n/**\n * Splits audio file into chunks if it's too large for Whisper API\n */ async function splitAudioIntoChunks(audioFilePath, maxSizeBytes = 15 * 1024 * 1024 // 15MB to be safe (Whisper limit is 25MB)\n) {\n    const audioStats = await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().stat(audioFilePath);\n    if (audioStats.size <= maxSizeBytes) {\n        // File is small enough, return as single chunk\n        return [\n            audioFilePath\n        ];\n    }\n    console.log(`[VideoTranscription] Audio file too large (${(audioStats.size / 1024 / 1024).toFixed(2)}MB), splitting into chunks...`);\n    // Calculate chunk duration based on file size\n    // Estimate: assume roughly 1MB per minute of audio at current settings\n    const estimatedDurationMinutes = audioStats.size / (1024 * 1024);\n    const maxChunkDurationMinutes = maxSizeBytes / (1024 * 1024); // Rough estimate\n    const numberOfChunks = Math.ceil(estimatedDurationMinutes / maxChunkDurationMinutes);\n    console.log(`[VideoTranscription] Estimated duration: ${estimatedDurationMinutes.toFixed(1)} minutes, creating ${numberOfChunks} chunks`);\n    const chunkPaths = [];\n    const baseDir = path__WEBPACK_IMPORTED_MODULE_1___default().dirname(audioFilePath);\n    const baseName = path__WEBPACK_IMPORTED_MODULE_1___default().basename(audioFilePath, path__WEBPACK_IMPORTED_MODULE_1___default().extname(audioFilePath));\n    // Split audio into chunks\n    for(let i = 0; i < numberOfChunks; i++){\n        const chunkPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(baseDir, `${baseName}_chunk_${i}.mp3`);\n        const startTime = i * maxChunkDurationMinutes * 60; // Convert to seconds\n        await new Promise((resolve, reject)=>{\n            fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default()(audioFilePath).seekInput(startTime).duration(maxChunkDurationMinutes * 60) // Duration in seconds\n            .audioCodec(\"libmp3lame\").audioBitrate(\"48k\") // Match the main extraction bitrate\n            .audioChannels(1).audioFrequency(16000).format(\"mp3\").on(\"end\", ()=>{\n                console.log(`[VideoTranscription] Created chunk ${i + 1}/${numberOfChunks}: ${chunkPath}`);\n                resolve();\n            }).on(\"error\", (error)=>{\n                console.error(`[VideoTranscription] Error creating chunk ${i + 1}:`, error);\n                reject(new Error(`Failed to create audio chunk ${i + 1}: ${error.message}`));\n            }).save(chunkPath);\n        });\n        // Verify chunk was created and has reasonable size\n        try {\n            const chunkStats = await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().stat(chunkPath);\n            if (chunkStats.size > 0) {\n                chunkPaths.push(chunkPath);\n            } else {\n                console.warn(`[VideoTranscription] Chunk ${i + 1} is empty, skipping`);\n            }\n        } catch (error) {\n            console.warn(`[VideoTranscription] Chunk ${i + 1} was not created properly, skipping`);\n        }\n    }\n    console.log(`[VideoTranscription] Successfully created ${chunkPaths.length} audio chunks`);\n    return chunkPaths;\n}\n/**\n * Transcribes multiple audio chunks and combines the results\n */ async function transcribeAudioChunks(chunkPaths) {\n    if (chunkPaths.length === 1) {\n        // Single chunk, use existing function\n        return await transcribeAudioWithWhisper(chunkPaths[0]);\n    }\n    console.log(`[VideoTranscription] Transcribing ${chunkPaths.length} audio chunks...`);\n    const transcripts = [];\n    let totalDuration = 0;\n    for(let i = 0; i < chunkPaths.length; i++){\n        const chunkPath = chunkPaths[i];\n        console.log(`[VideoTranscription] Transcribing chunk ${i + 1}/${chunkPaths.length}: ${path__WEBPACK_IMPORTED_MODULE_1___default().basename(chunkPath)}`);\n        try {\n            const chunkResult = await transcribeAudioWithWhisper(chunkPath);\n            if (chunkResult.error) {\n                console.error(`[VideoTranscription] Error transcribing chunk ${i + 1}:`, chunkResult.error);\n                return {\n                    transcript: \"\",\n                    error: `Failed to transcribe audio chunk ${i + 1}: ${chunkResult.error}`\n                };\n            }\n            if (chunkResult.transcript && chunkResult.transcript.trim()) {\n                transcripts.push(chunkResult.transcript.trim());\n            }\n            // Clean up chunk file after processing\n            try {\n                await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().remove(chunkPath);\n            } catch (cleanupError) {\n                console.warn(`[VideoTranscription] Failed to cleanup chunk ${i + 1}:`, cleanupError);\n            }\n        } catch (error) {\n            console.error(`[VideoTranscription] Exception transcribing chunk ${i + 1}:`, error);\n            return {\n                transcript: \"\",\n                error: `Exception during chunk ${i + 1} transcription: ${error instanceof Error ? error.message : \"Unknown error\"}`\n            };\n        }\n    }\n    // Combine all transcripts\n    const combinedTranscript = transcripts.join(\" \");\n    console.log(`[VideoTranscription] Successfully transcribed ${transcripts.length} chunks, total length: ${combinedTranscript.length} characters`);\n    return {\n        transcript: combinedTranscript,\n        language: \"auto-detected\"\n    };\n}\n/**\n * Transcribes audio file using OpenAI Whisper API (handles chunking for large files)\n */ async function transcribeAudioWithWhisper(audioFilePath) {\n    try {\n        if (!openai) {\n            throw new Error(\"OpenAI client not initialized - check API key configuration\");\n        }\n        // Check if audio file exists and get its size\n        const audioStats = await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().stat(audioFilePath);\n        console.log(`[VideoTranscription] Audio file size: ${(audioStats.size / 1024 / 1024).toFixed(2)} MB`);\n        // OpenAI Whisper API has a 25MB file size limit - throw error immediately for large files\n        if (audioStats.size > 25 * 1024 * 1024) {\n            throw new Error(`Audio file too large for Whisper API (max 25MB). Consider splitting the video into smaller segments.`);\n        }\n        // Create a file stream for the audio\n        const audioStream = fs_extra__WEBPACK_IMPORTED_MODULE_2___default().createReadStream(audioFilePath);\n        console.log(\"[VideoTranscription] Sending audio to OpenAI Whisper API...\");\n        const transcription = await openai.audio.transcriptions.create({\n            file: audioStream,\n            model: \"whisper-1\",\n            language: undefined,\n            response_format: \"text\",\n            temperature: 0.1 // Lower temperature for more consistent transcription\n        });\n        if (!transcription || typeof transcription !== \"string\") {\n            throw new Error(\"Invalid response from Whisper API\");\n        }\n        console.log(`[VideoTranscription] Transcription completed: ${transcription.length} characters`);\n        return {\n            transcript: transcription.trim(),\n            language: \"auto-detected\" // Whisper auto-detects language\n        };\n    } catch (error) {\n        console.error(\"[VideoTranscription] Whisper API error:\", error);\n        if (error instanceof Error) {\n            // Check for the custom file size error message we might return directly or other known patterns\n            if (error.message.includes(\"Audio file too large\") || error.message.includes(\"max 25MB\") || error.message.includes(\"maximum content length exceeded\") || error.message.includes(\"file size\")) {\n                return {\n                    transcript: \"\",\n                    error: \"Audio file is too large for the transcription service (max 25MB). This should be handled by chunking.\"\n                };\n            } else if (error.message.includes(\"API key\")) {\n                return {\n                    transcript: \"\",\n                    error: \"Transcription service configuration error. Please contact support.\"\n                };\n            } else if (error.message.includes(\"rate limit\")) {\n                return {\n                    transcript: \"\",\n                    error: \"Transcription service is temporarily overloaded. Please try again in a few minutes.\"\n                };\n            }\n        }\n        return {\n            transcript: \"\",\n            error: \"Failed to transcribe audio. Please ensure the video contains clear speech or check service status.\"\n        };\n    }\n}\n/**\n * Gets video file information (duration, format, etc.)\n */ async function getVideoInfo(videoFilePath) {\n    const stats = await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().stat(videoFilePath);\n    return new Promise((resolve, reject)=>{\n        fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().ffprobe(videoFilePath, (error, metadata)=>{\n            if (error) {\n                reject(new Error(`Failed to analyze video: ${error.message}`));\n                return;\n            }\n            const duration = metadata.format.duration || 0;\n            const format = metadata.format.format_name || \"unknown\";\n            resolve({\n                duration,\n                format,\n                size: stats.size\n            });\n        });\n    });\n}\n/**\n * Validates if the uploaded file is a supported video format\n */ function validateVideoFile(filePath, originalName) {\n    return new Promise((resolve)=>{\n        console.log(`[VideoTranscription] Validating file: ${originalName}`);\n        console.log(`[VideoTranscription] File path: ${filePath}`);\n        // First check if file exists\n        if (!fs_extra__WEBPACK_IMPORTED_MODULE_2___default().existsSync(filePath)) {\n            console.error(\"[VideoTranscription] File does not exist at path:\", filePath);\n            resolve(false);\n            return;\n        }\n        // Check file size\n        try {\n            const stats = fs_extra__WEBPACK_IMPORTED_MODULE_2___default().statSync(filePath);\n            console.log(`[VideoTranscription] File size: ${(stats.size / 1024 / 1024).toFixed(2)} MB`);\n            if (stats.size === 0) {\n                console.error(\"[VideoTranscription] File is empty\");\n                resolve(false);\n                return;\n            }\n        } catch (error) {\n            console.error(\"[VideoTranscription] Error reading file stats:\", error);\n            resolve(false);\n            return;\n        }\n        // Set a timeout for FFprobe to prevent hanging\n        const timeout = setTimeout(()=>{\n            console.warn(\"[VideoTranscription] FFprobe timeout, using fallback validation\");\n            const supportedExtensions = [\n                \".mp4\",\n                \".mov\",\n                \".webm\",\n                \".avi\",\n                \".mkv\"\n            ];\n            const fileExtension = path__WEBPACK_IMPORTED_MODULE_1___default().extname(originalName).toLowerCase();\n            const isValidExtension = supportedExtensions.includes(fileExtension);\n            console.log(`[VideoTranscription] Timeout fallback - Extension: ${fileExtension}, Valid: ${isValidExtension}`);\n            resolve(isValidExtension);\n        }, 10000); // 10 second timeout\n        fluent_ffmpeg__WEBPACK_IMPORTED_MODULE_0___default().ffprobe(filePath, (error, metadata)=>{\n            clearTimeout(timeout); // Clear the timeout since we got a response\n            if (error) {\n                console.error(\"[VideoTranscription] FFprobe error:\", error);\n                console.error(\"[VideoTranscription] FFprobe error message:\", error.message);\n                // If FFprobe fails, use fallback validation based on file extension and MIME type\n                const supportedExtensions = [\n                    \".mp4\",\n                    \".mov\",\n                    \".webm\",\n                    \".avi\",\n                    \".mkv\"\n                ];\n                const fileExtension = path__WEBPACK_IMPORTED_MODULE_1___default().extname(originalName).toLowerCase();\n                const isValidExtension = supportedExtensions.includes(fileExtension);\n                console.log(`[VideoTranscription] FFprobe failed, using fallback validation`);\n                console.log(`[VideoTranscription] File extension: ${fileExtension}`);\n                console.log(`[VideoTranscription] Valid extension: ${isValidExtension}`);\n                // Be more permissive - if it has a valid extension, allow it through\n                // The transcription process will catch any real issues\n                resolve(isValidExtension);\n                return;\n            }\n            console.log(\"[VideoTranscription] FFprobe metadata obtained successfully\");\n            console.log(\"[VideoTranscription] Format:\", metadata.format?.format_name);\n            console.log(\"[VideoTranscription] Duration:\", metadata.format?.duration);\n            console.log(\"[VideoTranscription] Streams count:\", metadata.streams?.length);\n            if (!metadata.streams || metadata.streams.length === 0) {\n                console.error(\"[VideoTranscription] No streams found in file\");\n                // Even if no streams found, try fallback validation\n                const supportedExtensions = [\n                    \".mp4\",\n                    \".mov\",\n                    \".webm\",\n                    \".avi\",\n                    \".mkv\"\n                ];\n                const fileExtension = path__WEBPACK_IMPORTED_MODULE_1___default().extname(originalName).toLowerCase();\n                const isValidExtension = supportedExtensions.includes(fileExtension);\n                console.log(`[VideoTranscription] No streams fallback - Extension: ${fileExtension}, Valid: ${isValidExtension}`);\n                resolve(isValidExtension);\n                return;\n            }\n            // Check if file has video streams\n            const hasVideoStream = metadata.streams.some((stream)=>{\n                console.log(`[VideoTranscription] Stream type: ${stream.codec_type}, codec: ${stream.codec_name}`);\n                return stream.codec_type === \"video\";\n            });\n            const hasAudioStream = metadata.streams.some((stream)=>{\n                return stream.codec_type === \"audio\";\n            });\n            console.log(`[VideoTranscription] Has video stream: ${hasVideoStream}`);\n            console.log(`[VideoTranscription] Has audio stream: ${hasAudioStream}`);\n            // For note generation, we primarily need audio, but video presence is also good\n            const isValid = hasAudioStream || hasVideoStream;\n            console.log(`[VideoTranscription] File validation result: ${isValid}`);\n            // If FFprobe says invalid but file has proper extension, be more lenient\n            if (!isValid) {\n                console.warn(\"[VideoTranscription] FFprobe validation failed, checking fallback...\");\n                const supportedExtensions = [\n                    \".mp4\",\n                    \".mov\",\n                    \".webm\",\n                    \".avi\",\n                    \".mkv\"\n                ];\n                const fileExtension = path__WEBPACK_IMPORTED_MODULE_1___default().extname(originalName).toLowerCase();\n                const isValidExtension = supportedExtensions.includes(fileExtension);\n                if (isValidExtension) {\n                    console.warn(\"[VideoTranscription] Using fallback validation - file has valid extension\");\n                    resolve(true); // Be permissive for files with correct extensions\n                    return;\n                }\n            }\n            resolve(isValid);\n        });\n    });\n}\n/**\n * Creates a safe temporary directory for video processing\n */ async function createTempDirectory() {\n    const tempDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp\", \"video-processing\", `session_${Date.now()}`);\n    await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().ensureDir(tempDir);\n    return tempDir;\n}\n/**\n * Cleans up temporary files and directories\n */ async function cleanupTempDirectory(tempDir) {\n    try {\n        await fs_extra__WEBPACK_IMPORTED_MODULE_2___default().remove(tempDir);\n        console.log(`[VideoTranscription] Cleaned up temp directory: ${tempDir}`);\n    } catch (error) {\n        console.warn(`[VideoTranscription] Failed to cleanup temp directory: ${tempDir}`, error);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvc2VydmljZXMvdmlkZW9UcmFuc2NyaXB0aW9uLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNUO0FBQ0Y7QUFDSTtBQUc1Qiw0REFBNEQ7QUFDNUQsSUFBSUksZ0JBQWdCO0FBQ3BCLElBQUlDLGlCQUFpQjtBQUVyQixxQkFBcUI7QUFDckIsSUFBSTtJQUNGLE1BQU1DLGtCQUFrQkMsbUJBQU9BLENBQUM7SUFDaEMsSUFBSUQsbUJBQW1CQSxnQkFBZ0JKLElBQUksRUFBRTtRQUMzQyxJQUFJRCwwREFBYSxDQUFDSyxnQkFBZ0JKLElBQUksR0FBRztZQUN2Q0Ysa0VBQW9CLENBQUNNLGdCQUFnQkosSUFBSTtZQUN6Q1EsUUFBUUMsR0FBRyxDQUFDLHdEQUF3REwsZ0JBQWdCSixJQUFJO1lBQ3hGRSxnQkFBZ0I7UUFDbEIsT0FBTztZQUNMTSxRQUFRRSxJQUFJLENBQUMsOERBQThETixnQkFBZ0JKLElBQUk7UUFDakc7SUFDRixPQUFPO1FBQ0xRLFFBQVFFLElBQUksQ0FBQztJQUNmO0FBQ0YsRUFBRSxPQUFPQyxPQUFPO0lBQ2RILFFBQVFFLElBQUksQ0FBQyx5REFBeURDO0FBQ3hFO0FBRUEsOEVBQThFO0FBQzlFLElBQUk7SUFDRiw0QkFBNEI7SUFDNUJiLG1FQUFxQixDQUFDO0lBQ3RCVSxRQUFRQyxHQUFHLENBQUM7SUFDWk4saUJBQWlCO0FBQ25CLEVBQUUsT0FBT1EsT0FBTztJQUNkSCxRQUFRRSxJQUFJLENBQUMsc0RBQXNEQztBQUNyRTtBQUVBLCtFQUErRTtBQUMvRSxJQUFJLENBQUNULGlCQUFpQixDQUFDQyxnQkFBZ0I7SUFDckMsTUFBTVUsY0FBYztRQUNsQiwrQ0FBK0M7UUFDL0M7WUFBRWYsUUFBUUUsZ0RBQVMsQ0FBQ2UsUUFBUUMsR0FBRyxJQUFJLGdCQUFnQixxQkFBcUIsY0FBYztZQUFXQyxTQUFTO1FBQXlCO1FBQ25JO1lBQUVuQixRQUFRRSxnREFBUyxDQUFDZSxRQUFRQyxHQUFHLElBQUks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QkFBZ0J0SSxtREFBWSxDQUFDaUksY0FBY3JHLFdBQVc7Z0JBQzVELE1BQU0yRyxtQkFBbUJGLG9CQUFvQnhHLFFBQVEsQ0FBQ3lHO2dCQUV0RCxJQUFJQyxrQkFBa0I7b0JBQ3BCL0gsUUFBUUUsSUFBSSxDQUFDO29CQUNiWSxRQUFRLE9BQU8sa0RBQWtEO29CQUNqRTtnQkFDRjtZQUNGO1lBRUFBLFFBQVEwSDtRQUNWO0lBQ0Y7QUFDRjtBQUVBOztDQUVDLEdBQ00sZUFBZUM7SUFDcEIsTUFBTTNHLFVBQVV0QyxnREFBUyxDQUFDZSxRQUFRQyxHQUFHLElBQUksUUFBUSxvQkFBb0IsQ0FBQyxRQUFRLEVBQUV3QixLQUFLQyxHQUFHLEdBQUcsQ0FBQztJQUM1RixNQUFNMUMseURBQVksQ0FBQ3VDO0lBQ25CLE9BQU9BO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLGVBQWU0RyxxQkFBcUI1RyxPQUFlO0lBQ3hELElBQUk7UUFDRixNQUFNdkMsc0RBQVMsQ0FBQ3VDO1FBQ2hCOUIsUUFBUUMsR0FBRyxDQUFDLENBQUMsZ0RBQWdELEVBQUU2QixRQUFRLENBQUM7SUFDMUUsRUFBRSxPQUFPM0IsT0FBTztRQUNkSCxRQUFRRSxJQUFJLENBQUMsQ0FBQyx1REFBdUQsRUFBRTRCLFFBQVEsQ0FBQyxFQUFFM0I7SUFDcEY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy92aWRlb1RyYW5zY3JpcHRpb24udHM/ZTM3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZmZtcGVnIGZyb20gJ2ZsdWVudC1mZm1wZWcnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5cbi8vIFNldCBGRm1wZWcgcGF0aCB1c2luZyB0aGUgZmZtcGVnLWluc3RhbGxlciB3aXRoIGZhbGxiYWNrc1xubGV0IGZmbXBlZ1BhdGhTZXQgPSBmYWxzZTtcbmxldCBmZnByb2JlUGF0aFNldCA9IGZhbHNlO1xuXG4vLyBTZXQgdXAgRkZtcGVnIHBhdGhcbnRyeSB7XG4gIGNvbnN0IGZmbXBlZ0luc3RhbGxlciA9IHJlcXVpcmUoJ0BmZm1wZWctaW5zdGFsbGVyL2ZmbXBlZycpO1xuICBpZiAoZmZtcGVnSW5zdGFsbGVyICYmIGZmbXBlZ0luc3RhbGxlci5wYXRoKSB7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZmZtcGVnSW5zdGFsbGVyLnBhdGgpKSB7XG4gICAgICBmZm1wZWcuc2V0RmZtcGVnUGF0aChmZm1wZWdJbnN0YWxsZXIucGF0aCk7XG4gICAgICBjb25zb2xlLmxvZygnW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRkZtcGVnIHBhdGggc2V0IGZyb20gaW5zdGFsbGVyOicsIGZmbXBlZ0luc3RhbGxlci5wYXRoKTtcbiAgICAgIGZmbXBlZ1BhdGhTZXQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGbXBlZyBpbnN0YWxsZXIgcGF0aCBkb2VzIG5vdCBleGlzdDonLCBmZm1wZWdJbnN0YWxsZXIucGF0aCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRkZtcGVnIGluc3RhbGxlciBmb3VuZCBidXQgbm8gcGF0aCBwcm92aWRlZCcpO1xuICB9XG59IGNhdGNoIChlcnJvcikge1xuICBjb25zb2xlLndhcm4oJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGbXBlZyBpbnN0YWxsZXIgcmVxdWlyZSBmYWlsZWQ6JywgZXJyb3IpO1xufVxuXG4vLyBTZXQgdXAgRkZwcm9iZSBwYXRoIC0gdXNpbmcgc3lzdGVtIGZmcHJvYmUgc2luY2UgZmZwcm9iZS1zdGF0aWMgd2FzIHJlbW92ZWRcbnRyeSB7XG4gIC8vIFRyeSB0byB1c2Ugc3lzdGVtIGZmcHJvYmVcbiAgZmZtcGVnLnNldEZmcHJvYmVQYXRoKCdmZnByb2JlJyk7XG4gIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIHBhdGggc2V0IHRvIHN5c3RlbSBmZnByb2JlJyk7XG4gIGZmcHJvYmVQYXRoU2V0ID0gdHJ1ZTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUud2FybignW1ZpZGVvVHJhbnNjcmlwdGlvbl0gU3lzdGVtIGZmcHJvYmUgbm90IGF2YWlsYWJsZTonLCBlcnJvcik7XG59XG5cbi8vIElmIGluc3RhbGxlciBkaWRuJ3Qgd29yaywgdHJ5IHRvIGZpbmQgZmZtcGVnIGFuZCBmZnByb2JlIGluIGNvbW1vbiBsb2NhdGlvbnNcbmlmICghZmZtcGVnUGF0aFNldCB8fCAhZmZwcm9iZVBhdGhTZXQpIHtcbiAgY29uc3QgY29tbW9uUGF0aHMgPSBbXG4gICAgLy8gVHJ5IHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFsbGVyIHBhdGggbWFudWFsbHlcbiAgICB7IGZmbXBlZzogcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdub2RlX21vZHVsZXMnLCAnQGZmbXBlZy1pbnN0YWxsZXInLCAnZGFyd2luLXg2NCcsICdmZm1wZWcnKSwgZmZwcm9iZTogJy91c3IvbG9jYWwvYmluL2ZmcHJvYmUnIH0sXG4gICAgeyBmZm1wZWc6IHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnbm9kZV9tb2R1bGVzJywgJ0BmZm1wZWctaW5zdGFsbGVyJywgJ2Rhcndpbi1hcm02NCcsICdmZm1wZWcnKSwgZmZwcm9iZTogJy9vcHQvaG9tZWJyZXcvYmluL2ZmcHJvYmUnIH0sXG4gICAgLy8gU3lzdGVtIHBhdGhzIChhc3N1bWluZyBmZm1wZWcgYW5kIGZmcHJvYmUgYXJlIGluIHRoZSBzYW1lIGRpcilcbiAgICB7IGZmbXBlZzogJy91c3IvbG9jYWwvYmluL2ZmbXBlZycsIGZmcHJvYmU6ICcvdXNyL2xvY2FsL2Jpbi9mZnByb2JlJyB9LFxuICAgIHsgZmZtcGVnOiAnL3Vzci9iaW4vZmZtcGVnJywgZmZwcm9iZTogJy91c3IvYmluL2ZmcHJvYmUnIH0sXG4gICAgeyBmZm1wZWc6ICcvb3B0L2hvbWVicmV3L2Jpbi9mZm1wZWcnLCBmZnByb2JlOiAnL29wdC9ob21lYnJldy9iaW4vZmZwcm9iZScgfSxcbiAgICB7IGZmbXBlZzogJ2ZmbXBlZycsIGZmcHJvYmU6ICdmZnByb2JlJyB9IC8vIFVzZSBQQVRIXG4gIF07XG5cbiAgZm9yIChjb25zdCBwYXRocyBvZiBjb21tb25QYXRocykge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWZmbXBlZ1BhdGhTZXQgJiYgKHBhdGhzLmZmbXBlZyA9PT0gJ2ZmbXBlZycgfHwgZnMuZXhpc3RzU3luYyhwYXRocy5mZm1wZWcpKSkge1xuICAgICAgICBmZm1wZWcuc2V0RmZtcGVnUGF0aChwYXRocy5mZm1wZWcpO1xuICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvVHJhbnNjcmlwdGlvbl0gVXNpbmcgRkZtcGVnIGF0OicsIHBhdGhzLmZmbXBlZyk7XG4gICAgICAgIGZmbXBlZ1BhdGhTZXQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFmZnByb2JlUGF0aFNldCAmJiAocGF0aHMuZmZwcm9iZSA9PT0gJ2ZmcHJvYmUnIHx8IGZzLmV4aXN0c1N5bmMocGF0aHMuZmZwcm9iZSkpKSB7XG4gICAgICAgIGZmbXBlZy5zZXRGZnByb2JlUGF0aChwYXRocy5mZnByb2JlKTtcbiAgICAgICAgY29uc29sZS5sb2coJ1tWaWRlb1RyYW5zY3JpcHRpb25dIFVzaW5nIEZGcHJvYmUgYXQ6JywgcGF0aHMuZmZwcm9iZSk7XG4gICAgICAgIGZmcHJvYmVQYXRoU2V0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmZm1wZWdQYXRoU2V0ICYmIGZmcHJvYmVQYXRoU2V0KSBicmVhaztcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBDb3VsZCBub3QgdXNlIEZGbXBlZy9GRnByb2JlIGF0OicsIHBhdGhzKTtcbiAgICB9XG4gIH1cbn1cblxuaWYgKCFmZm1wZWdQYXRoU2V0KSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIOKaoO+4jyAgQ291bGQgbm90IGZpbmQgRkZtcGVnISBWaWRlbyBwcm9jZXNzaW5nIG1heSBmYWlsIGZvciBleHRyYWN0aW9uLicpO1xufVxuaWYgKCFmZnByb2JlUGF0aFNldCkge1xuICBjb25zb2xlLmVycm9yKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSDimqDvuI8gIENvdWxkIG5vdCBmaW5kIEZGcHJvYmUhIFZpZGVvIHZhbGlkYXRpb24vaW5mbyBtYXkgZmFpbC4nKTtcbn1cblxuLyoqXG4gKiBUZXN0cyBpZiBGRm1wZWcgYW5kIEZGcHJvYmUgYXJlIGF2YWlsYWJsZSBhbmQgd29ya2luZ1xuICovXG5hc3luYyBmdW5jdGlvbiB0ZXN0RkZtcGVnQXZhaWxhYmlsaXR5KCk6IFByb21pc2U8e2ZmbXBlZzogYm9vbGVhbiwgZmZwcm9iZTogYm9vbGVhbn0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IHsgZmZtcGVnOiBmYWxzZSwgZmZwcm9iZTogZmFsc2UgfTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgZmZtcGVnLmdldEF2YWlsYWJsZUZvcm1hdHMoKGVycikgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRm1wZWcgdGVzdCBmYWlsZWQ6JywgZXJyLm1lc3NhZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGbXBlZyB0ZXN0IHBhc3NlZCAoZm9ybWF0cyBjaGVjayknKTtcbiAgICAgICAgcmVzdWx0cy5mZm1wZWcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUZXN0IGZmcHJvYmUgYnkgdHJ5aW5nIHRvIGdldCBpbmZvIGZyb20gYSBkdW1teS9ub24tZXhpc3RlbnQgZmlsZSBwYXRoXG4gICAgICAvLyBXZSBleHBlY3QgYW4gZXJyb3IsIGJ1dCBub3QgJ2ZmcHJvYmUgbm90IGZvdW5kJ1xuICAgICAgZmZtcGVnLmZmcHJvYmUoJ2R1bW15X3Rlc3RfZmlsZS5tcDQnLCAocHJvYmVFcnIsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIGlmIChwcm9iZUVyciAmJiBwcm9iZUVyci5tZXNzYWdlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2Nhbm5vdCBmaW5kIGZmcHJvYmUnKSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGcHJvYmUgdGVzdCBmYWlsZWQ6IGZmcHJvYmUgbm90IGZvdW5kJyk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvYmVFcnIgJiYgcHJvYmVFcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdubyBzdWNoIGZpbGUnKSl7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGcHJvYmUgdGVzdCBwYXNzZWQgKGV4cGVjdGVkIGVycm9yIG9uIGR1bW15IGZpbGUpJyk7XG4gICAgICAgICAgcmVzdWx0cy5mZnByb2JlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICghcHJvYmVFcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIHRlc3QgcGFzc2VkICh1bmV4cGVjdGVkIHN1Y2Nlc3Mgb24gZHVtbXkgZmlsZSwgYnV0IG9rKScpO1xuICAgICAgICAgICAgcmVzdWx0cy5mZnByb2JlID0gdHJ1ZTsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIHRlc3QgcmV0dXJuZWQgdW5leHBlY3RlZCBlcnJvcjonLCBwcm9iZUVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBJbml0aWFsaXplIE9wZW5BSSBjbGllbnQgZm9yIFdoaXNwZXIgQVBJXG5jb25zdCBvcGVuYWkgPSBuZXcgT3BlbkFJKHtcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWVxufSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmlkZW9UcmFuc2NyaXB0aW9uUmVzdWx0IHtcbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuICBkdXJhdGlvbj86IG51bWJlcjtcbiAgbGFuZ3VhZ2U/OiBzdHJpbmc7XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZpZGVvUHJvY2Vzc2luZ1Byb2dyZXNzIHtcbiAgc3RlcDogJ2V4dHJhY3RpbmcnIHwgJ3RyYW5zY3JpYmluZycgfCAnY29tcGxldGUnO1xuICBwcm9ncmVzczogbnVtYmVyO1xuICBtZXNzYWdlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgYXVkaW8gZnJvbSB2aWRlbyBmaWxlIGFuZCB0cmFuc2NyaWJlcyBpdCB1c2luZyBPcGVuQUkgV2hpc3BlciBBUElcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmVWaWRlb0ZpbGUoXG4gIHZpZGVvRmlsZVBhdGg6IHN0cmluZyxcbiAgb3V0cHV0RGlyPzogc3RyaW5nLFxuICBwcm9ncmVzc0NhbGxiYWNrPzogKHByb2dyZXNzOiBWaWRlb1Byb2Nlc3NpbmdQcm9ncmVzcykgPT4gdm9pZFxuKTogUHJvbWlzZTxWaWRlb1RyYW5zY3JpcHRpb25SZXN1bHQ+IHtcbiAgY29uc3QgdGVtcERpciA9IG91dHB1dERpciB8fCBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RlbXAnLCAndmlkZW8tcHJvY2Vzc2luZycpO1xuICBjb25zdCBhdWRpb0ZpbGVOYW1lID0gYGF1ZGlvXyR7RGF0ZS5ub3coKX0ubXAzYDtcbiAgY29uc3QgYXVkaW9GaWxlUGF0aCA9IHBhdGguam9pbih0ZW1wRGlyLCBhdWRpb0ZpbGVOYW1lKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVGVzdCBGRm1wZWcgYXZhaWxhYmlsaXR5IGZpcnN0XG4gICAgY29uc29sZS5sb2coJ1tWaWRlb1RyYW5zY3JpcHRpb25dIFRlc3RpbmcgRkZtcGVnL0ZGcHJvYmUgYXZhaWxhYmlsaXR5Li4uJyk7XG4gICAgY29uc3Qge2ZmbXBlZzogZmZtcGVnQXZhaWxhYmxlLCBmZnByb2JlOiBmZnByb2JlQXZhaWxhYmxlfSA9IGF3YWl0IHRlc3RGRm1wZWdBdmFpbGFiaWxpdHkoKTtcbiAgICBcbiAgICBpZiAoIWZmbXBlZ0F2YWlsYWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNjcmlwdDogJycsXG4gICAgICAgIGVycm9yOiAnRkZtcGVnIChmb3IgYXVkaW8gZXh0cmFjdGlvbikgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGVuc3VyZSBGRm1wZWcgaXMgcHJvcGVybHkgaW5zdGFsbGVkIGFuZCBhY2Nlc3NpYmxlLidcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIEZGcHJvYmUgaXMgdXNlZCBmb3IgdmFsaWRhdGlvbiBhbmQgaW5mbywgY2FuIHByb2NlZWQgd2l0aCBleHRyYWN0aW9uIGlmIG9ubHkgZmZwcm9iZSBpcyBtaXNzaW5nIGJ1dCB3YXJuLlxuICAgIGlmICghZmZwcm9iZUF2YWlsYWJsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGcHJvYmUgbm90IGF2YWlsYWJsZS4gVmlkZW8gdmFsaWRhdGlvbiBhbmQgaW5mbyBtaWdodCBiZSBpbmNvbXBsZXRlLCBidXQgYXR0ZW1wdGluZyBhdWRpbyBleHRyYWN0aW9uLicpXG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSB0ZW1wIGRpcmVjdG9yeSBleGlzdHNcbiAgICBhd2FpdCBmcy5lbnN1cmVEaXIodGVtcERpcik7XG4gICAgXG4gICAgLy8gU3RlcCAxOiBFeHRyYWN0IGF1ZGlvIGZyb20gdmlkZW9cbiAgICBjb25zb2xlLmxvZygnW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRXh0cmFjdGluZyBhdWRpbyBmcm9tIHZpZGVvLi4uJyk7XG4gICAgcHJvZ3Jlc3NDYWxsYmFjaz8uKHtcbiAgICAgIHN0ZXA6ICdleHRyYWN0aW5nJyxcbiAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgbWVzc2FnZTogJ0V4dHJhY3RpbmcgYXVkaW8gZnJvbSB2aWRlby4uLidcbiAgICB9KTtcblxuICAgIGF3YWl0IGV4dHJhY3RBdWRpb0Zyb21WaWRlbyh2aWRlb0ZpbGVQYXRoLCBhdWRpb0ZpbGVQYXRoLCAocHJvZ3Jlc3MpID0+IHtcbiAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lih7XG4gICAgICAgIHN0ZXA6ICdleHRyYWN0aW5nJyxcbiAgICAgICAgcHJvZ3Jlc3MsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHRyYWN0aW5nIGF1ZGlvOiAke3Byb2dyZXNzfSVgXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHByb2dyZXNzQ2FsbGJhY2s/Lih7XG4gICAgICBzdGVwOiAnZXh0cmFjdGluZycsXG4gICAgICBwcm9ncmVzczogMTAwLFxuICAgICAgbWVzc2FnZTogJ0F1ZGlvIGV4dHJhY3Rpb24gY29tcGxldGUnXG4gICAgfSk7XG5cbiAgICAvLyBTdGVwIDI6IENoZWNrIGlmIGF1ZGlvIG5lZWRzIHRvIGJlIGNodW5rZWQgYW5kIHRyYW5zY3JpYmVcbiAgICBjb25zb2xlLmxvZygnW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQ2hlY2tpbmcgYXVkaW8gZmlsZSBzaXplIGFuZCBwcmVwYXJpbmcgZm9yIHRyYW5zY3JpcHRpb24uLi4nKTtcbiAgICBcbiAgICAvLyBDaGVjayBhdWRpbyBmaWxlIHNpemUgZmlyc3RcbiAgICBjb25zdCBhdWRpb1N0YXRzID0gYXdhaXQgZnMuc3RhdChhdWRpb0ZpbGVQYXRoKTtcbiAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQXVkaW8gZmlsZSBzaXplOiAkeyhhdWRpb1N0YXRzLnNpemUgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX0gTUJgKTtcbiAgICBcbiAgICBsZXQgdHJhbnNjcmlwdGlvblJlc3VsdDogVmlkZW9UcmFuc2NyaXB0aW9uUmVzdWx0O1xuICAgIFxuICAgIGlmIChhdWRpb1N0YXRzLnNpemUgPiAxNSAqIDEwMjQgKiAxMDI0KSB7IC8vIDE1TUIgdGhyZXNob2xkIGZvciBiZXR0ZXIgc2FmZXR5IG1hcmdpblxuICAgICAgY29uc29sZS5sb2coJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEF1ZGlvIGZpbGUgaXMgbGFyZ2UsIHVzaW5nIGNodW5raW5nIGFwcHJvYWNoLi4uJyk7XG4gICAgICBcbiAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lih7XG4gICAgICAgIHN0ZXA6ICd0cmFuc2NyaWJpbmcnLFxuICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgbWVzc2FnZTogJ1ByZXBhcmluZyBsYXJnZSBhdWRpbyBmaWxlIGZvciB0cmFuc2NyaXB0aW9uLi4uJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFNwbGl0IGF1ZGlvIGludG8gY2h1bmtzXG4gICAgICBjb25zdCBjaHVua1BhdGhzID0gYXdhaXQgc3BsaXRBdWRpb0ludG9DaHVua3MoYXVkaW9GaWxlUGF0aCk7XG4gICAgICBcbiAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lih7XG4gICAgICAgIHN0ZXA6ICd0cmFuc2NyaWJpbmcnLFxuICAgICAgICBwcm9ncmVzczogMjUsXG4gICAgICAgIG1lc3NhZ2U6IGBUcmFuc2NyaWJpbmcgYXVkaW8gaW4gJHtjaHVua1BhdGhzLmxlbmd0aH0gY2h1bmtzLi4uYFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFRyYW5zY3JpYmUgYWxsIGNodW5rc1xuICAgICAgdHJhbnNjcmlwdGlvblJlc3VsdCA9IGF3YWl0IHRyYW5zY3JpYmVBdWRpb0NodW5rcyhjaHVua1BhdGhzKTtcbiAgICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZygnW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQXVkaW8gZmlsZSBpcyBzbWFsbCBlbm91Z2gsIHVzaW5nIGRpcmVjdCB0cmFuc2NyaXB0aW9uLi4uJyk7XG4gICAgICBcbiAgICAgIHByb2dyZXNzQ2FsbGJhY2s/Lih7XG4gICAgICAgIHN0ZXA6ICd0cmFuc2NyaWJpbmcnLFxuICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgbWVzc2FnZTogJ1RyYW5zY3JpYmluZyBhdWRpbyB3aXRoIEFJLi4uJ1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIFVzZSBkaXJlY3QgdHJhbnNjcmlwdGlvbiBmb3Igc21hbGxlciBmaWxlc1xuICAgICAgdHJhbnNjcmlwdGlvblJlc3VsdCA9IGF3YWl0IHRyYW5zY3JpYmVBdWRpb1dpdGhXaGlzcGVyKGF1ZGlvRmlsZVBhdGgpO1xuICAgIH1cblxuICAgIHByb2dyZXNzQ2FsbGJhY2s/Lih7XG4gICAgICBzdGVwOiAndHJhbnNjcmliaW5nJyxcbiAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICBtZXNzYWdlOiAnVHJhbnNjcmlwdGlvbiBjb21wbGV0ZSdcbiAgICB9KTtcblxuICAgIC8vIENsZWFudXA6IFJlbW92ZSB0ZW1wb3JhcnkgYXVkaW8gZmlsZVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmcy5yZW1vdmUoYXVkaW9GaWxlUGF0aCk7XG4gICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZhaWxlZCB0byBjbGVhbnVwIGF1ZGlvIGZpbGU6JywgY2xlYW51cEVycm9yKTtcbiAgICB9XG5cbiAgICBwcm9ncmVzc0NhbGxiYWNrPy4oe1xuICAgICAgc3RlcDogJ2NvbXBsZXRlJyxcbiAgICAgIHByb2dyZXNzOiAxMDAsXG4gICAgICBtZXNzYWdlOiAnVmlkZW8gcHJvY2Vzc2luZyBjb21wbGV0ZSdcbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2NyaXB0aW9uUmVzdWx0O1xuXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRXJyb3I6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIENsZWFudXAgb24gZXJyb3JcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZnMucmVtb3ZlKGF1ZGlvRmlsZVBhdGgpO1xuICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGYWlsZWQgdG8gY2xlYW51cCBhZnRlciBlcnJvcjonLCBjbGVhbnVwRXJyb3IpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2NyaXB0OiAnJyxcbiAgICAgIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIHRyYW5zY3JpcHRpb24gZXJyb3InXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIGF1ZGlvIGZyb20gdmlkZW8gZmlsZSB1c2luZyBGRm1wZWdcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEF1ZGlvRnJvbVZpZGVvKFxuICB2aWRlb1BhdGg6IHN0cmluZyxcbiAgb3V0cHV0UGF0aDogc3RyaW5nLFxuICBwcm9ncmVzc0NhbGxiYWNrPzogKHByb2dyZXNzOiBudW1iZXIpID0+IHZvaWRcbik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBkdXJhdGlvbjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG5cbiAgICBmZm1wZWcodmlkZW9QYXRoKVxuICAgICAgLmF1ZGlvQ29kZWMoJ2xpYm1wM2xhbWUnKSAvLyBVc2UgTVAzIGNvbXByZXNzaW9uIGluc3RlYWQgb2YgdW5jb21wcmVzc2VkIFdBVlxuICAgICAgLmF1ZGlvQml0cmF0ZSgnNDhrJykgLy8gRXZlbiBsb3dlciBiaXRyYXRlIGZvciBzcGVlY2ggKHdhcyA2NGspXG4gICAgICAuYXVkaW9DaGFubmVscygxKSAvLyBNb25vIGF1ZGlvIGZvciBlZmZpY2llbmN5XG4gICAgICAuYXVkaW9GcmVxdWVuY3koMTYwMDApIC8vIDE2a0h6IHNhbXBsZSByYXRlIChvcHRpbWFsIGZvciBzcGVlY2gpXG4gICAgICAuZm9ybWF0KCdtcDMnKSAvLyBVc2UgTVAzIGZvcm1hdCB0byBzYXZlIHNwYWNlXG4gICAgICAub24oJ2NvZGVjRGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIC8vIEdldCBkdXJhdGlvbiBmb3IgcHJvZ3Jlc3MgY2FsY3VsYXRpb25cbiAgICAgICAgY29uc3QgZHVyYXRpb25NYXRjaCA9IGRhdGEuZHVyYXRpb24ubWF0Y2goLyhcXGQrKTooXFxkKyk6KFxcZCtcXC5cXGQrKS8pO1xuICAgICAgICBpZiAoZHVyYXRpb25NYXRjaCkge1xuICAgICAgICAgIGNvbnN0IGhvdXJzID0gcGFyc2VJbnQoZHVyYXRpb25NYXRjaFsxXSk7XG4gICAgICAgICAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KGR1cmF0aW9uTWF0Y2hbMl0pO1xuICAgICAgICAgIGNvbnN0IHNlY29uZHMgPSBwYXJzZUZsb2F0KGR1cmF0aW9uTWF0Y2hbM10pO1xuICAgICAgICAgIGR1cmF0aW9uID0gaG91cnMgKiAzNjAwICsgbWludXRlcyAqIDYwICsgc2Vjb25kcztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5vbigncHJvZ3Jlc3MnLCAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgaWYgKGR1cmF0aW9uICYmIHByb2dyZXNzQ2FsbGJhY2sgJiYgcHJvZ3Jlc3MudGltZW1hcmspIHtcbiAgICAgICAgICAvLyBQYXJzZSB0aW1lbWFyayB3aGljaCBpcyBpbiBmb3JtYXQgXCJISDpNTTpTUy5tc1wiXG4gICAgICAgICAgY29uc3QgdGltZU1hdGNoID0gcHJvZ3Jlc3MudGltZW1hcmsudG9TdHJpbmcoKS5tYXRjaCgvKFxcZCspOihcXGQrKTooXFxkK1xcLlxcZCspLyk7XG4gICAgICAgICAgaWYgKHRpbWVNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgaG91cnMgPSBwYXJzZUludCh0aW1lTWF0Y2hbMV0pO1xuICAgICAgICAgICAgY29uc3QgbWludXRlcyA9IHBhcnNlSW50KHRpbWVNYXRjaFsyXSk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRzID0gcGFyc2VGbG9hdCh0aW1lTWF0Y2hbM10pO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBob3VycyAqIDM2MDAgKyBtaW51dGVzICogNjAgKyBzZWNvbmRzO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudCA9IE1hdGgubWluKDEwMCwgTWF0aC5yb3VuZCgoY3VycmVudFRpbWUgLyBkdXJhdGlvbikgKiAxMDApKTtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2socGVyY2VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBBdWRpbyBleHRyYWN0aW9uIGNvbXBsZXRlZCcpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRm1wZWcgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICBcbiAgICAgICAgLy8gUHJvdmlkZSBtb3JlIHNwZWNpZmljIGVycm9yIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSB0eXBlIG9mIGVycm9yXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBgQXVkaW8gZXh0cmFjdGlvbiBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0Nhbm5vdCBmaW5kIGZmbXBlZycpKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ0Nhbm5vdCBmaW5kIGZmbXBlZy4gUGxlYXNlIGVuc3VyZSBGRm1wZWcgaXMgcHJvcGVybHkgaW5zdGFsbGVkLic7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRkZtcGVnIG5vdCBmb3VuZC4gSW5zdGFsbGVkIHBhdGhzIGNoZWNrZWQ6Jyk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvVHJhbnNjcmlwdGlvbl0gLSBAZmZtcGVnLWluc3RhbGxlciBwYXRoOicsIGZmbXBlZ1BhdGhTZXQgPyAnRm91bmQnIDogJ05vdCBmb3VuZCcpO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIC0gU3lzdGVtIHBhdGhzIGNoZWNrZWQ6IC91c3IvbG9jYWwvYmluL2ZmbXBlZywgL3Vzci9iaW4vZmZtcGVnLCAvb3B0L2hvbWVicmV3L2Jpbi9mZm1wZWcnKTtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdObyBzdWNoIGZpbGUnKSkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGBJbnB1dCB2aWRlbyBmaWxlIG5vdCBmb3VuZDogJHt2aWRlb1BhdGh9YDtcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdJbnZhbGlkIGRhdGEnKSkge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9ICdJbnZhbGlkIHZpZGVvIGZpbGUgZm9ybWF0IG9yIGNvcnJ1cHRlZCBmaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdQZXJtaXNzaW9uIGRlbmllZCcpKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ1Blcm1pc3Npb24gZGVuaWVkIGFjY2Vzc2luZyB2aWRlbyBmaWxlIG9yIG91dHB1dCBkaXJlY3RvcnknO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yTWVzc2FnZSkpO1xuICAgICAgfSlcbiAgICAgIC5zYXZlKG91dHB1dFBhdGgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTcGxpdHMgYXVkaW8gZmlsZSBpbnRvIGNodW5rcyBpZiBpdCdzIHRvbyBsYXJnZSBmb3IgV2hpc3BlciBBUElcbiAqL1xuYXN5bmMgZnVuY3Rpb24gc3BsaXRBdWRpb0ludG9DaHVua3MoXG4gIGF1ZGlvRmlsZVBhdGg6IHN0cmluZyxcbiAgbWF4U2l6ZUJ5dGVzOiBudW1iZXIgPSAxNSAqIDEwMjQgKiAxMDI0IC8vIDE1TUIgdG8gYmUgc2FmZSAoV2hpc3BlciBsaW1pdCBpcyAyNU1CKVxuKTogUHJvbWlzZTxzdHJpbmdbXT4ge1xuICBjb25zdCBhdWRpb1N0YXRzID0gYXdhaXQgZnMuc3RhdChhdWRpb0ZpbGVQYXRoKTtcbiAgXG4gIGlmIChhdWRpb1N0YXRzLnNpemUgPD0gbWF4U2l6ZUJ5dGVzKSB7XG4gICAgLy8gRmlsZSBpcyBzbWFsbCBlbm91Z2gsIHJldHVybiBhcyBzaW5nbGUgY2h1bmtcbiAgICByZXR1cm4gW2F1ZGlvRmlsZVBhdGhdO1xuICB9XG5cbiAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIEF1ZGlvIGZpbGUgdG9vIGxhcmdlICgkeyhhdWRpb1N0YXRzLnNpemUgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX1NQiksIHNwbGl0dGluZyBpbnRvIGNodW5rcy4uLmApO1xuICBcbiAgLy8gQ2FsY3VsYXRlIGNodW5rIGR1cmF0aW9uIGJhc2VkIG9uIGZpbGUgc2l6ZVxuICAvLyBFc3RpbWF0ZTogYXNzdW1lIHJvdWdobHkgMU1CIHBlciBtaW51dGUgb2YgYXVkaW8gYXQgY3VycmVudCBzZXR0aW5nc1xuICBjb25zdCBlc3RpbWF0ZWREdXJhdGlvbk1pbnV0ZXMgPSBhdWRpb1N0YXRzLnNpemUgLyAoMTAyNCAqIDEwMjQpO1xuICBjb25zdCBtYXhDaHVua0R1cmF0aW9uTWludXRlcyA9IChtYXhTaXplQnl0ZXMgLyAoMTAyNCAqIDEwMjQpKTsgLy8gUm91Z2ggZXN0aW1hdGVcbiAgY29uc3QgbnVtYmVyT2ZDaHVua3MgPSBNYXRoLmNlaWwoZXN0aW1hdGVkRHVyYXRpb25NaW51dGVzIC8gbWF4Q2h1bmtEdXJhdGlvbk1pbnV0ZXMpO1xuICBcbiAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIEVzdGltYXRlZCBkdXJhdGlvbjogJHtlc3RpbWF0ZWREdXJhdGlvbk1pbnV0ZXMudG9GaXhlZCgxKX0gbWludXRlcywgY3JlYXRpbmcgJHtudW1iZXJPZkNodW5rc30gY2h1bmtzYCk7XG5cbiAgY29uc3QgY2h1bmtQYXRoczogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgYmFzZURpciA9IHBhdGguZGlybmFtZShhdWRpb0ZpbGVQYXRoKTtcbiAgY29uc3QgYmFzZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGF1ZGlvRmlsZVBhdGgsIHBhdGguZXh0bmFtZShhdWRpb0ZpbGVQYXRoKSk7XG4gIFxuICAvLyBTcGxpdCBhdWRpbyBpbnRvIGNodW5rc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ2h1bmtzOyBpKyspIHtcbiAgICBjb25zdCBjaHVua1BhdGggPSBwYXRoLmpvaW4oYmFzZURpciwgYCR7YmFzZU5hbWV9X2NodW5rXyR7aX0ubXAzYCk7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gaSAqIG1heENodW5rRHVyYXRpb25NaW51dGVzICogNjA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuICAgIFxuICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZmbXBlZyhhdWRpb0ZpbGVQYXRoKVxuICAgICAgICAuc2Vla0lucHV0KHN0YXJ0VGltZSlcbiAgICAgICAgLmR1cmF0aW9uKG1heENodW5rRHVyYXRpb25NaW51dGVzICogNjApIC8vIER1cmF0aW9uIGluIHNlY29uZHNcbiAgICAgICAgLmF1ZGlvQ29kZWMoJ2xpYm1wM2xhbWUnKVxuICAgICAgICAuYXVkaW9CaXRyYXRlKCc0OGsnKSAvLyBNYXRjaCB0aGUgbWFpbiBleHRyYWN0aW9uIGJpdHJhdGVcbiAgICAgICAgLmF1ZGlvQ2hhbm5lbHMoMSlcbiAgICAgICAgLmF1ZGlvRnJlcXVlbmN5KDE2MDAwKVxuICAgICAgICAuZm9ybWF0KCdtcDMnKVxuICAgICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQ3JlYXRlZCBjaHVuayAke2kgKyAxfS8ke251bWJlck9mQ2h1bmtzfTogJHtjaHVua1BhdGh9YCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRXJyb3IgY3JlYXRpbmcgY2h1bmsgJHtpICsgMX06YCwgZXJyb3IpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgYXVkaW8gY2h1bmsgJHtpICsgMX06ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5zYXZlKGNodW5rUGF0aCk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IGNodW5rIHdhcyBjcmVhdGVkIGFuZCBoYXMgcmVhc29uYWJsZSBzaXplXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNodW5rU3RhdHMgPSBhd2FpdCBmcy5zdGF0KGNodW5rUGF0aCk7XG4gICAgICBpZiAoY2h1bmtTdGF0cy5zaXplID4gMCkge1xuICAgICAgICBjaHVua1BhdGhzLnB1c2goY2h1bmtQYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQ2h1bmsgJHtpICsgMX0gaXMgZW1wdHksIHNraXBwaW5nYCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQ2h1bmsgJHtpICsgMX0gd2FzIG5vdCBjcmVhdGVkIHByb3Blcmx5LCBza2lwcGluZ2ApO1xuICAgIH1cbiAgfVxuICBcbiAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSBjcmVhdGVkICR7Y2h1bmtQYXRocy5sZW5ndGh9IGF1ZGlvIGNodW5rc2ApO1xuICByZXR1cm4gY2h1bmtQYXRocztcbn1cblxuLyoqXG4gKiBUcmFuc2NyaWJlcyBtdWx0aXBsZSBhdWRpbyBjaHVua3MgYW5kIGNvbWJpbmVzIHRoZSByZXN1bHRzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmVBdWRpb0NodW5rcyhjaHVua1BhdGhzOiBzdHJpbmdbXSk6IFByb21pc2U8VmlkZW9UcmFuc2NyaXB0aW9uUmVzdWx0PiB7XG4gIGlmIChjaHVua1BhdGhzLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFNpbmdsZSBjaHVuaywgdXNlIGV4aXN0aW5nIGZ1bmN0aW9uXG4gICAgcmV0dXJuIGF3YWl0IHRyYW5zY3JpYmVBdWRpb1dpdGhXaGlzcGVyKGNodW5rUGF0aHNbMF0pO1xuICB9XG5cbiAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIFRyYW5zY3JpYmluZyAke2NodW5rUGF0aHMubGVuZ3RofSBhdWRpbyBjaHVua3MuLi5gKTtcbiAgXG4gIGNvbnN0IHRyYW5zY3JpcHRzOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgdG90YWxEdXJhdGlvbiA9IDA7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNodW5rUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaHVua1BhdGggPSBjaHVua1BhdGhzW2ldO1xuICAgIGNvbnNvbGUubG9nKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBUcmFuc2NyaWJpbmcgY2h1bmsgJHtpICsgMX0vJHtjaHVua1BhdGhzLmxlbmd0aH06ICR7cGF0aC5iYXNlbmFtZShjaHVua1BhdGgpfWApO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjaHVua1Jlc3VsdCA9IGF3YWl0IHRyYW5zY3JpYmVBdWRpb1dpdGhXaGlzcGVyKGNodW5rUGF0aCk7XG4gICAgICBcbiAgICAgIGlmIChjaHVua1Jlc3VsdC5lcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBFcnJvciB0cmFuc2NyaWJpbmcgY2h1bmsgJHtpICsgMX06YCwgY2h1bmtSZXN1bHQuZXJyb3IpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxuICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHRyYW5zY3JpYmUgYXVkaW8gY2h1bmsgJHtpICsgMX06ICR7Y2h1bmtSZXN1bHQuZXJyb3J9YFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoY2h1bmtSZXN1bHQudHJhbnNjcmlwdCAmJiBjaHVua1Jlc3VsdC50cmFuc2NyaXB0LnRyaW0oKSkge1xuICAgICAgICB0cmFuc2NyaXB0cy5wdXNoKGNodW5rUmVzdWx0LnRyYW5zY3JpcHQudHJpbSgpKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2xlYW4gdXAgY2h1bmsgZmlsZSBhZnRlciBwcm9jZXNzaW5nXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmcy5yZW1vdmUoY2h1bmtQYXRoKTtcbiAgICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oYFtWaWRlb1RyYW5zY3JpcHRpb25dIEZhaWxlZCB0byBjbGVhbnVwIGNodW5rICR7aSArIDF9OmAsIGNsZWFudXBFcnJvcik7XG4gICAgICB9XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRXhjZXB0aW9uIHRyYW5zY3JpYmluZyBjaHVuayAke2kgKyAxfTpgLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcbiAgICAgICAgZXJyb3I6IGBFeGNlcHRpb24gZHVyaW5nIGNodW5rICR7aSArIDF9IHRyYW5zY3JpcHRpb246ICR7ZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcid9YFxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIENvbWJpbmUgYWxsIHRyYW5zY3JpcHRzXG4gIGNvbnN0IGNvbWJpbmVkVHJhbnNjcmlwdCA9IHRyYW5zY3JpcHRzLmpvaW4oJyAnKTtcbiAgXG4gIGNvbnNvbGUubG9nKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBTdWNjZXNzZnVsbHkgdHJhbnNjcmliZWQgJHt0cmFuc2NyaXB0cy5sZW5ndGh9IGNodW5rcywgdG90YWwgbGVuZ3RoOiAke2NvbWJpbmVkVHJhbnNjcmlwdC5sZW5ndGh9IGNoYXJhY3RlcnNgKTtcbiAgXG4gIHJldHVybiB7XG4gICAgdHJhbnNjcmlwdDogY29tYmluZWRUcmFuc2NyaXB0LFxuICAgIGxhbmd1YWdlOiAnYXV0by1kZXRlY3RlZCdcbiAgfTtcbn1cblxuLyoqXG4gKiBUcmFuc2NyaWJlcyBhdWRpbyBmaWxlIHVzaW5nIE9wZW5BSSBXaGlzcGVyIEFQSSAoaGFuZGxlcyBjaHVua2luZyBmb3IgbGFyZ2UgZmlsZXMpXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHRyYW5zY3JpYmVBdWRpb1dpdGhXaGlzcGVyKGF1ZGlvRmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8VmlkZW9UcmFuc2NyaXB0aW9uUmVzdWx0PiB7XG4gIHRyeSB7XG4gICAgaWYgKCFvcGVuYWkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIGNsaWVudCBub3QgaW5pdGlhbGl6ZWQgLSBjaGVjayBBUEkga2V5IGNvbmZpZ3VyYXRpb24nKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhdWRpbyBmaWxlIGV4aXN0cyBhbmQgZ2V0IGl0cyBzaXplXG4gICAgY29uc3QgYXVkaW9TdGF0cyA9IGF3YWl0IGZzLnN0YXQoYXVkaW9GaWxlUGF0aCk7XG4gICAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIEF1ZGlvIGZpbGUgc2l6ZTogJHsoYXVkaW9TdGF0cy5zaXplIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9IE1CYCk7XG5cbiAgICAvLyBPcGVuQUkgV2hpc3BlciBBUEkgaGFzIGEgMjVNQiBmaWxlIHNpemUgbGltaXQgLSB0aHJvdyBlcnJvciBpbW1lZGlhdGVseSBmb3IgbGFyZ2UgZmlsZXNcbiAgICBpZiAoYXVkaW9TdGF0cy5zaXplID4gMjUgKiAxMDI0ICogMTAyNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdWRpbyBmaWxlIHRvbyBsYXJnZSBmb3IgV2hpc3BlciBBUEkgKG1heCAyNU1CKS4gQ29uc2lkZXIgc3BsaXR0aW5nIHRoZSB2aWRlbyBpbnRvIHNtYWxsZXIgc2VnbWVudHMuYCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGEgZmlsZSBzdHJlYW0gZm9yIHRoZSBhdWRpb1xuICAgIGNvbnN0IGF1ZGlvU3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShhdWRpb0ZpbGVQYXRoKTtcblxuICAgIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBTZW5kaW5nIGF1ZGlvIHRvIE9wZW5BSSBXaGlzcGVyIEFQSS4uLicpO1xuICAgIFxuICAgIGNvbnN0IHRyYW5zY3JpcHRpb24gPSBhd2FpdCBvcGVuYWkuYXVkaW8udHJhbnNjcmlwdGlvbnMuY3JlYXRlKHtcbiAgICAgIGZpbGU6IGF1ZGlvU3RyZWFtLFxuICAgICAgbW9kZWw6ICd3aGlzcGVyLTEnLFxuICAgICAgbGFuZ3VhZ2U6IHVuZGVmaW5lZCwgLy8gQXV0by1kZXRlY3QgbGFuZ3VhZ2VcbiAgICAgIHJlc3BvbnNlX2Zvcm1hdDogJ3RleHQnLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuMSAvLyBMb3dlciB0ZW1wZXJhdHVyZSBmb3IgbW9yZSBjb25zaXN0ZW50IHRyYW5zY3JpcHRpb25cbiAgICB9KTtcblxuICAgIGlmICghdHJhbnNjcmlwdGlvbiB8fCB0eXBlb2YgdHJhbnNjcmlwdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBmcm9tIFdoaXNwZXIgQVBJJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIFRyYW5zY3JpcHRpb24gY29tcGxldGVkOiAke3RyYW5zY3JpcHRpb24ubGVuZ3RofSBjaGFyYWN0ZXJzYCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNjcmlwdDogdHJhbnNjcmlwdGlvbi50cmltKCksXG4gICAgICBsYW5ndWFnZTogJ2F1dG8tZGV0ZWN0ZWQnIC8vIFdoaXNwZXIgYXV0by1kZXRlY3RzIGxhbmd1YWdlXG4gICAgfTtcblxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIFdoaXNwZXIgQVBJIGVycm9yOicsIGVycm9yKTtcbiAgICBcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gQ2hlY2sgZm9yIHRoZSBjdXN0b20gZmlsZSBzaXplIGVycm9yIG1lc3NhZ2Ugd2UgbWlnaHQgcmV0dXJuIGRpcmVjdGx5IG9yIG90aGVyIGtub3duIHBhdHRlcm5zXG4gICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnQXVkaW8gZmlsZSB0b28gbGFyZ2UnKSB8fCBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdtYXggMjVNQicpIHx8IFxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ21heGltdW0gY29udGVudCBsZW5ndGggZXhjZWVkZWQnKSB8fCBcbiAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdmaWxlIHNpemUnKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxuICAgICAgICAgIGVycm9yOiAnQXVkaW8gZmlsZSBpcyB0b28gbGFyZ2UgZm9yIHRoZSB0cmFuc2NyaXB0aW9uIHNlcnZpY2UgKG1heCAyNU1CKS4gVGhpcyBzaG91bGQgYmUgaGFuZGxlZCBieSBjaHVua2luZy4nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ0FQSSBrZXknKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxuICAgICAgICAgIGVycm9yOiAnVHJhbnNjcmlwdGlvbiBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gZXJyb3IuIFBsZWFzZSBjb250YWN0IHN1cHBvcnQuJ1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdyYXRlIGxpbWl0JykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0cmFuc2NyaXB0OiAnJyxcbiAgICAgICAgICBlcnJvcjogJ1RyYW5zY3JpcHRpb24gc2VydmljZSBpcyB0ZW1wb3JhcmlseSBvdmVybG9hZGVkLiBQbGVhc2UgdHJ5IGFnYWluIGluIGEgZmV3IG1pbnV0ZXMuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2NyaXB0OiAnJyxcbiAgICAgIGVycm9yOiAnRmFpbGVkIHRvIHRyYW5zY3JpYmUgYXVkaW8uIFBsZWFzZSBlbnN1cmUgdGhlIHZpZGVvIGNvbnRhaW5zIGNsZWFyIHNwZWVjaCBvciBjaGVjayBzZXJ2aWNlIHN0YXR1cy4nXG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdmlkZW8gZmlsZSBpbmZvcm1hdGlvbiAoZHVyYXRpb24sIGZvcm1hdCwgZXRjLilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFZpZGVvSW5mbyh2aWRlb0ZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPHtcbiAgZHVyYXRpb246IG51bWJlcjtcbiAgZm9ybWF0OiBzdHJpbmc7XG4gIHNpemU6IG51bWJlcjtcbn0+IHtcbiAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5zdGF0KHZpZGVvRmlsZVBhdGgpO1xuICBcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBmZm1wZWcuZmZwcm9iZSh2aWRlb0ZpbGVQYXRoLCAoZXJyb3IsIG1ldGFkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGFuYWx5emUgdmlkZW86ICR7ZXJyb3IubWVzc2FnZX1gKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHVyYXRpb24gPSBtZXRhZGF0YS5mb3JtYXQuZHVyYXRpb24gfHwgMDtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IG1ldGFkYXRhLmZvcm1hdC5mb3JtYXRfbmFtZSB8fCAndW5rbm93bic7XG5cbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBzaXplOiBzdGF0cy5zaXplXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIGlmIHRoZSB1cGxvYWRlZCBmaWxlIGlzIGEgc3VwcG9ydGVkIHZpZGVvIGZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVWaWRlb0ZpbGUoZmlsZVBhdGg6IHN0cmluZywgb3JpZ2luYWxOYW1lOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIFZhbGlkYXRpbmcgZmlsZTogJHtvcmlnaW5hbE5hbWV9YCk7XG4gICAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIEZpbGUgcGF0aDogJHtmaWxlUGF0aH1gKTtcbiAgICBcbiAgICAvLyBGaXJzdCBjaGVjayBpZiBmaWxlIGV4aXN0c1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZpbGUgZG9lcyBub3QgZXhpc3QgYXQgcGF0aDonLCBmaWxlUGF0aCk7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmaWxlIHNpemVcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhdHMgPSBmcy5zdGF0U3luYyhmaWxlUGF0aCk7XG4gICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRmlsZSBzaXplOiAkeyhzdGF0cy5zaXplIC8gMTAyNCAvIDEwMjQpLnRvRml4ZWQoMil9IE1CYCk7XG4gICAgICBcbiAgICAgIGlmIChzdGF0cy5zaXplID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZpbGUgaXMgZW1wdHknKTtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRXJyb3IgcmVhZGluZyBmaWxlIHN0YXRzOicsIGVycm9yKTtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNldCBhIHRpbWVvdXQgZm9yIEZGcHJvYmUgdG8gcHJldmVudCBoYW5naW5nXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIHRpbWVvdXQsIHVzaW5nIGZhbGxiYWNrIHZhbGlkYXRpb24nKTtcbiAgICAgIGNvbnN0IHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBbJy5tcDQnLCAnLm1vdicsICcud2VibScsICcuYXZpJywgJy5ta3YnXTtcbiAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUob3JpZ2luYWxOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgY29uc3QgaXNWYWxpZEV4dGVuc2lvbiA9IHN1cHBvcnRlZEV4dGVuc2lvbnMuaW5jbHVkZXMoZmlsZUV4dGVuc2lvbik7XG4gICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gVGltZW91dCBmYWxsYmFjayAtIEV4dGVuc2lvbjogJHtmaWxlRXh0ZW5zaW9ufSwgVmFsaWQ6ICR7aXNWYWxpZEV4dGVuc2lvbn1gKTtcbiAgICAgIHJlc29sdmUoaXNWYWxpZEV4dGVuc2lvbik7XG4gICAgfSwgMTAwMDApOyAvLyAxMCBzZWNvbmQgdGltZW91dFxuXG4gICAgZmZtcGVnLmZmcHJvYmUoZmlsZVBhdGgsIChlcnJvciwgbWV0YWRhdGEpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTsgLy8gQ2xlYXIgdGhlIHRpbWVvdXQgc2luY2Ugd2UgZ290IGEgcmVzcG9uc2VcbiAgICAgIFxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZGcHJvYmUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIGVycm9yIG1lc3NhZ2U6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBGRnByb2JlIGZhaWxzLCB1c2UgZmFsbGJhY2sgdmFsaWRhdGlvbiBiYXNlZCBvbiBmaWxlIGV4dGVuc2lvbiBhbmQgTUlNRSB0eXBlXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEV4dGVuc2lvbnMgPSBbJy5tcDQnLCAnLm1vdicsICcud2VibScsICcuYXZpJywgJy5ta3YnXTtcbiAgICAgICAgY29uc3QgZmlsZUV4dGVuc2lvbiA9IHBhdGguZXh0bmFtZShvcmlnaW5hbE5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRFeHRlbnNpb24gPSBzdXBwb3J0ZWRFeHRlbnNpb25zLmluY2x1ZGVzKGZpbGVFeHRlbnNpb24pO1xuICAgICAgICBcbiAgICAgICAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIEZGcHJvYmUgZmFpbGVkLCB1c2luZyBmYWxsYmFjayB2YWxpZGF0aW9uYCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBGaWxlIGV4dGVuc2lvbjogJHtmaWxlRXh0ZW5zaW9ufWApO1xuICAgICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gVmFsaWQgZXh0ZW5zaW9uOiAke2lzVmFsaWRFeHRlbnNpb259YCk7XG4gICAgICAgIFxuICAgICAgICAvLyBCZSBtb3JlIHBlcm1pc3NpdmUgLSBpZiBpdCBoYXMgYSB2YWxpZCBleHRlbnNpb24sIGFsbG93IGl0IHRocm91Z2hcbiAgICAgICAgLy8gVGhlIHRyYW5zY3JpcHRpb24gcHJvY2VzcyB3aWxsIGNhdGNoIGFueSByZWFsIGlzc3Vlc1xuICAgICAgICByZXNvbHZlKGlzVmFsaWRFeHRlbnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIG1ldGFkYXRhIG9idGFpbmVkIHN1Y2Nlc3NmdWxseScpO1xuICAgICAgY29uc29sZS5sb2coJ1tWaWRlb1RyYW5zY3JpcHRpb25dIEZvcm1hdDonLCBtZXRhZGF0YS5mb3JtYXQ/LmZvcm1hdF9uYW1lKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBEdXJhdGlvbjonLCBtZXRhZGF0YS5mb3JtYXQ/LmR1cmF0aW9uKTtcbiAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBTdHJlYW1zIGNvdW50OicsIG1ldGFkYXRhLnN0cmVhbXM/Lmxlbmd0aCk7XG5cbiAgICAgIGlmICghbWV0YWRhdGEuc3RyZWFtcyB8fCBtZXRhZGF0YS5zdHJlYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBObyBzdHJlYW1zIGZvdW5kIGluIGZpbGUnKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEV2ZW4gaWYgbm8gc3RyZWFtcyBmb3VuZCwgdHJ5IGZhbGxiYWNrIHZhbGlkYXRpb25cbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkRXh0ZW5zaW9ucyA9IFsnLm1wNCcsICcubW92JywgJy53ZWJtJywgJy5hdmknLCAnLm1rdiddO1xuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKG9yaWdpbmFsTmFtZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaXNWYWxpZEV4dGVuc2lvbiA9IHN1cHBvcnRlZEV4dGVuc2lvbnMuaW5jbHVkZXMoZmlsZUV4dGVuc2lvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBObyBzdHJlYW1zIGZhbGxiYWNrIC0gRXh0ZW5zaW9uOiAke2ZpbGVFeHRlbnNpb259LCBWYWxpZDogJHtpc1ZhbGlkRXh0ZW5zaW9ufWApO1xuICAgICAgICByZXNvbHZlKGlzVmFsaWRFeHRlbnNpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGZpbGUgaGFzIHZpZGVvIHN0cmVhbXNcbiAgICAgIGNvbnN0IGhhc1ZpZGVvU3RyZWFtID0gbWV0YWRhdGEuc3RyZWFtcy5zb21lKHN0cmVhbSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBTdHJlYW0gdHlwZTogJHtzdHJlYW0uY29kZWNfdHlwZX0sIGNvZGVjOiAke3N0cmVhbS5jb2RlY19uYW1lfWApO1xuICAgICAgICByZXR1cm4gc3RyZWFtLmNvZGVjX3R5cGUgPT09ICd2aWRlbyc7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgY29uc3QgaGFzQXVkaW9TdHJlYW0gPSBtZXRhZGF0YS5zdHJlYW1zLnNvbWUoc3RyZWFtID0+IHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5jb2RlY190eXBlID09PSAnYXVkaW8nO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW9UcmFuc2NyaXB0aW9uXSBIYXMgdmlkZW8gc3RyZWFtOiAke2hhc1ZpZGVvU3RyZWFtfWApO1xuICAgICAgY29uc29sZS5sb2coYFtWaWRlb1RyYW5zY3JpcHRpb25dIEhhcyBhdWRpbyBzdHJlYW06ICR7aGFzQXVkaW9TdHJlYW19YCk7XG5cbiAgICAgIC8vIEZvciBub3RlIGdlbmVyYXRpb24sIHdlIHByaW1hcmlseSBuZWVkIGF1ZGlvLCBidXQgdmlkZW8gcHJlc2VuY2UgaXMgYWxzbyBnb29kXG4gICAgICBjb25zdCBpc1ZhbGlkID0gaGFzQXVkaW9TdHJlYW0gfHwgaGFzVmlkZW9TdHJlYW07XG4gICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRmlsZSB2YWxpZGF0aW9uIHJlc3VsdDogJHtpc1ZhbGlkfWApO1xuICAgICAgXG4gICAgICAvLyBJZiBGRnByb2JlIHNheXMgaW52YWxpZCBidXQgZmlsZSBoYXMgcHJvcGVyIGV4dGVuc2lvbiwgYmUgbW9yZSBsZW5pZW50XG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBGRnByb2JlIHZhbGlkYXRpb24gZmFpbGVkLCBjaGVja2luZyBmYWxsYmFjay4uLicpO1xuICAgICAgICBjb25zdCBzdXBwb3J0ZWRFeHRlbnNpb25zID0gWycubXA0JywgJy5tb3YnLCAnLndlYm0nLCAnLmF2aScsICcubWt2J107XG4gICAgICAgIGNvbnN0IGZpbGVFeHRlbnNpb24gPSBwYXRoLmV4dG5hbWUob3JpZ2luYWxOYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkRXh0ZW5zaW9uID0gc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlRXh0ZW5zaW9uKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc1ZhbGlkRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdbVmlkZW9UcmFuc2NyaXB0aW9uXSBVc2luZyBmYWxsYmFjayB2YWxpZGF0aW9uIC0gZmlsZSBoYXMgdmFsaWQgZXh0ZW5zaW9uJyk7XG4gICAgICAgICAgcmVzb2x2ZSh0cnVlKTsgLy8gQmUgcGVybWlzc2l2ZSBmb3IgZmlsZXMgd2l0aCBjb3JyZWN0IGV4dGVuc2lvbnNcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVzb2x2ZShpc1ZhbGlkKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNhZmUgdGVtcG9yYXJ5IGRpcmVjdG9yeSBmb3IgdmlkZW8gcHJvY2Vzc2luZ1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVGVtcERpcmVjdG9yeSgpOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zdCB0ZW1wRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICd0ZW1wJywgJ3ZpZGVvLXByb2Nlc3NpbmcnLCBgc2Vzc2lvbl8ke0RhdGUubm93KCl9YCk7XG4gIGF3YWl0IGZzLmVuc3VyZURpcih0ZW1wRGlyKTtcbiAgcmV0dXJuIHRlbXBEaXI7XG59XG5cbi8qKlxuICogQ2xlYW5zIHVwIHRlbXBvcmFyeSBmaWxlcyBhbmQgZGlyZWN0b3JpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFudXBUZW1wRGlyZWN0b3J5KHRlbXBEaXI6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGF3YWl0IGZzLnJlbW92ZSh0ZW1wRGlyKTtcbiAgICBjb25zb2xlLmxvZyhgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gQ2xlYW5lZCB1cCB0ZW1wIGRpcmVjdG9yeTogJHt0ZW1wRGlyfWApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUud2FybihgW1ZpZGVvVHJhbnNjcmlwdGlvbl0gRmFpbGVkIHRvIGNsZWFudXAgdGVtcCBkaXJlY3Rvcnk6ICR7dGVtcERpcn1gLCBlcnJvcik7XG4gIH1cbn0gIl0sIm5hbWVzIjpbImZmbXBlZyIsImZzIiwicGF0aCIsIk9wZW5BSSIsImZmbXBlZ1BhdGhTZXQiLCJmZnByb2JlUGF0aFNldCIsImZmbXBlZ0luc3RhbGxlciIsInJlcXVpcmUiLCJleGlzdHNTeW5jIiwic2V0RmZtcGVnUGF0aCIsImNvbnNvbGUiLCJsb2ciLCJ3YXJuIiwiZXJyb3IiLCJzZXRGZnByb2JlUGF0aCIsImNvbW1vblBhdGhzIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJmZnByb2JlIiwicGF0aHMiLCJ0ZXN0RkZtcGVnQXZhaWxhYmlsaXR5IiwicmVzdWx0cyIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2V0QXZhaWxhYmxlRm9ybWF0cyIsImVyciIsIm1lc3NhZ2UiLCJwcm9iZUVyciIsIm1ldGFkYXRhIiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIm9wZW5haSIsImFwaUtleSIsImVudiIsIk9QRU5BSV9BUElfS0VZIiwidHJhbnNjcmliZVZpZGVvRmlsZSIsInZpZGVvRmlsZVBhdGgiLCJvdXRwdXREaXIiLCJwcm9ncmVzc0NhbGxiYWNrIiwidGVtcERpciIsImF1ZGlvRmlsZU5hbWUiLCJEYXRlIiwibm93IiwiYXVkaW9GaWxlUGF0aCIsImZmbXBlZ0F2YWlsYWJsZSIsImZmcHJvYmVBdmFpbGFibGUiLCJ0cmFuc2NyaXB0IiwiZW5zdXJlRGlyIiwic3RlcCIsInByb2dyZXNzIiwiZXh0cmFjdEF1ZGlvRnJvbVZpZGVvIiwiYXVkaW9TdGF0cyIsInN0YXQiLCJzaXplIiwidG9GaXhlZCIsInRyYW5zY3JpcHRpb25SZXN1bHQiLCJjaHVua1BhdGhzIiwic3BsaXRBdWRpb0ludG9DaHVua3MiLCJsZW5ndGgiLCJ0cmFuc2NyaWJlQXVkaW9DaHVua3MiLCJ0cmFuc2NyaWJlQXVkaW9XaXRoV2hpc3BlciIsInJlbW92ZSIsImNsZWFudXBFcnJvciIsIkVycm9yIiwidmlkZW9QYXRoIiwib3V0cHV0UGF0aCIsInJlamVjdCIsImR1cmF0aW9uIiwiYXVkaW9Db2RlYyIsImF1ZGlvQml0cmF0ZSIsImF1ZGlvQ2hhbm5lbHMiLCJhdWRpb0ZyZXF1ZW5jeSIsImZvcm1hdCIsIm9uIiwiZGF0YSIsImR1cmF0aW9uTWF0Y2giLCJtYXRjaCIsImhvdXJzIiwicGFyc2VJbnQiLCJtaW51dGVzIiwic2Vjb25kcyIsInBhcnNlRmxvYXQiLCJ0aW1lbWFyayIsInRpbWVNYXRjaCIsInRvU3RyaW5nIiwiY3VycmVudFRpbWUiLCJwZXJjZW50IiwiTWF0aCIsIm1pbiIsInJvdW5kIiwiZXJyb3JNZXNzYWdlIiwic2F2ZSIsIm1heFNpemVCeXRlcyIsImVzdGltYXRlZER1cmF0aW9uTWludXRlcyIsIm1heENodW5rRHVyYXRpb25NaW51dGVzIiwibnVtYmVyT2ZDaHVua3MiLCJjZWlsIiwiYmFzZURpciIsImRpcm5hbWUiLCJiYXNlTmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSIsImkiLCJjaHVua1BhdGgiLCJzdGFydFRpbWUiLCJzZWVrSW5wdXQiLCJjaHVua1N0YXRzIiwicHVzaCIsInRyYW5zY3JpcHRzIiwidG90YWxEdXJhdGlvbiIsImNodW5rUmVzdWx0IiwidHJpbSIsImNvbWJpbmVkVHJhbnNjcmlwdCIsImxhbmd1YWdlIiwiYXVkaW9TdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwidHJhbnNjcmlwdGlvbiIsImF1ZGlvIiwidHJhbnNjcmlwdGlvbnMiLCJjcmVhdGUiLCJmaWxlIiwibW9kZWwiLCJ1bmRlZmluZWQiLCJyZXNwb25zZV9mb3JtYXQiLCJ0ZW1wZXJhdHVyZSIsImdldFZpZGVvSW5mbyIsInN0YXRzIiwiZm9ybWF0X25hbWUiLCJ2YWxpZGF0ZVZpZGVvRmlsZSIsImZpbGVQYXRoIiwib3JpZ2luYWxOYW1lIiwic3RhdFN5bmMiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsInN1cHBvcnRlZEV4dGVuc2lvbnMiLCJmaWxlRXh0ZW5zaW9uIiwiaXNWYWxpZEV4dGVuc2lvbiIsImNsZWFyVGltZW91dCIsInN0cmVhbXMiLCJoYXNWaWRlb1N0cmVhbSIsInNvbWUiLCJzdHJlYW0iLCJjb2RlY190eXBlIiwiY29kZWNfbmFtZSIsImhhc0F1ZGlvU3RyZWFtIiwiaXNWYWxpZCIsImNyZWF0ZVRlbXBEaXJlY3RvcnkiLCJjbGVhbnVwVGVtcERpcmVjdG9yeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/services/videoTranscription.ts\n");

/***/ }),

/***/ "(rsc)/./src/utils/splitTranscript.ts":
/*!**************************************!*\
  !*** ./src/utils/splitTranscript.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateTokenCount: () => (/* binding */ estimateTokenCount),\n/* harmony export */   isChunkWithinTokenLimit: () => (/* binding */ isChunkWithinTokenLimit),\n/* harmony export */   splitTranscriptIntoChunks: () => (/* binding */ splitTranscriptIntoChunks)\n/* harmony export */ });\n/**\n * Represents a chunk of text with metadata\n */ /**\n * Splits a transcript into chunks based on word count\n * @param transcript The full transcript text to split\n * @param maxWords Maximum number of words per chunk (default: 800)\n * @returns Array of TranscriptChunk objects\n */ function splitTranscriptIntoChunks(transcript, maxWords = 800) {\n    // Split into words and filter out empty strings\n    const words = transcript.split(/\\s+/).filter((word)=>word.length > 0);\n    const chunks = [];\n    for(let i = 0; i < words.length; i += maxWords){\n        const startWord = i;\n        const endWord = Math.min(i + maxWords, words.length);\n        const chunkWords = words.slice(startWord, endWord);\n        chunks.push({\n            content: chunkWords.join(\" \"),\n            index: chunks.length,\n            wordCount: chunkWords.length,\n            startWord,\n            endWord\n        });\n    }\n    return chunks;\n}\n/**\n * Estimates the number of tokens in a text string\n * This is a rough estimate: ~4 characters per token on average\n * @param text The text to estimate tokens for\n * @returns Estimated number of tokens\n */ function estimateTokenCount(text) {\n    return Math.ceil(text.length / 4);\n}\n/**\n * Validates if a chunk is within safe token limits\n * @param chunk The chunk to validate\n * @param maxTokens Maximum allowed tokens (default: 3000)\n * @returns boolean indicating if chunk is within limits\n */ function isChunkWithinTokenLimit(chunk, maxTokens = 3000) {\n    return estimateTokenCount(chunk.content) <= maxTokens;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvdXRpbHMvc3BsaXRUcmFuc2NyaXB0LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBb0JEOzs7OztDQUtDLEdBQ00sU0FBU0EsMEJBQ2RDLFVBQWtCLEVBQ2xCQyxXQUFtQixHQUFHO0lBRXRCLGdEQUFnRDtJQUNoRCxNQUFNQyxRQUFRRixXQUFXRyxLQUFLLENBQUMsT0FBT0MsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxNQUFNLEdBQUc7SUFDbkUsTUFBTUMsU0FBNEIsRUFBRTtJQUVwQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sTUFBTUksTUFBTSxFQUFFRSxLQUFLUCxTQUFVO1FBQy9DLE1BQU1RLFlBQVlEO1FBQ2xCLE1BQU1FLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQ0osSUFBSVAsVUFBVUMsTUFBTUksTUFBTTtRQUNuRCxNQUFNTyxhQUFhWCxNQUFNWSxLQUFLLENBQUNMLFdBQVdDO1FBRTFDSCxPQUFPUSxJQUFJLENBQUM7WUFDVkMsU0FBU0gsV0FBV0ksSUFBSSxDQUFDO1lBQ3pCQyxPQUFPWCxPQUFPRCxNQUFNO1lBQ3BCYSxXQUFXTixXQUFXUCxNQUFNO1lBQzVCRztZQUNBQztRQUNGO0lBQ0Y7SUFFQSxPQUFPSDtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTYSxtQkFBbUJDLElBQVk7SUFDN0MsT0FBT1YsS0FBS1csSUFBSSxDQUFDRCxLQUFLZixNQUFNLEdBQUc7QUFDakM7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNpQix3QkFDZEMsS0FBc0IsRUFDdEJDLFlBQW9CLElBQUk7SUFFeEIsT0FBT0wsbUJBQW1CSSxNQUFNUixPQUFPLEtBQUtTO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL3V0aWxzL3NwbGl0VHJhbnNjcmlwdC50cz9jZmVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIHRleHQgd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRDaHVuayB7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgaW5kZXg6IG51bWJlcjtcbiAgd29yZENvdW50OiBudW1iZXI7XG4gIHN0YXJ0V29yZDogbnVtYmVyO1xuICBlbmRXb3JkOiBudW1iZXI7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZhaWxlZCBjaHVuayBwcm9jZXNzaW5nIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGYWlsZWRDaHVuayB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHJlYXNvbjogc3RyaW5nO1xuICBhdHRlbXB0czogbnVtYmVyO1xuICBzdGFydFdvcmQ6IG51bWJlcjtcbiAgZW5kV29yZDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhIHRyYW5zY3JpcHQgaW50byBjaHVua3MgYmFzZWQgb24gd29yZCBjb3VudFxuICogQHBhcmFtIHRyYW5zY3JpcHQgVGhlIGZ1bGwgdHJhbnNjcmlwdCB0ZXh0IHRvIHNwbGl0XG4gKiBAcGFyYW0gbWF4V29yZHMgTWF4aW11bSBudW1iZXIgb2Ygd29yZHMgcGVyIGNodW5rIChkZWZhdWx0OiA4MDApXG4gKiBAcmV0dXJucyBBcnJheSBvZiBUcmFuc2NyaXB0Q2h1bmsgb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRUcmFuc2NyaXB0SW50b0NodW5rcyhcbiAgdHJhbnNjcmlwdDogc3RyaW5nLFxuICBtYXhXb3JkczogbnVtYmVyID0gODAwXG4pOiBUcmFuc2NyaXB0Q2h1bmtbXSB7XG4gIC8vIFNwbGl0IGludG8gd29yZHMgYW5kIGZpbHRlciBvdXQgZW1wdHkgc3RyaW5nc1xuICBjb25zdCB3b3JkcyA9IHRyYW5zY3JpcHQuc3BsaXQoL1xccysvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApO1xuICBjb25zdCBjaHVua3M6IFRyYW5zY3JpcHRDaHVua1tdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gbWF4V29yZHMpIHtcbiAgICBjb25zdCBzdGFydFdvcmQgPSBpO1xuICAgIGNvbnN0IGVuZFdvcmQgPSBNYXRoLm1pbihpICsgbWF4V29yZHMsIHdvcmRzLmxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmtXb3JkcyA9IHdvcmRzLnNsaWNlKHN0YXJ0V29yZCwgZW5kV29yZCk7XG4gICAgXG4gICAgY2h1bmtzLnB1c2goe1xuICAgICAgY29udGVudDogY2h1bmtXb3Jkcy5qb2luKCcgJyksXG4gICAgICBpbmRleDogY2h1bmtzLmxlbmd0aCxcbiAgICAgIHdvcmRDb3VudDogY2h1bmtXb3Jkcy5sZW5ndGgsXG4gICAgICBzdGFydFdvcmQsXG4gICAgICBlbmRXb3JkXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiBhIHRleHQgc3RyaW5nXG4gKiBUaGlzIGlzIGEgcm91Z2ggZXN0aW1hdGU6IH40IGNoYXJhY3RlcnMgcGVyIHRva2VuIG9uIGF2ZXJhZ2VcbiAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGVzdGltYXRlIHRva2VucyBmb3JcbiAqIEByZXR1cm5zIEVzdGltYXRlZCBudW1iZXIgb2YgdG9rZW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRva2VuQ291bnQodGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0ZXh0Lmxlbmd0aCAvIDQpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIGNodW5rIGlzIHdpdGhpbiBzYWZlIHRva2VuIGxpbWl0c1xuICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byB2YWxpZGF0ZVxuICogQHBhcmFtIG1heFRva2VucyBNYXhpbXVtIGFsbG93ZWQgdG9rZW5zIChkZWZhdWx0OiAzMDAwKVxuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNodW5rIGlzIHdpdGhpbiBsaW1pdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0KFxuICBjaHVuazogVHJhbnNjcmlwdENodW5rLFxuICBtYXhUb2tlbnM6IG51bWJlciA9IDMwMDBcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gZXN0aW1hdGVUb2tlbkNvdW50KGNodW5rLmNvbnRlbnQpIDw9IG1heFRva2Vucztcbn0gIl0sIm5hbWVzIjpbInNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MiLCJ0cmFuc2NyaXB0IiwibWF4V29yZHMiLCJ3b3JkcyIsInNwbGl0IiwiZmlsdGVyIiwid29yZCIsImxlbmd0aCIsImNodW5rcyIsImkiLCJzdGFydFdvcmQiLCJlbmRXb3JkIiwiTWF0aCIsIm1pbiIsImNodW5rV29yZHMiLCJzbGljZSIsInB1c2giLCJjb250ZW50Iiwiam9pbiIsImluZGV4Iiwid29yZENvdW50IiwiZXN0aW1hdGVUb2tlbkNvdW50IiwidGV4dCIsImNlaWwiLCJpc0NodW5rV2l0aGluVG9rZW5MaW1pdCIsImNodW5rIiwibWF4VG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/utils/splitTranscript.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions","vendor-chunks/formdata-node","vendor-chunks/openai","vendor-chunks/web-streams-polyfill","vendor-chunks/event-target-shim","vendor-chunks/agentkeepalive","vendor-chunks/form-data-encoder","vendor-chunks/abort-controller","vendor-chunks/ms","vendor-chunks/humanize-ms","vendor-chunks/isexe","vendor-chunks/fs-extra","vendor-chunks/fluent-ffmpeg","vendor-chunks/graceful-fs","vendor-chunks/@ffmpeg-installer","vendor-chunks/jsonfile","vendor-chunks/universalify","vendor-chunks/async"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fupload-video%2Froute&page=%2Fapi%2Fupload-video%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fupload-video%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();