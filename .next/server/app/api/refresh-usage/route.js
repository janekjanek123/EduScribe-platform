"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/refresh-usage/route";
exports.ids = ["app/api/refresh-usage/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frefresh-usage%2Froute&page=%2Fapi%2Frefresh-usage%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frefresh-usage%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frefresh-usage%2Froute&page=%2Fapi%2Frefresh-usage%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frefresh-usage%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_janjedrach_Cursor_eduscribe_src_app_api_refresh_usage_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/refresh-usage/route.ts */ \"(rsc)/./src/app/api/refresh-usage/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/refresh-usage/route\",\n        pathname: \"/api/refresh-usage\",\n        filename: \"route\",\n        bundlePath: \"app/api/refresh-usage/route\"\n    },\n    resolvedPagePath: \"/Users/janjedrach/Cursor/eduscribe/src/app/api/refresh-usage/route.ts\",\n    nextConfigOutput,\n    userland: _Users_janjedrach_Cursor_eduscribe_src_app_api_refresh_usage_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/refresh-usage/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZyZWZyZXNoLXVzYWdlJTJGcm91dGUmcGFnZT0lMkZhcGklMkZyZWZyZXNoLXVzYWdlJTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGcmVmcmVzaC11c2FnZSUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9anMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz1tZHgmcm9vdERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9c3RhbmRhbG9uZSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNxQjtBQUNsRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8/ZmMwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvamFuamVkcmFjaC9DdXJzb3IvZWR1c2NyaWJlL3NyYy9hcHAvYXBpL3JlZnJlc2gtdXNhZ2Uvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwic3RhbmRhbG9uZVwiXG5jb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBBcHBSb3V0ZVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5BUFBfUk9VVEUsXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9yZWZyZXNoLXVzYWdlL3JvdXRlXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvcmVmcmVzaC11c2FnZVwiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcmVmcmVzaC11c2FnZS9yb3V0ZVwiXG4gICAgfSxcbiAgICByZXNvbHZlZFBhZ2VQYXRoOiBcIi9Vc2Vycy9qYW5qZWRyYWNoL0N1cnNvci9lZHVzY3JpYmUvc3JjL2FwcC9hcGkvcmVmcmVzaC11c2FnZS9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvcmVmcmVzaC11c2FnZS9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frefresh-usage%2Froute&page=%2Fapi%2Frefresh-usage%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frefresh-usage%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/refresh-usage/route.ts":
/*!********************************************!*\
  !*** ./src/app/api/refresh-usage/route.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   dynamic: () => (/* binding */ dynamic)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _services_subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/subscription */ \"(rsc)/./src/services/subscription.ts\");\n\n\n\n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * POST endpoint to refresh user's saved notes count\n */ async function POST(request) {\n    console.log(\"[Refresh Usage API] Request received: POST\");\n    try {\n        // STEP 1: Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[Refresh Usage API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_2__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[Refresh Usage API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[Refresh Usage API] User authenticated: ${user.id}`);\n        // STEP 2: Refresh the saved notes count\n        console.log(\"[Refresh Usage API] Refreshing saved notes count...\");\n        const success = await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_1__.refreshSavedNotesCount)(user.id, token);\n        if (!success) {\n            console.error(\"[Refresh Usage API] Failed to refresh saved notes count\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Refresh failed\",\n                message: \"Failed to refresh saved notes count\"\n            }, {\n                status: 500\n            });\n        }\n        // STEP 3: Get the updated usage data\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { data: usage, error: usageError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", user.id).eq(\"month_year\", currentMonth).single();\n        if (usageError) {\n            console.error(\"[Refresh Usage API] Error fetching updated usage:\", usageError);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: true,\n                message: \"Saved notes count refreshed successfully, but could not fetch updated data\"\n            });\n        }\n        console.log(`[Refresh Usage API] Successfully refreshed usage for user ${user.id}`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"Saved notes count refreshed successfully\",\n            data: usage\n        });\n    } catch (error) {\n        console.error(\"[Refresh Usage API] Error refreshing usage:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred while refreshing usage\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n// Configure dynamic behavior to avoid caching\nconst dynamic = \"force-dynamic\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9yZWZyZXNoLXVzYWdlL3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXdEO0FBQ0g7QUFDWTtBQUVqRSw2QkFBNkI7QUFDN0IsTUFBTUcsY0FBY0MsMENBQW9DO0FBQ3hELE1BQU1HLGtCQUFrQkgsa05BQXlDO0FBRWpFOztDQUVDLEdBQ00sZUFBZUssS0FBS0MsT0FBb0I7SUFDN0NDLFFBQVFDLEdBQUcsQ0FBQztJQUVaLElBQUk7UUFDRixtQ0FBbUM7UUFDbkMsTUFBTUMsYUFBYUgsUUFBUUksT0FBTyxDQUFDQyxHQUFHLENBQUM7UUFDdkMsSUFBSSxDQUFDRixjQUFjLENBQUNBLFdBQVdHLFVBQVUsQ0FBQyxZQUFZO1lBQ3BETCxRQUFRTSxLQUFLLENBQUM7WUFDZCxPQUFPakIscURBQVlBLENBQUNrQixJQUFJLENBQUM7Z0JBQ3ZCQyxTQUFTO2dCQUNURixPQUFPO2dCQUNQRyxTQUFTO1lBQ1gsR0FBRztnQkFBRUMsUUFBUTtZQUFJO1FBQ25CO1FBRUEsNENBQTRDO1FBQzVDLE1BQU1DLFFBQVFULFdBQVdVLE9BQU8sQ0FBQyxXQUFXO1FBQzVDLE1BQU1DLFdBQVd2QixtRUFBWUEsQ0FBQ0UsYUFBYUksaUJBQWlCO1lBQzFEa0IsUUFBUTtnQkFDTlgsU0FBUztvQkFDUFksZUFBZSxDQUFDLE9BQU8sRUFBRUosTUFBTSxDQUFDO2dCQUNsQztZQUNGO1FBQ0Y7UUFFQSwwQkFBMEI7UUFDMUIsTUFBTSxFQUFFSyxNQUFNLEVBQUVDLElBQUksRUFBRSxFQUFFWCxPQUFPWSxTQUFTLEVBQUUsR0FBRyxNQUFNTCxTQUFTTSxJQUFJLENBQUNDLE9BQU8sQ0FBQ1Q7UUFDekUsSUFBSU8sYUFBYSxDQUFDRCxNQUFNO1lBQ3RCakIsUUFBUU0sS0FBSyxDQUFDLDhDQUE4Q1ksV0FBV1Q7WUFDdkUsT0FBT3BCLHFEQUFZQSxDQUFDa0IsSUFBSSxDQUFDO2dCQUN2QkMsU0FBUztnQkFDVEYsT0FBTztnQkFDUEcsU0FBU1MsV0FBV1QsV0FBVztZQUNqQyxHQUFHO2dCQUFFQyxRQUFRO1lBQUk7UUFDbkI7UUFFQVYsUUFBUUMsR0FBRyxDQUFDLENBQUMsd0NBQXdDLEVBQUVnQixLQUFLSSxFQUFFLENBQUMsQ0FBQztRQUVoRSx3Q0FBd0M7UUFDeENyQixRQUFRQyxHQUFHLENBQUM7UUFDWixNQUFNTyxVQUFVLE1BQU1qQiw4RUFBc0JBLENBQUMwQixLQUFLSSxFQUFFLEVBQUVWO1FBRXRELElBQUksQ0FBQ0gsU0FBUztZQUNaUixRQUFRTSxLQUFLLENBQUM7WUFDZCxPQUFPakIscURBQVlBLENBQUNrQixJQUFJLENBQUM7Z0JBQ3ZCQyxTQUFTO2dCQUNURixPQUFPO2dCQUNQRyxTQUFTO1lBQ1gsR0FBRztnQkFBRUMsUUFBUTtZQUFJO1FBQ25CO1FBRUEscUNBQXFDO1FBQ3JDLE1BQU1ZLGVBQWUsSUFBSUMsT0FBT0MsV0FBVyxHQUFHQyxLQUFLLENBQUMsR0FBRztRQUN2RCxNQUFNLEVBQUVULE1BQU1VLEtBQUssRUFBRXBCLE9BQU9xQixVQUFVLEVBQUUsR0FBRyxNQUFNZCxTQUM5Q2UsSUFBSSxDQUFDLGNBQ0xDLE1BQU0sQ0FBQyxLQUNQQyxFQUFFLENBQUMsV0FBV2IsS0FBS0ksRUFBRSxFQUNyQlMsRUFBRSxDQUFDLGNBQWNSLGNBQ2pCUyxNQUFNO1FBRVQsSUFBSUosWUFBWTtZQUNkM0IsUUFBUU0sS0FBSyxDQUFDLHFEQUFxRHFCO1lBQ25FLE9BQU90QyxxREFBWUEsQ0FBQ2tCLElBQUksQ0FBQztnQkFDdkJDLFNBQVM7Z0JBQ1RDLFNBQVM7WUFDWDtRQUNGO1FBRUFULFFBQVFDLEdBQUcsQ0FBQyxDQUFDLDBEQUEwRCxFQUFFZ0IsS0FBS0ksRUFBRSxDQUFDLENBQUM7UUFFbEYsT0FBT2hDLHFEQUFZQSxDQUFDa0IsSUFBSSxDQUFDO1lBQ3ZCQyxTQUFTO1lBQ1RDLFNBQVM7WUFDVE8sTUFBTVU7UUFDUjtJQUVGLEVBQUUsT0FBT3BCLE9BQVk7UUFDbkJOLFFBQVFNLEtBQUssQ0FBQywrQ0FBK0NBO1FBQzdELE9BQU9qQixxREFBWUEsQ0FBQ2tCLElBQUksQ0FBQztZQUN2QkMsU0FBUztZQUNURixPQUFPO1lBQ1BHLFNBQVM7WUFDVHVCLFNBQVMxQixNQUFNRyxPQUFPO1FBQ3hCLEdBQUc7WUFBRUMsUUFBUTtRQUFJO0lBQ25CO0FBQ0Y7QUFFQSw4Q0FBOEM7QUFDdkMsTUFBTXVCLFVBQVUsZ0JBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL2FwcC9hcGkvcmVmcmVzaC11c2FnZS9yb3V0ZS50cz9lOTcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgcmVmcmVzaFNhdmVkTm90ZXNDb3VudCB9IGZyb20gJ0Avc2VydmljZXMvc3Vic2NyaXB0aW9uJztcblxuLy8gSW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnRcbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMITtcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZITtcblxuLyoqXG4gKiBQT1NUIGVuZHBvaW50IHRvIHJlZnJlc2ggdXNlcidzIHNhdmVkIG5vdGVzIGNvdW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBQT1NUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKCdbUmVmcmVzaCBVc2FnZSBBUEldIFJlcXVlc3QgcmVjZWl2ZWQ6IFBPU1QnKTtcblxuICB0cnkge1xuICAgIC8vIFNURVAgMTogQXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbUmVmcmVzaCBVc2FnZSBBUEldIEF1dGhlbnRpY2F0aW9uIG1pc3NpbmcnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdWYWxpZCBCZWFyZXIgdG9rZW4gaXMgcmVxdWlyZWQnXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IHdpdGggdGhlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnJlcGxhY2UoJ0JlYXJlciAnLCAnJyk7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyJ3MgdG9rZW5cbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogYXV0aEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIodG9rZW4pO1xuICAgIGlmIChhdXRoRXJyb3IgfHwgIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tSZWZyZXNoIFVzYWdlIEFQSV0gQXV0aGVudGljYXRpb24gZmFpbGVkOicsIGF1dGhFcnJvcj8ubWVzc2FnZSk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gZmFpbGVkJyxcbiAgICAgICAgbWVzc2FnZTogYXV0aEVycm9yPy5tZXNzYWdlIHx8ICdJbnZhbGlkIGF1dGhlbnRpY2F0aW9uIHRva2VuJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtSZWZyZXNoIFVzYWdlIEFQSV0gVXNlciBhdXRoZW50aWNhdGVkOiAke3VzZXIuaWR9YCk7XG5cbiAgICAvLyBTVEVQIDI6IFJlZnJlc2ggdGhlIHNhdmVkIG5vdGVzIGNvdW50XG4gICAgY29uc29sZS5sb2coJ1tSZWZyZXNoIFVzYWdlIEFQSV0gUmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudC4uLicpO1xuICAgIGNvbnN0IHN1Y2Nlc3MgPSBhd2FpdCByZWZyZXNoU2F2ZWROb3Rlc0NvdW50KHVzZXIuaWQsIHRva2VuKTtcblxuICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgY29uc29sZS5lcnJvcignW1JlZnJlc2ggVXNhZ2UgQVBJXSBGYWlsZWQgdG8gcmVmcmVzaCBzYXZlZCBub3RlcyBjb3VudCcpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnUmVmcmVzaCBmYWlsZWQnLFxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHJlZnJlc2ggc2F2ZWQgbm90ZXMgY291bnQnXG4gICAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICAgIH1cblxuICAgIC8vIFNURVAgMzogR2V0IHRoZSB1cGRhdGVkIHVzYWdlIGRhdGFcbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc3QgeyBkYXRhOiB1c2FnZSwgZXJyb3I6IHVzYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAuZXEoJ21vbnRoX3llYXInLCBjdXJyZW50TW9udGgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAodXNhZ2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1JlZnJlc2ggVXNhZ2UgQVBJXSBFcnJvciBmZXRjaGluZyB1cGRhdGVkIHVzYWdlOicsIHVzYWdlRXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgbWVzc2FnZTogJ1NhdmVkIG5vdGVzIGNvdW50IHJlZnJlc2hlZCBzdWNjZXNzZnVsbHksIGJ1dCBjb3VsZCBub3QgZmV0Y2ggdXBkYXRlZCBkYXRhJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtSZWZyZXNoIFVzYWdlIEFQSV0gU3VjY2Vzc2Z1bGx5IHJlZnJlc2hlZCB1c2FnZSBmb3IgdXNlciAke3VzZXIuaWR9YCk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6ICdTYXZlZCBub3RlcyBjb3VudCByZWZyZXNoZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgIGRhdGE6IHVzYWdlXG4gICAgfSk7XG5cbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tSZWZyZXNoIFVzYWdlIEFQSV0gRXJyb3IgcmVmcmVzaGluZyB1c2FnZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdTZXJ2ZXIgZXJyb3InLFxuICAgICAgbWVzc2FnZTogJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVmcmVzaGluZyB1c2FnZScsXG4gICAgICBkZXRhaWxzOiBlcnJvci5tZXNzYWdlXG4gICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufVxuXG4vLyBDb25maWd1cmUgZHluYW1pYyBiZWhhdmlvciB0byBhdm9pZCBjYWNoaW5nXG5leHBvcnQgY29uc3QgZHluYW1pYyA9ICdmb3JjZS1keW5hbWljJzsgIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsImNyZWF0ZUNsaWVudCIsInJlZnJlc2hTYXZlZE5vdGVzQ291bnQiLCJzdXBhYmFzZVVybCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9VUkwiLCJzdXBhYmFzZUFub25LZXkiLCJORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSIsIlBPU1QiLCJyZXF1ZXN0IiwiY29uc29sZSIsImxvZyIsImF1dGhIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0Iiwic3RhcnRzV2l0aCIsImVycm9yIiwianNvbiIsInN1Y2Nlc3MiLCJtZXNzYWdlIiwic3RhdHVzIiwidG9rZW4iLCJyZXBsYWNlIiwic3VwYWJhc2UiLCJnbG9iYWwiLCJBdXRob3JpemF0aW9uIiwiZGF0YSIsInVzZXIiLCJhdXRoRXJyb3IiLCJhdXRoIiwiZ2V0VXNlciIsImlkIiwiY3VycmVudE1vbnRoIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwic2xpY2UiLCJ1c2FnZSIsInVzYWdlRXJyb3IiLCJmcm9tIiwic2VsZWN0IiwiZXEiLCJzaW5nbGUiLCJkZXRhaWxzIiwiZHluYW1pYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/refresh-usage/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/subscription.ts":
/*!**************************************!*\
  !*** ./src/services/subscription.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignUserSubscription: () => (/* binding */ assignUserSubscription),\n/* harmony export */   checkUsageLimits: () => (/* binding */ checkUsageLimits),\n/* harmony export */   getPlanPricing: () => (/* binding */ getPlanPricing),\n/* harmony export */   getSubscriptionPlan: () => (/* binding */ getSubscriptionPlan),\n/* harmony export */   getSubscriptionPlans: () => (/* binding */ getSubscriptionPlans),\n/* harmony export */   getUserSubscription: () => (/* binding */ getUserSubscription),\n/* harmony export */   hasFeatureAccess: () => (/* binding */ hasFeatureAccess),\n/* harmony export */   incrementUsage: () => (/* binding */ incrementUsage),\n/* harmony export */   refreshSavedNotesCount: () => (/* binding */ refreshSavedNotesCount),\n/* harmony export */   updateSavedNotesCount: () => (/* binding */ updateSavedNotesCount)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/**\n * Subscription Service\n * \n * Handles subscription plans, usage tracking, and feature access control\n */ \n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get all available subscription plans\n */ async function getSubscriptionPlans() {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"is_active\", true).order(\"price_monthly\", {\n        ascending: true\n    });\n    if (error) {\n        console.error(\"[Subscription] Error fetching plans:\", error);\n        throw new Error(\"Failed to fetch subscription plans\");\n    }\n    return data || [];\n}\n/**\n * Get user's current subscription with plan details\n */ async function getUserSubscription(userId, token) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Use direct table query instead of RPC function\n        const { data: userSub, error } = await supabase.from(\"user_subscriptions\").select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        if (error) {\n            console.error(\"[Subscription] Error fetching user subscription:\", error);\n            return null;\n        }\n        if (!userSub || !userSub.subscription_plans) {\n            return null;\n        }\n        const planData = userSub.subscription_plans;\n        return {\n            subscription_id: userSub.id,\n            plan_id: userSub.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: userSub.billing_cycle,\n            status: userSub.status,\n            current_period_end: userSub.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in getUserSubscription:\", error);\n        return null;\n    }\n}\n/**\n * Get a specific subscription plan by ID\n */ async function getSubscriptionPlan(planId) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"id\", planId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"[Subscription] Error fetching plan:\", error);\n        return null;\n    }\n    return data;\n}\n/**\n * Check if user can generate notes based on their plan and usage\n */ async function checkUsageLimits(userId, token, noteType = \"text\") {\n    try {\n        // Use direct table queries instead of RPC functions to avoid issues\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Checking usage limits for user:\", userId);\n        // Get user's subscription directly\n        const { data: userSub, error: subError } = await supabase.from(\"user_subscriptions\").select(`\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        // Get current month usage directly\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { data: usage, error: usageError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        // Default free plan limits\n        const freePlanLimits = {\n            notes_per_month: 2,\n            max_saved_notes: 3,\n            max_text_length: 5000\n        };\n        const currentUsage = usage || {\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            month_year: currentMonth\n        };\n        // If usage record doesn't exist, create it\n        if (!usage) {\n            console.log(\"[Subscription] Creating usage record for current month:\", currentMonth);\n            const { error: createUsageError } = await supabase.from(\"user_usage\").insert({\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 0,\n                video_notes_count: 0,\n                file_notes_count: 0,\n                text_notes_count: 0,\n                total_saved_notes: 0,\n                updated_at: new Date().toISOString()\n            });\n            if (createUsageError) {\n                console.error(\"[Subscription] Warning: Could not create usage record:\", createUsageError);\n            }\n        }\n        // If no subscription found or error, try to create a free subscription\n        if (!userSub || subError) {\n            console.log(\"[Subscription] No active subscription found, attempting to create free subscription\");\n            if (subError) {\n                console.error(\"[Subscription] Subscription query error:\", subError);\n            }\n            // Try to create a free subscription for the user\n            const { error: createSubError } = await supabase.from(\"user_subscriptions\").insert({\n                user_id: userId,\n                plan_id: \"free\",\n                billing_cycle: \"monthly\",\n                status: \"active\",\n                current_period_start: new Date().toISOString(),\n                current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n                updated_at: new Date().toISOString()\n            }).select();\n            if (createSubError) {\n                console.error(\"[Subscription] Could not create free subscription:\", createSubError);\n            } else {\n                console.log(\"[Subscription] Created free subscription for user\");\n            }\n            // Return free plan limits regardless of whether we could create the subscription\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: !canGenerate ? `Monthly limit reached (${freePlanLimits.notes_per_month} notes per month)` : !canSave ? `Storage limit reached (${freePlanLimits.max_saved_notes} saved notes maximum)` : undefined,\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        const subscription = userSub;\n        const planData = subscription.subscription_plans;\n        if (!planData) {\n            console.error(\"[Subscription] Plan data not found for subscription:\", subscription);\n            // Fallback to free plan\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: \"Plan data not found - using free plan limits\",\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        console.log(\"[Subscription] Found subscription:\", {\n            planId: subscription.plan_id,\n            planLimits: planData.limits,\n            currentUsage: currentUsage\n        });\n        // Check monthly generation limit (handle unlimited case)\n        const monthlyLimit = planData.limits.notes_per_month;\n        const canGenerate = monthlyLimit === -1 || currentUsage.notes_generated < monthlyLimit;\n        // Check saved notes limit\n        const canSave = currentUsage.total_saved_notes < planData.limits.max_saved_notes;\n        let reason;\n        if (!canGenerate && monthlyLimit !== -1) {\n            reason = `Monthly limit reached (${monthlyLimit} notes per month)`;\n        } else if (!canSave) {\n            reason = `Storage limit reached (${planData.limits.max_saved_notes} saved notes maximum)`;\n        }\n        return {\n            canGenerate,\n            canSave,\n            reason,\n            usage: currentUsage,\n            limits: planData.limits\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error checking usage limits:\", error);\n        // Return restrictive fallback\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const fallbackUsage = {\n            notes_generated: 999,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 999,\n            month_year: currentMonth\n        };\n        return {\n            canGenerate: false,\n            canSave: false,\n            reason: \"Error checking subscription limits. Please try again.\",\n            usage: fallbackUsage,\n            limits: {\n                notes_per_month: 2,\n                max_saved_notes: 3,\n                max_text_length: 5000\n            }\n        };\n    }\n}\n/**\n * Increment user's usage count after successful note generation\n */ async function incrementUsage(userId, token, noteType = \"text\") {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Incrementing usage for user:\", userId, \"type:\", noteType);\n        // Get current usage\n        const { data: currentUsage, error: fetchError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        if (fetchError && fetchError.code !== \"PGRST116\") {\n            console.error(\"[Subscription] Error fetching current usage:\", fetchError);\n            return false;\n        }\n        // Prepare update data\n        const updateData = {\n            notes_generated: (currentUsage?.notes_generated || 0) + 1,\n            updated_at: new Date().toISOString()\n        };\n        // Increment specific note type counter\n        if (noteType === \"video\") {\n            updateData.video_notes_count = (currentUsage?.video_notes_count || 0) + 1;\n        } else if (noteType === \"file\") {\n            updateData.file_notes_count = (currentUsage?.file_notes_count || 0) + 1;\n        } else if (noteType === \"text\") {\n            updateData.text_notes_count = (currentUsage?.text_notes_count || 0) + 1;\n        }\n        // Update or insert usage record\n        if (currentUsage) {\n            const { error: updateError } = await supabase.from(\"user_usage\").update(updateData).eq(\"user_id\", userId).eq(\"month_year\", currentMonth);\n            if (updateError) {\n                console.error(\"[Subscription] Error updating usage:\", updateError);\n                return false;\n            }\n        } else {\n            // Create new usage record\n            const insertData = {\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 1,\n                video_notes_count: noteType === \"video\" ? 1 : 0,\n                file_notes_count: noteType === \"file\" ? 1 : 0,\n                text_notes_count: noteType === \"text\" ? 1 : 0,\n                total_saved_notes: 0,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            const { error: insertError } = await supabase.from(\"user_usage\").insert(insertData);\n            if (insertError) {\n                console.error(\"[Subscription] Error creating usage record:\", insertError);\n                return false;\n            }\n        }\n        console.log(\"[Subscription] Successfully incremented usage\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error incrementing usage:\", error);\n        return false;\n    }\n}\n/**\n * Update saved notes count (used when notes are saved or deleted)\n */ async function updateSavedNotesCount(userId, token, count) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Updating saved notes count for user:\", userId, \"count:\", count);\n        // Upsert the saved notes count\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: Math.max(0, count),\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully updated saved notes count\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error updating saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Refresh saved notes count by counting all notes from all tables\n */ async function refreshSavedNotesCount(userId, token) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Refreshing saved notes count for user:\", userId);\n        // Count notes from all tables\n        const [videoResult, fileResult, textResult] = await Promise.all([\n            supabase.from(\"video_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"file_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"text_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId)\n        ]);\n        const videoCount = videoResult.count || 0;\n        const fileCount = fileResult.count || 0;\n        const textCount = textResult.count || 0;\n        const totalCount = videoCount + fileCount + textCount;\n        console.log(\"[Subscription] Note counts:\", {\n            video: videoCount,\n            file: fileCount,\n            text: textCount,\n            total: totalCount\n        });\n        // Update the usage record with the actual count\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: totalCount,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully refreshed saved notes count to:\", totalCount);\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error refreshing saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Get plan pricing with discount calculation\n */ function getPlanPricing(plan) {\n    const monthlyPrice = plan.price_monthly;\n    const yearlyPrice = plan.price_yearly;\n    const yearlyMonthlyEquivalent = yearlyPrice / 12;\n    const discountPercentage = monthlyPrice > 0 ? Math.round((1 - yearlyMonthlyEquivalent / monthlyPrice) * 100) : 0;\n    const yearlySavings = monthlyPrice * 12 - yearlyPrice;\n    return {\n        monthly: monthlyPrice,\n        yearly: yearlyPrice,\n        yearlyMonthlyEquivalent,\n        discountPercentage,\n        yearlySavings,\n        currency: plan.currency\n    };\n}\n/**\n * Check if user has access to a specific feature\n */ async function hasFeatureAccess(userId, token, feature) {\n    try {\n        const subscription = await getUserSubscription(userId, token);\n        if (!subscription) {\n            // Default free plan features\n            const freeFeatures = {\n                notes_generation: true,\n                quizzes: false,\n                youtube_support: true,\n                ppt_support: false,\n                export: false,\n                copy_paste: true,\n                upload_video: false,\n                priority_generation: false\n            };\n            return freeFeatures[feature] || false;\n        }\n        return subscription.features[feature] || false;\n    } catch (error) {\n        console.error(\"[Subscription] Error checking feature access:\", error);\n        return false; // Default to no access on error\n    }\n}\n/**\n * Assign subscription to user after successful payment\n */ async function assignUserSubscription(userId, token, planId, billingCycle, paymentData) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Calculate period dates\n        const currentPeriodStart = new Date();\n        const currentPeriodEnd = new Date();\n        if (billingCycle === \"yearly\") {\n            currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);\n        } else {\n            currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);\n        }\n        // Prepare subscription data\n        const subscriptionData = {\n            user_id: userId,\n            plan_id: planId,\n            billing_cycle: billingCycle,\n            status: \"active\",\n            current_period_start: currentPeriodStart.toISOString(),\n            current_period_end: currentPeriodEnd.toISOString(),\n            cancel_at_period_end: false,\n            stripe_subscription_id: paymentData?.stripeSubscriptionId || null,\n            stripe_customer_id: paymentData?.stripeCustomerId || null,\n            updated_at: new Date().toISOString()\n        };\n        // Upsert subscription (update if exists, insert if new)\n        const { data: subscription, error: subscriptionError } = await supabase.from(\"user_subscriptions\").upsert(subscriptionData, {\n            onConflict: \"user_id\"\n        }).select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).single();\n        if (subscriptionError) {\n            console.error(\"[Subscription] Error assigning subscription:\", subscriptionError);\n            throw new Error(\"Failed to assign subscription\");\n        }\n        if (!subscription || !subscription.subscription_plans) {\n            throw new Error(\"Failed to retrieve subscription details\");\n        }\n        // Initialize usage tracking for current month\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error: usageError } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\",\n            ignoreDuplicates: true\n        });\n        if (usageError) {\n            console.error(\"[Subscription] Warning: Failed to initialize usage tracking:\", usageError);\n        // Don't throw error here as subscription assignment was successful\n        }\n        const planData = subscription.subscription_plans;\n        return {\n            subscription_id: subscription.id,\n            plan_id: subscription.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: subscription.billing_cycle,\n            status: subscription.status,\n            current_period_end: subscription.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in assignUserSubscription:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YXpDLGFBQWE7WUFDekNDLFFBQVF3QyxhQUFheEMsTUFBTTtZQUMzQkMsb0JBQW9CdUMsYUFBYXZDLGtCQUFrQjtZQUNuREMsVUFBVVgsU0FBU1csUUFBUTtZQUMzQkMsUUFBUVosU0FBU1ksTUFBTTtZQUN2QkMsZUFBZWIsU0FBU2EsYUFBYTtZQUNyQ0MsY0FBY2QsU0FBU2MsWUFBWTtRQUNyQztJQUNGLEVBQUUsT0FBTy9CLE9BQU87UUFDZE0sUUFBUU4sS0FBSyxDQUFDLG1EQUFtREE7UUFDakUsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL3NlcnZpY2VzL3N1YnNjcmlwdGlvbi50cz8wNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3Vic2NyaXB0aW9uIFNlcnZpY2VcbiAqIFxuICogSGFuZGxlcyBzdWJzY3JpcHRpb24gcGxhbnMsIHVzYWdlIHRyYWNraW5nLCBhbmQgZmVhdHVyZSBhY2Nlc3MgY29udHJvbFxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50XG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0aW9uUGxhbiB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHByaWNlX21vbnRobHk6IG51bWJlcjtcbiAgcHJpY2VfeWVhcmx5OiBudW1iZXI7XG4gIGN1cnJlbmN5OiBzdHJpbmc7XG4gIGZlYXR1cmVzOiB7XG4gICAgbm90ZXNfZ2VuZXJhdGlvbjogYm9vbGVhbjtcbiAgICBxdWl6emVzOiBib29sZWFuO1xuICAgIHlvdXR1YmVfc3VwcG9ydDogYm9vbGVhbjtcbiAgICBwcHRfc3VwcG9ydDogYm9vbGVhbjtcbiAgICBleHBvcnQ6IGJvb2xlYW47XG4gICAgY29weV9wYXN0ZTogYm9vbGVhbjtcbiAgICB1cGxvYWRfdmlkZW8/OiBib29sZWFuO1xuICAgIHByaW9yaXR5X2dlbmVyYXRpb24/OiBib29sZWFuO1xuICB9O1xuICBsaW1pdHM6IHtcbiAgICBub3Rlc19wZXJfbW9udGg6IG51bWJlcjsgLy8gLTEgbWVhbnMgdW5saW1pdGVkXG4gICAgbWF4X3NhdmVkX25vdGVzOiBudW1iZXI7XG4gICAgbWF4X3RleHRfbGVuZ3RoOiBudW1iZXI7XG4gIH07XG4gIGlzX2FjdGl2ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyU3Vic2NyaXB0aW9uIHtcbiAgc3Vic2NyaXB0aW9uX2lkOiBzdHJpbmc7XG4gIHBsYW5faWQ6IHN0cmluZztcbiAgcGxhbl9uYW1lOiBzdHJpbmc7XG4gIHBsYW5fZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGJpbGxpbmdfY3ljbGU6ICdtb250aGx5JyB8ICd5ZWFybHknO1xuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ2NhbmNlbGxlZCcgfCAnZXhwaXJlZCcgfCAndHJpYWwnO1xuICBjdXJyZW50X3BlcmlvZF9lbmQ6IHN0cmluZztcbiAgZmVhdHVyZXM6IFN1YnNjcmlwdGlvblBsYW5bJ2ZlYXR1cmVzJ107XG4gIGxpbWl0czogU3Vic2NyaXB0aW9uUGxhblsnbGltaXRzJ107XG4gIHByaWNlX21vbnRobHk6IG51bWJlcjtcbiAgcHJpY2VfeWVhcmx5OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclVzYWdlIHtcbiAgbm90ZXNfZ2VuZXJhdGVkOiBudW1iZXI7XG4gIHZpZGVvX25vdGVzX2NvdW50OiBudW1iZXI7XG4gIGZpbGVfbm90ZXNfY291bnQ6IG51bWJlcjtcbiAgdGV4dF9ub3Rlc19jb3VudDogbnVtYmVyO1xuICB0b3RhbF9zYXZlZF9ub3RlczogbnVtYmVyO1xuICBtb250aF95ZWFyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNhZ2VDaGVjayB7XG4gIGNhbkdlbmVyYXRlOiBib29sZWFuO1xuICBjYW5TYXZlOiBib29sZWFuO1xuICByZWFzb24/OiBzdHJpbmc7XG4gIHVzYWdlOiBVc2VyVXNhZ2U7XG4gIGxpbWl0czogU3Vic2NyaXB0aW9uUGxhblsnbGltaXRzJ107XG59XG5cbi8qKlxuICogR2V0IGFsbCBhdmFpbGFibGUgc3Vic2NyaXB0aW9uIHBsYW5zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25QbGFucygpOiBQcm9taXNlPFN1YnNjcmlwdGlvblBsYW5bXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcbiAgXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3N1YnNjcmlwdGlvbl9wbGFucycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5vcmRlcigncHJpY2VfbW9udGhseScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICAgIFxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBmZXRjaGluZyBwbGFuczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggc3Vic2NyaXB0aW9uIHBsYW5zJyk7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG4vKipcbiAqIEdldCB1c2VyJ3MgY3VycmVudCBzdWJzY3JpcHRpb24gd2l0aCBwbGFuIGRldGFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJTdWJzY3JpcHRpb24odXNlcklkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJTdWJzY3JpcHRpb24gfCBudWxsPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICBnbG9iYWw6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBVc2UgZGlyZWN0IHRhYmxlIHF1ZXJ5IGluc3RlYWQgb2YgUlBDIGZ1bmN0aW9uXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyU3ViLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIGlkLFxuICAgICAgICBwbGFuX2lkLFxuICAgICAgICBiaWxsaW5nX2N5Y2xlLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uX3BsYW5zIChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICBsaW1pdHMsXG4gICAgICAgICAgcHJpY2VfbW9udGhseSxcbiAgICAgICAgICBwcmljZV95ZWFybHlcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGZldGNoaW5nIHVzZXIgc3Vic2NyaXB0aW9uOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdXNlclN1YiB8fCAhdXNlclN1Yi5zdWJzY3JpcHRpb25fcGxhbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYW5EYXRhID0gdXNlclN1Yi5zdWJzY3JpcHRpb25fcGxhbnMgYXMgYW55O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpcHRpb25faWQ6IHVzZXJTdWIuaWQsXG4gICAgICBwbGFuX2lkOiB1c2VyU3ViLnBsYW5faWQsXG4gICAgICBwbGFuX25hbWU6IHBsYW5EYXRhLm5hbWUsXG4gICAgICBwbGFuX2Rpc3BsYXlfbmFtZTogcGxhbkRhdGEuZGlzcGxheV9uYW1lLFxuICAgICAgYmlsbGluZ19jeWNsZTogdXNlclN1Yi5iaWxsaW5nX2N5Y2xlLFxuICAgICAgc3RhdHVzOiB1c2VyU3ViLnN0YXR1cyxcbiAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogdXNlclN1Yi5jdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICBmZWF0dXJlczogcGxhbkRhdGEuZmVhdHVyZXMsXG4gICAgICBsaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIHByaWNlX21vbnRobHk6IHBsYW5EYXRhLnByaWNlX21vbnRobHksXG4gICAgICBwcmljZV95ZWFybHk6IHBsYW5EYXRhLnByaWNlX3llYXJseVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgaW4gZ2V0VXNlclN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBzcGVjaWZpYyBzdWJzY3JpcHRpb24gcGxhbiBieSBJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUGxhbihwbGFuSWQ6IHN0cmluZyk6IFByb21pc2U8U3Vic2NyaXB0aW9uUGxhbiB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdzdWJzY3JpcHRpb25fcGxhbnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCBwbGFuSWQpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgcGxhbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgY2FuIGdlbmVyYXRlIG5vdGVzIGJhc2VkIG9uIHRoZWlyIHBsYW4gYW5kIHVzYWdlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1VzYWdlTGltaXRzKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBub3RlVHlwZTogJ3ZpZGVvJyB8ICdmaWxlJyB8ICd0ZXh0JyA9ICd0ZXh0J1xuKTogUHJvbWlzZTxVc2FnZUNoZWNrPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGRpcmVjdCB0YWJsZSBxdWVyaWVzIGluc3RlYWQgb2YgUlBDIGZ1bmN0aW9ucyB0byBhdm9pZCBpc3N1ZXNcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBDaGVja2luZyB1c2FnZSBsaW1pdHMgZm9yIHVzZXI6JywgdXNlcklkKVxuXG4gICAgLy8gR2V0IHVzZXIncyBzdWJzY3JpcHRpb24gZGlyZWN0bHlcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJTdWIsIGVycm9yOiBzdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIHBsYW5faWQsXG4gICAgICAgIGJpbGxpbmdfY3ljbGUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgY3VycmVudF9wZXJpb2RfZW5kLFxuICAgICAgICBzdWJzY3JpcHRpb25fcGxhbnMgKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIGxpbWl0cyxcbiAgICAgICAgICBwcmljZV9tb250aGx5LFxuICAgICAgICAgIHByaWNlX3llYXJseVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIC8vIEdldCBjdXJyZW50IG1vbnRoIHVzYWdlIGRpcmVjdGx5XG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZGF0YTogdXNhZ2UsIGVycm9yOiB1c2FnZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ21vbnRoX3llYXInLCBjdXJyZW50TW9udGgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICAvLyBEZWZhdWx0IGZyZWUgcGxhbiBsaW1pdHNcbiAgICBjb25zdCBmcmVlUGxhbkxpbWl0cyA9IHsgXG4gICAgICBub3Rlc19wZXJfbW9udGg6IDIsIFxuICAgICAgbWF4X3NhdmVkX25vdGVzOiAzLCBcbiAgICAgIG1heF90ZXh0X2xlbmd0aDogNTAwMCBcbiAgICB9O1xuXG4gICAgY29uc3QgY3VycmVudFVzYWdlID0gdXNhZ2UgfHwge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICBmaWxlX25vdGVzX2NvdW50OiAwLFxuICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoXG4gICAgfTtcblxuICAgIC8vIElmIHVzYWdlIHJlY29yZCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoIXVzYWdlKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gQ3JlYXRpbmcgdXNhZ2UgcmVjb3JkIGZvciBjdXJyZW50IG1vbnRoOicsIGN1cnJlbnRNb250aClcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGNyZWF0ZVVzYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgICBub3Rlc19nZW5lcmF0ZWQ6IDAsXG4gICAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgICB0ZXh0X25vdGVzX2NvdW50OiAwLFxuICAgICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGNyZWF0ZVVzYWdlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gV2FybmluZzogQ291bGQgbm90IGNyZWF0ZSB1c2FnZSByZWNvcmQ6JywgY3JlYXRlVXNhZ2VFcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gc3Vic2NyaXB0aW9uIGZvdW5kIG9yIGVycm9yLCB0cnkgdG8gY3JlYXRlIGEgZnJlZSBzdWJzY3JpcHRpb25cbiAgICBpZiAoIXVzZXJTdWIgfHwgc3ViRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBObyBhY3RpdmUgc3Vic2NyaXB0aW9uIGZvdW5kLCBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBmcmVlIHN1YnNjcmlwdGlvbicpXG4gICAgICBcbiAgICAgIGlmIChzdWJFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBTdWJzY3JpcHRpb24gcXVlcnkgZXJyb3I6Jywgc3ViRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgZnJlZSBzdWJzY3JpcHRpb24gZm9yIHRoZSB1c2VyXG4gICAgICBjb25zdCB7IGVycm9yOiBjcmVhdGVTdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfc3Vic2NyaXB0aW9ucycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBwbGFuX2lkOiAnZnJlZScsXG4gICAgICAgICAgYmlsbGluZ19jeWNsZTogJ21vbnRobHknLFxuICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgY3VycmVudF9wZXJpb2Rfc3RhcnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgaWYgKGNyZWF0ZVN1YkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIENvdWxkIG5vdCBjcmVhdGUgZnJlZSBzdWJzY3JpcHRpb246JywgY3JlYXRlU3ViRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIENyZWF0ZWQgZnJlZSBzdWJzY3JpcHRpb24gZm9yIHVzZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGZyZWUgcGxhbiBsaW1pdHMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGNvdWxkIGNyZWF0ZSB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICBjb25zdCBjYW5HZW5lcmF0ZSA9IGN1cnJlbnRVc2FnZS5ub3Rlc19nZW5lcmF0ZWQgPCBmcmVlUGxhbkxpbWl0cy5ub3Rlc19wZXJfbW9udGg7XG4gICAgICBjb25zdCBjYW5TYXZlID0gY3VycmVudFVzYWdlLnRvdGFsX3NhdmVkX25vdGVzIDwgZnJlZVBsYW5MaW1pdHMubWF4X3NhdmVkX25vdGVzO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5HZW5lcmF0ZSxcbiAgICAgICAgY2FuU2F2ZSxcbiAgICAgICAgcmVhc29uOiAhY2FuR2VuZXJhdGUgPyBgTW9udGhseSBsaW1pdCByZWFjaGVkICgke2ZyZWVQbGFuTGltaXRzLm5vdGVzX3Blcl9tb250aH0gbm90ZXMgcGVyIG1vbnRoKWAgOlxuICAgICAgICAgICAgICAgICFjYW5TYXZlID8gYFN0b3JhZ2UgbGltaXQgcmVhY2hlZCAoJHtmcmVlUGxhbkxpbWl0cy5tYXhfc2F2ZWRfbm90ZXN9IHNhdmVkIG5vdGVzIG1heGltdW0pYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgbGltaXRzOiBmcmVlUGxhbkxpbWl0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB1c2VyU3ViO1xuICAgIGNvbnN0IHBsYW5EYXRhID0gc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbl9wbGFucyBhcyBhbnk7XG4gICAgXG4gICAgaWYgKCFwbGFuRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gUGxhbiBkYXRhIG5vdCBmb3VuZCBmb3Igc3Vic2NyaXB0aW9uOicsIHN1YnNjcmlwdGlvbik7XG4gICAgICAvLyBGYWxsYmFjayB0byBmcmVlIHBsYW5cbiAgICAgIGNvbnN0IGNhbkdlbmVyYXRlID0gY3VycmVudFVzYWdlLm5vdGVzX2dlbmVyYXRlZCA8IGZyZWVQbGFuTGltaXRzLm5vdGVzX3Blcl9tb250aDtcbiAgICAgIGNvbnN0IGNhblNhdmUgPSBjdXJyZW50VXNhZ2UudG90YWxfc2F2ZWRfbm90ZXMgPCBmcmVlUGxhbkxpbWl0cy5tYXhfc2F2ZWRfbm90ZXM7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbkdlbmVyYXRlLFxuICAgICAgICBjYW5TYXZlLFxuICAgICAgICByZWFzb246ICdQbGFuIGRhdGEgbm90IGZvdW5kIC0gdXNpbmcgZnJlZSBwbGFuIGxpbWl0cycsXG4gICAgICAgIHVzYWdlOiBjdXJyZW50VXNhZ2UsXG4gICAgICAgIGxpbWl0czogZnJlZVBsYW5MaW1pdHNcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBGb3VuZCBzdWJzY3JpcHRpb246Jywge1xuICAgICAgcGxhbklkOiBzdWJzY3JpcHRpb24ucGxhbl9pZCxcbiAgICAgIHBsYW5MaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIGN1cnJlbnRVc2FnZTogY3VycmVudFVzYWdlXG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBtb250aGx5IGdlbmVyYXRpb24gbGltaXQgKGhhbmRsZSB1bmxpbWl0ZWQgY2FzZSlcbiAgICBjb25zdCBtb250aGx5TGltaXQgPSBwbGFuRGF0YS5saW1pdHMubm90ZXNfcGVyX21vbnRoO1xuICAgIGNvbnN0IGNhbkdlbmVyYXRlID0gbW9udGhseUxpbWl0ID09PSAtMSB8fCBjdXJyZW50VXNhZ2Uubm90ZXNfZ2VuZXJhdGVkIDwgbW9udGhseUxpbWl0O1xuICAgIFxuICAgIC8vIENoZWNrIHNhdmVkIG5vdGVzIGxpbWl0XG4gICAgY29uc3QgY2FuU2F2ZSA9IGN1cnJlbnRVc2FnZS50b3RhbF9zYXZlZF9ub3RlcyA8IHBsYW5EYXRhLmxpbWl0cy5tYXhfc2F2ZWRfbm90ZXM7XG4gICAgXG4gICAgbGV0IHJlYXNvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmICghY2FuR2VuZXJhdGUgJiYgbW9udGhseUxpbWl0ICE9PSAtMSkge1xuICAgICAgcmVhc29uID0gYE1vbnRobHkgbGltaXQgcmVhY2hlZCAoJHttb250aGx5TGltaXR9IG5vdGVzIHBlciBtb250aClgO1xuICAgIH0gZWxzZSBpZiAoIWNhblNhdmUpIHtcbiAgICAgIHJlYXNvbiA9IGBTdG9yYWdlIGxpbWl0IHJlYWNoZWQgKCR7cGxhbkRhdGEubGltaXRzLm1heF9zYXZlZF9ub3Rlc30gc2F2ZWQgbm90ZXMgbWF4aW11bSlgO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY2FuR2VuZXJhdGUsXG4gICAgICBjYW5TYXZlLFxuICAgICAgcmVhc29uLFxuICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgIGxpbWl0czogcGxhbkRhdGEubGltaXRzXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjaGVja2luZyB1c2FnZSBsaW1pdHM6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFJldHVybiByZXN0cmljdGl2ZSBmYWxsYmFja1xuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KTtcbiAgICBjb25zdCBmYWxsYmFja1VzYWdlID0ge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiA5OTksXG4gICAgICB2aWRlb19ub3Rlc19jb3VudDogMCxcbiAgICAgIGZpbGVfbm90ZXNfY291bnQ6IDAsXG4gICAgICB0ZXh0X25vdGVzX2NvdW50OiAwLFxuICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDk5OSxcbiAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aFxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkdlbmVyYXRlOiBmYWxzZSxcbiAgICAgIGNhblNhdmU6IGZhbHNlLFxuICAgICAgcmVhc29uOiAnRXJyb3IgY2hlY2tpbmcgc3Vic2NyaXB0aW9uIGxpbWl0cy4gUGxlYXNlIHRyeSBhZ2Fpbi4nLFxuICAgICAgdXNhZ2U6IGZhbGxiYWNrVXNhZ2UsXG4gICAgICBsaW1pdHM6IHsgbm90ZXNfcGVyX21vbnRoOiAyLCBtYXhfc2F2ZWRfbm90ZXM6IDMsIG1heF90ZXh0X2xlbmd0aDogNTAwMCB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEluY3JlbWVudCB1c2VyJ3MgdXNhZ2UgY291bnQgYWZ0ZXIgc3VjY2Vzc2Z1bCBub3RlIGdlbmVyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlbWVudFVzYWdlKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBub3RlVHlwZTogJ3ZpZGVvJyB8ICdmaWxlJyB8ICd0ZXh0JyA9ICd0ZXh0J1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIEluY3JlbWVudGluZyB1c2FnZSBmb3IgdXNlcjonLCB1c2VySWQsICd0eXBlOicsIG5vdGVUeXBlKVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgdXNhZ2VcbiAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRVc2FnZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnbW9udGhfeWVhcicsIGN1cnJlbnRNb250aClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChmZXRjaEVycm9yICYmIGZldGNoRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2Jykge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgY3VycmVudCB1c2FnZTonLCBmZXRjaEVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHVwZGF0ZSBkYXRhXG4gICAgY29uc3QgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAoY3VycmVudFVzYWdlPy5ub3Rlc19nZW5lcmF0ZWQgfHwgMCkgKyAxLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIC8vIEluY3JlbWVudCBzcGVjaWZpYyBub3RlIHR5cGUgY291bnRlclxuICAgIGlmIChub3RlVHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdXBkYXRlRGF0YS52aWRlb19ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LnZpZGVvX25vdGVzX2NvdW50IHx8IDApICsgMTtcbiAgICB9IGVsc2UgaWYgKG5vdGVUeXBlID09PSAnZmlsZScpIHtcbiAgICAgIHVwZGF0ZURhdGEuZmlsZV9ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LmZpbGVfbm90ZXNfY291bnQgfHwgMCkgKyAxO1xuICAgIH0gZWxzZSBpZiAobm90ZVR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgdXBkYXRlRGF0YS50ZXh0X25vdGVzX2NvdW50ID0gKGN1cnJlbnRVc2FnZT8udGV4dF9ub3Rlc19jb3VudCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG9yIGluc2VydCB1c2FnZSByZWNvcmRcbiAgICBpZiAoY3VycmVudFVzYWdlKSB7XG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLmVxKCdtb250aF95ZWFyJywgY3VycmVudE1vbnRoKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHVwZGF0aW5nIHVzYWdlOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IHVzYWdlIHJlY29yZFxuICAgICAgY29uc3QgaW5zZXJ0RGF0YSA9IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIG5vdGVzX2dlbmVyYXRlZDogMSxcbiAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAndmlkZW8nID8gMSA6IDAsXG4gICAgICAgIGZpbGVfbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAnZmlsZScgPyAxIDogMCxcbiAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogbm90ZVR5cGUgPT09ICd0ZXh0JyA/IDEgOiAwLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogMCxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAgIC5pbnNlcnQoaW5zZXJ0RGF0YSk7XG5cbiAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjcmVhdGluZyB1c2FnZSByZWNvcmQ6JywgaW5zZXJ0RXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSBpbmNyZW1lbnRlZCB1c2FnZScpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGluY3JlbWVudGluZyB1c2FnZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHNhdmVkIG5vdGVzIGNvdW50ICh1c2VkIHdoZW4gbm90ZXMgYXJlIHNhdmVkIG9yIGRlbGV0ZWQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVTYXZlZE5vdGVzQ291bnQoXG4gIHVzZXJJZDogc3RyaW5nLCBcbiAgdG9rZW46IHN0cmluZywgXG4gIGNvdW50OiBudW1iZXJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBVcGRhdGluZyBzYXZlZCBub3RlcyBjb3VudCBmb3IgdXNlcjonLCB1c2VySWQsICdjb3VudDonLCBjb3VudClcblxuICAgIC8vIFVwc2VydCB0aGUgc2F2ZWQgbm90ZXMgY291bnRcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnVwc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogTWF0aC5tYXgoMCwgY291bnQpLCAvLyBFbnN1cmUgbm9uLW5lZ2F0aXZlXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCxtb250aF95ZWFyJ1xuICAgICAgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHVwZGF0aW5nIHNhdmVkIG5vdGVzIGNvdW50OicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgc2F2ZWQgbm90ZXMgY291bnQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmVmcmVzaCBzYXZlZCBub3RlcyBjb3VudCBieSBjb3VudGluZyBhbGwgbm90ZXMgZnJvbSBhbGwgdGFibGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoU2F2ZWROb3Rlc0NvdW50KFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gUmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudCBmb3IgdXNlcjonLCB1c2VySWQpO1xuXG4gICAgLy8gQ291bnQgbm90ZXMgZnJvbSBhbGwgdGFibGVzXG4gICAgY29uc3QgW3ZpZGVvUmVzdWx0LCBmaWxlUmVzdWx0LCB0ZXh0UmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2aWRlb19ub3RlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpLFxuICAgICAgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2ZpbGVfbm90ZXMnKVxuICAgICAgICAuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKSxcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0ZXh0X25vdGVzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICBdKTtcblxuICAgIGNvbnN0IHZpZGVvQ291bnQgPSB2aWRlb1Jlc3VsdC5jb3VudCB8fCAwO1xuICAgIGNvbnN0IGZpbGVDb3VudCA9IGZpbGVSZXN1bHQuY291bnQgfHwgMDtcbiAgICBjb25zdCB0ZXh0Q291bnQgPSB0ZXh0UmVzdWx0LmNvdW50IHx8IDA7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHZpZGVvQ291bnQgKyBmaWxlQ291bnQgKyB0ZXh0Q291bnQ7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gTm90ZSBjb3VudHM6Jywge1xuICAgICAgdmlkZW86IHZpZGVvQ291bnQsXG4gICAgICBmaWxlOiBmaWxlQ291bnQsXG4gICAgICB0ZXh0OiB0ZXh0Q291bnQsXG4gICAgICB0b3RhbDogdG90YWxDb3VudFxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB1c2FnZSByZWNvcmQgd2l0aCB0aGUgYWN0dWFsIGNvdW50XG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAudXBzZXJ0KHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiB0b3RhbENvdW50LFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sIHtcbiAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsbW9udGhfeWVhcidcbiAgICAgIH0pO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSByZWZyZXNoZWQgc2F2ZWQgbm90ZXMgY291bnQgdG86JywgdG90YWxDb3VudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgcmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHBsYW4gcHJpY2luZyB3aXRoIGRpc2NvdW50IGNhbGN1bGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuUHJpY2luZyhwbGFuOiBTdWJzY3JpcHRpb25QbGFuKSB7XG4gIGNvbnN0IG1vbnRobHlQcmljZSA9IHBsYW4ucHJpY2VfbW9udGhseTtcbiAgY29uc3QgeWVhcmx5UHJpY2UgPSBwbGFuLnByaWNlX3llYXJseTtcbiAgY29uc3QgeWVhcmx5TW9udGhseUVxdWl2YWxlbnQgPSB5ZWFybHlQcmljZSAvIDEyO1xuICBjb25zdCBkaXNjb3VudFBlcmNlbnRhZ2UgPSBtb250aGx5UHJpY2UgPiAwID8gTWF0aC5yb3VuZCgoMSAtIHllYXJseU1vbnRobHlFcXVpdmFsZW50IC8gbW9udGhseVByaWNlKSAqIDEwMCkgOiAwO1xuICBjb25zdCB5ZWFybHlTYXZpbmdzID0gKG1vbnRobHlQcmljZSAqIDEyKSAtIHllYXJseVByaWNlO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtb250aGx5OiBtb250aGx5UHJpY2UsXG4gICAgeWVhcmx5OiB5ZWFybHlQcmljZSxcbiAgICB5ZWFybHlNb250aGx5RXF1aXZhbGVudCxcbiAgICBkaXNjb3VudFBlcmNlbnRhZ2UsXG4gICAgeWVhcmx5U2F2aW5ncyxcbiAgICBjdXJyZW5jeTogcGxhbi5jdXJyZW5jeVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgaGFzIGFjY2VzcyB0byBhIHNwZWNpZmljIGZlYXR1cmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc0ZlYXR1cmVBY2Nlc3MoXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0b2tlbjogc3RyaW5nLFxuICBmZWF0dXJlOiBrZXlvZiBTdWJzY3JpcHRpb25QbGFuWydmZWF0dXJlcyddXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRVc2VyU3Vic2NyaXB0aW9uKHVzZXJJZCwgdG9rZW4pO1xuICAgIFxuICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAvLyBEZWZhdWx0IGZyZWUgcGxhbiBmZWF0dXJlc1xuICAgICAgY29uc3QgZnJlZUZlYXR1cmVzID0ge1xuICAgICAgICBub3Rlc19nZW5lcmF0aW9uOiB0cnVlLFxuICAgICAgICBxdWl6emVzOiBmYWxzZSxcbiAgICAgICAgeW91dHViZV9zdXBwb3J0OiB0cnVlLFxuICAgICAgICBwcHRfc3VwcG9ydDogZmFsc2UsXG4gICAgICAgIGV4cG9ydDogZmFsc2UsXG4gICAgICAgIGNvcHlfcGFzdGU6IHRydWUsXG4gICAgICAgIHVwbG9hZF92aWRlbzogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5X2dlbmVyYXRpb246IGZhbHNlXG4gICAgICB9O1xuICAgICAgXG4gICAgICByZXR1cm4gZnJlZUZlYXR1cmVzW2ZlYXR1cmVdIHx8IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLmZlYXR1cmVzW2ZlYXR1cmVdIHx8IGZhbHNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGNoZWNraW5nIGZlYXR1cmUgYWNjZXNzOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7IC8vIERlZmF1bHQgdG8gbm8gYWNjZXNzIG9uIGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NpZ24gc3Vic2NyaXB0aW9uIHRvIHVzZXIgYWZ0ZXIgc3VjY2Vzc2Z1bCBwYXltZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZyxcbiAgcGxhbklkOiBzdHJpbmcsXG4gIGJpbGxpbmdDeWNsZTogJ21vbnRobHknIHwgJ3llYXJseScsXG4gIHBheW1lbnREYXRhPzoge1xuICAgIHN0cmlwZVN1YnNjcmlwdGlvbklkPzogc3RyaW5nO1xuICAgIHN0cmlwZUN1c3RvbWVySWQ/OiBzdHJpbmc7XG4gIH1cbik6IFByb21pc2U8VXNlclN1YnNjcmlwdGlvbiB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgIGdsb2JhbDoge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICAvLyBDYWxjdWxhdGUgcGVyaW9kIGRhdGVzXG4gICAgY29uc3QgY3VycmVudFBlcmlvZFN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50UGVyaW9kRW5kID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICBpZiAoYmlsbGluZ0N5Y2xlID09PSAneWVhcmx5Jykge1xuICAgICAgY3VycmVudFBlcmlvZEVuZC5zZXRGdWxsWWVhcihjdXJyZW50UGVyaW9kRW5kLmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFBlcmlvZEVuZC5zZXRNb250aChjdXJyZW50UGVyaW9kRW5kLmdldE1vbnRoKCkgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHN1YnNjcmlwdGlvbiBkYXRhXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uRGF0YSA9IHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgIHBsYW5faWQ6IHBsYW5JZCxcbiAgICAgIGJpbGxpbmdfY3ljbGU6IGJpbGxpbmdDeWNsZSxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScgYXMgY29uc3QsXG4gICAgICBjdXJyZW50X3BlcmlvZF9zdGFydDogY3VycmVudFBlcmlvZFN0YXJ0LnRvSVNPU3RyaW5nKCksXG4gICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IGN1cnJlbnRQZXJpb2RFbmQudG9JU09TdHJpbmcoKSxcbiAgICAgIGNhbmNlbF9hdF9wZXJpb2RfZW5kOiBmYWxzZSxcbiAgICAgIHN0cmlwZV9zdWJzY3JpcHRpb25faWQ6IHBheW1lbnREYXRhPy5zdHJpcGVTdWJzY3JpcHRpb25JZCB8fCBudWxsLFxuICAgICAgc3RyaXBlX2N1c3RvbWVyX2lkOiBwYXltZW50RGF0YT8uc3RyaXBlQ3VzdG9tZXJJZCB8fCBudWxsLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIC8vIFVwc2VydCBzdWJzY3JpcHRpb24gKHVwZGF0ZSBpZiBleGlzdHMsIGluc2VydCBpZiBuZXcpXG4gICAgY29uc3QgeyBkYXRhOiBzdWJzY3JpcHRpb24sIGVycm9yOiBzdWJzY3JpcHRpb25FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnVwc2VydChzdWJzY3JpcHRpb25EYXRhLCB7XG4gICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkJ1xuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcGxhbl9pZCxcbiAgICAgICAgYmlsbGluZ19jeWNsZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICAgIHN1YnNjcmlwdGlvbl9wbGFucyAoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgbGltaXRzLFxuICAgICAgICAgIHByaWNlX21vbnRobHksXG4gICAgICAgICAgcHJpY2VfeWVhcmx5XG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGFzc2lnbmluZyBzdWJzY3JpcHRpb246Jywgc3Vic2NyaXB0aW9uRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXNzaWduIHN1YnNjcmlwdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghc3Vic2NyaXB0aW9uIHx8ICFzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uX3BsYW5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb24gZGV0YWlscycpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdXNhZ2UgdHJhY2tpbmcgZm9yIGN1cnJlbnQgbW9udGhcbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc3QgeyBlcnJvcjogdXNhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgIC51cHNlcnQoe1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgICB2aWRlb19ub3Rlc19jb3VudDogMCxcbiAgICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDAsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCxtb250aF95ZWFyJyxcbiAgICAgICAgaWdub3JlRHVwbGljYXRlczogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICBpZiAodXNhZ2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gV2FybmluZzogRmFpbGVkIHRvIGluaXRpYWxpemUgdXNhZ2UgdHJhY2tpbmc6JywgdXNhZ2VFcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciBoZXJlIGFzIHN1YnNjcmlwdGlvbiBhc3NpZ25tZW50IHdhcyBzdWNjZXNzZnVsXG4gICAgfVxuXG4gICAgY29uc3QgcGxhbkRhdGEgPSBzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uX3BsYW5zIGFzIGFueTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3Vic2NyaXB0aW9uX2lkOiBzdWJzY3JpcHRpb24uaWQsXG4gICAgICBwbGFuX2lkOiBzdWJzY3JpcHRpb24ucGxhbl9pZCxcbiAgICAgIHBsYW5fbmFtZTogcGxhbkRhdGEubmFtZSxcbiAgICAgIHBsYW5fZGlzcGxheV9uYW1lOiBwbGFuRGF0YS5kaXNwbGF5X25hbWUsXG4gICAgICBiaWxsaW5nX2N5Y2xlOiBzdWJzY3JpcHRpb24uYmlsbGluZ19jeWNsZSxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uLnN0YXR1cyxcbiAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgIGZlYXR1cmVzOiBwbGFuRGF0YS5mZWF0dXJlcyxcbiAgICAgIGxpbWl0czogcGxhbkRhdGEubGltaXRzLFxuICAgICAgcHJpY2VfbW9udGhseTogcGxhbkRhdGEucHJpY2VfbW9udGhseSxcbiAgICAgIHByaWNlX3llYXJseTogcGxhbkRhdGEucHJpY2VfeWVhcmx5XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBpbiBhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSAiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdWJzY3JpcHRpb25QbGFucyIsInN1cGFiYXNlIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJjb25zb2xlIiwiRXJyb3IiLCJnZXRVc2VyU3Vic2NyaXB0aW9uIiwidXNlcklkIiwidG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInVzZXJTdWIiLCJzaW5nbGUiLCJzdWJzY3JpcHRpb25fcGxhbnMiLCJwbGFuRGF0YSIsInN1YnNjcmlwdGlvbl9pZCIsImlkIiwicGxhbl9pZCIsInBsYW5fbmFtZSIsIm5hbWUiLCJwbGFuX2Rpc3BsYXlfbmFtZSIsImRpc3BsYXlfbmFtZSIsImJpbGxpbmdfY3ljbGUiLCJzdGF0dXMiLCJjdXJyZW50X3BlcmlvZF9lbmQiLCJmZWF0dXJlcyIsImxpbWl0cyIsInByaWNlX21vbnRobHkiLCJwcmljZV95ZWFybHkiLCJnZXRTdWJzY3JpcHRpb25QbGFuIiwicGxhbklkIiwiY2hlY2tVc2FnZUxpbWl0cyIsIm5vdGVUeXBlIiwibG9nIiwic3ViRXJyb3IiLCJjdXJyZW50TW9udGgiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInVzYWdlIiwidXNhZ2VFcnJvciIsImZyZWVQbGFuTGltaXRzIiwibm90ZXNfcGVyX21vbnRoIiwibWF4X3NhdmVkX25vdGVzIiwibWF4X3RleHRfbGVuZ3RoIiwiY3VycmVudFVzYWdlIiwibm90ZXNfZ2VuZXJhdGVkIiwidmlkZW9fbm90ZXNfY291bnQiLCJmaWxlX25vdGVzX2NvdW50IiwidGV4dF9ub3Rlc19jb3VudCIsInRvdGFsX3NhdmVkX25vdGVzIiwibW9udGhfeWVhciIsImNyZWF0ZVVzYWdlRXJyb3IiLCJpbnNlcnQiLCJ1c2VyX2lkIiwidXBkYXRlZF9hdCIsImNyZWF0ZVN1YkVycm9yIiwiY3VycmVudF9wZXJpb2Rfc3RhcnQiLCJub3ciLCJjYW5HZW5lcmF0ZSIsImNhblNhdmUiLCJyZWFzb24iLCJ1bmRlZmluZWQiLCJzdWJzY3JpcHRpb24iLCJwbGFuTGltaXRzIiwibW9udGhseUxpbWl0IiwiZmFsbGJhY2tVc2FnZSIsImluY3JlbWVudFVzYWdlIiwiZmV0Y2hFcnJvciIsImNvZGUiLCJ1cGRhdGVEYXRhIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJpbnNlcnREYXRhIiwiY3JlYXRlZF9hdCIsImluc2VydEVycm9yIiwidXBkYXRlU2F2ZWROb3Rlc0NvdW50IiwiY291bnQiLCJ1cHNlcnQiLCJNYXRoIiwibWF4Iiwib25Db25mbGljdCIsInJlZnJlc2hTYXZlZE5vdGVzQ291bnQiLCJ2aWRlb1Jlc3VsdCIsImZpbGVSZXN1bHQiLCJ0ZXh0UmVzdWx0IiwiUHJvbWlzZSIsImFsbCIsImhlYWQiLCJ2aWRlb0NvdW50IiwiZmlsZUNvdW50IiwidGV4dENvdW50IiwidG90YWxDb3VudCIsInZpZGVvIiwiZmlsZSIsInRleHQiLCJ0b3RhbCIsImdldFBsYW5QcmljaW5nIiwicGxhbiIsIm1vbnRobHlQcmljZSIsInllYXJseVByaWNlIiwieWVhcmx5TW9udGhseUVxdWl2YWxlbnQiLCJkaXNjb3VudFBlcmNlbnRhZ2UiLCJyb3VuZCIsInllYXJseVNhdmluZ3MiLCJtb250aGx5IiwieWVhcmx5IiwiY3VycmVuY3kiLCJoYXNGZWF0dXJlQWNjZXNzIiwiZmVhdHVyZSIsImZyZWVGZWF0dXJlcyIsIm5vdGVzX2dlbmVyYXRpb24iLCJxdWl6emVzIiwieW91dHViZV9zdXBwb3J0IiwicHB0X3N1cHBvcnQiLCJleHBvcnQiLCJjb3B5X3Bhc3RlIiwidXBsb2FkX3ZpZGVvIiwicHJpb3JpdHlfZ2VuZXJhdGlvbiIsImFzc2lnblVzZXJTdWJzY3JpcHRpb24iLCJiaWxsaW5nQ3ljbGUiLCJwYXltZW50RGF0YSIsImN1cnJlbnRQZXJpb2RTdGFydCIsImN1cnJlbnRQZXJpb2RFbmQiLCJzZXRGdWxsWWVhciIsImdldEZ1bGxZZWFyIiwic2V0TW9udGgiLCJnZXRNb250aCIsInN1YnNjcmlwdGlvbkRhdGEiLCJjYW5jZWxfYXRfcGVyaW9kX2VuZCIsInN0cmlwZV9zdWJzY3JpcHRpb25faWQiLCJzdHJpcGVTdWJzY3JpcHRpb25JZCIsInN0cmlwZV9jdXN0b21lcl9pZCIsInN0cmlwZUN1c3RvbWVySWQiLCJzdWJzY3JpcHRpb25FcnJvciIsImlnbm9yZUR1cGxpY2F0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/subscription.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frefresh-usage%2Froute&page=%2Fapi%2Frefresh-usage%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frefresh-usage%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();