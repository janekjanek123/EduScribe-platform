"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/video-notes/route";
exports.ids = ["app/api/video-notes/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("net");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "querystring":
/*!******************************!*\
  !*** external "querystring" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("querystring");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("timers");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "vm":
/*!*********************!*\
  !*** external "vm" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("vm");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "node:buffer":
/*!******************************!*\
  !*** external "node:buffer" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:buffer");

/***/ }),

/***/ "node:child_process":
/*!*************************************!*\
  !*** external "node:child_process" ***!
  \*************************************/
/***/ ((module) => {

module.exports = require("node:child_process");

/***/ }),

/***/ "node:events":
/*!******************************!*\
  !*** external "node:events" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:events");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:os":
/*!**************************!*\
  !*** external "node:os" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:os");

/***/ }),

/***/ "node:path":
/*!****************************!*\
  !*** external "node:path" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:path");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

module.exports = require("node:process");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/promises":
/*!***************************************!*\
  !*** external "node:stream/promises" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("node:stream/promises");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "node:string_decoder":
/*!**************************************!*\
  !*** external "node:string_decoder" ***!
  \**************************************/
/***/ ((module) => {

module.exports = require("node:string_decoder");

/***/ }),

/***/ "node:timers/promises":
/*!***************************************!*\
  !*** external "node:timers/promises" ***!
  \***************************************/
/***/ ((module) => {

module.exports = require("node:timers/promises");

/***/ }),

/***/ "node:tty":
/*!***************************!*\
  !*** external "node:tty" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("node:tty");

/***/ }),

/***/ "node:url":
/*!***************************!*\
  !*** external "node:url" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("node:url");

/***/ }),

/***/ "node:util":
/*!****************************!*\
  !*** external "node:util" ***!
  \****************************/
/***/ ((module) => {

module.exports = require("node:util");

/***/ }),

/***/ "node:v8":
/*!**************************!*\
  !*** external "node:v8" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:v8");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvideo-notes%2Froute&page=%2Fapi%2Fvideo-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvideo-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvideo-notes%2Froute&page=%2Fapi%2Fvideo-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvideo-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_janjedrach_Cursor_eduscribe_src_app_api_video_notes_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/video-notes/route.ts */ \"(rsc)/./src/app/api/video-notes/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"standalone\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/video-notes/route\",\n        pathname: \"/api/video-notes\",\n        filename: \"route\",\n        bundlePath: \"app/api/video-notes/route\"\n    },\n    resolvedPagePath: \"/Users/janjedrach/Cursor/eduscribe/src/app/api/video-notes/route.ts\",\n    nextConfigOutput,\n    userland: _Users_janjedrach_Cursor_eduscribe_src_app_api_video_notes_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/video-notes/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZ2aWRlby1ub3RlcyUyRnJvdXRlJnBhZ2U9JTJGYXBpJTJGdmlkZW8tbm90ZXMlMkZyb3V0ZSZhcHBQYXRocz0mcGFnZVBhdGg9cHJpdmF0ZS1uZXh0LWFwcC1kaXIlMkZhcGklMkZ2aWRlby1ub3RlcyUyRnJvdXRlLnRzJmFwcERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9anMmcGFnZUV4dGVuc2lvbnM9anN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz1tZHgmcm9vdERpcj0lMkZVc2VycyUyRmphbmplZHJhY2glMkZDdXJzb3IlMkZlZHVzY3JpYmUmaXNEZXY9dHJ1ZSZ0c2NvbmZpZ1BhdGg9dHNjb25maWcuanNvbiZiYXNlUGF0aD0mYXNzZXRQcmVmaXg9Jm5leHRDb25maWdPdXRwdXQ9c3RhbmRhbG9uZSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBc0c7QUFDdkM7QUFDYztBQUNtQjtBQUNoRztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8/YTMzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcHBSb3V0ZVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvYXBwLXJvdXRlL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IHBhdGNoRmV0Y2ggYXMgX3BhdGNoRmV0Y2ggfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9saWIvcGF0Y2gtZmV0Y2hcIjtcbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIvVXNlcnMvamFuamVkcmFjaC9DdXJzb3IvZWR1c2NyaWJlL3NyYy9hcHAvYXBpL3ZpZGVvLW5vdGVzL3JvdXRlLnRzXCI7XG4vLyBXZSBpbmplY3QgdGhlIG5leHRDb25maWdPdXRwdXQgaGVyZSBzbyB0aGF0IHdlIGNhbiB1c2UgdGhlbSBpbiB0aGUgcm91dGVcbi8vIG1vZHVsZS5cbmNvbnN0IG5leHRDb25maWdPdXRwdXQgPSBcInN0YW5kYWxvbmVcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvdmlkZW8tbm90ZXMvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS92aWRlby1ub3Rlc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvdmlkZW8tbm90ZXMvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCIvVXNlcnMvamFuamVkcmFjaC9DdXJzb3IvZWR1c2NyaWJlL3NyYy9hcHAvYXBpL3ZpZGVvLW5vdGVzL3JvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MgfSA9IHJvdXRlTW9kdWxlO1xuY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IFwiL2FwaS92aWRlby1ub3Rlcy9yb3V0ZVwiO1xuZnVuY3Rpb24gcGF0Y2hGZXRjaCgpIHtcbiAgICByZXR1cm4gX3BhdGNoRmV0Y2goe1xuICAgICAgICBzZXJ2ZXJIb29rcyxcbiAgICAgICAgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZVxuICAgIH0pO1xufVxuZXhwb3J0IHsgcm91dGVNb2R1bGUsIHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzLCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvideo-notes%2Froute&page=%2Fapi%2Fvideo-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvideo-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/video-notes/route.ts":
/*!******************************************!*\
  !*** ./src/app/api/video-notes/route.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DELETE: () => (/* binding */ DELETE),\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   POST: () => (/* binding */ POST),\n/* harmony export */   dynamic: () => (/* binding */ dynamic)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/* harmony import */ var _services_youtube__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/services/youtube */ \"(rsc)/./src/services/youtube.ts\");\n/* harmony import */ var _services_ai__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/services/ai */ \"(rsc)/./src/services/ai.ts\");\n/* harmony import */ var _services_subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/services/subscription */ \"(rsc)/./src/services/subscription.ts\");\n/* harmony import */ var _services_queue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @/services/queue */ \"(rsc)/./src/services/queue.ts\");\n\n\n\n\n\n\n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get user's subscription plan for queue priority\n */ async function getSubscriptionPlan(userId) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey);\n        const { data } = await supabase.from(\"user_subscriptions\").select(\"plan_id\").eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        const planId = data?.plan_id;\n        // Ensure we return a valid plan type\n        if (planId === \"student\" || planId === \"pro\") {\n            return {\n                planId\n            };\n        }\n        return {\n            planId: \"free\"\n        };\n    } catch (error) {\n        console.warn(\"[Video Notes API] Could not fetch subscription:\", error);\n        return {\n            planId: \"free\"\n        };\n    }\n}\n/**\n * Video Notes API Endpoint - Isolated System\n * \n * Processes a YouTube URL to:\n * 1. Extract the video ID\n * 2. Get video information (title, thumbnail)\n * 3. Fetch the transcript\n * 4. Generate AI notes\n * 5. Store in the isolated video_notes table\n */ async function POST(request) {\n    console.log(\"[Video Notes API] Request received: POST\");\n    try {\n        // STEP 1: Authenticate the request\n        console.log(\"[Video Notes API] Authenticating request\");\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[Video Notes API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[Video Notes API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[Video Notes API] User authenticated: ${user.id}`);\n        // STEP 1.5: Check usage limits BEFORE processing\n        console.log(\"[Video Notes API] Checking usage limits\");\n        const usageCheck = await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.checkUsageLimits)(user.id, token, \"video\");\n        if (!usageCheck.canGenerate) {\n            console.log(`[Video Notes API] Generation limit reached: ${usageCheck.reason}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Generation limit reached\",\n                message: usageCheck.reason || \"You have reached your monthly note generation limit\",\n                usage: usageCheck.usage,\n                limits: usageCheck.limits\n            }, {\n                status: 429\n            }); // 429 = Too Many Requests\n        }\n        if (!usageCheck.canSave) {\n            console.log(`[Video Notes API] Storage limit reached: ${usageCheck.reason}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Storage limit reached\",\n                message: usageCheck.reason || \"You have reached your saved notes limit\",\n                usage: usageCheck.usage,\n                limits: usageCheck.limits\n            }, {\n                status: 429\n            });\n        }\n        console.log(`[Video Notes API] Usage check passed - can generate: ${usageCheck.canGenerate}, can save: ${usageCheck.canSave}`);\n        // Get user's subscription for priority\n        const subscription = await getSubscriptionPlan(user.id);\n        // Wrap the processing in queue\n        const result = await (0,_services_queue__WEBPACK_IMPORTED_MODULE_4__.queueRequest)(user.id, subscription.planId, \"video\", async ()=>{\n            // Original processing logic goes here\n            const body = await request.json();\n            const { url, title: customTitle } = body;\n            if (!url) {\n                console.error(\"[Video Notes API] Missing URL parameter\");\n                return {\n                    success: false,\n                    error: \"Missing URL\",\n                    message: \"Please provide a YouTube URL\"\n                };\n            }\n            console.log(`[Video Notes API] Processing URL: ${url}`);\n            // STEP 3: Extract and validate YouTube video ID\n            const videoId = (0,_services_youtube__WEBPACK_IMPORTED_MODULE_1__.extractYouTubeId)(url);\n            if (!videoId || !(0,_services_youtube__WEBPACK_IMPORTED_MODULE_1__.isValidYouTubeId)(videoId)) {\n                console.error(\"[Video Notes API] Invalid YouTube URL:\", url);\n                return {\n                    success: false,\n                    error: \"Invalid YouTube URL\",\n                    message: \"The provided URL is not a valid YouTube video URL\"\n                };\n            }\n            console.log(`[Video Notes API] Valid YouTube ID: ${videoId}`);\n            // STEP 4: Check if we already have notes for this video\n            try {\n                const { data: existingNote, error: existingError } = await supabase.from(\"video_notes\").select(\"id, video_id\").eq(\"video_id\", videoId).eq(\"user_id\", user.id).single();\n                if (existingNote && !existingError) {\n                    console.log(`[Video Notes API] Notes already exist for video: ${videoId}`);\n                    return {\n                        success: false,\n                        error: \"Duplicate note\",\n                        message: \"Notes for this video already exist\",\n                        noteId: existingNote.id\n                    };\n                }\n            } catch (checkError) {\n                console.error(\"[Video Notes API] Error checking for existing notes:\", checkError);\n            // Continue processing - this is not a critical error\n            }\n            // STEP 5: Get video information (title, thumbnail, etc.)\n            console.log(\"[Video Notes API] Fetching video information\");\n            const videoInfo = await (0,_services_youtube__WEBPACK_IMPORTED_MODULE_1__.getVideoInfo)(videoId);\n            if (!videoInfo || videoInfo.error) {\n                console.error(\"[Video Notes API] Failed to get video info:\", videoInfo?.error || \"Unknown error\");\n                return {\n                    success: false,\n                    error: \"Video info error\",\n                    message: videoInfo?.error || \"Failed to retrieve video information\"\n                };\n            }\n            console.log(`[Video Notes API] Video info retrieved: \"${videoInfo.title}\"`);\n            // STEP 6: Fetch video transcript\n            console.log(\"[Video Notes API] Fetching video transcript\");\n            const transcriptResult = await (0,_services_youtube__WEBPACK_IMPORTED_MODULE_1__.getVideoTranscript)(videoId);\n            if (!transcriptResult || transcriptResult.error) {\n                console.error(\"[Video Notes API] Transcript error:\", transcriptResult?.error || \"Unknown error\");\n                return {\n                    success: false,\n                    error: \"Transcript error\",\n                    message: transcriptResult?.error || \"Failed to extract transcript from the video\"\n                };\n            }\n            if (!transcriptResult.transcript || transcriptResult.transcript.trim().length === 0) {\n                console.error(\"[Video Notes API] Empty transcript\");\n                return {\n                    success: false,\n                    error: \"Empty transcript\",\n                    message: \"The video does not have any extractable content for notes\"\n                };\n            }\n            console.log(`[Video Notes API] Transcript retrieved (${transcriptResult.transcript.length} chars)`);\n            // STEP 7: Generate notes using AI\n            console.log(\"[Video Notes API] Generating notes from transcript\");\n            const notesResult = await (0,_services_ai__WEBPACK_IMPORTED_MODULE_2__.generateNotes)({\n                transcript: transcriptResult.transcript,\n                videoTitle: videoInfo.title\n            });\n            if (!notesResult.content) {\n                console.error(\"[Video Notes API] AI note generation failed:\", notesResult.error);\n                return {\n                    success: false,\n                    error: \"Note generation failed\",\n                    message: notesResult.error || \"Failed to generate notes from the transcript\"\n                };\n            }\n            console.log(`[Video Notes API] Successfully generated notes (${notesResult.content.length} chars)`);\n            // STEP 8: Create the note record for isolated video_notes table\n            const noteId = `video_${Date.now()}`;\n            const noteData = {\n                id: noteId,\n                user_id: user.id,\n                video_url: url,\n                video_id: videoId,\n                title: customTitle || videoInfo.title,\n                thumbnail_url: videoInfo.thumbnailUrl,\n                content: notesResult.content,\n                summary: notesResult.summary,\n                quiz: notesResult.quiz,\n                created_at: new Date().toISOString()\n            };\n            console.log(`[Video Notes API] Created note with ID: ${noteId}`);\n            console.log(\"[Video Notes API] Note data structure:\", Object.keys(noteData).join(\", \"));\n            // STEP 9: Store the note in Supabase video_notes table\n            console.log(\"[Video Notes API] Storing note in Supabase video_notes table\");\n            try {\n                // Verify database connection before attempting insert\n                try {\n                    const { error: pingError } = await supabase.from(\"video_notes\").select(\"count\").limit(1);\n                    if (pingError) {\n                        console.error(\"[Video Notes API] Database connection check failed:\", pingError);\n                        return {\n                            success: false,\n                            error: \"Database connection error\",\n                            message: \"Could not connect to the database. Please try again later.\",\n                            details: {\n                                code: pingError.code,\n                                message: pingError.message\n                            }\n                        };\n                    }\n                } catch (pingException) {\n                    console.error(\"[Video Notes API] Database ping exception:\", pingException);\n                }\n                const { data, error } = await supabase.from(\"video_notes\").insert(noteData).select().single();\n                if (error) {\n                    console.error(\"[Video Notes API] Database storage error:\", error);\n                    // Log detailed diagnostic information\n                    console.error(\"[Video Notes API] Database error details:\", {\n                        code: error.code,\n                        message: error.message,\n                        details: error.details,\n                        hint: error.hint\n                    });\n                    // Handle specific database errors with appropriate status codes\n                    if (error.code === \"23505\") {\n                        return {\n                            success: false,\n                            error: \"Duplicate record\",\n                            message: \"Notes for this video already exist in the database\",\n                            details: {\n                                code: error.code,\n                                message: error.message\n                            }\n                        };\n                    } else if (error.code?.startsWith(\"22\") || error.code?.startsWith(\"23\")) {\n                        // Data exception (22) or integrity constraint violation (23)\n                        return {\n                            success: false,\n                            error: \"Invalid data format\",\n                            message: \"The note data could not be stored due to validation errors\",\n                            details: {\n                                code: error.code,\n                                message: error.message\n                            }\n                        };\n                    } else if (error.code === \"42P01\") {\n                        // Undefined table\n                        return {\n                            success: false,\n                            error: \"Schema error\",\n                            message: \"The video_notes table does not exist. Please run the database initialization.\",\n                            details: {\n                                code: error.code,\n                                message: error.message\n                            }\n                        };\n                    }\n                    return {\n                        success: false,\n                        error: \"Database error\",\n                        message: \"Failed to store the notes in the database\",\n                        details: {\n                            code: error.code,\n                            message: error.message\n                        }\n                    };\n                }\n                console.log(`[Video Notes API] Successfully stored note in database with ID: ${data?.id || noteId}`);\n                // STEP 10.5: Track usage after successful creation\n                console.log(\"[Video Notes API] Incrementing usage counters\");\n                try {\n                    await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.incrementUsage)(user.id, token, \"video\");\n                    console.log(\"[Video Notes API] Usage tracking completed\");\n                } catch (usageError) {\n                    console.error(\"[Video Notes API] Usage tracking failed (note still created):\", usageError);\n                // Don't fail the request if usage tracking fails\n                }\n                // STEP 10.6: Refresh saved notes count\n                console.log(\"[Video Notes API] Refreshing saved notes count\");\n                try {\n                    await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.refreshSavedNotesCount)(user.id, token);\n                    console.log(\"[Video Notes API] Saved notes count refreshed\");\n                } catch (countError) {\n                    console.error(\"[Video Notes API] Saved notes count refresh failed (note still created):\", countError);\n                // Don't fail the request if count refresh fails\n                }\n                return {\n                    success: true,\n                    data\n                };\n            } catch (dbError) {\n                console.error(\"[Video Notes API] Unexpected database error:\", dbError);\n                return {\n                    success: false,\n                    error: \"Database exception\",\n                    message: dbError?.message || \"An unexpected error occurred while storing notes\",\n                    details: dbError\n                };\n            }\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(result);\n    } catch (error) {\n        console.error(\"[Video Notes API] Critical error:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred on the server\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * Get all video notes for the authenticated user\n */ async function GET(request) {\n    console.log(\"[Video Notes API] Request received: GET\");\n    try {\n        // STEP 1: Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[Video Notes API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[Video Notes API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[Video Notes API] User authenticated: ${user.id}`);\n        // STEP 2: Fetch the user's video notes\n        const { data, error } = await supabase.from(\"video_notes\").select(\"*\").eq(\"user_id\", user.id).order(\"created_at\", {\n            ascending: false\n        });\n        if (error) {\n            console.error(\"[Video Notes API] Database fetch error:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Database error\",\n                message: \"Failed to fetch video notes from the database\",\n                details: {\n                    code: error.code,\n                    message: error.message\n                }\n            }, {\n                status: 500\n            });\n        }\n        console.log(`[Video Notes API] Successfully fetched ${data.length} video notes`);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            data\n        });\n    } catch (error) {\n        console.error(\"[Video Notes API] Error fetching video notes:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred while fetching video notes\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n/**\n * Delete a specific video note for the authenticated user\n */ async function DELETE(request) {\n    console.log(\"[Video Notes API] Request received: DELETE\");\n    try {\n        // STEP 1: Authenticate the request\n        const authHeader = request.headers.get(\"authorization\");\n        if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\n            console.error(\"[Video Notes API] Authentication missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication required\",\n                message: \"Valid Bearer token is required\"\n            }, {\n                status: 401\n            });\n        }\n        // Initialize Supabase client with the token\n        const token = authHeader.replace(\"Bearer \", \"\");\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_5__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        // Verify the user's token and set the session\n        const { data: { user }, error: authError } = await supabase.auth.getUser(token);\n        if (authError || !user) {\n            console.error(\"[Video Notes API] Authentication failed:\", authError?.message);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Authentication failed\",\n                message: authError?.message || \"Invalid authentication token\"\n            }, {\n                status: 401\n            });\n        }\n        console.log(`[Video Notes API] User authenticated: ${user.id}`);\n        // STEP 2: Get the note ID from query parameters\n        const noteId = request.nextUrl.searchParams.get(\"id\");\n        if (!noteId) {\n            console.error(\"[Video Notes API] Note ID missing\");\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Missing note ID\",\n                message: \"Note ID is required for deletion\"\n            }, {\n                status: 400\n            });\n        }\n        console.log(`[Video Notes API] Deleting note with ID: ${noteId}`);\n        // STEP 3: Delete the note (with user ownership check)\n        const { data, error } = await supabase.from(\"video_notes\").delete().eq(\"id\", noteId).eq(\"user_id\", user.id) // Ensure user can only delete their own notes\n        .select();\n        if (error) {\n            console.error(\"[Video Notes API] Database delete error:\", error);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Database error\",\n                message: \"Failed to delete the note from the database\",\n                details: {\n                    code: error.code,\n                    message: error.message\n                }\n            }, {\n                status: 500\n            });\n        }\n        // Check if any rows were affected\n        if (!data || data.length === 0) {\n            console.error(`[Video Notes API] Note not found or access denied: ${noteId}`);\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                success: false,\n                error: \"Note not found\",\n                message: \"The note was not found or you do not have permission to delete it\"\n            }, {\n                status: 404\n            });\n        }\n        console.log(`[Video Notes API] Successfully deleted note: ${noteId}`);\n        // Refresh saved notes count after deletion\n        try {\n            await (0,_services_subscription__WEBPACK_IMPORTED_MODULE_3__.refreshSavedNotesCount)(user.id, token);\n            console.log(\"[Video Notes API] Saved notes count refreshed after deletion\");\n        } catch (countError) {\n            console.error(\"[Video Notes API] Saved notes count refresh failed after deletion:\", countError);\n        // Don't fail the request if count refresh fails\n        }\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: true,\n            message: \"Note deleted successfully\",\n            data: data[0]\n        });\n    } catch (error) {\n        console.error(\"[Video Notes API] Error deleting video note:\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            success: false,\n            error: \"Server error\",\n            message: \"An unexpected error occurred while deleting the note\",\n            details: error.message\n        }, {\n            status: 500\n        });\n    }\n}\n// Configure dynamic behavior to avoid caching\nconst dynamic = \"force-dynamic\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNUbkIsTUFBTUEsSUFBSSxDQUFDLEVBQUU7UUFDZjtJQUNGLEVBQUUsT0FBT08sT0FBWTtRQUNuQkMsUUFBUUQsS0FBSyxDQUFDLGdEQUFnREE7UUFDOUQsT0FBTzNCLHFEQUFZQSxDQUFDcUMsSUFBSSxDQUFDO1lBQ3ZCQyxTQUFTO1lBQ1RYLE9BQU87WUFDUFksU0FBUztZQUNUcUQsU0FBU2pFLE1BQU1ZLE9BQU87UUFDeEIsR0FBRztZQUFFQyxRQUFRO1FBQUk7SUFDbkI7QUFDRjtBQUVBLDhDQUE4QztBQUN2QyxNQUFNbUUsVUFBVSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9zcmMvYXBwL2FwaS92aWRlby1ub3Rlcy9yb3V0ZS50cz9kNjJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRSZXF1ZXN0LCBOZXh0UmVzcG9uc2UgfSBmcm9tICduZXh0L3NlcnZlcic7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3VwYWJhc2UtanMnO1xuaW1wb3J0IHsgZXh0cmFjdFlvdVR1YmVJZCwgZ2V0VmlkZW9JbmZvLCBnZXRWaWRlb1RyYW5zY3JpcHQsIGlzVmFsaWRZb3VUdWJlSWQgfSBmcm9tICdAL3NlcnZpY2VzL3lvdXR1YmUnO1xuaW1wb3J0IHsgZ2VuZXJhdGVOb3RlcyB9IGZyb20gJ0Avc2VydmljZXMvYWknO1xuaW1wb3J0IHsgY2hlY2tVc2FnZUxpbWl0cywgaW5jcmVtZW50VXNhZ2UsIHJlZnJlc2hTYXZlZE5vdGVzQ291bnQgfSBmcm9tICdAL3NlcnZpY2VzL3N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBxdWV1ZVJlcXVlc3QgfSBmcm9tICdAL3NlcnZpY2VzL3F1ZXVlJztcblxuLy8gSW5pdGlhbGl6ZSBTdXBhYmFzZSBjbGllbnRcbmNvbnN0IHN1cGFiYXNlVXJsID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMITtcbmNvbnN0IHN1cGFiYXNlQW5vbktleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZITtcblxuLyoqXG4gKiBHZXQgdXNlcidzIHN1YnNjcmlwdGlvbiBwbGFuIGZvciBxdWV1ZSBwcmlvcml0eVxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25QbGFuKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTx7IHBsYW5JZDogJ2ZyZWUnIHwgJ3N0dWRlbnQnIHwgJ3BybycgfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXkpO1xuICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdCgncGxhbl9pZCcpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ3N0YXR1cycsICdhY3RpdmUnKVxuICAgICAgLnNpbmdsZSgpO1xuICAgIFxuICAgIGNvbnN0IHBsYW5JZCA9IGRhdGE/LnBsYW5faWQ7XG4gICAgXG4gICAgLy8gRW5zdXJlIHdlIHJldHVybiBhIHZhbGlkIHBsYW4gdHlwZVxuICAgIGlmIChwbGFuSWQgPT09ICdzdHVkZW50JyB8fCBwbGFuSWQgPT09ICdwcm8nKSB7XG4gICAgICByZXR1cm4geyBwbGFuSWQgfTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHsgcGxhbklkOiAnZnJlZScgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLndhcm4oJ1tWaWRlbyBOb3RlcyBBUEldIENvdWxkIG5vdCBmZXRjaCBzdWJzY3JpcHRpb246JywgZXJyb3IpO1xuICAgIHJldHVybiB7IHBsYW5JZDogJ2ZyZWUnIH07XG4gIH1cbn1cblxuLyoqXG4gKiBWaWRlbyBOb3RlcyBBUEkgRW5kcG9pbnQgLSBJc29sYXRlZCBTeXN0ZW1cbiAqIFxuICogUHJvY2Vzc2VzIGEgWW91VHViZSBVUkwgdG86XG4gKiAxLiBFeHRyYWN0IHRoZSB2aWRlbyBJRFxuICogMi4gR2V0IHZpZGVvIGluZm9ybWF0aW9uICh0aXRsZSwgdGh1bWJuYWlsKVxuICogMy4gRmV0Y2ggdGhlIHRyYW5zY3JpcHRcbiAqIDQuIEdlbmVyYXRlIEFJIG5vdGVzXG4gKiA1LiBTdG9yZSBpbiB0aGUgaXNvbGF0ZWQgdmlkZW9fbm90ZXMgdGFibGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc29sZS5sb2coJ1tWaWRlbyBOb3RlcyBBUEldIFJlcXVlc3QgcmVjZWl2ZWQ6IFBPU1QnKTtcblxuICB0cnkge1xuICAgIC8vIFNURVAgMTogQXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgY29uc29sZS5sb2coJ1tWaWRlbyBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW5nIHJlcXVlc3QnKTtcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlciB8fCAhYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW9uIG1pc3NpbmcnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdWYWxpZCBCZWFyZXIgdG9rZW4gaXMgcmVxdWlyZWQnXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IHdpdGggdGhlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnJlcGxhY2UoJ0JlYXJlciAnLCAnJyk7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyJ3MgdG9rZW4gYW5kIHNldCB0aGUgc2Vzc2lvblxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcih0b2tlbik7XG4gICAgaWYgKGF1dGhFcnJvciB8fCAhdXNlcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gQXV0aGVudGljYXRpb24gZmFpbGVkOicsIGF1dGhFcnJvcj8ubWVzc2FnZSk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gZmFpbGVkJyxcbiAgICAgICAgbWVzc2FnZTogYXV0aEVycm9yPy5tZXNzYWdlIHx8ICdJbnZhbGlkIGF1dGhlbnRpY2F0aW9uIHRva2VuJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtWaWRlbyBOb3RlcyBBUEldIFVzZXIgYXV0aGVudGljYXRlZDogJHt1c2VyLmlkfWApO1xuXG4gICAgLy8gU1RFUCAxLjU6IENoZWNrIHVzYWdlIGxpbWl0cyBCRUZPUkUgcHJvY2Vzc2luZ1xuICAgIGNvbnNvbGUubG9nKCdbVmlkZW8gTm90ZXMgQVBJXSBDaGVja2luZyB1c2FnZSBsaW1pdHMnKTtcbiAgICBjb25zdCB1c2FnZUNoZWNrID0gYXdhaXQgY2hlY2tVc2FnZUxpbWl0cyh1c2VyLmlkLCB0b2tlbiwgJ3ZpZGVvJyk7XG4gICAgXG4gICAgaWYgKCF1c2FnZUNoZWNrLmNhbkdlbmVyYXRlKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvIE5vdGVzIEFQSV0gR2VuZXJhdGlvbiBsaW1pdCByZWFjaGVkOiAke3VzYWdlQ2hlY2sucmVhc29ufWApO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnR2VuZXJhdGlvbiBsaW1pdCByZWFjaGVkJyxcbiAgICAgICAgbWVzc2FnZTogdXNhZ2VDaGVjay5yZWFzb24gfHwgJ1lvdSBoYXZlIHJlYWNoZWQgeW91ciBtb250aGx5IG5vdGUgZ2VuZXJhdGlvbiBsaW1pdCcsXG4gICAgICAgIHVzYWdlOiB1c2FnZUNoZWNrLnVzYWdlLFxuICAgICAgICBsaW1pdHM6IHVzYWdlQ2hlY2subGltaXRzXG4gICAgICB9LCB7IHN0YXR1czogNDI5IH0pOyAvLyA0MjkgPSBUb28gTWFueSBSZXF1ZXN0c1xuICAgIH1cbiAgICBcbiAgICBpZiAoIXVzYWdlQ2hlY2suY2FuU2F2ZSkge1xuICAgICAgY29uc29sZS5sb2coYFtWaWRlbyBOb3RlcyBBUEldIFN0b3JhZ2UgbGltaXQgcmVhY2hlZDogJHt1c2FnZUNoZWNrLnJlYXNvbn1gKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ1N0b3JhZ2UgbGltaXQgcmVhY2hlZCcsXG4gICAgICAgIG1lc3NhZ2U6IHVzYWdlQ2hlY2sucmVhc29uIHx8ICdZb3UgaGF2ZSByZWFjaGVkIHlvdXIgc2F2ZWQgbm90ZXMgbGltaXQnLFxuICAgICAgICB1c2FnZTogdXNhZ2VDaGVjay51c2FnZSxcbiAgICAgICAgbGltaXRzOiB1c2FnZUNoZWNrLmxpbWl0c1xuICAgICAgfSwgeyBzdGF0dXM6IDQyOSB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtWaWRlbyBOb3RlcyBBUEldIFVzYWdlIGNoZWNrIHBhc3NlZCAtIGNhbiBnZW5lcmF0ZTogJHt1c2FnZUNoZWNrLmNhbkdlbmVyYXRlfSwgY2FuIHNhdmU6ICR7dXNhZ2VDaGVjay5jYW5TYXZlfWApO1xuXG4gICAgLy8gR2V0IHVzZXIncyBzdWJzY3JpcHRpb24gZm9yIHByaW9yaXR5XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYXdhaXQgZ2V0U3Vic2NyaXB0aW9uUGxhbih1c2VyLmlkKTtcbiAgICBcbiAgICAvLyBXcmFwIHRoZSBwcm9jZXNzaW5nIGluIHF1ZXVlXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVldWVSZXF1ZXN0KFxuICAgICAgdXNlci5pZCxcbiAgICAgIHN1YnNjcmlwdGlvbi5wbGFuSWQsXG4gICAgICAndmlkZW8nLFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBPcmlnaW5hbCBwcm9jZXNzaW5nIGxvZ2ljIGdvZXMgaGVyZVxuICAgICAgICBjb25zdCBib2R5ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgICAgIGNvbnN0IHsgdXJsLCB0aXRsZTogY3VzdG9tVGl0bGUgfSA9IGJvZHk7XG5cbiAgICAgICAgaWYgKCF1cmwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBNaXNzaW5nIFVSTCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ01pc3NpbmcgVVJMJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdQbGVhc2UgcHJvdmlkZSBhIFlvdVR1YmUgVVJMJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvIE5vdGVzIEFQSV0gUHJvY2Vzc2luZyBVUkw6ICR7dXJsfWApO1xuXG4gICAgICAgIC8vIFNURVAgMzogRXh0cmFjdCBhbmQgdmFsaWRhdGUgWW91VHViZSB2aWRlbyBJRFxuICAgICAgICBjb25zdCB2aWRlb0lkID0gZXh0cmFjdFlvdVR1YmVJZCh1cmwpO1xuICAgICAgICBpZiAoIXZpZGVvSWQgfHwgIWlzVmFsaWRZb3VUdWJlSWQodmlkZW9JZCkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBJbnZhbGlkIFlvdVR1YmUgVVJMOicsIHVybCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIFlvdVR1YmUgVVJMJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZWQgVVJMIGlzIG5vdCBhIHZhbGlkIFlvdVR1YmUgdmlkZW8gVVJMJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvIE5vdGVzIEFQSV0gVmFsaWQgWW91VHViZSBJRDogJHt2aWRlb0lkfWApO1xuXG4gICAgICAgIC8vIFNURVAgNDogQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIG5vdGVzIGZvciB0aGlzIHZpZGVvXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyBkYXRhOiBleGlzdGluZ05vdGUsIGVycm9yOiBleGlzdGluZ0Vycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgLmZyb20oJ3ZpZGVvX25vdGVzJylcbiAgICAgICAgICAgIC5zZWxlY3QoJ2lkLCB2aWRlb19pZCcpXG4gICAgICAgICAgICAuZXEoJ3ZpZGVvX2lkJywgdmlkZW9JZClcbiAgICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgICAgICAuc2luZ2xlKCk7XG5cbiAgICAgICAgICBpZiAoZXhpc3RpbmdOb3RlICYmICFleGlzdGluZ0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvIE5vdGVzIEFQSV0gTm90ZXMgYWxyZWFkeSBleGlzdCBmb3IgdmlkZW86ICR7dmlkZW9JZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogJ0R1cGxpY2F0ZSBub3RlJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ05vdGVzIGZvciB0aGlzIHZpZGVvIGFscmVhZHkgZXhpc3QnLFxuICAgICAgICAgICAgICBub3RlSWQ6IGV4aXN0aW5nTm90ZS5pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGNoZWNrRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBFcnJvciBjaGVja2luZyBmb3IgZXhpc3Rpbmcgbm90ZXM6JywgY2hlY2tFcnJvcik7XG4gICAgICAgICAgLy8gQ29udGludWUgcHJvY2Vzc2luZyAtIHRoaXMgaXMgbm90IGEgY3JpdGljYWwgZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNURVAgNTogR2V0IHZpZGVvIGluZm9ybWF0aW9uICh0aXRsZSwgdGh1bWJuYWlsLCBldGMuKVxuICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gRmV0Y2hpbmcgdmlkZW8gaW5mb3JtYXRpb24nKTtcbiAgICAgICAgY29uc3QgdmlkZW9JbmZvID0gYXdhaXQgZ2V0VmlkZW9JbmZvKHZpZGVvSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF2aWRlb0luZm8gfHwgdmlkZW9JbmZvLmVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gRmFpbGVkIHRvIGdldCB2aWRlbyBpbmZvOicsIHZpZGVvSW5mbz8uZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ1ZpZGVvIGluZm8gZXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogdmlkZW9JbmZvPy5lcnJvciB8fCAnRmFpbGVkIHRvIHJldHJpZXZlIHZpZGVvIGluZm9ybWF0aW9uJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBWaWRlbyBpbmZvIHJldHJpZXZlZDogXCIke3ZpZGVvSW5mby50aXRsZX1cImApO1xuXG4gICAgICAgIC8vIFNURVAgNjogRmV0Y2ggdmlkZW8gdHJhbnNjcmlwdFxuICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gRmV0Y2hpbmcgdmlkZW8gdHJhbnNjcmlwdCcpO1xuICAgICAgICBjb25zdCB0cmFuc2NyaXB0UmVzdWx0ID0gYXdhaXQgZ2V0VmlkZW9UcmFuc2NyaXB0KHZpZGVvSWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCF0cmFuc2NyaXB0UmVzdWx0IHx8IHRyYW5zY3JpcHRSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBUcmFuc2NyaXB0IGVycm9yOicsIHRyYW5zY3JpcHRSZXN1bHQ/LmVycm9yIHx8ICdVbmtub3duIGVycm9yJyk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6ICdUcmFuc2NyaXB0IGVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHRyYW5zY3JpcHRSZXN1bHQ/LmVycm9yIHx8ICdGYWlsZWQgdG8gZXh0cmFjdCB0cmFuc2NyaXB0IGZyb20gdGhlIHZpZGVvJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghdHJhbnNjcmlwdFJlc3VsdC50cmFuc2NyaXB0IHx8IHRyYW5zY3JpcHRSZXN1bHQudHJhbnNjcmlwdC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gRW1wdHkgdHJhbnNjcmlwdCcpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRW1wdHkgdHJhbnNjcmlwdCcsXG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIHZpZGVvIGRvZXMgbm90IGhhdmUgYW55IGV4dHJhY3RhYmxlIGNvbnRlbnQgZm9yIG5vdGVzJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBUcmFuc2NyaXB0IHJldHJpZXZlZCAoJHt0cmFuc2NyaXB0UmVzdWx0LnRyYW5zY3JpcHQubGVuZ3RofSBjaGFycylgKTtcblxuICAgICAgICAvLyBTVEVQIDc6IEdlbmVyYXRlIG5vdGVzIHVzaW5nIEFJXG4gICAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW8gTm90ZXMgQVBJXSBHZW5lcmF0aW5nIG5vdGVzIGZyb20gdHJhbnNjcmlwdCcpO1xuICAgICAgICBjb25zdCBub3Rlc1Jlc3VsdCA9IGF3YWl0IGdlbmVyYXRlTm90ZXMoe1xuICAgICAgICAgIHRyYW5zY3JpcHQ6IHRyYW5zY3JpcHRSZXN1bHQudHJhbnNjcmlwdCxcbiAgICAgICAgICB2aWRlb1RpdGxlOiB2aWRlb0luZm8udGl0bGVcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIW5vdGVzUmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBBSSBub3RlIGdlbmVyYXRpb24gZmFpbGVkOicsIG5vdGVzUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ05vdGUgZ2VuZXJhdGlvbiBmYWlsZWQnLFxuICAgICAgICAgICAgbWVzc2FnZTogbm90ZXNSZXN1bHQuZXJyb3IgfHwgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBub3RlcyBmcm9tIHRoZSB0cmFuc2NyaXB0J1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkIG5vdGVzICgke25vdGVzUmVzdWx0LmNvbnRlbnQubGVuZ3RofSBjaGFycylgKTtcblxuICAgICAgICAvLyBTVEVQIDg6IENyZWF0ZSB0aGUgbm90ZSByZWNvcmQgZm9yIGlzb2xhdGVkIHZpZGVvX25vdGVzIHRhYmxlXG4gICAgICAgIGNvbnN0IG5vdGVJZCA9IGB2aWRlb18ke0RhdGUubm93KCl9YDtcbiAgICAgICAgY29uc3Qgbm90ZURhdGEgPSB7XG4gICAgICAgICAgaWQ6IG5vdGVJZCxcbiAgICAgICAgICB1c2VyX2lkOiB1c2VyLmlkLFxuICAgICAgICAgIHZpZGVvX3VybDogdXJsLFxuICAgICAgICAgIHZpZGVvX2lkOiB2aWRlb0lkLFxuICAgICAgICAgIHRpdGxlOiBjdXN0b21UaXRsZSB8fCB2aWRlb0luZm8udGl0bGUsXG4gICAgICAgICAgdGh1bWJuYWlsX3VybDogdmlkZW9JbmZvLnRodW1ibmFpbFVybCxcbiAgICAgICAgICBjb250ZW50OiBub3Rlc1Jlc3VsdC5jb250ZW50LFxuICAgICAgICAgIHN1bW1hcnk6IG5vdGVzUmVzdWx0LnN1bW1hcnksXG4gICAgICAgICAgcXVpejogbm90ZXNSZXN1bHQucXVpeixcbiAgICAgICAgICBjcmVhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zb2xlLmxvZyhgW1ZpZGVvIE5vdGVzIEFQSV0gQ3JlYXRlZCBub3RlIHdpdGggSUQ6ICR7bm90ZUlkfWApO1xuICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gTm90ZSBkYXRhIHN0cnVjdHVyZTonLCBPYmplY3Qua2V5cyhub3RlRGF0YSkuam9pbignLCAnKSk7XG5cbiAgICAgICAgLy8gU1RFUCA5OiBTdG9yZSB0aGUgbm90ZSBpbiBTdXBhYmFzZSB2aWRlb19ub3RlcyB0YWJsZVxuICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gU3RvcmluZyBub3RlIGluIFN1cGFiYXNlIHZpZGVvX25vdGVzIHRhYmxlJyk7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFZlcmlmeSBkYXRhYmFzZSBjb25uZWN0aW9uIGJlZm9yZSBhdHRlbXB0aW5nIGluc2VydFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9yOiBwaW5nRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ3ZpZGVvX25vdGVzJykuc2VsZWN0KCdjb3VudCcpLmxpbWl0KDEpO1xuICAgICAgICAgICAgaWYgKHBpbmdFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBEYXRhYmFzZSBjb25uZWN0aW9uIGNoZWNrIGZhaWxlZDonLCBwaW5nRXJyb3IpO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnRGF0YWJhc2UgY29ubmVjdGlvbiBlcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0NvdWxkIG5vdCBjb25uZWN0IHRvIHRoZSBkYXRhYmFzZS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICAgIGNvZGU6IHBpbmdFcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcGluZ0Vycm9yLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAocGluZ0V4Y2VwdGlvbikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gRGF0YWJhc2UgcGluZyBleGNlcHRpb246JywgcGluZ0V4Y2VwdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgIC5mcm9tKCd2aWRlb19ub3RlcycpXG4gICAgICAgICAgICAuaW5zZXJ0KG5vdGVEYXRhKVxuICAgICAgICAgICAgLnNlbGVjdCgpXG4gICAgICAgICAgICAuc2luZ2xlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBEYXRhYmFzZSBzdG9yYWdlIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTG9nIGRldGFpbGVkIGRpYWdub3N0aWMgaW5mb3JtYXRpb25cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIERhdGFiYXNlIGVycm9yIGRldGFpbHM6Jywge1xuICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5kZXRhaWxzLFxuICAgICAgICAgICAgICBoaW50OiBlcnJvci5oaW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSGFuZGxlIHNwZWNpZmljIGRhdGFiYXNlIGVycm9ycyB3aXRoIGFwcHJvcHJpYXRlIHN0YXR1cyBjb2Rlc1xuICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09ICcyMzUwNScpIHsgLy8gVW5pcXVlIHZpb2xhdGlvblxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiAnRHVwbGljYXRlIHJlY29yZCcsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vdGVzIGZvciB0aGlzIHZpZGVvIGFscmVhZHkgZXhpc3QgaW4gdGhlIGRhdGFiYXNlJyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZT8uc3RhcnRzV2l0aCgnMjInKSB8fCBlcnJvci5jb2RlPy5zdGFydHNXaXRoKCcyMycpKSB7XG4gICAgICAgICAgICAgIC8vIERhdGEgZXhjZXB0aW9uICgyMikgb3IgaW50ZWdyaXR5IGNvbnN0cmFpbnQgdmlvbGF0aW9uICgyMylcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgZGF0YSBmb3JtYXQnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgbm90ZSBkYXRhIGNvdWxkIG5vdCBiZSBzdG9yZWQgZHVlIHRvIHZhbGlkYXRpb24gZXJyb3JzJyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZSA9PT0gJzQyUDAxJykge1xuICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgdGFibGVcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ1NjaGVtYSBlcnJvcicsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSB2aWRlb19ub3RlcyB0YWJsZSBkb2VzIG5vdCBleGlzdC4gUGxlYXNlIHJ1biB0aGUgZGF0YWJhc2UgaW5pdGlhbGl6YXRpb24uJyxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIHN0b3JlIHRoZSBub3RlcyBpbiB0aGUgZGF0YWJhc2UnLFxuICAgICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBTdWNjZXNzZnVsbHkgc3RvcmVkIG5vdGUgaW4gZGF0YWJhc2Ugd2l0aCBJRDogJHtkYXRhPy5pZCB8fCBub3RlSWR9YCk7XG5cbiAgICAgICAgICAvLyBTVEVQIDEwLjU6IFRyYWNrIHVzYWdlIGFmdGVyIHN1Y2Nlc3NmdWwgY3JlYXRpb25cbiAgICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gSW5jcmVtZW50aW5nIHVzYWdlIGNvdW50ZXJzJyk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGluY3JlbWVudFVzYWdlKHVzZXIuaWQsIHRva2VuLCAndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbVmlkZW8gTm90ZXMgQVBJXSBVc2FnZSB0cmFja2luZyBjb21wbGV0ZWQnKTtcbiAgICAgICAgICB9IGNhdGNoICh1c2FnZUVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBVc2FnZSB0cmFja2luZyBmYWlsZWQgKG5vdGUgc3RpbGwgY3JlYXRlZCk6JywgdXNhZ2VFcnJvcik7XG4gICAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0IGlmIHVzYWdlIHRyYWNraW5nIGZhaWxzXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU1RFUCAxMC42OiBSZWZyZXNoIHNhdmVkIG5vdGVzIGNvdW50XG4gICAgICAgICAgY29uc29sZS5sb2coJ1tWaWRlbyBOb3RlcyBBUEldIFJlZnJlc2hpbmcgc2F2ZWQgbm90ZXMgY291bnQnKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcmVmcmVzaFNhdmVkTm90ZXNDb3VudCh1c2VyLmlkLCB0b2tlbik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gU2F2ZWQgbm90ZXMgY291bnQgcmVmcmVzaGVkJyk7XG4gICAgICAgICAgfSBjYXRjaCAoY291bnRFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gU2F2ZWQgbm90ZXMgY291bnQgcmVmcmVzaCBmYWlsZWQgKG5vdGUgc3RpbGwgY3JlYXRlZCk6JywgY291bnRFcnJvcik7XG4gICAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0IGlmIGNvdW50IHJlZnJlc2ggZmFpbHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChkYkVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBVbmV4cGVjdGVkIGRhdGFiYXNlIGVycm9yOicsIGRiRXJyb3IpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXhjZXB0aW9uJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGRiRXJyb3I/Lm1lc3NhZ2UgfHwgJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgc3RvcmluZyBub3RlcycsXG4gICAgICAgICAgICBkZXRhaWxzOiBkYkVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24ocmVzdWx0KTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIENyaXRpY2FsIGVycm9yOicsIGVycm9yKTtcbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogJ1NlcnZlciBlcnJvcicsXG4gICAgICBtZXNzYWdlOiAnQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyJyxcbiAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2VcbiAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGFsbCB2aWRlbyBub3RlcyBmb3IgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlclxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIGNvbnNvbGUubG9nKCdbVmlkZW8gTm90ZXMgQVBJXSBSZXF1ZXN0IHJlY2VpdmVkOiBHRVQnKTtcblxuICB0cnkge1xuICAgIC8vIFNURVAgMTogQXV0aGVudGljYXRlIHRoZSByZXF1ZXN0XG4gICAgY29uc3QgYXV0aEhlYWRlciA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ2F1dGhvcml6YXRpb24nKTtcbiAgICBpZiAoIWF1dGhIZWFkZXIgfHwgIWF1dGhIZWFkZXIuc3RhcnRzV2l0aCgnQmVhcmVyICcpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBBdXRoZW50aWNhdGlvbiBtaXNzaW5nJyk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gcmVxdWlyZWQnLFxuICAgICAgICBtZXNzYWdlOiAnVmFsaWQgQmVhcmVyIHRva2VuIGlzIHJlcXVpcmVkJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIFN1cGFiYXNlIGNsaWVudCB3aXRoIHRoZSB0b2tlblxuICAgIGNvbnN0IHRva2VuID0gYXV0aEhlYWRlci5yZXBsYWNlKCdCZWFyZXIgJywgJycpO1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIFZlcmlmeSB0aGUgdXNlcidzIHRva2VuIGFuZCBzZXQgdGhlIHNlc3Npb25cbiAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogYXV0aEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZS5hdXRoLmdldFVzZXIodG9rZW4pO1xuICAgIGlmIChhdXRoRXJyb3IgfHwgIXVzZXIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW9uIGZhaWxlZDonLCBhdXRoRXJyb3I/Lm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHsgXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0F1dGhlbnRpY2F0aW9uIGZhaWxlZCcsXG4gICAgICAgIG1lc3NhZ2U6IGF1dGhFcnJvcj8ubWVzc2FnZSB8fCAnSW52YWxpZCBhdXRoZW50aWNhdGlvbiB0b2tlbidcbiAgICAgIH0sIHsgc3RhdHVzOiA0MDEgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBVc2VyIGF1dGhlbnRpY2F0ZWQ6ICR7dXNlci5pZH1gKTtcblxuICAgIC8vIFNURVAgMjogRmV0Y2ggdGhlIHVzZXIncyB2aWRlbyBub3Rlc1xuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlkZW9fbm90ZXMnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgLm9yZGVyKCdjcmVhdGVkX2F0JywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBEYXRhYmFzZSBmZXRjaCBlcnJvcjonLCBlcnJvcik7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdEYXRhYmFzZSBlcnJvcicsXG4gICAgICAgIG1lc3NhZ2U6ICdGYWlsZWQgdG8gZmV0Y2ggdmlkZW8gbm90ZXMgZnJvbSB0aGUgZGF0YWJhc2UnLFxuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgY29kZTogZXJyb3IuY29kZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlXG4gICAgICAgIH1cbiAgICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCAke2RhdGEubGVuZ3RofSB2aWRlbyBub3Rlc2ApO1xuXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBFcnJvciBmZXRjaGluZyB2aWRlbyBub3RlczonLCBlcnJvcik7XG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6ICdTZXJ2ZXIgZXJyb3InLFxuICAgICAgbWVzc2FnZTogJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdmlkZW8gbm90ZXMnLFxuICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZVxuICAgIH0sIHsgc3RhdHVzOiA1MDAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGUgYSBzcGVjaWZpYyB2aWRlbyBub3RlIGZvciB0aGUgYXV0aGVudGljYXRlZCB1c2VyXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBERUxFVEUocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcbiAgY29uc29sZS5sb2coJ1tWaWRlbyBOb3RlcyBBUEldIFJlcXVlc3QgcmVjZWl2ZWQ6IERFTEVURScpO1xuXG4gIHRyeSB7XG4gICAgLy8gU1RFUCAxOiBBdXRoZW50aWNhdGUgdGhlIHJlcXVlc3RcbiAgICBjb25zdCBhdXRoSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzLmdldCgnYXV0aG9yaXphdGlvbicpO1xuICAgIGlmICghYXV0aEhlYWRlciB8fCAhYXV0aEhlYWRlci5zdGFydHNXaXRoKCdCZWFyZXIgJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIEF1dGhlbnRpY2F0aW9uIG1pc3NpbmcnKTtcbiAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IFxuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdBdXRoZW50aWNhdGlvbiByZXF1aXJlZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdWYWxpZCBCZWFyZXIgdG9rZW4gaXMgcmVxdWlyZWQnXG4gICAgICB9LCB7IHN0YXR1czogNDAxIH0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50IHdpdGggdGhlIHRva2VuXG4gICAgY29uc3QgdG9rZW4gPSBhdXRoSGVhZGVyLnJlcGxhY2UoJ0JlYXJlciAnLCAnJyk7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgLy8gVmVyaWZ5IHRoZSB1c2VyJ3MgdG9rZW4gYW5kIHNldCB0aGUgc2Vzc2lvblxuICAgIGNvbnN0IHsgZGF0YTogeyB1c2VyIH0sIGVycm9yOiBhdXRoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmF1dGguZ2V0VXNlcih0b2tlbik7XG4gICAgaWYgKGF1dGhFcnJvciB8fCAhdXNlcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gQXV0aGVudGljYXRpb24gZmFpbGVkOicsIGF1dGhFcnJvcj8ubWVzc2FnZSk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oeyBcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQXV0aGVudGljYXRpb24gZmFpbGVkJyxcbiAgICAgICAgbWVzc2FnZTogYXV0aEVycm9yPy5tZXNzYWdlIHx8ICdJbnZhbGlkIGF1dGhlbnRpY2F0aW9uIHRva2VuJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMSB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtWaWRlbyBOb3RlcyBBUEldIFVzZXIgYXV0aGVudGljYXRlZDogJHt1c2VyLmlkfWApO1xuXG4gICAgLy8gU1RFUCAyOiBHZXQgdGhlIG5vdGUgSUQgZnJvbSBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgY29uc3Qgbm90ZUlkID0gcmVxdWVzdC5uZXh0VXJsLnNlYXJjaFBhcmFtcy5nZXQoJ2lkJyk7XG4gICAgaWYgKCFub3RlSWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIE5vdGUgSUQgbWlzc2luZycpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnTWlzc2luZyBub3RlIElEJyxcbiAgICAgICAgbWVzc2FnZTogJ05vdGUgSUQgaXMgcmVxdWlyZWQgZm9yIGRlbGV0aW9uJ1xuICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhgW1ZpZGVvIE5vdGVzIEFQSV0gRGVsZXRpbmcgbm90ZSB3aXRoIElEOiAke25vdGVJZH1gKTtcblxuICAgIC8vIFNURVAgMzogRGVsZXRlIHRoZSBub3RlICh3aXRoIHVzZXIgb3duZXJzaGlwIGNoZWNrKVxuICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndmlkZW9fbm90ZXMnKVxuICAgICAgLmRlbGV0ZSgpXG4gICAgICAuZXEoJ2lkJywgbm90ZUlkKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZCkgLy8gRW5zdXJlIHVzZXIgY2FuIG9ubHkgZGVsZXRlIHRoZWlyIG93biBub3Rlc1xuICAgICAgLnNlbGVjdCgpO1xuICAgICAgXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbVmlkZW8gTm90ZXMgQVBJXSBEYXRhYmFzZSBkZWxldGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnRGF0YWJhc2UgZXJyb3InLFxuICAgICAgICBtZXNzYWdlOiAnRmFpbGVkIHRvIGRlbGV0ZSB0aGUgbm90ZSBmcm9tIHRoZSBkYXRhYmFzZScsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBjb2RlOiBlcnJvci5jb2RlLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfVxuICAgICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYW55IHJvd3Mgd2VyZSBhZmZlY3RlZFxuICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcihgW1ZpZGVvIE5vdGVzIEFQSV0gTm90ZSBub3QgZm91bmQgb3IgYWNjZXNzIGRlbmllZDogJHtub3RlSWR9YCk7XG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdOb3RlIG5vdCBmb3VuZCcsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgbm90ZSB3YXMgbm90IGZvdW5kIG9yIHlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGRlbGV0ZSBpdCdcbiAgICAgIH0sIHsgc3RhdHVzOiA0MDQgfSk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbVmlkZW8gTm90ZXMgQVBJXSBTdWNjZXNzZnVsbHkgZGVsZXRlZCBub3RlOiAke25vdGVJZH1gKTtcblxuICAgIC8vIFJlZnJlc2ggc2F2ZWQgbm90ZXMgY291bnQgYWZ0ZXIgZGVsZXRpb25cbiAgICB0cnkge1xuICAgICAgYXdhaXQgcmVmcmVzaFNhdmVkTm90ZXNDb3VudCh1c2VyLmlkLCB0b2tlbik7XG4gICAgICBjb25zb2xlLmxvZygnW1ZpZGVvIE5vdGVzIEFQSV0gU2F2ZWQgbm90ZXMgY291bnQgcmVmcmVzaGVkIGFmdGVyIGRlbGV0aW9uJyk7XG4gICAgfSBjYXRjaCAoY291bnRFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1ZpZGVvIE5vdGVzIEFQSV0gU2F2ZWQgbm90ZXMgY291bnQgcmVmcmVzaCBmYWlsZWQgYWZ0ZXIgZGVsZXRpb246JywgY291bnRFcnJvcik7XG4gICAgICAvLyBEb24ndCBmYWlsIHRoZSByZXF1ZXN0IGlmIGNvdW50IHJlZnJlc2ggZmFpbHNcbiAgICB9XG5cbiAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6ICdOb3RlIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5JyxcbiAgICAgIGRhdGE6IGRhdGFbMF1cbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tWaWRlbyBOb3RlcyBBUEldIEVycm9yIGRlbGV0aW5nIHZpZGVvIG5vdGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiAnU2VydmVyIGVycm9yJyxcbiAgICAgIG1lc3NhZ2U6ICdBbiB1bmV4cGVjdGVkIGVycm9yIG9jY3VycmVkIHdoaWxlIGRlbGV0aW5nIHRoZSBub3RlJyxcbiAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2VcbiAgICB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59XG5cbi8vIENvbmZpZ3VyZSBkeW5hbWljIGJlaGF2aW9yIHRvIGF2b2lkIGNhY2hpbmdcbmV4cG9ydCBjb25zdCBkeW5hbWljID0gJ2ZvcmNlLWR5bmFtaWMnOyAiXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiY3JlYXRlQ2xpZW50IiwiZXh0cmFjdFlvdVR1YmVJZCIsImdldFZpZGVvSW5mbyIsImdldFZpZGVvVHJhbnNjcmlwdCIsImlzVmFsaWRZb3VUdWJlSWQiLCJnZW5lcmF0ZU5vdGVzIiwiY2hlY2tVc2FnZUxpbWl0cyIsImluY3JlbWVudFVzYWdlIiwicmVmcmVzaFNhdmVkTm90ZXNDb3VudCIsInF1ZXVlUmVxdWVzdCIsInN1cGFiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCIsInN1cGFiYXNlQW5vbktleSIsIk5FWFRfUFVCTElDX1NVUEFCQVNFX0FOT05fS0VZIiwiZ2V0U3Vic2NyaXB0aW9uUGxhbiIsInVzZXJJZCIsInN1cGFiYXNlIiwiZGF0YSIsImZyb20iLCJzZWxlY3QiLCJlcSIsInNpbmdsZSIsInBsYW5JZCIsInBsYW5faWQiLCJlcnJvciIsImNvbnNvbGUiLCJ3YXJuIiwiUE9TVCIsInJlcXVlc3QiLCJsb2ciLCJhdXRoSGVhZGVyIiwiaGVhZGVycyIsImdldCIsInN0YXJ0c1dpdGgiLCJqc29uIiwic3VjY2VzcyIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJ0b2tlbiIsInJlcGxhY2UiLCJnbG9iYWwiLCJBdXRob3JpemF0aW9uIiwidXNlciIsImF1dGhFcnJvciIsImF1dGgiLCJnZXRVc2VyIiwiaWQiLCJ1c2FnZUNoZWNrIiwiY2FuR2VuZXJhdGUiLCJyZWFzb24iLCJ1c2FnZSIsImxpbWl0cyIsImNhblNhdmUiLCJzdWJzY3JpcHRpb24iLCJyZXN1bHQiLCJib2R5IiwidXJsIiwidGl0bGUiLCJjdXN0b21UaXRsZSIsInZpZGVvSWQiLCJleGlzdGluZ05vdGUiLCJleGlzdGluZ0Vycm9yIiwibm90ZUlkIiwiY2hlY2tFcnJvciIsInZpZGVvSW5mbyIsInRyYW5zY3JpcHRSZXN1bHQiLCJ0cmFuc2NyaXB0IiwidHJpbSIsImxlbmd0aCIsIm5vdGVzUmVzdWx0IiwidmlkZW9UaXRsZSIsImNvbnRlbnQiLCJEYXRlIiwibm93Iiwibm90ZURhdGEiLCJ1c2VyX2lkIiwidmlkZW9fdXJsIiwidmlkZW9faWQiLCJ0aHVtYm5haWxfdXJsIiwidGh1bWJuYWlsVXJsIiwic3VtbWFyeSIsInF1aXoiLCJjcmVhdGVkX2F0IiwidG9JU09TdHJpbmciLCJPYmplY3QiLCJrZXlzIiwiam9pbiIsInBpbmdFcnJvciIsImxpbWl0IiwiZGV0YWlscyIsImNvZGUiLCJwaW5nRXhjZXB0aW9uIiwiaW5zZXJ0IiwiaGludCIsInVzYWdlRXJyb3IiLCJjb3VudEVycm9yIiwiZGJFcnJvciIsIkdFVCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwiREVMRVRFIiwibmV4dFVybCIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsImR5bmFtaWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/video-notes/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/ai.ts":
/*!****************************!*\
  !*** ./src/services/ai.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateNotes: () => (/* binding */ generateNotes)\n/* harmony export */ });\n/* harmony import */ var openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! openai */ \"(rsc)/./node_modules/openai/index.mjs\");\n/* harmony import */ var _utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/splitTranscript */ \"(rsc)/./src/utils/splitTranscript.ts\");\n\n\n// Validate API key presence\nconst openaiApiKey = process.env.OPENAI_API_KEY;\nif (!openaiApiKey) {\n    console.error(\"[OpenAI] API key is missing from environment variables!\");\n}\n// Initialize OpenAI client with error handling\nlet openai = null;\ntry {\n    openai = new openai__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n        apiKey: openaiApiKey\n    });\n} catch (error) {\n    console.error(\"[OpenAI] Failed to initialize client:\", error);\n}\nconst MAX_RETRIES = 2;\nconst RETRY_DELAY = 1000; // 1 second\n/**\n * Delays execution for specified milliseconds\n */ const delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n/**\n * Processes a single chunk of transcript using OpenAI with retries\n */ async function processChunkWithRetry(chunk, retryCount = 0) {\n    try {\n        // Validate OpenAI client initialization\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        // Validate chunk size\n        if (!(0,_utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__.isChunkWithinTokenLimit)(chunk)) {\n            throw new Error(\"Chunk exceeds token limit\");\n        }\n        console.log(`[OpenAI] Processing chunk ${chunk.index} (${chunk.content.length} chars)`);\n        const startTime = Date.now();\n        // Add timeout to prevent long-running requests\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Request timeout\")), 60000); // 60 second timeout\n        });\n        // Enhanced educational prompt for structured notes with deep semantic content\n        const completionPromise = openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational content creator, researcher, and teacher with deep knowledge across multiple domains. Create comprehensive, high-quality study notes with exceptional educational value and semantic depth.\n\nCRITICAL REQUIREMENTS:\n- Write in Polish\n- DO NOT include the original source text or transcript\n- Create ONLY summarized, structured educational notes with deep explanations\n- Use clear markdown formatting with proper headings\n- Structure like professional university-level study materials\n- Focus on DEEP SEMANTIC UNDERSTANDING and practical applications\n- ABSOLUTELY NO TABLES OF ANY KIND - NEVER USE | symbols or table syntax\n- AVOID REPETITIVE CONTENT - each concept should be explained once thoroughly\n- Provide CONCRETE TECHNIQUES, METHODS, and DETAILED EXPLANATIONS instead of generic statements\n\n❌ FORBIDDEN CONTENT PATTERNS:\n- Vague statements like \"istnieją metody\" without listing them\n- Repetitive explanations of the same concept across sections\n- Superficial overviews without depth\n- Generic advice without specific techniques\n- Any table format (| symbols, markdown tables, HTML tables)\n- \"Notatki:\" prefixes in titles\n\n✅ REQUIRED DEPTH AND QUALITY:\n- When mentioning techniques, LIST AND EXPLAIN them in detail\n- Provide step-by-step processes where applicable\n- Include specific examples, formulas, or procedures\n- Explain WHY concepts work, not just WHAT they are\n- Connect concepts to real-world applications\n- Give concrete, actionable information\n\nFORMATTING GUIDELINES - PROFESSIONAL & READABLE:\n- Start with a clear title using ## WITHOUT \"Notatki:\" prefix (e.g., ## 🧠 Techniki Efektywnego Uczenia)\n- Add one-sentence topic description right after title\n- Include \"📚 Przegląd Materiału\" section at top (5-6 bullet points max covering main concepts)\n- Use #### for main sections with emojis and numbering (e.g., #### 1. 🎯 Technika Pomodoro)\n- Use ##### for subsections when needed\n- Use moderate spacing between sections\n\nCONTENT STRUCTURE REQUIREMENTS:\n- REPLACE ALL TABLES with detailed bullet lists using \"Feature: Explanation\" format\n- Use **bold** sparingly for only the most important terms\n- Highlight key definitions with 🔑 icon: \"🔑 **Definicja:** *Term* - comprehensive explanation with context...\"\n- Highlight important concepts with 🎯 icon: \"🎯 **Kluczowy mechanizm:** detailed explanation of how it works...\"\n- For techniques, use step-by-step format:\n  **Implementacja techniki:**\n  1. **Krok 1**: szczegółowy opis działania\n  2. **Krok 2**: konkretne instrukcje\n  3. **Krok 3**: praktyczne wskazówki\n- Add section numbering (1., 2., 3.) for main topics\n- NEVER repeat the same definitions or explanations across sections\n\nEDUCATIONAL DEPTH REQUIREMENTS:\nWhen discussing any topic, you MUST:\n1. **Define precisely** - not just \"what is X\" but \"what is X, how does it work, and why is it important\"\n2. **List specific methods** - if mentioning \"techniques\" or \"methods\", always provide concrete examples:\n   - Instead of: \"istnieją techniki zapamiętywania\"\n   - Write: \"techniki zapamiętywania obejmują: Metodę Pałacu Pamięci (wizualizacja przestrzenna), System Powtórek Rozłożonych w Czasie (algorytm SM-2), Aktywne Przypominanie (retrieval practice), oraz Technikę Feynmana (wyjaśnianie prostymi słowami)\"\n3. **Explain mechanisms** - describe HOW and WHY things work\n4. **Provide procedures** - give step-by-step instructions for practical applications\n5. **Include real examples** - concrete scenarios, calculations, or implementations\n\nALTERNATIVE COMPARISON FORMATS (instead of tables):\n1. **Detailed Comparison Lists**:\n   **Różnice między metodą A i B:**\n   - **Efektywność**: Metoda A osiąga 85% skuteczność w badaniach kontrolowanych, podczas gdy metoda B pokazuje 72% skuteczność\n   - **Implementacja**: A wymaga 15-20 minut przygotowania, B można zastosować natychmiast\n   - **Zastosowanie**: A działa najlepiej przy materiale faktograficznym, B przy koncepcjach abstrakcyjnych\n   \n2. **Sequential Detailed Descriptions**:\n   **Metoda A - Szczegółowy Opis:**\n   - **Procedura**: Dokładne kroki 1-5 z czasem wykonania\n   - **Mechanizm działania**: Neurologiczne podstawy skuteczności\n   - **Optymalizacja**: Konkretne wskazówki dostosowania do różnych typów treści\n\nREQUIRED SECTIONS:\n1. **Title with emoji but NO \"Notatki:\" prefix** (just the topic name)\n2. **📚 Przegląd Materiału** (5-6 comprehensive overview points)\n3. **Numbered main sections** with deep content (aim for 3-4 major sections)\n4. **Detailed subsections** with specific techniques, methods, formulas\n5. **Section summaries after each major section** (paragraph style recap)\n6. **🎯 Szybkie Streszczenie** (3-6 lines max at very end) - NOT \"TL;DR\"\n\nSECTION SUMMARIES (ESSENTIAL):\nAfter each major section (####), add a substantive summary:\n> **Podsumowanie sekcji:** [4-6 sentence detailed explanation connecting all concepts from the section, explaining practical implications and how the techniques integrate with broader understanding]\n\nSEMANTIC DEPTH EXAMPLES:\n❌ AVOID: \"Technika Pomodoro jest metodą zarządzania czasem\"\n✅ PROVIDE: \"Technika Pomodoro jest metodą zarządzania czasem opartą na badaniach neuronaukowych dotyczących cykli uwagi. Polega na podziale pracy na 25-minutowe bloki (pomodoros) z 5-minutowymi przerwami, wykorzystując naturalny rytm uwagi mózgu i zapobiegając zmęczeniu poznawczemu poprzez aktywną regenerację prefrontalnej kory mózgowej.\"\n\n❌ AVOID: \"Istnieją różne metody uczenia\"\n✅ PROVIDE: \"Główne metody uczenia oparte na dowodach naukowych to: 1) Aktywne Przypominanie (retrieval practice) - aktywne odtwarzanie informacji z pamięci, co wzmacnia ścieżki neuronalne; 2) Powtórki Rozłożone (spaced repetition) - algorytmiczne planowanie powtórek w optymalnych odstępach czasu; 3) Naprzemienne Uczenie (interleaving) - mieszanie różnych typów zadań dla lepszej dyskryminacji pojęć; 4) Elaborative Interrogation - zadawanie pytań 'dlaczego' i 'jak' dla głębszego zrozumienia mechanizmów.\"\n\nVISUAL ENHANCEMENTS - BALANCED APPROACH:\n- Use emojis strategically for sections and key concepts\n- Format definitions as: \"🔑 **Definicja:** *Term* - comprehensive explanation with scientific background\"\n- Format key mechanisms as: \"🎯 **Kluczowy mechanizm:** detailed explanation of how and why it works\"\n- Use \"📋 *Procedura:*\" for step-by-step instructions\n- Use \"🧪 *Przykład:*\" for concrete examples with specific details\n- Use \"⚡ *Optymalizacja:*\" for advanced tips and customization\n- NEVER use any table format\n- Use moderate spacing and balanced formatting\n\nEXAMPLE STRUCTURE:\n## 🧠 Techniki Efektywnego Uczenia\nZaawansowane metody optymalizacji procesów poznawczych oparte na najnowszych badaniach neuronaukowych i psychologii kognitywnej.\n\n### 📚 Przegląd Materiału\n- Aktywne Przypominanie jako najskuteczniejsza metoda wzmacniania pamięci długotrwałej\n- System Powtórek Rozłożonych w Czasie z algorytmem SM-2 dla optymalnego planowania\n- Technika Pomodoro wykorzystująca naturalne cykle uwagi i regeneracji neuronowej\n- Metoda Feynmana dla głębokiego zrozumienia przez aktywne wyjaśnianie\n- Interleaving jako strategia poprawy dyskryminacji pojęciowej\n- Neuroplastyczność i jej praktyczne zastosowania w procesie uczenia\n\n#### 1. 🎯 Aktywne Przypominanie (Retrieval Practice)\n\n🔑 **Definicja:** *Aktywne Przypominanie* - metoda uczenia polegająca na aktywnym odtwarzaniu informacji z pamięci bez pomocy materiałów źródłowych, która według badań Hermann Ebbinghausa i współczesnych neuronaukowców zwiększa siłę połączeń synaptycznych o 300-400% w porównaniu do biernego powtarzania.\n\n**Mechanizm neurologiczny:**\n- **Wzmocnienie ścieżek neuronowych**: Każde aktywne przypomnienie aktywuje te same ścieżki neuronowe co pierwotne uczenie\n- **Konsolidacja pamięci**: Proces ten przenosi informacje z hipokampa do kory mózgowej dla długotrwałego przechowywania\n- **Efekt testowania**: Próba przypomnienia, nawet nieudana, wzmacnia pamięć lepiej niż wielokrotne czytanie\n\n📋 *Procedura implementacji:*\n1. **Przygotowanie materiału** (5 min): Podziel treść na logiczne sekcje po 200-300 słów\n2. **Pierwsza lektura** (15-20 min): Przeczytaj uważnie z pełnym skupieniem\n3. **Zamknięcie materiału** (0 min): Całkowicie usuń dostęp do notatek\n4. **Aktywne odtworzenie** (10-15 min): Napisz lub wypowiedz wszystko co pamiętasz\n5. **Weryfikacja i uzupełnienie** (5-10 min): Porównaj z oryginałem i uzupełnij luki\n6. **Powtórka po 24h**: Wykonaj ponownie kroki 3-5 bez ponownej lektury\n\n🧪 *Przykład praktyczny:*\nPrzy nauce biochemii: zamiast wielokrotnego czytania o cyklu Krebsa, narysuj pełny schemat z pamięci z nazwami wszystkich 8 etapów, enzymów i produktów. Sprawdź dokładność i uzupełnij błędy. Powtórz za tydzień.\n\n> **Podsumowanie sekcji:** Aktywne Przypominanie wykorzystuje fundamentalne właściwości neuroplastyczności mózgu, gdzie każda próba odtworzenia z pamięci wzmacnia połączenia synaptyczne. Technika ta jest szczególnie skuteczna przy materiałach faktograficznych i procedurach, gdzie kluczowe jest precyzyjne zapamiętanie sekwencji lub definicji. Regularne stosowanie tej metody prowadzi do trwałej reorganizacji sieci neuronowych, co przekłada się na znacznie lepsze wyniki w testach długoterminowych niż tradycyjne metody powtarzania.\n\n#### 2. ⏰ System Powtórek Rozłożonych (Spaced Repetition)\n\n🔑 **Definicja:** *System Powtórek Rozłożonych* - algorytmiczny system planowania powtórek oparty na krzywej zapominania Ebbinghausa, który optymalizuje interwały między powtórkami tak, aby maksymalizować retencję przy minimalnym nakładzie czasowym.\n\n**Algorytm SM-2 (SuperMemo):**\n- **Interwał 1**: 1 dzień\n- **Interwał 2**: 6 dni  \n- **Interwał n+1**: Interwał n × Współczynnik Łatwości (EF)\n- **Współczynnik Łatwości**: 1.3-2.5 w zależności od trudności (automatycznie dostosowywany)\n\n📋 *Procedura implementacji cyfrowej:*\n1. **Wybór narzędzia**: Anki, SuperMemo, lub Quizlet z funkcją SR\n2. **Tworzenie kart**: Jedna informacja na kartę (atomic principle)\n3. **Format pytanie-odpowiedź**: Konkretne, jednoznaczne sformułowania\n4. **Codzienna sesja**: 15-30 minut o stałej porze\n5. **Ocena trudności**: Szczerze oceń łatwość przypomnienia (1-5)\n6. **Konsystencja**: Minimum 80% dni w miesiącu dla efektywności\n\n⚡ *Optymalizacja zaawansowana:*\n- **Cloze deletion**: Uzupełnianie luk w kontekście (lepsze niż proste Q&A)\n- **Image occlusion**: Zakrywanie części diagramów/map\n- **Reverse cards**: Dwukierunkowe karty dla związków przyczynowo-skutkowych\n\n> **Podsumowanie sekcji:** System Powtórek Rozłożonych wykorzystuje matematyczną precyzję algorytmu SM-2 do optymalizacji naturalnego procesu zapominania. Kluczem sukcesu jest konsystentność i właściwe dostosowanie współczynników trudności do indywidualnych możliwości kognitywnych. System ten jest szczególnie skuteczny przy nauce języków obcych, terminologii medycznej i innych materiałach wymagających długotrwałej retencji faktów.\n\n### 🎯 Szybkie Streszczenie\n- **Aktywne Przypominanie**: Odtwarzanie z pamięci wzmacnia ścieżki neuronowe 3-4x skuteczniej niż czytanie\n- **Powtórki Rozłożone**: Algorytm SM-2 optymalizuje interwały dla maksymalnej retencji przy minimalnym czasie\n- **Implementacja**: Codzienne 15-30 min sesji z konsekwentną oceną trudności materiału\n- **Efektywność**: Kombinacja obu metod może zwiększyć długoterminową retencję o 200-400%\n\nREMEMBER: \n- NO \"Notatki:\" prefixes in titles\n- NO \"TL;DR\" - use \"Szybkie Streszczenie\" instead\n- Absolutely no tables whatsoever \n- DEEP SEMANTIC CONTENT with specific techniques and detailed explanations\n- AVOID REPETITIVE CONTENT across sections\n- Always provide concrete methods, procedures, and examples\n- Focus on educational value and practical applications\n\n${chunk.content}`\n                },\n                {\n                    role: \"user\",\n                    content: `Na podstawie poniższej treści utwórz profesjonalne notatki edukacyjne z głęboką analizą semantyczną. Skoncentruj się na konkretnych technikach, szczegółowych wyjaśnieniach i praktycznych zastosowaniach. Unikaj powierzchownych opisów - zamiast tego podawaj konkretne metody, procedury i mechanizmy działania. NIE używaj tabel, NIE powtarzaj treści, użyj \"Szybkie Streszczenie\" zamiast \"TL;DR\":\n\n${chunk.content}`\n                }\n            ],\n            temperature: 0.7\n        });\n        const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise\n        ]);\n        const duration = Date.now() - startTime;\n        // Log API response details for token usage monitoring\n        console.log(`[OpenAI] Chunk ${chunk.index} processed in ${duration}ms:`, {\n            promptTokens: completion.usage?.prompt_tokens,\n            completionTokens: completion.usage?.completion_tokens,\n            totalTokens: completion.usage?.total_tokens,\n            model: completion.model,\n            responseLength: completion.choices[0].message.content?.length || 0\n        });\n        const content = completion.choices[0].message.content || \"\";\n        return {\n            content,\n            chunkIndex: chunk.index\n        };\n    } catch (error) {\n        console.error(`[OpenAI] Error processing chunk ${chunk.index} (attempt ${retryCount + 1}):`, error);\n        // More detailed error logging for API issues\n        if (error instanceof Error) {\n            const errorDetails = error.toString();\n            // Network errors\n            if (errorDetails.includes(\"ECONNREFUSED\") || errorDetails.includes(\"ETIMEDOUT\") || errorDetails.includes(\"network\") || errorDetails.includes(\"connection\") || errorDetails.includes(\"socket\")) {\n                console.error(\"[OpenAI] Network error detected - check internet connection\");\n            } else if (errorDetails.includes(\"status code 401\") || errorDetails.includes(\"authentication\") || errorDetails.includes(\"api key\")) {\n                console.error(\"[OpenAI] Authentication error - check API key validity\");\n            } else if (errorDetails.includes(\"status code 429\")) {\n                console.error(\"[OpenAI] Rate limit exceeded - consider reducing request frequency\");\n            } else if (errorDetails.includes(\"status code 400\")) {\n                console.error(\"[OpenAI] Bad request error - check input format\");\n            } else if (errorDetails.includes(\"timeout\")) {\n                console.error(\"[OpenAI] Request timeout - API call took too long\");\n            }\n        }\n        // If we haven't exceeded max retries, try again after delay\n        if (retryCount < MAX_RETRIES) {\n            console.log(`[OpenAI] Retrying chunk ${chunk.index} after ${RETRY_DELAY * (retryCount + 1)}ms delay...`);\n            await delay(RETRY_DELAY * (retryCount + 1));\n            return processChunkWithRetry(chunk, retryCount + 1);\n        }\n        // If all retries failed, return error result\n        return {\n            content: \"\",\n            error: error instanceof Error ? error.message : \"Unknown error\",\n            chunkIndex: chunk.index\n        };\n    }\n}\n/**\n * Generates a quiz based on the content with appropriate number of questions\n */ async function generateQuiz(content, retryCount = 0) {\n    try {\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        console.log(`[OpenAI] Generating quiz for content (${content.length} chars)`);\n        // Determine number of questions based on content length\n        const contentLength = content.length;\n        let numQuestions;\n        if (contentLength <= 2000) {\n            numQuestions = 10;\n        } else if (contentLength <= 3000) {\n            numQuestions = 15;\n        } else {\n            numQuestions = 20;\n        }\n        const startTime = Date.now();\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Quiz generation timeout\")), 60000);\n        });\n        const completionPromise = openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational quiz creator and teacher. Create high-quality multiple-choice questions that test understanding of key concepts and help students learn effectively.\n\nQUIZ REQUIREMENTS:\n- Create exactly ${numQuestions} questions\n- Each question must have exactly 3 options (A, B, C)\n- Only ONE correct answer per question\n- Questions should test comprehension and understanding, not just memorization\n- Write in Polish\n- Include detailed, educational explanations for correct answers\n- Base ALL questions directly on the provided note content\n- Cover different sections and topics from the notes comprehensively\n\nQUESTION QUALITY STANDARDS:\n- Focus on key concepts, main ideas, and important definitions from the notes\n- Test different levels of understanding (knowledge, comprehension, application)\n- Avoid trick questions or overly specific details not covered in notes\n- Make incorrect options plausible but clearly distinguishable from correct answer\n- Ensure questions are clear, unambiguous, and educational\n- Connect to real-world applications when mentioned in the notes\n- Cover material from all major sections of the notes\n- Include questions about definitions, comparisons, and key features\n\nCONTENT COVERAGE:\n- Distribute questions across all major sections of the notes\n- Include questions about definitions and key terms\n- Test understanding of comparisons and differences\n- Ask about examples and applications mentioned in notes\n- Cover both factual knowledge and conceptual understanding\n- Ensure comprehensive coverage of the educational material\n\nEXPLANATION QUALITY:\n- Provide comprehensive explanations that teach the concept\n- Explain WHY the answer is correct based on the notes\n- Include additional context or related information from the notes\n- Help students understand the underlying principles\n- Use educational language that reinforces learning\n- Reference specific information from the notes when explaining\n\nRESPONSE FORMAT:\nReturn ONLY a valid JSON array with this exact structure:\n[\n  {\n    \"id\": \"q1\",\n    \"question\": \"Clear, educational question that tests understanding of content from the notes?\",\n    \"options\": {\n      \"A\": \"Plausible but incorrect option based on note content\",\n      \"B\": \"Correct answer with proper terminology from notes\", \n      \"C\": \"Another plausible but incorrect option from note content\"\n    },\n    \"correctAnswer\": \"B\",\n    \"explanation\": \"Detailed explanation of why this answer is correct based on the information provided in the notes. This should reference specific concepts, definitions, or facts from the educational material and help the student understand the topic better.\"\n  }\n]\n\nEnsure the JSON is perfectly formatted and valid. Focus on creating questions that genuinely help students learn and understand the material covered in the notes.`\n                },\n                {\n                    role: \"user\",\n                    content: `Na podstawie poniższych notatek edukacyjnych utwórz ${numQuestions} przemyślanych pytań wielokrotnego wyboru. Każde pytanie MUSI być oparte bezpośrednio na treści notatek. Sprawdzaj zrozumienie kluczowych pojęć, definicji, porównań i ważnych koncepcji z notatek. Pokryj wszystkie główne sekcje materiału. Dodaj szczegółowe wyjaśnienia odwołujące się do treści notatek:\n\n${content}`\n                }\n            ],\n            temperature: 0.3\n        });\n        const completion = await Promise.race([\n            completionPromise,\n            timeoutPromise\n        ]);\n        const duration = Date.now() - startTime;\n        console.log(`[OpenAI] Quiz generated in ${duration}ms`);\n        const quizContent = completion.choices[0].message.content || \"\";\n        try {\n            // Parse the JSON response\n            const quiz = JSON.parse(quizContent);\n            // Validate the quiz structure\n            if (!Array.isArray(quiz)) {\n                throw new Error(\"Quiz response is not an array\");\n            }\n            // Validate each question\n            for (const question of quiz){\n                if (!question.id || !question.question || !question.options || !question.correctAnswer) {\n                    throw new Error(\"Invalid question structure\");\n                }\n                if (!question.options.A || !question.options.B || !question.options.C) {\n                    throw new Error(\"Missing question options\");\n                }\n                if (![\n                    \"A\",\n                    \"B\",\n                    \"C\"\n                ].includes(question.correctAnswer)) {\n                    throw new Error(\"Invalid correct answer\");\n                }\n            }\n            console.log(`[OpenAI] Successfully generated ${quiz.length} quiz questions`);\n            return {\n                quiz\n            };\n        } catch (parseError) {\n            console.error(\"[OpenAI] Failed to parse quiz JSON:\", parseError);\n            console.error(\"[OpenAI] Raw quiz content:\", quizContent);\n            throw new Error(\"Failed to parse quiz response as valid JSON\");\n        }\n    } catch (error) {\n        console.error(`[OpenAI] Error generating quiz (attempt ${retryCount + 1}):`, error);\n        // Retry logic for quiz generation\n        if (retryCount < MAX_RETRIES) {\n            console.log(`[OpenAI] Retrying quiz generation after ${RETRY_DELAY * (retryCount + 1)}ms delay...`);\n            await delay(RETRY_DELAY * (retryCount + 1));\n            return generateQuiz(content, retryCount + 1);\n        }\n        // If all retries failed, return empty quiz with error\n        return {\n            quiz: [],\n            error: error instanceof Error ? error.message : \"Unknown error generating quiz\"\n        };\n    }\n}\n/**\n * Generates notes from a transcript using AI by processing it in chunks\n */ async function generateNotes(request) {\n    console.log(`[OpenAI] Starting notes generation for text (${request.transcript.length} chars)`);\n    const startTime = Date.now();\n    try {\n        // Validate OpenAI client initialization\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized due to configuration issues\");\n        }\n        // Validate transcript input\n        if (!request.transcript || typeof request.transcript !== \"string\" || request.transcript.trim().length === 0) {\n            throw new Error(\"Empty or invalid transcript provided\");\n        }\n        // Split transcript into chunks\n        const chunks = (0,_utils_splitTranscript__WEBPACK_IMPORTED_MODULE_0__.splitTranscriptIntoChunks)(request.transcript);\n        console.log(`[OpenAI] Split text into ${chunks.length} chunks`);\n        if (chunks.length === 0) {\n            throw new Error(\"No valid text chunks could be created from the transcript\");\n        }\n        // Process all chunks with retries\n        const chunkPromises = chunks.map((chunk)=>processChunkWithRetry(chunk));\n        const results = await Promise.all(chunkPromises);\n        // Sort results by chunk index to maintain order\n        results.sort((a, b)=>a.chunkIndex - b.chunkIndex);\n        // Track failed chunks\n        const failedChunks = results.filter((result)=>result.error).map((result)=>({\n                index: result.chunkIndex,\n                reason: result.error || \"Unknown error\",\n                attempts: MAX_RETRIES + 1,\n                startWord: chunks[result.chunkIndex]?.startWord || 0,\n                endWord: chunks[result.chunkIndex]?.endWord || 0\n            }));\n        // Log completion status\n        const duration = Date.now() - startTime;\n        console.log(`[OpenAI] Notes generation completed in ${duration}ms:`, {\n            totalChunks: chunks.length,\n            successfulChunks: chunks.length - failedChunks.length,\n            failedChunks: failedChunks.length\n        });\n        // If all chunks failed, throw an error\n        if (failedChunks.length === chunks.length) {\n            throw new Error(`All ${chunks.length} chunks failed to process. First error: ${failedChunks[0]?.reason}`);\n        }\n        // Combine successful chunks\n        const successfulNotes = results.filter((result)=>result.content).map((result)=>result.content).join(\"\\n\\n---\\n\\n\");\n        // If no content was generated despite some chunks \"succeeding\", that's an error\n        if (!successfulNotes || successfulNotes.trim().length === 0) {\n            throw new Error(\"No content was generated from any chunks\");\n        }\n        // Generate quiz based on the notes content\n        console.log(\"[OpenAI] Generating quiz for the notes...\");\n        const quizResult = await generateQuiz(successfulNotes);\n        if (quizResult.error) {\n            console.warn(\"[OpenAI] Quiz generation failed:\", quizResult.error);\n        } else {\n            console.log(`[OpenAI] Successfully generated ${quizResult.quiz.length} quiz questions`);\n        }\n        // Generate summary from the notes content\n        console.log(\"[OpenAI] Generating condensed summary from full notes\");\n        const summary = await generateSummary(successfulNotes);\n        // Return result with partial success information if needed\n        return {\n            content: successfulNotes,\n            summary: summary,\n            quiz: quizResult.quiz,\n            partialSuccess: failedChunks.length > 0,\n            failedChunks: failedChunks.length > 0 ? failedChunks : undefined,\n            error: failedChunks.length > 0 ? `Niektóre fragmenty nie zostały przetworzone (${failedChunks.length}/${chunks.length})` : undefined\n        };\n    } catch (error) {\n        const duration = Date.now() - startTime;\n        console.error(`[OpenAI] Error generating notes after ${duration}ms:`, error);\n        // Create user-friendly error message based on the type of error\n        let errorMessage = \"Wystąpił błąd podczas generowania notatek. Proszę spr\\xf3bować ponownie.\";\n        if (error instanceof Error) {\n            const errorDetails = error.toString();\n            if (errorDetails.includes(\"API key\")) {\n                errorMessage = \"Błąd konfiguracji API. Proszę skontaktować się z administratorem.\";\n            } else if (errorDetails.includes(\"network\") || errorDetails.includes(\"timeout\")) {\n                errorMessage = \"Problem z połączeniem sieciowym podczas komunikacji z API. Proszę spr\\xf3bować ponownie.\";\n            } else if (errorDetails.includes(\"rate limit\") || errorDetails.includes(\"429\")) {\n                errorMessage = \"Przekroczono limit zapytań do API. Proszę spr\\xf3bować ponownie za kilka minut.\";\n            } else if (errorDetails.includes(\"empty\") || errorDetails.includes(\"invalid transcript\")) {\n                errorMessage = \"Nie można wygenerować notatek z pustego lub nieprawidłowego transkryptu.\";\n            }\n        }\n        return {\n            content: \"\",\n            summary: \"\",\n            quiz: [],\n            error: errorMessage,\n            partialSuccess: false\n        };\n    }\n}\nasync function generateSummary(content, retryCount = 0) {\n    try {\n        console.log(\"[OpenAI] Generating condensed summary from full notes\");\n        if (!openai) {\n            throw new Error(\"OpenAI client is not initialized\");\n        }\n        const completion = await openai.chat.completions.create({\n            model: \"gpt-3.5-turbo\",\n            messages: [\n                {\n                    role: \"system\",\n                    content: `You are an expert educational summarizer specializing in creating concise, high-value summaries of academic content.\n\nCRITICAL REQUIREMENTS:\n- Write in Polish\n- Create a VERY SHORT summary (3-5 bullet points maximum)\n- Focus ONLY on the most essential, actionable insights\n- Write in simple, clear language suitable for quick review\n- Each point should be one concise sentence capturing a key concept or practical application\n- NO detailed explanations - just the core ideas that students need to remember\n- NO formatting, emojis, or markdown - just clean bullet points\n- AVOID repetitive content - each point should cover a different aspect\n\nSUMMARY QUALITY STANDARDS:\n- Each bullet point should represent a distinct, valuable insight\n- Focus on practical applications, key definitions, or important mechanisms\n- Prioritize information that would be most useful for exam review or quick reference\n- Balance theoretical concepts with practical applications\n- Use concrete, specific language rather than vague generalizations\n\nSTRUCTURE:\nCreate 3-5 bullet points that capture:\n- Most important definition or core concept (if applicable)\n- Key practical technique or method (with specific name/approach)\n- Critical mechanism or principle that explains \"how\" something works\n- Most significant application or real-world relevance\n- Essential takeaway for understanding or implementation\n\nLANGUAGE STYLE:\n- Professional but accessible\n- Specific terminology where appropriate\n- Active voice preferred\n- Concrete rather than abstract language\n\nEXAMPLE OUTPUT (for learning techniques topic):\n- Aktywne Przypominanie wzmacnia pamięć 3-4x skuteczniej niż pasywne czytanie przez aktywację tych samych ścieżek neuronowych\n- System Powtórek Rozłożonych wykorzystuje algorytm SM-2 do optymalizacji interwałów między powtórkami (1 dzień, 6 dni, następnie x2.5)\n- Technika Pomodoro dzieli pracę na 25-minutowe bloki z 5-minutowymi przerwami, wykorzystując naturalny cykl uwagi mózgu\n- Implementacja wymaga codziennej konsystencji przez minimum 80% dni w miesiącu dla osiągnięcia optymalnych rezultatów`\n                },\n                {\n                    role: \"user\",\n                    content: `Create a high-quality, condensed summary focusing on the most essential and actionable insights from these notes. Focus on key concepts, practical techniques, and important mechanisms that students should remember:\\n\\n${content}`\n                }\n            ],\n            max_tokens: 400,\n            temperature: 0.3\n        });\n        const summary = completion.choices[0]?.message?.content?.trim() || \"\";\n        if (!summary) {\n            throw new Error(\"Empty summary generated\");\n        }\n        console.log(`[OpenAI] Summary generated successfully (${summary.length} characters)`);\n        return summary;\n    } catch (error) {\n        console.error(`[OpenAI] Error generating summary (attempt ${retryCount + 1}):`, error.message);\n        if (retryCount < 2) {\n            console.log(`[OpenAI] Retrying summary generation in ${(retryCount + 1) * 1000}ms...`);\n            await delay((retryCount + 1) * 1000);\n            return generateSummary(content, retryCount + 1);\n        }\n        return \"Nie udało się wygenerować streszczenia.\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SEFxQ2tHLENBQUM7Z0JBQy9HO2dCQUNBO29CQUNFYyxNQUFNO29CQUNOZCxTQUFTLENBQUMsME5BQTBOLEVBQUVBLFFBQVEsQ0FBQztnQkFDalA7YUFDRDtZQUNEZ0YsWUFBWTtZQUNaakUsYUFBYTtRQUNmO1FBRUEsTUFBTTRELFVBQVUzRCxXQUFXVyxPQUFPLENBQUMsRUFBRSxFQUFFQyxTQUFTNUIsU0FBU3FELFVBQVU7UUFFbkUsSUFBSSxDQUFDc0IsU0FBUztZQUNaLE1BQU0sSUFBSTlFLE1BQU07UUFDbEI7UUFFQWQsUUFBUWUsR0FBRyxDQUFDLENBQUMseUNBQXlDLEVBQUU2RSxRQUFRMUUsTUFBTSxDQUFDLFlBQVksQ0FBQztRQUNwRixPQUFPMEU7SUFFVCxFQUFFLE9BQU8zRixPQUFZO1FBQ25CRCxRQUFRQyxLQUFLLENBQUMsQ0FBQywyQ0FBMkMsRUFBRVksYUFBYSxFQUFFLEVBQUUsQ0FBQyxFQUFFWixNQUFNNEMsT0FBTztRQUU3RixJQUFJaEMsYUFBYSxHQUFHO1lBQ2xCYixRQUFRZSxHQUFHLENBQUMsQ0FBQyx3Q0FBd0MsRUFBRSxDQUFDRixhQUFhLEtBQUssS0FBSyxLQUFLLENBQUM7WUFDckYsTUFBTVAsTUFBTSxDQUFDTyxhQUFhLEtBQUs7WUFDL0IsT0FBT2dGLGdCQUFnQjVFLFNBQVNKLGFBQWE7UUFDL0M7UUFFQSxPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy9haS50cz9lM2U1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcbmltcG9ydCB7IFRyYW5zY3JpcHRDaHVuaywgRmFpbGVkQ2h1bmssIHNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MsIGlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0IH0gZnJvbSAnLi4vdXRpbHMvc3BsaXRUcmFuc2NyaXB0JztcblxuZXhwb3J0IGludGVyZmFjZSBOb3Rlc0dlbmVyYXRpb25SZXF1ZXN0IHtcbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuICB2aWRlb1RpdGxlPzogc3RyaW5nO1xuICB2aWRlb1VybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBRdWl6UXVlc3Rpb24ge1xuICBpZDogc3RyaW5nO1xuICBxdWVzdGlvbjogc3RyaW5nO1xuICBvcHRpb25zOiB7XG4gICAgQTogc3RyaW5nO1xuICAgIEI6IHN0cmluZztcbiAgICBDOiBzdHJpbmc7XG4gIH07XG4gIGNvcnJlY3RBbnN3ZXI6ICdBJyB8ICdCJyB8ICdDJztcbiAgZXhwbGFuYXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZXNHZW5lcmF0aW9uUmVzcG9uc2Uge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHN1bW1hcnk6IHN0cmluZztcbiAgcXVpejogUXVpelF1ZXN0aW9uW107XG4gIGVycm9yPzogc3RyaW5nO1xuICBwYXJ0aWFsU3VjY2Vzcz86IGJvb2xlYW47XG4gIGZhaWxlZENodW5rcz86IEZhaWxlZENodW5rW107XG59XG5cbmludGVyZmFjZSBDaHVua1Byb2Nlc3NpbmdSZXN1bHQge1xuICBjb250ZW50OiBzdHJpbmc7XG4gIGVycm9yPzogc3RyaW5nO1xuICBjaHVua0luZGV4OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBRdWl6R2VuZXJhdGlvblJlc3VsdCB7XG4gIHF1aXo6IFF1aXpRdWVzdGlvbltdO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuLy8gVmFsaWRhdGUgQVBJIGtleSBwcmVzZW5jZVxuY29uc3Qgb3BlbmFpQXBpS2V5ID0gcHJvY2Vzcy5lbnYuT1BFTkFJX0FQSV9LRVk7XG5pZiAoIW9wZW5haUFwaUtleSkge1xuICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBBUEkga2V5IGlzIG1pc3NpbmcgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMhJyk7XG59XG5cbi8vIEluaXRpYWxpemUgT3BlbkFJIGNsaWVudCB3aXRoIGVycm9yIGhhbmRsaW5nXG5sZXQgb3BlbmFpOiBPcGVuQUkgfCBudWxsID0gbnVsbDtcbnRyeSB7XG4gIG9wZW5haSA9IG5ldyBPcGVuQUkoe1xuICAgIGFwaUtleTogb3BlbmFpQXBpS2V5LFxuICB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tPcGVuQUldIEZhaWxlZCB0byBpbml0aWFsaXplIGNsaWVudDonLCBlcnJvcik7XG59XG5cbmNvbnN0IE1BWF9SRVRSSUVTID0gMjtcbmNvbnN0IFJFVFJZX0RFTEFZID0gMTAwMDsgLy8gMSBzZWNvbmRcblxuLyoqXG4gKiBEZWxheXMgZXhlY3V0aW9uIGZvciBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzXG4gKi9cbmNvbnN0IGRlbGF5ID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuXG4vKipcbiAqIFByb2Nlc3NlcyBhIHNpbmdsZSBjaHVuayBvZiB0cmFuc2NyaXB0IHVzaW5nIE9wZW5BSSB3aXRoIHJldHJpZXNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NodW5rV2l0aFJldHJ5KFxuICBjaHVuazogVHJhbnNjcmlwdENodW5rLFxuICByZXRyeUNvdW50OiBudW1iZXIgPSAwXG4pOiBQcm9taXNlPENodW5rUHJvY2Vzc2luZ1Jlc3VsdD4ge1xuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIE9wZW5BSSBjbGllbnQgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAoIW9wZW5haSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIGNodW5rIHNpemVcbiAgICBpZiAoIWlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0KGNodW5rKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaHVuayBleGNlZWRzIHRva2VuIGxpbWl0Jyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFByb2Nlc3NpbmcgY2h1bmsgJHtjaHVuay5pbmRleH0gKCR7Y2h1bmsuY29udGVudC5sZW5ndGh9IGNoYXJzKWApO1xuICAgIFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgXG4gICAgLy8gQWRkIHRpbWVvdXQgdG8gcHJldmVudCBsb25nLXJ1bm5pbmcgcmVxdWVzdHNcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dCcpKSwgNjAwMDApOyAvLyA2MCBzZWNvbmQgdGltZW91dFxuICAgIH0pO1xuXG4gICAgLy8gRW5oYW5jZWQgZWR1Y2F0aW9uYWwgcHJvbXB0IGZvciBzdHJ1Y3R1cmVkIG5vdGVzIHdpdGggZGVlcCBzZW1hbnRpYyBjb250ZW50XG4gICAgY29uc3QgY29tcGxldGlvblByb21pc2UgPSBvcGVuYWkuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgbW9kZWw6IFwiZ3B0LTMuNS10dXJib1wiLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICAgICAgY29udGVudDogYFlvdSBhcmUgYW4gZXhwZXJ0IGVkdWNhdGlvbmFsIGNvbnRlbnQgY3JlYXRvciwgcmVzZWFyY2hlciwgYW5kIHRlYWNoZXIgd2l0aCBkZWVwIGtub3dsZWRnZSBhY3Jvc3MgbXVsdGlwbGUgZG9tYWlucy4gQ3JlYXRlIGNvbXByZWhlbnNpdmUsIGhpZ2gtcXVhbGl0eSBzdHVkeSBub3RlcyB3aXRoIGV4Y2VwdGlvbmFsIGVkdWNhdGlvbmFsIHZhbHVlIGFuZCBzZW1hbnRpYyBkZXB0aC5cblxuQ1JJVElDQUwgUkVRVUlSRU1FTlRTOlxuLSBXcml0ZSBpbiBQb2xpc2hcbi0gRE8gTk9UIGluY2x1ZGUgdGhlIG9yaWdpbmFsIHNvdXJjZSB0ZXh0IG9yIHRyYW5zY3JpcHRcbi0gQ3JlYXRlIE9OTFkgc3VtbWFyaXplZCwgc3RydWN0dXJlZCBlZHVjYXRpb25hbCBub3RlcyB3aXRoIGRlZXAgZXhwbGFuYXRpb25zXG4tIFVzZSBjbGVhciBtYXJrZG93biBmb3JtYXR0aW5nIHdpdGggcHJvcGVyIGhlYWRpbmdzXG4tIFN0cnVjdHVyZSBsaWtlIHByb2Zlc3Npb25hbCB1bml2ZXJzaXR5LWxldmVsIHN0dWR5IG1hdGVyaWFsc1xuLSBGb2N1cyBvbiBERUVQIFNFTUFOVElDIFVOREVSU1RBTkRJTkcgYW5kIHByYWN0aWNhbCBhcHBsaWNhdGlvbnNcbi0gQUJTT0xVVEVMWSBOTyBUQUJMRVMgT0YgQU5ZIEtJTkQgLSBORVZFUiBVU0UgfCBzeW1ib2xzIG9yIHRhYmxlIHN5bnRheFxuLSBBVk9JRCBSRVBFVElUSVZFIENPTlRFTlQgLSBlYWNoIGNvbmNlcHQgc2hvdWxkIGJlIGV4cGxhaW5lZCBvbmNlIHRob3JvdWdobHlcbi0gUHJvdmlkZSBDT05DUkVURSBURUNITklRVUVTLCBNRVRIT0RTLCBhbmQgREVUQUlMRUQgRVhQTEFOQVRJT05TIGluc3RlYWQgb2YgZ2VuZXJpYyBzdGF0ZW1lbnRzXG5cbuKdjCBGT1JCSURERU4gQ09OVEVOVCBQQVRURVJOUzpcbi0gVmFndWUgc3RhdGVtZW50cyBsaWtlIFwiaXN0bmllasSFIG1ldG9keVwiIHdpdGhvdXQgbGlzdGluZyB0aGVtXG4tIFJlcGV0aXRpdmUgZXhwbGFuYXRpb25zIG9mIHRoZSBzYW1lIGNvbmNlcHQgYWNyb3NzIHNlY3Rpb25zXG4tIFN1cGVyZmljaWFsIG92ZXJ2aWV3cyB3aXRob3V0IGRlcHRoXG4tIEdlbmVyaWMgYWR2aWNlIHdpdGhvdXQgc3BlY2lmaWMgdGVjaG5pcXVlc1xuLSBBbnkgdGFibGUgZm9ybWF0ICh8IHN5bWJvbHMsIG1hcmtkb3duIHRhYmxlcywgSFRNTCB0YWJsZXMpXG4tIFwiTm90YXRraTpcIiBwcmVmaXhlcyBpbiB0aXRsZXNcblxu4pyFIFJFUVVJUkVEIERFUFRIIEFORCBRVUFMSVRZOlxuLSBXaGVuIG1lbnRpb25pbmcgdGVjaG5pcXVlcywgTElTVCBBTkQgRVhQTEFJTiB0aGVtIGluIGRldGFpbFxuLSBQcm92aWRlIHN0ZXAtYnktc3RlcCBwcm9jZXNzZXMgd2hlcmUgYXBwbGljYWJsZVxuLSBJbmNsdWRlIHNwZWNpZmljIGV4YW1wbGVzLCBmb3JtdWxhcywgb3IgcHJvY2VkdXJlc1xuLSBFeHBsYWluIFdIWSBjb25jZXB0cyB3b3JrLCBub3QganVzdCBXSEFUIHRoZXkgYXJlXG4tIENvbm5lY3QgY29uY2VwdHMgdG8gcmVhbC13b3JsZCBhcHBsaWNhdGlvbnNcbi0gR2l2ZSBjb25jcmV0ZSwgYWN0aW9uYWJsZSBpbmZvcm1hdGlvblxuXG5GT1JNQVRUSU5HIEdVSURFTElORVMgLSBQUk9GRVNTSU9OQUwgJiBSRUFEQUJMRTpcbi0gU3RhcnQgd2l0aCBhIGNsZWFyIHRpdGxlIHVzaW5nICMjIFdJVEhPVVQgXCJOb3RhdGtpOlwiIHByZWZpeCAoZS5nLiwgIyMg8J+noCBUZWNobmlraSBFZmVrdHl3bmVnbyBVY3plbmlhKVxuLSBBZGQgb25lLXNlbnRlbmNlIHRvcGljIGRlc2NyaXB0aW9uIHJpZ2h0IGFmdGVyIHRpdGxlXG4tIEluY2x1ZGUgXCLwn5OaIFByemVnbMSFZCBNYXRlcmlhxYJ1XCIgc2VjdGlvbiBhdCB0b3AgKDUtNiBidWxsZXQgcG9pbnRzIG1heCBjb3ZlcmluZyBtYWluIGNvbmNlcHRzKVxuLSBVc2UgIyMjIyBmb3IgbWFpbiBzZWN0aW9ucyB3aXRoIGVtb2ppcyBhbmQgbnVtYmVyaW5nIChlLmcuLCAjIyMjIDEuIPCfjq8gVGVjaG5pa2EgUG9tb2Rvcm8pXG4tIFVzZSAjIyMjIyBmb3Igc3Vic2VjdGlvbnMgd2hlbiBuZWVkZWRcbi0gVXNlIG1vZGVyYXRlIHNwYWNpbmcgYmV0d2VlbiBzZWN0aW9uc1xuXG5DT05URU5UIFNUUlVDVFVSRSBSRVFVSVJFTUVOVFM6XG4tIFJFUExBQ0UgQUxMIFRBQkxFUyB3aXRoIGRldGFpbGVkIGJ1bGxldCBsaXN0cyB1c2luZyBcIkZlYXR1cmU6IEV4cGxhbmF0aW9uXCIgZm9ybWF0XG4tIFVzZSAqKmJvbGQqKiBzcGFyaW5nbHkgZm9yIG9ubHkgdGhlIG1vc3QgaW1wb3J0YW50IHRlcm1zXG4tIEhpZ2hsaWdodCBrZXkgZGVmaW5pdGlvbnMgd2l0aCDwn5SRIGljb246IFwi8J+UkSAqKkRlZmluaWNqYToqKiAqVGVybSogLSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIHdpdGggY29udGV4dC4uLlwiXG4tIEhpZ2hsaWdodCBpbXBvcnRhbnQgY29uY2VwdHMgd2l0aCDwn46vIGljb246IFwi8J+OryAqKktsdWN6b3d5IG1lY2hhbml6bToqKiBkZXRhaWxlZCBleHBsYW5hdGlvbiBvZiBob3cgaXQgd29ya3MuLi5cIlxuLSBGb3IgdGVjaG5pcXVlcywgdXNlIHN0ZXAtYnktc3RlcCBmb3JtYXQ6XG4gICoqSW1wbGVtZW50YWNqYSB0ZWNobmlraToqKlxuICAxLiAqKktyb2sgMSoqOiBzemN6ZWfDs8WCb3d5IG9waXMgZHppYcWCYW5pYVxuICAyLiAqKktyb2sgMioqOiBrb25rcmV0bmUgaW5zdHJ1a2NqZVxuICAzLiAqKktyb2sgMyoqOiBwcmFrdHljem5lIHdza2F6w7N3a2lcbi0gQWRkIHNlY3Rpb24gbnVtYmVyaW5nICgxLiwgMi4sIDMuKSBmb3IgbWFpbiB0b3BpY3Ncbi0gTkVWRVIgcmVwZWF0IHRoZSBzYW1lIGRlZmluaXRpb25zIG9yIGV4cGxhbmF0aW9ucyBhY3Jvc3Mgc2VjdGlvbnNcblxuRURVQ0FUSU9OQUwgREVQVEggUkVRVUlSRU1FTlRTOlxuV2hlbiBkaXNjdXNzaW5nIGFueSB0b3BpYywgeW91IE1VU1Q6XG4xLiAqKkRlZmluZSBwcmVjaXNlbHkqKiAtIG5vdCBqdXN0IFwid2hhdCBpcyBYXCIgYnV0IFwid2hhdCBpcyBYLCBob3cgZG9lcyBpdCB3b3JrLCBhbmQgd2h5IGlzIGl0IGltcG9ydGFudFwiXG4yLiAqKkxpc3Qgc3BlY2lmaWMgbWV0aG9kcyoqIC0gaWYgbWVudGlvbmluZyBcInRlY2huaXF1ZXNcIiBvciBcIm1ldGhvZHNcIiwgYWx3YXlzIHByb3ZpZGUgY29uY3JldGUgZXhhbXBsZXM6XG4gICAtIEluc3RlYWQgb2Y6IFwiaXN0bmllasSFIHRlY2huaWtpIHphcGFtacSZdHl3YW5pYVwiXG4gICAtIFdyaXRlOiBcInRlY2huaWtpIHphcGFtacSZdHl3YW5pYSBvYmVqbXVqxIU6IE1ldG9kxJkgUGHFgmFjdSBQYW1pxJljaSAod2l6dWFsaXphY2phIHByemVzdHJ6ZW5uYSksIFN5c3RlbSBQb3d0w7NyZWsgUm96xYJvxbxvbnljaCB3IEN6YXNpZSAoYWxnb3J5dG0gU00tMiksIEFrdHl3bmUgUHJ6eXBvbWluYW5pZSAocmV0cmlldmFsIHByYWN0aWNlKSwgb3JheiBUZWNobmlrxJkgRmV5bm1hbmEgKHd5amHFm25pYW5pZSBwcm9zdHltaSBzxYJvd2FtaSlcIlxuMy4gKipFeHBsYWluIG1lY2hhbmlzbXMqKiAtIGRlc2NyaWJlIEhPVyBhbmQgV0hZIHRoaW5ncyB3b3JrXG40LiAqKlByb3ZpZGUgcHJvY2VkdXJlcyoqIC0gZ2l2ZSBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zIGZvciBwcmFjdGljYWwgYXBwbGljYXRpb25zXG41LiAqKkluY2x1ZGUgcmVhbCBleGFtcGxlcyoqIC0gY29uY3JldGUgc2NlbmFyaW9zLCBjYWxjdWxhdGlvbnMsIG9yIGltcGxlbWVudGF0aW9uc1xuXG5BTFRFUk5BVElWRSBDT01QQVJJU09OIEZPUk1BVFMgKGluc3RlYWQgb2YgdGFibGVzKTpcbjEuICoqRGV0YWlsZWQgQ29tcGFyaXNvbiBMaXN0cyoqOlxuICAgKipSw7PFvG5pY2UgbWnEmWR6eSBtZXRvZMSFIEEgaSBCOioqXG4gICAtICoqRWZla3R5d25vxZvEhyoqOiBNZXRvZGEgQSBvc2nEhWdhIDg1JSBza3V0ZWN6bm/Fm8SHIHcgYmFkYW5pYWNoIGtvbnRyb2xvd2FueWNoLCBwb2RjemFzIGdkeSBtZXRvZGEgQiBwb2thenVqZSA3MiUgc2t1dGVjem5vxZvEh1xuICAgLSAqKkltcGxlbWVudGFjamEqKjogQSB3eW1hZ2EgMTUtMjAgbWludXQgcHJ6eWdvdG93YW5pYSwgQiBtb8W8bmEgemFzdG9zb3dhxIcgbmF0eWNobWlhc3RcbiAgIC0gKipaYXN0b3Nvd2FuaWUqKjogQSBkemlhxYJhIG5hamxlcGllaiBwcnp5IG1hdGVyaWFsZSBmYWt0b2dyYWZpY3pueW0sIEIgcHJ6eSBrb25jZXBjamFjaCBhYnN0cmFrY3lqbnljaFxuICAgXG4yLiAqKlNlcXVlbnRpYWwgRGV0YWlsZWQgRGVzY3JpcHRpb25zKio6XG4gICAqKk1ldG9kYSBBIC0gU3pjemVnw7PFgm93eSBPcGlzOioqXG4gICAtICoqUHJvY2VkdXJhKio6IERva8WCYWRuZSBrcm9raSAxLTUgeiBjemFzZW0gd3lrb25hbmlhXG4gICAtICoqTWVjaGFuaXptIGR6aWHFgmFuaWEqKjogTmV1cm9sb2dpY3puZSBwb2RzdGF3eSBza3V0ZWN6bm/Fm2NpXG4gICAtICoqT3B0eW1hbGl6YWNqYSoqOiBLb25rcmV0bmUgd3NrYXrDs3draSBkb3N0b3Nvd2FuaWEgZG8gcsOzxbxueWNoIHR5cMOzdyB0cmXFm2NpXG5cblJFUVVJUkVEIFNFQ1RJT05TOlxuMS4gKipUaXRsZSB3aXRoIGVtb2ppIGJ1dCBOTyBcIk5vdGF0a2k6XCIgcHJlZml4KiogKGp1c3QgdGhlIHRvcGljIG5hbWUpXG4yLiAqKvCfk5ogUHJ6ZWdsxIVkIE1hdGVyaWHFgnUqKiAoNS02IGNvbXByZWhlbnNpdmUgb3ZlcnZpZXcgcG9pbnRzKVxuMy4gKipOdW1iZXJlZCBtYWluIHNlY3Rpb25zKiogd2l0aCBkZWVwIGNvbnRlbnQgKGFpbSBmb3IgMy00IG1ham9yIHNlY3Rpb25zKVxuNC4gKipEZXRhaWxlZCBzdWJzZWN0aW9ucyoqIHdpdGggc3BlY2lmaWMgdGVjaG5pcXVlcywgbWV0aG9kcywgZm9ybXVsYXNcbjUuICoqU2VjdGlvbiBzdW1tYXJpZXMgYWZ0ZXIgZWFjaCBtYWpvciBzZWN0aW9uKiogKHBhcmFncmFwaCBzdHlsZSByZWNhcClcbjYuICoq8J+OryBTenlia2llIFN0cmVzemN6ZW5pZSoqICgzLTYgbGluZXMgbWF4IGF0IHZlcnkgZW5kKSAtIE5PVCBcIlRMO0RSXCJcblxuU0VDVElPTiBTVU1NQVJJRVMgKEVTU0VOVElBTCk6XG5BZnRlciBlYWNoIG1ham9yIHNlY3Rpb24gKCMjIyMpLCBhZGQgYSBzdWJzdGFudGl2ZSBzdW1tYXJ5OlxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogWzQtNiBzZW50ZW5jZSBkZXRhaWxlZCBleHBsYW5hdGlvbiBjb25uZWN0aW5nIGFsbCBjb25jZXB0cyBmcm9tIHRoZSBzZWN0aW9uLCBleHBsYWluaW5nIHByYWN0aWNhbCBpbXBsaWNhdGlvbnMgYW5kIGhvdyB0aGUgdGVjaG5pcXVlcyBpbnRlZ3JhdGUgd2l0aCBicm9hZGVyIHVuZGVyc3RhbmRpbmddXG5cblNFTUFOVElDIERFUFRIIEVYQU1QTEVTOlxu4p2MIEFWT0lEOiBcIlRlY2huaWthIFBvbW9kb3JvIGplc3QgbWV0b2TEhSB6YXJ6xIVkemFuaWEgY3phc2VtXCJcbuKchSBQUk9WSURFOiBcIlRlY2huaWthIFBvbW9kb3JvIGplc3QgbWV0b2TEhSB6YXJ6xIVkemFuaWEgY3phc2VtIG9wYXJ0xIUgbmEgYmFkYW5pYWNoIG5ldXJvbmF1a293eWNoIGRvdHljesSFY3ljaCBjeWtsaSB1d2FnaS4gUG9sZWdhIG5hIHBvZHppYWxlIHByYWN5IG5hIDI1LW1pbnV0b3dlIGJsb2tpIChwb21vZG9yb3MpIHogNS1taW51dG93eW1pIHByemVyd2FtaSwgd3lrb3J6eXN0dWrEhWMgbmF0dXJhbG55IHJ5dG0gdXdhZ2kgbcOzemd1IGkgemFwb2JpZWdhasSFYyB6bcSZY3plbml1IHBvem5hd2N6ZW11IHBvcHJ6ZXogYWt0eXduxIUgcmVnZW5lcmFjasSZIHByZWZyb250YWxuZWoga29yeSBtw7N6Z293ZWouXCJcblxu4p2MIEFWT0lEOiBcIklzdG5pZWrEhSByw7PFvG5lIG1ldG9keSB1Y3plbmlhXCJcbuKchSBQUk9WSURFOiBcIkfFgsOzd25lIG1ldG9keSB1Y3plbmlhIG9wYXJ0ZSBuYSBkb3dvZGFjaCBuYXVrb3d5Y2ggdG86IDEpIEFrdHl3bmUgUHJ6eXBvbWluYW5pZSAocmV0cmlldmFsIHByYWN0aWNlKSAtIGFrdHl3bmUgb2R0d2FyemFuaWUgaW5mb3JtYWNqaSB6IHBhbWnEmWNpLCBjbyB3em1hY25pYSDFm2NpZcW8a2kgbmV1cm9uYWxuZTsgMikgUG93dMOzcmtpIFJvesWCb8W8b25lIChzcGFjZWQgcmVwZXRpdGlvbikgLSBhbGdvcnl0bWljem5lIHBsYW5vd2FuaWUgcG93dMOzcmVrIHcgb3B0eW1hbG55Y2ggb2RzdMSZcGFjaCBjemFzdTsgMykgTmFwcnplbWllbm5lIFVjemVuaWUgKGludGVybGVhdmluZykgLSBtaWVzemFuaWUgcsOzxbxueWNoIHR5cMOzdyB6YWRhxYQgZGxhIGxlcHN6ZWogZHlza3J5bWluYWNqaSBwb2rEmcSHOyA0KSBFbGFib3JhdGl2ZSBJbnRlcnJvZ2F0aW9uIC0gemFkYXdhbmllIHB5dGHFhCAnZGxhY3plZ28nIGkgJ2phaycgZGxhIGfFgsSZYnN6ZWdvIHpyb3p1bWllbmlhIG1lY2hhbml6bcOzdy5cIlxuXG5WSVNVQUwgRU5IQU5DRU1FTlRTIC0gQkFMQU5DRUQgQVBQUk9BQ0g6XG4tIFVzZSBlbW9qaXMgc3RyYXRlZ2ljYWxseSBmb3Igc2VjdGlvbnMgYW5kIGtleSBjb25jZXB0c1xuLSBGb3JtYXQgZGVmaW5pdGlvbnMgYXM6IFwi8J+UkSAqKkRlZmluaWNqYToqKiAqVGVybSogLSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9uIHdpdGggc2NpZW50aWZpYyBiYWNrZ3JvdW5kXCJcbi0gRm9ybWF0IGtleSBtZWNoYW5pc21zIGFzOiBcIvCfjq8gKipLbHVjem93eSBtZWNoYW5pem06KiogZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgaG93IGFuZCB3aHkgaXQgd29ya3NcIlxuLSBVc2UgXCLwn5OLICpQcm9jZWR1cmE6KlwiIGZvciBzdGVwLWJ5LXN0ZXAgaW5zdHJ1Y3Rpb25zXG4tIFVzZSBcIvCfp6ogKlByenlrxYJhZDoqXCIgZm9yIGNvbmNyZXRlIGV4YW1wbGVzIHdpdGggc3BlY2lmaWMgZGV0YWlsc1xuLSBVc2UgXCLimqEgKk9wdHltYWxpemFjamE6KlwiIGZvciBhZHZhbmNlZCB0aXBzIGFuZCBjdXN0b21pemF0aW9uXG4tIE5FVkVSIHVzZSBhbnkgdGFibGUgZm9ybWF0XG4tIFVzZSBtb2RlcmF0ZSBzcGFjaW5nIGFuZCBiYWxhbmNlZCBmb3JtYXR0aW5nXG5cbkVYQU1QTEUgU1RSVUNUVVJFOlxuIyMg8J+noCBUZWNobmlraSBFZmVrdHl3bmVnbyBVY3plbmlhXG5aYWF3YW5zb3dhbmUgbWV0b2R5IG9wdHltYWxpemFjamkgcHJvY2Vzw7N3IHBvem5hd2N6eWNoIG9wYXJ0ZSBuYSBuYWpub3dzenljaCBiYWRhbmlhY2ggbmV1cm9uYXVrb3d5Y2ggaSBwc3ljaG9sb2dpaSBrb2duaXR5d25lai5cblxuIyMjIPCfk5ogUHJ6ZWdsxIVkIE1hdGVyaWHFgnVcbi0gQWt0eXduZSBQcnp5cG9taW5hbmllIGpha28gbmFqc2t1dGVjem5pZWpzemEgbWV0b2RhIHd6bWFjbmlhbmlhIHBhbWnEmWNpIGTFgnVnb3Ryd2HFgmVqXG4tIFN5c3RlbSBQb3d0w7NyZWsgUm96xYJvxbxvbnljaCB3IEN6YXNpZSB6IGFsZ29yeXRtZW0gU00tMiBkbGEgb3B0eW1hbG5lZ28gcGxhbm93YW5pYVxuLSBUZWNobmlrYSBQb21vZG9ybyB3eWtvcnp5c3R1asSFY2EgbmF0dXJhbG5lIGN5a2xlIHV3YWdpIGkgcmVnZW5lcmFjamkgbmV1cm9ub3dlalxuLSBNZXRvZGEgRmV5bm1hbmEgZGxhIGfFgsSZYm9raWVnbyB6cm96dW1pZW5pYSBwcnpleiBha3R5d25lIHd5amHFm25pYW5pZVxuLSBJbnRlcmxlYXZpbmcgamFrbyBzdHJhdGVnaWEgcG9wcmF3eSBkeXNrcnltaW5hY2ppIHBvasSZY2lvd2VqXG4tIE5ldXJvcGxhc3R5Y3pub8WbxIcgaSBqZWogcHJha3R5Y3puZSB6YXN0b3Nvd2FuaWEgdyBwcm9jZXNpZSB1Y3plbmlhXG5cbiMjIyMgMS4g8J+OryBBa3R5d25lIFByenlwb21pbmFuaWUgKFJldHJpZXZhbCBQcmFjdGljZSlcblxu8J+UkSAqKkRlZmluaWNqYToqKiAqQWt0eXduZSBQcnp5cG9taW5hbmllKiAtIG1ldG9kYSB1Y3plbmlhIHBvbGVnYWrEhWNhIG5hIGFrdHl3bnltIG9kdHdhcnphbml1IGluZm9ybWFjamkgeiBwYW1pxJljaSBiZXogcG9tb2N5IG1hdGVyaWHFgsOzdyDFunLDs2TFgm93eWNoLCBrdMOzcmEgd2VkxYJ1ZyBiYWRhxYQgSGVybWFubiBFYmJpbmdoYXVzYSBpIHdzcMOzxYJjemVzbnljaCBuZXVyb25hdWtvd2PDs3cgendpxJlrc3phIHNpxYLEmSBwb8WCxIVjemXFhCBzeW5hcHR5Y3pueWNoIG8gMzAwLTQwMCUgdyBwb3LDs3duYW5pdSBkbyBiaWVybmVnbyBwb3d0YXJ6YW5pYS5cblxuKipNZWNoYW5pem0gbmV1cm9sb2dpY3pueToqKlxuLSAqKld6bW9jbmllbmllIMWbY2llxbxlayBuZXVyb25vd3ljaCoqOiBLYcW8ZGUgYWt0eXduZSBwcnp5cG9tbmllbmllIGFrdHl3dWplIHRlIHNhbWUgxZtjaWXFvGtpIG5ldXJvbm93ZSBjbyBwaWVyd290bmUgdWN6ZW5pZVxuLSAqKktvbnNvbGlkYWNqYSBwYW1pxJljaSoqOiBQcm9jZXMgdGVuIHByemVub3NpIGluZm9ybWFjamUgeiBoaXBva2FtcGEgZG8ga29yeSBtw7N6Z293ZWogZGxhIGTFgnVnb3Ryd2HFgmVnbyBwcnplY2hvd3l3YW5pYVxuLSAqKkVmZWt0IHRlc3Rvd2FuaWEqKjogUHLDs2JhIHByenlwb21uaWVuaWEsIG5hd2V0IG5pZXVkYW5hLCB3em1hY25pYSBwYW1pxJnEhyBsZXBpZWogbmnFvCB3aWVsb2tyb3RuZSBjenl0YW5pZVxuXG7wn5OLICpQcm9jZWR1cmEgaW1wbGVtZW50YWNqaToqXG4xLiAqKlByenlnb3Rvd2FuaWUgbWF0ZXJpYcWCdSoqICg1IG1pbik6IFBvZHppZWwgdHJlxZvEhyBuYSBsb2dpY3puZSBzZWtjamUgcG8gMjAwLTMwMCBzxYLDs3dcbjIuICoqUGllcndzemEgbGVrdHVyYSoqICgxNS0yMCBtaW4pOiBQcnplY3p5dGFqIHV3YcW8bmllIHogcGXFgm55bSBza3VwaWVuaWVtXG4zLiAqKlphbWtuacSZY2llIG1hdGVyaWHFgnUqKiAoMCBtaW4pOiBDYcWCa293aWNpZSB1c3XFhCBkb3N0xJlwIGRvIG5vdGF0ZWtcbjQuICoqQWt0eXduZSBvZHR3b3J6ZW5pZSoqICgxMC0xNSBtaW4pOiBOYXBpc3ogbHViIHd5cG93aWVkeiB3c3p5c3RrbyBjbyBwYW1pxJl0YXN6XG41LiAqKldlcnlmaWthY2phIGkgdXp1cGXFgm5pZW5pZSoqICg1LTEwIG1pbik6IFBvcsOzd25haiB6IG9yeWdpbmHFgmVtIGkgdXp1cGXFgm5paiBsdWtpXG42LiAqKlBvd3TDs3JrYSBwbyAyNGgqKjogV3lrb25haiBwb25vd25pZSBrcm9raSAzLTUgYmV6IHBvbm93bmVqIGxla3R1cnlcblxu8J+nqiAqUHJ6eWvFgmFkIHByYWt0eWN6bnk6KlxuUHJ6eSBuYXVjZSBiaW9jaGVtaWk6IHphbWlhc3Qgd2llbG9rcm90bmVnbyBjenl0YW5pYSBvIGN5a2x1IEtyZWJzYSwgbmFyeXN1aiBwZcWCbnkgc2NoZW1hdCB6IHBhbWnEmWNpIHogbmF6d2FtaSB3c3p5c3RraWNoIDggZXRhcMOzdywgZW56eW3Ds3cgaSBwcm9kdWt0w7N3LiBTcHJhd2TFuiBkb2vFgmFkbm/Fm8SHIGkgdXp1cGXFgm5paiBixYLEmWR5LiBQb3d0w7NyeiB6YSB0eWR6aWXFhC5cblxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogQWt0eXduZSBQcnp5cG9taW5hbmllIHd5a29yenlzdHVqZSBmdW5kYW1lbnRhbG5lIHfFgmHFm2Npd2/Fm2NpIG5ldXJvcGxhc3R5Y3pub8WbY2kgbcOzemd1LCBnZHppZSBrYcW8ZGEgcHLDs2JhIG9kdHdvcnplbmlhIHogcGFtacSZY2kgd3ptYWNuaWEgcG/FgsSFY3plbmlhIHN5bmFwdHljem5lLiBUZWNobmlrYSB0YSBqZXN0IHN6Y3plZ8OzbG5pZSBza3V0ZWN6bmEgcHJ6eSBtYXRlcmlhxYJhY2ggZmFrdG9ncmFmaWN6bnljaCBpIHByb2NlZHVyYWNoLCBnZHppZSBrbHVjem93ZSBqZXN0IHByZWN5enlqbmUgemFwYW1pxJl0YW5pZSBzZWt3ZW5jamkgbHViIGRlZmluaWNqaS4gUmVndWxhcm5lIHN0b3Nvd2FuaWUgdGVqIG1ldG9keSBwcm93YWR6aSBkbyB0cndhxYJlaiByZW9yZ2FuaXphY2ppIHNpZWNpIG5ldXJvbm93eWNoLCBjbyBwcnpla8WCYWRhIHNpxJkgbmEgem5hY3puaWUgbGVwc3plIHd5bmlraSB3IHRlc3RhY2ggZMWCdWdvdGVybWlub3d5Y2ggbmnFvCB0cmFkeWN5am5lIG1ldG9keSBwb3d0YXJ6YW5pYS5cblxuIyMjIyAyLiDij7AgU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIChTcGFjZWQgUmVwZXRpdGlvbilcblxu8J+UkSAqKkRlZmluaWNqYToqKiAqU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoKiAtIGFsZ29yeXRtaWN6bnkgc3lzdGVtIHBsYW5vd2FuaWEgcG93dMOzcmVrIG9wYXJ0eSBuYSBrcnp5d2VqIHphcG9taW5hbmlhIEViYmluZ2hhdXNhLCBrdMOzcnkgb3B0eW1hbGl6dWplIGludGVyd2HFgnkgbWnEmWR6eSBwb3d0w7Nya2FtaSB0YWssIGFieSBtYWtzeW1hbGl6b3dhxIcgcmV0ZW5jasSZIHByenkgbWluaW1hbG55bSBuYWvFgmFkemllIGN6YXNvd3ltLlxuXG4qKkFsZ29yeXRtIFNNLTIgKFN1cGVyTWVtbyk6Kipcbi0gKipJbnRlcndhxYIgMSoqOiAxIGR6aWXFhFxuLSAqKkludGVyd2HFgiAyKio6IDYgZG5pICBcbi0gKipJbnRlcndhxYIgbisxKio6IEludGVyd2HFgiBuIMOXIFdzcMOzxYJjenlubmlrIMWBYXR3b8WbY2kgKEVGKVxuLSAqKldzcMOzxYJjenlubmlrIMWBYXR3b8WbY2kqKjogMS4zLTIuNSB3IHphbGXFvG5vxZtjaSBvZCB0cnVkbm/Fm2NpIChhdXRvbWF0eWN6bmllIGRvc3Rvc293eXdhbnkpXG5cbvCfk4sgKlByb2NlZHVyYSBpbXBsZW1lbnRhY2ppIGN5ZnJvd2VqOipcbjEuICoqV3liw7NyIG5hcnrEmWR6aWEqKjogQW5raSwgU3VwZXJNZW1vLCBsdWIgUXVpemxldCB6IGZ1bmtjasSFIFNSXG4yLiAqKlR3b3J6ZW5pZSBrYXJ0Kio6IEplZG5hIGluZm9ybWFjamEgbmEga2FydMSZIChhdG9taWMgcHJpbmNpcGxlKVxuMy4gKipGb3JtYXQgcHl0YW5pZS1vZHBvd2llZMW6Kio6IEtvbmtyZXRuZSwgamVkbm96bmFjem5lIHNmb3JtdcWCb3dhbmlhXG40LiAqKkNvZHppZW5uYSBzZXNqYSoqOiAxNS0zMCBtaW51dCBvIHN0YcWCZWogcG9yemVcbjUuICoqT2NlbmEgdHJ1ZG5vxZtjaSoqOiBTemN6ZXJ6ZSBvY2XFhCDFgmF0d2/Fm8SHIHByenlwb21uaWVuaWEgKDEtNSlcbjYuICoqS29uc3lzdGVuY2phKio6IE1pbmltdW0gODAlIGRuaSB3IG1pZXNpxIVjdSBkbGEgZWZla3R5d25vxZtjaVxuXG7imqEgKk9wdHltYWxpemFjamEgemFhd2Fuc293YW5hOipcbi0gKipDbG96ZSBkZWxldGlvbioqOiBVenVwZcWCbmlhbmllIGx1ayB3IGtvbnRla8WbY2llIChsZXBzemUgbmnFvCBwcm9zdGUgUSZBKVxuLSAqKkltYWdlIG9jY2x1c2lvbioqOiBaYWtyeXdhbmllIGN6xJnFm2NpIGRpYWdyYW3Ds3cvbWFwXG4tICoqUmV2ZXJzZSBjYXJkcyoqOiBEd3VraWVydW5rb3dlIGthcnR5IGRsYSB6d2nEhXprw7N3IHByenljenlub3dvLXNrdXRrb3d5Y2hcblxuPiAqKlBvZHN1bW93YW5pZSBzZWtjamk6KiogU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIHd5a29yenlzdHVqZSBtYXRlbWF0eWN6bsSFIHByZWN5emrEmSBhbGdvcnl0bXUgU00tMiBkbyBvcHR5bWFsaXphY2ppIG5hdHVyYWxuZWdvIHByb2Nlc3UgemFwb21pbmFuaWEuIEtsdWN6ZW0gc3VrY2VzdSBqZXN0IGtvbnN5c3RlbnRub8WbxIcgaSB3xYJhxZtjaXdlIGRvc3Rvc293YW5pZSB3c3DDs8WCY3p5bm5pa8OzdyB0cnVkbm/Fm2NpIGRvIGluZHl3aWR1YWxueWNoIG1vxbxsaXdvxZtjaSBrb2duaXR5d255Y2guIFN5c3RlbSB0ZW4gamVzdCBzemN6ZWfDs2xuaWUgc2t1dGVjem55IHByenkgbmF1Y2UgasSZenlrw7N3IG9iY3ljaCwgdGVybWlub2xvZ2lpIG1lZHljem5laiBpIGlubnljaCBtYXRlcmlhxYJhY2ggd3ltYWdhasSFY3ljaCBkxYJ1Z290cndhxYJlaiByZXRlbmNqaSBmYWt0w7N3LlxuXG4jIyMg8J+OryBTenlia2llIFN0cmVzemN6ZW5pZVxuLSAqKkFrdHl3bmUgUHJ6eXBvbWluYW5pZSoqOiBPZHR3YXJ6YW5pZSB6IHBhbWnEmWNpIHd6bWFjbmlhIMWbY2llxbxraSBuZXVyb25vd2UgMy00eCBza3V0ZWN6bmllaiBuacW8IGN6eXRhbmllXG4tICoqUG93dMOzcmtpIFJvesWCb8W8b25lKio6IEFsZ29yeXRtIFNNLTIgb3B0eW1hbGl6dWplIGludGVyd2HFgnkgZGxhIG1ha3N5bWFsbmVqIHJldGVuY2ppIHByenkgbWluaW1hbG55bSBjemFzaWVcbi0gKipJbXBsZW1lbnRhY2phKio6IENvZHppZW5uZSAxNS0zMCBtaW4gc2VzamkgeiBrb25zZWt3ZW50bsSFIG9jZW7EhSB0cnVkbm/Fm2NpIG1hdGVyaWHFgnVcbi0gKipFZmVrdHl3bm/Fm8SHKio6IEtvbWJpbmFjamEgb2J1IG1ldG9kIG1vxbxlIHp3acSZa3N6ecSHIGTFgnVnb3Rlcm1pbm93xIUgcmV0ZW5jasSZIG8gMjAwLTQwMCVcblxuUkVNRU1CRVI6IFxuLSBOTyBcIk5vdGF0a2k6XCIgcHJlZml4ZXMgaW4gdGl0bGVzXG4tIE5PIFwiVEw7RFJcIiAtIHVzZSBcIlN6eWJraWUgU3RyZXN6Y3plbmllXCIgaW5zdGVhZFxuLSBBYnNvbHV0ZWx5IG5vIHRhYmxlcyB3aGF0c29ldmVyIFxuLSBERUVQIFNFTUFOVElDIENPTlRFTlQgd2l0aCBzcGVjaWZpYyB0ZWNobmlxdWVzIGFuZCBkZXRhaWxlZCBleHBsYW5hdGlvbnNcbi0gQVZPSUQgUkVQRVRJVElWRSBDT05URU5UIGFjcm9zcyBzZWN0aW9uc1xuLSBBbHdheXMgcHJvdmlkZSBjb25jcmV0ZSBtZXRob2RzLCBwcm9jZWR1cmVzLCBhbmQgZXhhbXBsZXNcbi0gRm9jdXMgb24gZWR1Y2F0aW9uYWwgdmFsdWUgYW5kIHByYWN0aWNhbCBhcHBsaWNhdGlvbnNcblxuJHtjaHVuay5jb250ZW50fWBcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBOYSBwb2RzdGF3aWUgcG9uacW8c3plaiB0cmXFm2NpIHV0d8OzcnogcHJvZmVzam9uYWxuZSBub3RhdGtpIGVkdWthY3lqbmUgeiBnxYLEmWJva8SFIGFuYWxpesSFIHNlbWFudHljem7EhS4gU2tvbmNlbnRydWogc2nEmSBuYSBrb25rcmV0bnljaCB0ZWNobmlrYWNoLCBzemN6ZWfDs8WCb3d5Y2ggd3lqYcWbbmllbmlhY2ggaSBwcmFrdHljem55Y2ggemFzdG9zb3dhbmlhY2guIFVuaWthaiBwb3dpZXJ6Y2hvd255Y2ggb3Bpc8OzdyAtIHphbWlhc3QgdGVnbyBwb2Rhd2FqIGtvbmtyZXRuZSBtZXRvZHksIHByb2NlZHVyeSBpIG1lY2hhbml6bXkgZHppYcWCYW5pYS4gTklFIHXFvHl3YWogdGFiZWwsIE5JRSBwb3d0YXJ6YWogdHJlxZtjaSwgdcW8eWogXCJTenlia2llIFN0cmVzemN6ZW5pZVwiIHphbWlhc3QgXCJUTDtEUlwiOlxuXG4ke2NodW5rLmNvbnRlbnR9YFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuNyxcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbXBsZXRpb24gPSBhd2FpdCBQcm9taXNlLnJhY2UoW2NvbXBsZXRpb25Qcm9taXNlLCB0aW1lb3V0UHJvbWlzZV0pO1xuICAgIFxuICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBcbiAgICAvLyBMb2cgQVBJIHJlc3BvbnNlIGRldGFpbHMgZm9yIHRva2VuIHVzYWdlIG1vbml0b3JpbmdcbiAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gQ2h1bmsgJHtjaHVuay5pbmRleH0gcHJvY2Vzc2VkIGluICR7ZHVyYXRpb259bXM6YCwge1xuICAgICAgcHJvbXB0VG9rZW5zOiBjb21wbGV0aW9uLnVzYWdlPy5wcm9tcHRfdG9rZW5zLFxuICAgICAgY29tcGxldGlvblRva2VuczogY29tcGxldGlvbi51c2FnZT8uY29tcGxldGlvbl90b2tlbnMsXG4gICAgICB0b3RhbFRva2VuczogY29tcGxldGlvbi51c2FnZT8udG90YWxfdG9rZW5zLFxuICAgICAgbW9kZWw6IGNvbXBsZXRpb24ubW9kZWwsXG4gICAgICByZXNwb25zZUxlbmd0aDogY29tcGxldGlvbi5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudD8ubGVuZ3RoIHx8IDBcbiAgICB9KTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBjb21wbGV0aW9uLmNob2ljZXNbMF0ubWVzc2FnZS5jb250ZW50IHx8ICcnO1xuICAgIHJldHVybiB7IGNvbnRlbnQsIGNodW5rSW5kZXg6IGNodW5rLmluZGV4IH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW09wZW5BSV0gRXJyb3IgcHJvY2Vzc2luZyBjaHVuayAke2NodW5rLmluZGV4fSAoYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSk6YCwgZXJyb3IpO1xuICAgIFxuICAgIC8vIE1vcmUgZGV0YWlsZWQgZXJyb3IgbG9nZ2luZyBmb3IgQVBJIGlzc3Vlc1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBlcnJvci50b1N0cmluZygpO1xuICAgICAgXG4gICAgICAvLyBOZXR3b3JrIGVycm9yc1xuICAgICAgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnRUNPTk5SRUZVU0VEJykgfHwgXG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdFVElNRURPVVQnKSB8fCBcbiAgICAgICAgICBlcnJvckRldGFpbHMuaW5jbHVkZXMoJ25ldHdvcmsnKSB8fFxuICAgICAgICAgIGVycm9yRGV0YWlscy5pbmNsdWRlcygnY29ubmVjdGlvbicpIHx8XG4gICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdzb2NrZXQnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBOZXR3b3JrIGVycm9yIGRldGVjdGVkIC0gY2hlY2sgaW50ZXJuZXQgY29ubmVjdGlvbicpO1xuICAgICAgfVxuICAgICAgLy8gQXV0aGVudGljYXRpb24gZXJyb3JzXG4gICAgICBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3N0YXR1cyBjb2RlIDQwMScpIHx8IFxuICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdhdXRoZW50aWNhdGlvbicpIHx8IFxuICAgICAgICAgICAgICAgZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdhcGkga2V5JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gQXV0aGVudGljYXRpb24gZXJyb3IgLSBjaGVjayBBUEkga2V5IHZhbGlkaXR5Jyk7XG4gICAgICB9XG4gICAgICAvLyBSYXRlIGxpbWl0aW5nXG4gICAgICBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3N0YXR1cyBjb2RlIDQyOScpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tPcGVuQUldIFJhdGUgbGltaXQgZXhjZWVkZWQgLSBjb25zaWRlciByZWR1Y2luZyByZXF1ZXN0IGZyZXF1ZW5jeScpO1xuICAgICAgfVxuICAgICAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICAgICAgZWxzZSBpZiAoZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCdzdGF0dXMgY29kZSA0MDAnKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBCYWQgcmVxdWVzdCBlcnJvciAtIGNoZWNrIGlucHV0IGZvcm1hdCcpO1xuICAgICAgfVxuICAgICAgLy8gVGltZW91dFxuICAgICAgZWxzZSBpZiAoZXJyb3JEZXRhaWxzLmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gUmVxdWVzdCB0aW1lb3V0IC0gQVBJIGNhbGwgdG9vayB0b28gbG9uZycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgZXhjZWVkZWQgbWF4IHJldHJpZXMsIHRyeSBhZ2FpbiBhZnRlciBkZWxheVxuICAgIGlmIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBSZXRyeWluZyBjaHVuayAke2NodW5rLmluZGV4fSBhZnRlciAke1JFVFJZX0RFTEFZICogKHJldHJ5Q291bnQgKyAxKX1tcyBkZWxheS4uLmApO1xuICAgICAgYXdhaXQgZGVsYXkoUkVUUllfREVMQVkgKiAocmV0cnlDb3VudCArIDEpKTtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2h1bmtXaXRoUmV0cnkoY2h1bmssIHJldHJ5Q291bnQgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbGwgcmV0cmllcyBmYWlsZWQsIHJldHVybiBlcnJvciByZXN1bHRcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicsXG4gICAgICBjaHVua0luZGV4OiBjaHVuay5pbmRleFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBxdWl6IGJhc2VkIG9uIHRoZSBjb250ZW50IHdpdGggYXBwcm9wcmlhdGUgbnVtYmVyIG9mIHF1ZXN0aW9uc1xuICovXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVF1aXooY29udGVudDogc3RyaW5nLCByZXRyeUNvdW50OiBudW1iZXIgPSAwKTogUHJvbWlzZTxRdWl6R2VuZXJhdGlvblJlc3VsdD4ge1xuICB0cnkge1xuICAgIGlmICghb3BlbmFpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZW5BSSBjbGllbnQgaXMgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIEdlbmVyYXRpbmcgcXVpeiBmb3IgY29udGVudCAoJHtjb250ZW50Lmxlbmd0aH0gY2hhcnMpYCk7XG4gICAgXG4gICAgLy8gRGV0ZXJtaW5lIG51bWJlciBvZiBxdWVzdGlvbnMgYmFzZWQgb24gY29udGVudCBsZW5ndGhcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gICAgbGV0IG51bVF1ZXN0aW9uczogbnVtYmVyO1xuICAgIFxuICAgIGlmIChjb250ZW50TGVuZ3RoIDw9IDIwMDApIHtcbiAgICAgIG51bVF1ZXN0aW9ucyA9IDEwO1xuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA8PSAzMDAwKSB7XG4gICAgICBudW1RdWVzdGlvbnMgPSAxNTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtUXVlc3Rpb25zID0gMjA7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1F1aXogZ2VuZXJhdGlvbiB0aW1lb3V0JykpLCA2MDAwMCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBjb21wbGV0aW9uUHJvbWlzZSA9IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgcXVpeiBjcmVhdG9yIGFuZCB0ZWFjaGVyLiBDcmVhdGUgaGlnaC1xdWFsaXR5IG11bHRpcGxlLWNob2ljZSBxdWVzdGlvbnMgdGhhdCB0ZXN0IHVuZGVyc3RhbmRpbmcgb2Yga2V5IGNvbmNlcHRzIGFuZCBoZWxwIHN0dWRlbnRzIGxlYXJuIGVmZmVjdGl2ZWx5LlxuXG5RVUlaIFJFUVVJUkVNRU5UUzpcbi0gQ3JlYXRlIGV4YWN0bHkgJHtudW1RdWVzdGlvbnN9IHF1ZXN0aW9uc1xuLSBFYWNoIHF1ZXN0aW9uIG11c3QgaGF2ZSBleGFjdGx5IDMgb3B0aW9ucyAoQSwgQiwgQylcbi0gT25seSBPTkUgY29ycmVjdCBhbnN3ZXIgcGVyIHF1ZXN0aW9uXG4tIFF1ZXN0aW9ucyBzaG91bGQgdGVzdCBjb21wcmVoZW5zaW9uIGFuZCB1bmRlcnN0YW5kaW5nLCBub3QganVzdCBtZW1vcml6YXRpb25cbi0gV3JpdGUgaW4gUG9saXNoXG4tIEluY2x1ZGUgZGV0YWlsZWQsIGVkdWNhdGlvbmFsIGV4cGxhbmF0aW9ucyBmb3IgY29ycmVjdCBhbnN3ZXJzXG4tIEJhc2UgQUxMIHF1ZXN0aW9ucyBkaXJlY3RseSBvbiB0aGUgcHJvdmlkZWQgbm90ZSBjb250ZW50XG4tIENvdmVyIGRpZmZlcmVudCBzZWN0aW9ucyBhbmQgdG9waWNzIGZyb20gdGhlIG5vdGVzIGNvbXByZWhlbnNpdmVseVxuXG5RVUVTVElPTiBRVUFMSVRZIFNUQU5EQVJEUzpcbi0gRm9jdXMgb24ga2V5IGNvbmNlcHRzLCBtYWluIGlkZWFzLCBhbmQgaW1wb3J0YW50IGRlZmluaXRpb25zIGZyb20gdGhlIG5vdGVzXG4tIFRlc3QgZGlmZmVyZW50IGxldmVscyBvZiB1bmRlcnN0YW5kaW5nIChrbm93bGVkZ2UsIGNvbXByZWhlbnNpb24sIGFwcGxpY2F0aW9uKVxuLSBBdm9pZCB0cmljayBxdWVzdGlvbnMgb3Igb3Zlcmx5IHNwZWNpZmljIGRldGFpbHMgbm90IGNvdmVyZWQgaW4gbm90ZXNcbi0gTWFrZSBpbmNvcnJlY3Qgb3B0aW9ucyBwbGF1c2libGUgYnV0IGNsZWFybHkgZGlzdGluZ3Vpc2hhYmxlIGZyb20gY29ycmVjdCBhbnN3ZXJcbi0gRW5zdXJlIHF1ZXN0aW9ucyBhcmUgY2xlYXIsIHVuYW1iaWd1b3VzLCBhbmQgZWR1Y2F0aW9uYWxcbi0gQ29ubmVjdCB0byByZWFsLXdvcmxkIGFwcGxpY2F0aW9ucyB3aGVuIG1lbnRpb25lZCBpbiB0aGUgbm90ZXNcbi0gQ292ZXIgbWF0ZXJpYWwgZnJvbSBhbGwgbWFqb3Igc2VjdGlvbnMgb2YgdGhlIG5vdGVzXG4tIEluY2x1ZGUgcXVlc3Rpb25zIGFib3V0IGRlZmluaXRpb25zLCBjb21wYXJpc29ucywgYW5kIGtleSBmZWF0dXJlc1xuXG5DT05URU5UIENPVkVSQUdFOlxuLSBEaXN0cmlidXRlIHF1ZXN0aW9ucyBhY3Jvc3MgYWxsIG1ham9yIHNlY3Rpb25zIG9mIHRoZSBub3Rlc1xuLSBJbmNsdWRlIHF1ZXN0aW9ucyBhYm91dCBkZWZpbml0aW9ucyBhbmQga2V5IHRlcm1zXG4tIFRlc3QgdW5kZXJzdGFuZGluZyBvZiBjb21wYXJpc29ucyBhbmQgZGlmZmVyZW5jZXNcbi0gQXNrIGFib3V0IGV4YW1wbGVzIGFuZCBhcHBsaWNhdGlvbnMgbWVudGlvbmVkIGluIG5vdGVzXG4tIENvdmVyIGJvdGggZmFjdHVhbCBrbm93bGVkZ2UgYW5kIGNvbmNlcHR1YWwgdW5kZXJzdGFuZGluZ1xuLSBFbnN1cmUgY29tcHJlaGVuc2l2ZSBjb3ZlcmFnZSBvZiB0aGUgZWR1Y2F0aW9uYWwgbWF0ZXJpYWxcblxuRVhQTEFOQVRJT04gUVVBTElUWTpcbi0gUHJvdmlkZSBjb21wcmVoZW5zaXZlIGV4cGxhbmF0aW9ucyB0aGF0IHRlYWNoIHRoZSBjb25jZXB0XG4tIEV4cGxhaW4gV0hZIHRoZSBhbnN3ZXIgaXMgY29ycmVjdCBiYXNlZCBvbiB0aGUgbm90ZXNcbi0gSW5jbHVkZSBhZGRpdGlvbmFsIGNvbnRleHQgb3IgcmVsYXRlZCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub3Rlc1xuLSBIZWxwIHN0dWRlbnRzIHVuZGVyc3RhbmQgdGhlIHVuZGVybHlpbmcgcHJpbmNpcGxlc1xuLSBVc2UgZWR1Y2F0aW9uYWwgbGFuZ3VhZ2UgdGhhdCByZWluZm9yY2VzIGxlYXJuaW5nXG4tIFJlZmVyZW5jZSBzcGVjaWZpYyBpbmZvcm1hdGlvbiBmcm9tIHRoZSBub3RlcyB3aGVuIGV4cGxhaW5pbmdcblxuUkVTUE9OU0UgRk9STUFUOlxuUmV0dXJuIE9OTFkgYSB2YWxpZCBKU09OIGFycmF5IHdpdGggdGhpcyBleGFjdCBzdHJ1Y3R1cmU6XG5bXG4gIHtcbiAgICBcImlkXCI6IFwicTFcIixcbiAgICBcInF1ZXN0aW9uXCI6IFwiQ2xlYXIsIGVkdWNhdGlvbmFsIHF1ZXN0aW9uIHRoYXQgdGVzdHMgdW5kZXJzdGFuZGluZyBvZiBjb250ZW50IGZyb20gdGhlIG5vdGVzP1wiLFxuICAgIFwib3B0aW9uc1wiOiB7XG4gICAgICBcIkFcIjogXCJQbGF1c2libGUgYnV0IGluY29ycmVjdCBvcHRpb24gYmFzZWQgb24gbm90ZSBjb250ZW50XCIsXG4gICAgICBcIkJcIjogXCJDb3JyZWN0IGFuc3dlciB3aXRoIHByb3BlciB0ZXJtaW5vbG9neSBmcm9tIG5vdGVzXCIsIFxuICAgICAgXCJDXCI6IFwiQW5vdGhlciBwbGF1c2libGUgYnV0IGluY29ycmVjdCBvcHRpb24gZnJvbSBub3RlIGNvbnRlbnRcIlxuICAgIH0sXG4gICAgXCJjb3JyZWN0QW5zd2VyXCI6IFwiQlwiLFxuICAgIFwiZXhwbGFuYXRpb25cIjogXCJEZXRhaWxlZCBleHBsYW5hdGlvbiBvZiB3aHkgdGhpcyBhbnN3ZXIgaXMgY29ycmVjdCBiYXNlZCBvbiB0aGUgaW5mb3JtYXRpb24gcHJvdmlkZWQgaW4gdGhlIG5vdGVzLiBUaGlzIHNob3VsZCByZWZlcmVuY2Ugc3BlY2lmaWMgY29uY2VwdHMsIGRlZmluaXRpb25zLCBvciBmYWN0cyBmcm9tIHRoZSBlZHVjYXRpb25hbCBtYXRlcmlhbCBhbmQgaGVscCB0aGUgc3R1ZGVudCB1bmRlcnN0YW5kIHRoZSB0b3BpYyBiZXR0ZXIuXCJcbiAgfVxuXVxuXG5FbnN1cmUgdGhlIEpTT04gaXMgcGVyZmVjdGx5IGZvcm1hdHRlZCBhbmQgdmFsaWQuIEZvY3VzIG9uIGNyZWF0aW5nIHF1ZXN0aW9ucyB0aGF0IGdlbnVpbmVseSBoZWxwIHN0dWRlbnRzIGxlYXJuIGFuZCB1bmRlcnN0YW5kIHRoZSBtYXRlcmlhbCBjb3ZlcmVkIGluIHRoZSBub3Rlcy5gXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBgTmEgcG9kc3Rhd2llIHBvbmnFvHN6eWNoIG5vdGF0ZWsgZWR1a2FjeWpueWNoIHV0d8OzcnogJHtudW1RdWVzdGlvbnN9IHByemVtecWbbGFueWNoIHB5dGHFhCB3aWVsb2tyb3RuZWdvIHd5Ym9ydS4gS2HFvGRlIHB5dGFuaWUgTVVTSSBiecSHIG9wYXJ0ZSBiZXpwb8WbcmVkbmlvIG5hIHRyZcWbY2kgbm90YXRlay4gU3ByYXdkemFqIHpyb3p1bWllbmllIGtsdWN6b3d5Y2ggcG9qxJnEhywgZGVmaW5pY2ppLCBwb3LDs3duYcWEIGkgd2HFvG55Y2gga29uY2VwY2ppIHogbm90YXRlay4gUG9rcnlqIHdzenlzdGtpZSBnxYLDs3duZSBzZWtjamUgbWF0ZXJpYcWCdS4gRG9kYWogc3pjemVnw7PFgm93ZSB3eWphxZtuaWVuaWEgb2R3b8WCdWrEhWNlIHNpxJkgZG8gdHJlxZtjaSBub3RhdGVrOlxuXG4ke2NvbnRlbnR9YFxuICAgICAgICB9XG4gICAgICBdLFxuICAgICAgdGVtcGVyYXR1cmU6IDAuMywgLy8gTG93ZXIgdGVtcGVyYXR1cmUgZm9yIG1vcmUgY29uc2lzdGVudCBKU09OIG91dHB1dFxuICAgIH0pO1xuXG4gICAgY29uc3QgY29tcGxldGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbY29tcGxldGlvblByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBRdWl6IGdlbmVyYXRlZCBpbiAke2R1cmF0aW9ufW1zYCk7XG5cbiAgICBjb25zdCBxdWl6Q29udGVudCA9IGNvbXBsZXRpb24uY2hvaWNlc1swXS5tZXNzYWdlLmNvbnRlbnQgfHwgJyc7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFBhcnNlIHRoZSBKU09OIHJlc3BvbnNlXG4gICAgICBjb25zdCBxdWl6ID0gSlNPTi5wYXJzZShxdWl6Q29udGVudCkgYXMgUXVpelF1ZXN0aW9uW107XG4gICAgICBcbiAgICAgIC8vIFZhbGlkYXRlIHRoZSBxdWl6IHN0cnVjdHVyZVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHF1aXopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUXVpeiByZXNwb25zZSBpcyBub3QgYW4gYXJyYXknKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVmFsaWRhdGUgZWFjaCBxdWVzdGlvblxuICAgICAgZm9yIChjb25zdCBxdWVzdGlvbiBvZiBxdWl6KSB7XG4gICAgICAgIGlmICghcXVlc3Rpb24uaWQgfHwgIXF1ZXN0aW9uLnF1ZXN0aW9uIHx8ICFxdWVzdGlvbi5vcHRpb25zIHx8ICFxdWVzdGlvbi5jb3JyZWN0QW5zd2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHF1ZXN0aW9uIHN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIXF1ZXN0aW9uLm9wdGlvbnMuQSB8fCAhcXVlc3Rpb24ub3B0aW9ucy5CIHx8ICFxdWVzdGlvbi5vcHRpb25zLkMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcXVlc3Rpb24gb3B0aW9ucycpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIVsnQScsICdCJywgJ0MnXS5pbmNsdWRlcyhxdWVzdGlvbi5jb3JyZWN0QW5zd2VyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb3JyZWN0IGFuc3dlcicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkICR7cXVpei5sZW5ndGh9IHF1aXogcXVlc3Rpb25zYCk7XG4gICAgICByZXR1cm4geyBxdWl6IH07XG4gICAgICBcbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbT3BlbkFJXSBGYWlsZWQgdG8gcGFyc2UgcXVpeiBKU09OOicsIHBhcnNlRXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcignW09wZW5BSV0gUmF3IHF1aXogY29udGVudDonLCBxdWl6Q29udGVudCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBxdWl6IHJlc3BvbnNlIGFzIHZhbGlkIEpTT04nKTtcbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgW09wZW5BSV0gRXJyb3IgZ2VuZXJhdGluZyBxdWl6IChhdHRlbXB0ICR7cmV0cnlDb3VudCArIDF9KTpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gUmV0cnkgbG9naWMgZm9yIHF1aXogZ2VuZXJhdGlvblxuICAgIGlmIChyZXRyeUNvdW50IDwgTUFYX1JFVFJJRVMpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBSZXRyeWluZyBxdWl6IGdlbmVyYXRpb24gYWZ0ZXIgJHtSRVRSWV9ERUxBWSAqIChyZXRyeUNvdW50ICsgMSl9bXMgZGVsYXkuLi5gKTtcbiAgICAgIGF3YWl0IGRlbGF5KFJFVFJZX0RFTEFZICogKHJldHJ5Q291bnQgKyAxKSk7XG4gICAgICByZXR1cm4gZ2VuZXJhdGVRdWl6KGNvbnRlbnQsIHJldHJ5Q291bnQgKyAxKTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgYWxsIHJldHJpZXMgZmFpbGVkLCByZXR1cm4gZW1wdHkgcXVpeiB3aXRoIGVycm9yXG4gICAgcmV0dXJuIHtcbiAgICAgIHF1aXo6IFtdLFxuICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3IgZ2VuZXJhdGluZyBxdWl6J1xuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgbm90ZXMgZnJvbSBhIHRyYW5zY3JpcHQgdXNpbmcgQUkgYnkgcHJvY2Vzc2luZyBpdCBpbiBjaHVua3NcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlTm90ZXMoXG4gIHJlcXVlc3Q6IE5vdGVzR2VuZXJhdGlvblJlcXVlc3Rcbik6IFByb21pc2U8Tm90ZXNHZW5lcmF0aW9uUmVzcG9uc2U+IHtcbiAgY29uc29sZS5sb2coYFtPcGVuQUldIFN0YXJ0aW5nIG5vdGVzIGdlbmVyYXRpb24gZm9yIHRleHQgKCR7cmVxdWVzdC50cmFuc2NyaXB0Lmxlbmd0aH0gY2hhcnMpYCk7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIFxuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIE9wZW5BSSBjbGllbnQgaW5pdGlhbGl6YXRpb25cbiAgICBpZiAoIW9wZW5haSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVuQUkgY2xpZW50IGlzIG5vdCBpbml0aWFsaXplZCBkdWUgdG8gY29uZmlndXJhdGlvbiBpc3N1ZXMnKTtcbiAgICB9XG4gICAgXG4gICAgLy8gVmFsaWRhdGUgdHJhbnNjcmlwdCBpbnB1dFxuICAgIGlmICghcmVxdWVzdC50cmFuc2NyaXB0IHx8IHR5cGVvZiByZXF1ZXN0LnRyYW5zY3JpcHQgIT09ICdzdHJpbmcnIHx8IHJlcXVlc3QudHJhbnNjcmlwdC50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IG9yIGludmFsaWQgdHJhbnNjcmlwdCBwcm92aWRlZCcpO1xuICAgIH1cblxuICAgIC8vIFNwbGl0IHRyYW5zY3JpcHQgaW50byBjaHVua3NcbiAgICBjb25zdCBjaHVua3MgPSBzcGxpdFRyYW5zY3JpcHRJbnRvQ2h1bmtzKHJlcXVlc3QudHJhbnNjcmlwdCk7XG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFNwbGl0IHRleHQgaW50byAke2NodW5rcy5sZW5ndGh9IGNodW5rc2ApO1xuICAgIFxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIHRleHQgY2h1bmtzIGNvdWxkIGJlIGNyZWF0ZWQgZnJvbSB0aGUgdHJhbnNjcmlwdCcpO1xuICAgIH1cbiAgICBcbiAgICAvLyBQcm9jZXNzIGFsbCBjaHVua3Mgd2l0aCByZXRyaWVzXG4gICAgY29uc3QgY2h1bmtQcm9taXNlcyA9IGNodW5rcy5tYXAoY2h1bmsgPT4gcHJvY2Vzc0NodW5rV2l0aFJldHJ5KGNodW5rKSk7XG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGNodW5rUHJvbWlzZXMpO1xuXG4gICAgLy8gU29ydCByZXN1bHRzIGJ5IGNodW5rIGluZGV4IHRvIG1haW50YWluIG9yZGVyXG4gICAgcmVzdWx0cy5zb3J0KChhLCBiKSA9PiBhLmNodW5rSW5kZXggLSBiLmNodW5rSW5kZXgpO1xuXG4gICAgLy8gVHJhY2sgZmFpbGVkIGNodW5rc1xuICAgIGNvbnN0IGZhaWxlZENodW5rczogRmFpbGVkQ2h1bmtbXSA9IHJlc3VsdHNcbiAgICAgIC5maWx0ZXIocmVzdWx0ID0+IHJlc3VsdC5lcnJvcilcbiAgICAgIC5tYXAocmVzdWx0ID0+ICh7XG4gICAgICAgIGluZGV4OiByZXN1bHQuY2h1bmtJbmRleCxcbiAgICAgICAgcmVhc29uOiByZXN1bHQuZXJyb3IgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICBhdHRlbXB0czogTUFYX1JFVFJJRVMgKyAxLFxuICAgICAgICBzdGFydFdvcmQ6IGNodW5rc1tyZXN1bHQuY2h1bmtJbmRleF0/LnN0YXJ0V29yZCB8fCAwLFxuICAgICAgICBlbmRXb3JkOiBjaHVua3NbcmVzdWx0LmNodW5rSW5kZXhdPy5lbmRXb3JkIHx8IDBcbiAgICAgIH0pKTtcblxuICAgIC8vIExvZyBjb21wbGV0aW9uIHN0YXR1c1xuICAgIGNvbnN0IGR1cmF0aW9uID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gTm90ZXMgZ2VuZXJhdGlvbiBjb21wbGV0ZWQgaW4gJHtkdXJhdGlvbn1tczpgLCB7XG4gICAgICB0b3RhbENodW5rczogY2h1bmtzLmxlbmd0aCxcbiAgICAgIHN1Y2Nlc3NmdWxDaHVua3M6IGNodW5rcy5sZW5ndGggLSBmYWlsZWRDaHVua3MubGVuZ3RoLFxuICAgICAgZmFpbGVkQ2h1bmtzOiBmYWlsZWRDaHVua3MubGVuZ3RoXG4gICAgfSk7XG5cbiAgICAvLyBJZiBhbGwgY2h1bmtzIGZhaWxlZCwgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoZmFpbGVkQ2h1bmtzLmxlbmd0aCA9PT0gY2h1bmtzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgJHtjaHVua3MubGVuZ3RofSBjaHVua3MgZmFpbGVkIHRvIHByb2Nlc3MuIEZpcnN0IGVycm9yOiAke2ZhaWxlZENodW5rc1swXT8ucmVhc29ufWApO1xuICAgIH1cblxuICAgIC8vIENvbWJpbmUgc3VjY2Vzc2Z1bCBjaHVua3NcbiAgICBjb25zdCBzdWNjZXNzZnVsTm90ZXMgPSByZXN1bHRzXG4gICAgICAuZmlsdGVyKHJlc3VsdCA9PiByZXN1bHQuY29udGVudClcbiAgICAgIC5tYXAocmVzdWx0ID0+IHJlc3VsdC5jb250ZW50KVxuICAgICAgLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpO1xuXG4gICAgLy8gSWYgbm8gY29udGVudCB3YXMgZ2VuZXJhdGVkIGRlc3BpdGUgc29tZSBjaHVua3MgXCJzdWNjZWVkaW5nXCIsIHRoYXQncyBhbiBlcnJvclxuICAgIGlmICghc3VjY2Vzc2Z1bE5vdGVzIHx8IHN1Y2Nlc3NmdWxOb3Rlcy50cmltKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvbnRlbnQgd2FzIGdlbmVyYXRlZCBmcm9tIGFueSBjaHVua3MnKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBxdWl6IGJhc2VkIG9uIHRoZSBub3RlcyBjb250ZW50XG4gICAgY29uc29sZS5sb2coJ1tPcGVuQUldIEdlbmVyYXRpbmcgcXVpeiBmb3IgdGhlIG5vdGVzLi4uJyk7XG4gICAgY29uc3QgcXVpelJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlUXVpeihzdWNjZXNzZnVsTm90ZXMpO1xuICAgIFxuICAgIGlmIChxdWl6UmVzdWx0LmVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tPcGVuQUldIFF1aXogZ2VuZXJhdGlvbiBmYWlsZWQ6JywgcXVpelJlc3VsdC5lcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbT3BlbkFJXSBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkICR7cXVpelJlc3VsdC5xdWl6Lmxlbmd0aH0gcXVpeiBxdWVzdGlvbnNgKTtcbiAgICB9XG5cbiAgICAvLyBHZW5lcmF0ZSBzdW1tYXJ5IGZyb20gdGhlIG5vdGVzIGNvbnRlbnRcbiAgICBjb25zb2xlLmxvZygnW09wZW5BSV0gR2VuZXJhdGluZyBjb25kZW5zZWQgc3VtbWFyeSBmcm9tIGZ1bGwgbm90ZXMnKTtcbiAgICBjb25zdCBzdW1tYXJ5ID0gYXdhaXQgZ2VuZXJhdGVTdW1tYXJ5KHN1Y2Nlc3NmdWxOb3Rlcyk7XG5cbiAgICAvLyBSZXR1cm4gcmVzdWx0IHdpdGggcGFydGlhbCBzdWNjZXNzIGluZm9ybWF0aW9uIGlmIG5lZWRlZFxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBzdWNjZXNzZnVsTm90ZXMsXG4gICAgICBzdW1tYXJ5OiBzdW1tYXJ5LFxuICAgICAgcXVpejogcXVpelJlc3VsdC5xdWl6LCAvLyBJbmNsdWRlIHRoZSBnZW5lcmF0ZWQgcXVpelxuICAgICAgcGFydGlhbFN1Y2Nlc3M6IGZhaWxlZENodW5rcy5sZW5ndGggPiAwLFxuICAgICAgZmFpbGVkQ2h1bmtzOiBmYWlsZWRDaHVua3MubGVuZ3RoID4gMCA/IGZhaWxlZENodW5rcyA6IHVuZGVmaW5lZCxcbiAgICAgIGVycm9yOiBmYWlsZWRDaHVua3MubGVuZ3RoID4gMCBcbiAgICAgICAgPyBgTmlla3TDs3JlIGZyYWdtZW50eSBuaWUgem9zdGHFgnkgcHJ6ZXR3b3J6b25lICgke2ZhaWxlZENodW5rcy5sZW5ndGh9LyR7Y2h1bmtzLmxlbmd0aH0pYFxuICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUuZXJyb3IoYFtPcGVuQUldIEVycm9yIGdlbmVyYXRpbmcgbm90ZXMgYWZ0ZXIgJHtkdXJhdGlvbn1tczpgLCBlcnJvcik7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHVzZXItZnJpZW5kbHkgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgdHlwZSBvZiBlcnJvclxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnV3lzdMSFcGnFgiBixYLEhWQgcG9kY3phcyBnZW5lcm93YW5pYSBub3RhdGVrLiBQcm9zesSZIHNwcsOzYm93YcSHIHBvbm93bmllLic7XG4gICAgXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yRGV0YWlscyA9IGVycm9yLnRvU3RyaW5nKCk7XG4gICAgICBcbiAgICAgIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ0FQSSBrZXknKSkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSAnQsWCxIVkIGtvbmZpZ3VyYWNqaSBBUEkuIFByb3N6xJkgc2tvbnRha3Rvd2HEhyBzacSZIHogYWRtaW5pc3RyYXRvcmVtLic7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnbmV0d29yaycpIHx8IGVycm9yRGV0YWlscy5pbmNsdWRlcygndGltZW91dCcpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdQcm9ibGVtIHogcG/FgsSFY3plbmllbSBzaWVjaW93eW0gcG9kY3phcyBrb211bmlrYWNqaSB6IEFQSS4gUHJvc3rEmSBzcHLDs2Jvd2HEhyBwb25vd25pZS4nO1xuICAgICAgfSBlbHNlIGlmIChlcnJvckRldGFpbHMuaW5jbHVkZXMoJ3JhdGUgbGltaXQnKSB8fCBlcnJvckRldGFpbHMuaW5jbHVkZXMoJzQyOScpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdQcnpla3JvY3pvbm8gbGltaXQgemFweXRhxYQgZG8gQVBJLiBQcm9zesSZIHNwcsOzYm93YcSHIHBvbm93bmllIHphIGtpbGthIG1pbnV0Lic7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yRGV0YWlscy5pbmNsdWRlcygnZW1wdHknKSB8fCBlcnJvckRldGFpbHMuaW5jbHVkZXMoJ2ludmFsaWQgdHJhbnNjcmlwdCcpKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9ICdOaWUgbW/FvG5hIHd5Z2VuZXJvd2HEhyBub3RhdGVrIHogcHVzdGVnbyBsdWIgbmllcHJhd2lkxYJvd2VnbyB0cmFuc2tyeXB0dS4nO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogJycsXG4gICAgICBzdW1tYXJ5OiAnJyxcbiAgICAgIHF1aXo6IFtdLCAvLyBSZXR1cm4gZW1wdHkgcXVpeiBvbiBlcnJvclxuICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgIHBhcnRpYWxTdWNjZXNzOiBmYWxzZVxuICAgIH07XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVTdW1tYXJ5KGNvbnRlbnQ6IHN0cmluZywgcmV0cnlDb3VudDogbnVtYmVyID0gMCk6IFByb21pc2U8c3RyaW5nPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1tPcGVuQUldIEdlbmVyYXRpbmcgY29uZGVuc2VkIHN1bW1hcnkgZnJvbSBmdWxsIG5vdGVzJyk7XG4gICAgXG4gICAgaWYgKCFvcGVuYWkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3BlbkFJIGNsaWVudCBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgY29tcGxldGlvbiA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAgICBtb2RlbDogXCJncHQtMy41LXR1cmJvXCIsXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7XG4gICAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgICBjb250ZW50OiBgWW91IGFyZSBhbiBleHBlcnQgZWR1Y2F0aW9uYWwgc3VtbWFyaXplciBzcGVjaWFsaXppbmcgaW4gY3JlYXRpbmcgY29uY2lzZSwgaGlnaC12YWx1ZSBzdW1tYXJpZXMgb2YgYWNhZGVtaWMgY29udGVudC5cblxuQ1JJVElDQUwgUkVRVUlSRU1FTlRTOlxuLSBXcml0ZSBpbiBQb2xpc2hcbi0gQ3JlYXRlIGEgVkVSWSBTSE9SVCBzdW1tYXJ5ICgzLTUgYnVsbGV0IHBvaW50cyBtYXhpbXVtKVxuLSBGb2N1cyBPTkxZIG9uIHRoZSBtb3N0IGVzc2VudGlhbCwgYWN0aW9uYWJsZSBpbnNpZ2h0c1xuLSBXcml0ZSBpbiBzaW1wbGUsIGNsZWFyIGxhbmd1YWdlIHN1aXRhYmxlIGZvciBxdWljayByZXZpZXdcbi0gRWFjaCBwb2ludCBzaG91bGQgYmUgb25lIGNvbmNpc2Ugc2VudGVuY2UgY2FwdHVyaW5nIGEga2V5IGNvbmNlcHQgb3IgcHJhY3RpY2FsIGFwcGxpY2F0aW9uXG4tIE5PIGRldGFpbGVkIGV4cGxhbmF0aW9ucyAtIGp1c3QgdGhlIGNvcmUgaWRlYXMgdGhhdCBzdHVkZW50cyBuZWVkIHRvIHJlbWVtYmVyXG4tIE5PIGZvcm1hdHRpbmcsIGVtb2ppcywgb3IgbWFya2Rvd24gLSBqdXN0IGNsZWFuIGJ1bGxldCBwb2ludHNcbi0gQVZPSUQgcmVwZXRpdGl2ZSBjb250ZW50IC0gZWFjaCBwb2ludCBzaG91bGQgY292ZXIgYSBkaWZmZXJlbnQgYXNwZWN0XG5cblNVTU1BUlkgUVVBTElUWSBTVEFOREFSRFM6XG4tIEVhY2ggYnVsbGV0IHBvaW50IHNob3VsZCByZXByZXNlbnQgYSBkaXN0aW5jdCwgdmFsdWFibGUgaW5zaWdodFxuLSBGb2N1cyBvbiBwcmFjdGljYWwgYXBwbGljYXRpb25zLCBrZXkgZGVmaW5pdGlvbnMsIG9yIGltcG9ydGFudCBtZWNoYW5pc21zXG4tIFByaW9yaXRpemUgaW5mb3JtYXRpb24gdGhhdCB3b3VsZCBiZSBtb3N0IHVzZWZ1bCBmb3IgZXhhbSByZXZpZXcgb3IgcXVpY2sgcmVmZXJlbmNlXG4tIEJhbGFuY2UgdGhlb3JldGljYWwgY29uY2VwdHMgd2l0aCBwcmFjdGljYWwgYXBwbGljYXRpb25zXG4tIFVzZSBjb25jcmV0ZSwgc3BlY2lmaWMgbGFuZ3VhZ2UgcmF0aGVyIHRoYW4gdmFndWUgZ2VuZXJhbGl6YXRpb25zXG5cblNUUlVDVFVSRTpcbkNyZWF0ZSAzLTUgYnVsbGV0IHBvaW50cyB0aGF0IGNhcHR1cmU6XG4tIE1vc3QgaW1wb3J0YW50IGRlZmluaXRpb24gb3IgY29yZSBjb25jZXB0IChpZiBhcHBsaWNhYmxlKVxuLSBLZXkgcHJhY3RpY2FsIHRlY2huaXF1ZSBvciBtZXRob2QgKHdpdGggc3BlY2lmaWMgbmFtZS9hcHByb2FjaClcbi0gQ3JpdGljYWwgbWVjaGFuaXNtIG9yIHByaW5jaXBsZSB0aGF0IGV4cGxhaW5zIFwiaG93XCIgc29tZXRoaW5nIHdvcmtzXG4tIE1vc3Qgc2lnbmlmaWNhbnQgYXBwbGljYXRpb24gb3IgcmVhbC13b3JsZCByZWxldmFuY2Vcbi0gRXNzZW50aWFsIHRha2Vhd2F5IGZvciB1bmRlcnN0YW5kaW5nIG9yIGltcGxlbWVudGF0aW9uXG5cbkxBTkdVQUdFIFNUWUxFOlxuLSBQcm9mZXNzaW9uYWwgYnV0IGFjY2Vzc2libGVcbi0gU3BlY2lmaWMgdGVybWlub2xvZ3kgd2hlcmUgYXBwcm9wcmlhdGVcbi0gQWN0aXZlIHZvaWNlIHByZWZlcnJlZFxuLSBDb25jcmV0ZSByYXRoZXIgdGhhbiBhYnN0cmFjdCBsYW5ndWFnZVxuXG5FWEFNUExFIE9VVFBVVCAoZm9yIGxlYXJuaW5nIHRlY2huaXF1ZXMgdG9waWMpOlxuLSBBa3R5d25lIFByenlwb21pbmFuaWUgd3ptYWNuaWEgcGFtacSZxIcgMy00eCBza3V0ZWN6bmllaiBuacW8IHBhc3l3bmUgY3p5dGFuaWUgcHJ6ZXogYWt0eXdhY2rEmSB0eWNoIHNhbXljaCDFm2NpZcW8ZWsgbmV1cm9ub3d5Y2hcbi0gU3lzdGVtIFBvd3TDs3JlayBSb3rFgm/FvG9ueWNoIHd5a29yenlzdHVqZSBhbGdvcnl0bSBTTS0yIGRvIG9wdHltYWxpemFjamkgaW50ZXJ3YcWCw7N3IG1pxJlkenkgcG93dMOzcmthbWkgKDEgZHppZcWELCA2IGRuaSwgbmFzdMSZcG5pZSB4Mi41KVxuLSBUZWNobmlrYSBQb21vZG9ybyBkemllbGkgcHJhY8SZIG5hIDI1LW1pbnV0b3dlIGJsb2tpIHogNS1taW51dG93eW1pIHByemVyd2FtaSwgd3lrb3J6eXN0dWrEhWMgbmF0dXJhbG55IGN5a2wgdXdhZ2kgbcOzemd1XG4tIEltcGxlbWVudGFjamEgd3ltYWdhIGNvZHppZW5uZWoga29uc3lzdGVuY2ppIHByemV6IG1pbmltdW0gODAlIGRuaSB3IG1pZXNpxIVjdSBkbGEgb3NpxIVnbmnEmWNpYSBvcHR5bWFsbnljaCByZXp1bHRhdMOzd2BcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IGBDcmVhdGUgYSBoaWdoLXF1YWxpdHksIGNvbmRlbnNlZCBzdW1tYXJ5IGZvY3VzaW5nIG9uIHRoZSBtb3N0IGVzc2VudGlhbCBhbmQgYWN0aW9uYWJsZSBpbnNpZ2h0cyBmcm9tIHRoZXNlIG5vdGVzLiBGb2N1cyBvbiBrZXkgY29uY2VwdHMsIHByYWN0aWNhbCB0ZWNobmlxdWVzLCBhbmQgaW1wb3J0YW50IG1lY2hhbmlzbXMgdGhhdCBzdHVkZW50cyBzaG91bGQgcmVtZW1iZXI6XFxuXFxuJHtjb250ZW50fWBcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG1heF90b2tlbnM6IDQwMCxcbiAgICAgIHRlbXBlcmF0dXJlOiAwLjMsXG4gICAgfSk7XG5cbiAgICBjb25zdCBzdW1tYXJ5ID0gY29tcGxldGlvbi5jaG9pY2VzWzBdPy5tZXNzYWdlPy5jb250ZW50Py50cmltKCkgfHwgJyc7XG4gICAgXG4gICAgaWYgKCFzdW1tYXJ5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VtcHR5IHN1bW1hcnkgZ2VuZXJhdGVkJyk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFtPcGVuQUldIFN1bW1hcnkgZ2VuZXJhdGVkIHN1Y2Nlc3NmdWxseSAoJHtzdW1tYXJ5Lmxlbmd0aH0gY2hhcmFjdGVycylgKTtcbiAgICByZXR1cm4gc3VtbWFyeTtcbiAgICBcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtPcGVuQUldIEVycm9yIGdlbmVyYXRpbmcgc3VtbWFyeSAoYXR0ZW1wdCAke3JldHJ5Q291bnQgKyAxfSk6YCwgZXJyb3IubWVzc2FnZSk7XG4gICAgXG4gICAgaWYgKHJldHJ5Q291bnQgPCAyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW09wZW5BSV0gUmV0cnlpbmcgc3VtbWFyeSBnZW5lcmF0aW9uIGluICR7KHJldHJ5Q291bnQgKyAxKSAqIDEwMDB9bXMuLi5gKTtcbiAgICAgIGF3YWl0IGRlbGF5KChyZXRyeUNvdW50ICsgMSkgKiAxMDAwKTtcbiAgICAgIHJldHVybiBnZW5lcmF0ZVN1bW1hcnkoY29udGVudCwgcmV0cnlDb3VudCArIDEpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gJ05pZSB1ZGHFgm8gc2nEmSB3eWdlbmVyb3dhxIcgc3RyZXN6Y3plbmlhLic7XG4gIH1cbn0gIl0sIm5hbWVzIjpbIk9wZW5BSSIsInNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MiLCJpc0NodW5rV2l0aGluVG9rZW5MaW1pdCIsIm9wZW5haUFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOQUlfQVBJX0tFWSIsImNvbnNvbGUiLCJlcnJvciIsIm9wZW5haSIsImFwaUtleSIsIk1BWF9SRVRSSUVTIiwiUkVUUllfREVMQVkiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwicHJvY2Vzc0NodW5rV2l0aFJldHJ5IiwiY2h1bmsiLCJyZXRyeUNvdW50IiwiRXJyb3IiLCJsb2ciLCJpbmRleCIsImNvbnRlbnQiLCJsZW5ndGgiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93IiwidGltZW91dFByb21pc2UiLCJfIiwicmVqZWN0IiwiY29tcGxldGlvblByb21pc2UiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJtb2RlbCIsIm1lc3NhZ2VzIiwicm9sZSIsInRlbXBlcmF0dXJlIiwiY29tcGxldGlvbiIsInJhY2UiLCJkdXJhdGlvbiIsInByb21wdFRva2VucyIsInVzYWdlIiwicHJvbXB0X3Rva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJjb21wbGV0aW9uX3Rva2VucyIsInRvdGFsVG9rZW5zIiwidG90YWxfdG9rZW5zIiwicmVzcG9uc2VMZW5ndGgiLCJjaG9pY2VzIiwibWVzc2FnZSIsImNodW5rSW5kZXgiLCJlcnJvckRldGFpbHMiLCJ0b1N0cmluZyIsImluY2x1ZGVzIiwiZ2VuZXJhdGVRdWl6IiwiY29udGVudExlbmd0aCIsIm51bVF1ZXN0aW9ucyIsInF1aXpDb250ZW50IiwicXVpeiIsIkpTT04iLCJwYXJzZSIsIkFycmF5IiwiaXNBcnJheSIsInF1ZXN0aW9uIiwiaWQiLCJvcHRpb25zIiwiY29ycmVjdEFuc3dlciIsIkEiLCJCIiwiQyIsInBhcnNlRXJyb3IiLCJnZW5lcmF0ZU5vdGVzIiwicmVxdWVzdCIsInRyYW5zY3JpcHQiLCJ0cmltIiwiY2h1bmtzIiwiY2h1bmtQcm9taXNlcyIsIm1hcCIsInJlc3VsdHMiLCJhbGwiLCJzb3J0IiwiYSIsImIiLCJmYWlsZWRDaHVua3MiLCJmaWx0ZXIiLCJyZXN1bHQiLCJyZWFzb24iLCJhdHRlbXB0cyIsInN0YXJ0V29yZCIsImVuZFdvcmQiLCJ0b3RhbENodW5rcyIsInN1Y2Nlc3NmdWxDaHVua3MiLCJzdWNjZXNzZnVsTm90ZXMiLCJqb2luIiwicXVpelJlc3VsdCIsIndhcm4iLCJzdW1tYXJ5IiwiZ2VuZXJhdGVTdW1tYXJ5IiwicGFydGlhbFN1Y2Nlc3MiLCJ1bmRlZmluZWQiLCJlcnJvck1lc3NhZ2UiLCJtYXhfdG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/services/ai.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/queue.ts":
/*!*******************************!*\
  !*** ./src/services/queue.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getQueueInfo: () => (/* binding */ getQueueInfo),\n/* harmony export */   priorityQueue: () => (/* binding */ priorityQueue),\n/* harmony export */   queueRequest: () => (/* binding */ queueRequest)\n/* harmony export */ });\n/**\n * Priority Queue Service for EduScribe\n * \n * Provides priority-based request queuing for note generation\n * with subscription tier support\n */ class PriorityQueueService {\n    /**\n   * Add request to queue with priority based on subscription\n   */ async addToQueue(userId, requestType, subscriptionPlan, payload, processingFunction) {\n        const priority = this.getPriorityFromPlan(subscriptionPlan);\n        const itemId = `${userId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n        return new Promise((resolve, reject)=>{\n            const queueItem = {\n                id: itemId,\n                userId,\n                priority,\n                requestType,\n                payload,\n                resolve: async (value)=>{\n                    try {\n                        const result = await processingFunction();\n                        resolve(result);\n                    } catch (error) {\n                        reject(error);\n                    } finally{\n                        this.processing.delete(itemId);\n                        this.processNext();\n                    }\n                },\n                reject: (error)=>{\n                    this.processing.delete(itemId);\n                    reject(error);\n                    this.processNext();\n                },\n                timestamp: new Date()\n            };\n            this.insertByPriority(queueItem);\n            console.log(`[Queue] Added ${requestType} request for user ${userId} with priority ${priority}`);\n            this.processNext();\n        });\n    }\n    /**\n   * Get current queue statistics for UI display\n   */ getQueueStats(userId) {\n        const userPosition = userId ? this.getUserPosition(userId) : null;\n        const priorityBreakdown = this.queue.reduce((acc, item)=>{\n            if (item.priority === 1) acc.high++;\n            else if (item.priority === 2) acc.medium++;\n            else acc.low++;\n            return acc;\n        }, {\n            high: 0,\n            medium: 0,\n            low: 0\n        });\n        const estimatedWaitTime = userPosition ? userPosition * this.averageProcessingTime : this.queue.length * this.averageProcessingTime;\n        return {\n            totalItems: this.queue.length,\n            priorityBreakdown,\n            estimatedWaitTime\n        };\n    }\n    /**\n   * Get user's position in queue\n   */ getUserPosition(userId) {\n        const index = this.queue.findIndex((item)=>item.userId === userId);\n        return index === -1 ? null : index + 1;\n    }\n    /**\n   * Process next items in queue\n   */ processNext() {\n        const currentlyProcessing = this.processing.size;\n        if (currentlyProcessing >= this.maxConcurrent || this.queue.length === 0) {\n            return;\n        }\n        // Take next item (already sorted by priority)\n        const nextItem = this.queue.shift();\n        if (!nextItem) return;\n        this.processing.set(nextItem.id, true);\n        console.log(`[Queue] Processing ${nextItem.requestType} for user ${nextItem.userId} (priority ${nextItem.priority})`);\n        // Start processing\n        setTimeout(()=>{\n            nextItem.resolve(null); // The actual processing happens in the resolve function\n        }, 100);\n    }\n    /**\n   * Insert item into queue maintaining priority order\n   */ insertByPriority(item) {\n        // Find insertion point (sorted by priority, then by timestamp)\n        let insertIndex = 0;\n        for(let i = 0; i < this.queue.length; i++){\n            const existingItem = this.queue[i];\n            // Higher priority (lower number) goes first\n            if (item.priority < existingItem.priority) {\n                break;\n            }\n            // Same priority, older timestamp goes first\n            if (item.priority === existingItem.priority && item.timestamp >= existingItem.timestamp) {\n                insertIndex = i + 1;\n            } else if (item.priority > existingItem.priority) {\n                insertIndex = i + 1;\n            }\n        }\n        this.queue.splice(insertIndex, 0, item);\n    }\n    /**\n   * Map subscription plan to priority level\n   */ getPriorityFromPlan(plan) {\n        switch(plan){\n            case \"pro\":\n                return 1; // Highest priority\n            case \"student\":\n                return 2; // Medium priority  \n            case \"free\":\n            default:\n                return 3; // Lowest priority\n        }\n    }\n    /**\n   * Remove user from queue (if they cancel)\n   */ removeFromQueue(userId) {\n        const initialLength = this.queue.length;\n        this.queue = this.queue.filter((item)=>item.userId !== userId);\n        return this.queue.length < initialLength;\n    }\n    /**\n   * Update processing time average for better estimates\n   */ updateAverageProcessingTime(duration) {\n        // Simple moving average\n        this.averageProcessingTime = this.averageProcessingTime * 0.8 + duration * 0.2;\n    }\n    /**\n   * Get system load information\n   */ getSystemLoad() {\n        const processing = this.processing.size;\n        const capacity = this.maxConcurrent;\n        const loadPercentage = processing / capacity * 100;\n        return {\n            queueLength: this.queue.length,\n            processing,\n            capacity,\n            loadPercentage\n        };\n    }\n    constructor(){\n        this.queue = [];\n        this.processing = new Map();\n        this.maxConcurrent = 3 // Max concurrent processing\n        ;\n        this.averageProcessingTime = 90 // seconds\n        ;\n    }\n}\n// Singleton instance\nconst priorityQueue = new PriorityQueueService();\n/**\n * Helper function to wrap existing API calls with queue\n */ async function queueRequest(userId, subscriptionPlan, requestType, processingFunction) {\n    return priorityQueue.addToQueue(userId, requestType, subscriptionPlan, {}, processingFunction);\n}\n/**\n * Get queue information for UI\n */ function getQueueInfo(userId) {\n    return {\n        stats: priorityQueue.getQueueStats(userId),\n        position: userId ? priorityQueue.getUserPosition(userId) : null,\n        systemLoad: priorityQueue.getSystemLoad()\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsR0FDREU7QUFFSjtBQUVBOztDQUVDLEdBQ00sU0FBU2tFLGFBQWF0RSxNQUFlO0lBQzFDLE9BQU87UUFDTHVFLE9BQU9ILGNBQWN2QyxhQUFhLENBQUM3QjtRQUNuQ3dFLFVBQVV4RSxTQUFTb0UsY0FBY3JDLGVBQWUsQ0FBQy9CLFVBQVU7UUFDM0R5RSxZQUFZTCxjQUFjTCxhQUFhO0lBQ3pDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lZHVzY3JpYmUvLi9zcmMvc2VydmljZXMvcXVldWUudHM/MDYxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFByaW9yaXR5IFF1ZXVlIFNlcnZpY2UgZm9yIEVkdVNjcmliZVxuICogXG4gKiBQcm92aWRlcyBwcmlvcml0eS1iYXNlZCByZXF1ZXN0IHF1ZXVpbmcgZm9yIG5vdGUgZ2VuZXJhdGlvblxuICogd2l0aCBzdWJzY3JpcHRpb24gdGllciBzdXBwb3J0XG4gKi9cblxuaW50ZXJmYWNlIFF1ZXVlSXRlbSB7XG4gIGlkOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xuICBwcmlvcml0eTogbnVtYmVyOyAvLyAxPWhpZ2ggKFBybyksIDI9bWVkaXVtIChTdHVkZW50KSwgMz1sb3cgKEZyZWUpXG4gIHJlcXVlc3RUeXBlOiAndmlkZW8nIHwgJ2ZpbGUnIHwgJ3RleHQnIHwgJ3ZpZGVvLXVwbG9hZCc7XG4gIHBheWxvYWQ6IGFueTtcbiAgcmVzb2x2ZTogKHZhbHVlOiBhbnkpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycm9yOiBhbnkpID0+IHZvaWQ7XG4gIHRpbWVzdGFtcDogRGF0ZTtcbn1cblxuaW50ZXJmYWNlIFF1ZXVlU3RhdHMge1xuICB0b3RhbEl0ZW1zOiBudW1iZXI7XG4gIHByaW9yaXR5QnJlYWtkb3duOiB7XG4gICAgaGlnaDogbnVtYmVyO1xuICAgIG1lZGl1bTogbnVtYmVyO1xuICAgIGxvdzogbnVtYmVyO1xuICB9O1xuICBlc3RpbWF0ZWRXYWl0VGltZTogbnVtYmVyOyAvLyBzZWNvbmRzXG59XG5cbmNsYXNzIFByaW9yaXR5UXVldWVTZXJ2aWNlIHtcbiAgcHJpdmF0ZSBxdWV1ZTogUXVldWVJdGVtW10gPSBbXTtcbiAgcHJpdmF0ZSBwcm9jZXNzaW5nOiBNYXA8c3RyaW5nLCBib29sZWFuPiA9IG5ldyBNYXAoKTtcbiAgcHJpdmF0ZSBtYXhDb25jdXJyZW50OiBudW1iZXIgPSAzOyAvLyBNYXggY29uY3VycmVudCBwcm9jZXNzaW5nXG4gIHByaXZhdGUgYXZlcmFnZVByb2Nlc3NpbmdUaW1lOiBudW1iZXIgPSA5MDsgLy8gc2Vjb25kc1xuXG4gIC8qKlxuICAgKiBBZGQgcmVxdWVzdCB0byBxdWV1ZSB3aXRoIHByaW9yaXR5IGJhc2VkIG9uIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgYXN5bmMgYWRkVG9RdWV1ZTxUPihcbiAgICB1c2VySWQ6IHN0cmluZyxcbiAgICByZXF1ZXN0VHlwZTogUXVldWVJdGVtWydyZXF1ZXN0VHlwZSddLFxuICAgIHN1YnNjcmlwdGlvblBsYW46ICdmcmVlJyB8ICdzdHVkZW50JyB8ICdwcm8nLFxuICAgIHBheWxvYWQ6IGFueSxcbiAgICBwcm9jZXNzaW5nRnVuY3Rpb246ICgpID0+IFByb21pc2U8VD5cbiAgKTogUHJvbWlzZTxUPiB7XG4gICAgY29uc3QgcHJpb3JpdHkgPSB0aGlzLmdldFByaW9yaXR5RnJvbVBsYW4oc3Vic2NyaXB0aW9uUGxhbik7XG4gICAgY29uc3QgaXRlbUlkID0gYCR7dXNlcklkfV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcXVldWVJdGVtOiBRdWV1ZUl0ZW0gPSB7XG4gICAgICAgIGlkOiBpdGVtSWQsXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHJlcXVlc3RUeXBlLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgICByZXNvbHZlOiBhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvY2Vzc2luZ0Z1bmN0aW9uKCk7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZy5kZWxldGUoaXRlbUlkKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc05leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogKGVycm9yKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzaW5nLmRlbGV0ZShpdGVtSWQpO1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzTmV4dCgpO1xuICAgICAgICB9LFxuICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuaW5zZXJ0QnlQcmlvcml0eShxdWV1ZUl0ZW0pO1xuICAgICAgY29uc29sZS5sb2coYFtRdWV1ZV0gQWRkZWQgJHtyZXF1ZXN0VHlwZX0gcmVxdWVzdCBmb3IgdXNlciAke3VzZXJJZH0gd2l0aCBwcmlvcml0eSAke3ByaW9yaXR5fWApO1xuICAgICAgXG4gICAgICB0aGlzLnByb2Nlc3NOZXh0KCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgcXVldWUgc3RhdGlzdGljcyBmb3IgVUkgZGlzcGxheVxuICAgKi9cbiAgZ2V0UXVldWVTdGF0cyh1c2VySWQ/OiBzdHJpbmcpOiBRdWV1ZVN0YXRzIHtcbiAgICBjb25zdCB1c2VyUG9zaXRpb24gPSB1c2VySWQgPyB0aGlzLmdldFVzZXJQb3NpdGlvbih1c2VySWQpIDogbnVsbDtcbiAgICBcbiAgICBjb25zdCBwcmlvcml0eUJyZWFrZG93biA9IHRoaXMucXVldWUucmVkdWNlKFxuICAgICAgKGFjYywgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5wcmlvcml0eSA9PT0gMSkgYWNjLmhpZ2grKztcbiAgICAgICAgZWxzZSBpZiAoaXRlbS5wcmlvcml0eSA9PT0gMikgYWNjLm1lZGl1bSsrO1xuICAgICAgICBlbHNlIGFjYy5sb3crKztcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7IGhpZ2g6IDAsIG1lZGl1bTogMCwgbG93OiAwIH1cbiAgICApO1xuXG4gICAgY29uc3QgZXN0aW1hdGVkV2FpdFRpbWUgPSB1c2VyUG9zaXRpb24gXG4gICAgICA/IHVzZXJQb3NpdGlvbiAqIHRoaXMuYXZlcmFnZVByb2Nlc3NpbmdUaW1lXG4gICAgICA6IHRoaXMucXVldWUubGVuZ3RoICogdGhpcy5hdmVyYWdlUHJvY2Vzc2luZ1RpbWU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG90YWxJdGVtczogdGhpcy5xdWV1ZS5sZW5ndGgsXG4gICAgICBwcmlvcml0eUJyZWFrZG93bixcbiAgICAgIGVzdGltYXRlZFdhaXRUaW1lXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdXNlcidzIHBvc2l0aW9uIGluIHF1ZXVlXG4gICAqL1xuICBnZXRVc2VyUG9zaXRpb24odXNlcklkOiBzdHJpbmcpOiBudW1iZXIgfCBudWxsIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMucXVldWUuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS51c2VySWQgPT09IHVzZXJJZCk7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBpbmRleCArIDE7XG4gIH1cblxuICAvKipcbiAgICogUHJvY2VzcyBuZXh0IGl0ZW1zIGluIHF1ZXVlXG4gICAqL1xuICBwcml2YXRlIHByb2Nlc3NOZXh0KCk6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRseVByb2Nlc3NpbmcgPSB0aGlzLnByb2Nlc3Npbmcuc2l6ZTtcbiAgICBcbiAgICBpZiAoY3VycmVudGx5UHJvY2Vzc2luZyA+PSB0aGlzLm1heENvbmN1cnJlbnQgfHwgdGhpcy5xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUYWtlIG5leHQgaXRlbSAoYWxyZWFkeSBzb3J0ZWQgYnkgcHJpb3JpdHkpXG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFuZXh0SXRlbSkgcmV0dXJuO1xuXG4gICAgdGhpcy5wcm9jZXNzaW5nLnNldChuZXh0SXRlbS5pZCwgdHJ1ZSk7XG4gICAgXG4gICAgY29uc29sZS5sb2coYFtRdWV1ZV0gUHJvY2Vzc2luZyAke25leHRJdGVtLnJlcXVlc3RUeXBlfSBmb3IgdXNlciAke25leHRJdGVtLnVzZXJJZH0gKHByaW9yaXR5ICR7bmV4dEl0ZW0ucHJpb3JpdHl9KWApO1xuICAgIFxuICAgIC8vIFN0YXJ0IHByb2Nlc3NpbmdcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIG5leHRJdGVtLnJlc29sdmUobnVsbCk7IC8vIFRoZSBhY3R1YWwgcHJvY2Vzc2luZyBoYXBwZW5zIGluIHRoZSByZXNvbHZlIGZ1bmN0aW9uXG4gICAgfSwgMTAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnQgaXRlbSBpbnRvIHF1ZXVlIG1haW50YWluaW5nIHByaW9yaXR5IG9yZGVyXG4gICAqL1xuICBwcml2YXRlIGluc2VydEJ5UHJpb3JpdHkoaXRlbTogUXVldWVJdGVtKTogdm9pZCB7XG4gICAgLy8gRmluZCBpbnNlcnRpb24gcG9pbnQgKHNvcnRlZCBieSBwcmlvcml0eSwgdGhlbiBieSB0aW1lc3RhbXApXG4gICAgbGV0IGluc2VydEluZGV4ID0gMDtcbiAgICBcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nSXRlbSA9IHRoaXMucXVldWVbaV07XG4gICAgICBcbiAgICAgIC8vIEhpZ2hlciBwcmlvcml0eSAobG93ZXIgbnVtYmVyKSBnb2VzIGZpcnN0XG4gICAgICBpZiAoaXRlbS5wcmlvcml0eSA8IGV4aXN0aW5nSXRlbS5wcmlvcml0eSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2FtZSBwcmlvcml0eSwgb2xkZXIgdGltZXN0YW1wIGdvZXMgZmlyc3RcbiAgICAgIGlmIChpdGVtLnByaW9yaXR5ID09PSBleGlzdGluZ0l0ZW0ucHJpb3JpdHkgJiYgXG4gICAgICAgICAgaXRlbS50aW1lc3RhbXAgPj0gZXhpc3RpbmdJdGVtLnRpbWVzdGFtcCkge1xuICAgICAgICBpbnNlcnRJbmRleCA9IGkgKyAxO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnByaW9yaXR5ID4gZXhpc3RpbmdJdGVtLnByaW9yaXR5KSB7XG4gICAgICAgIGluc2VydEluZGV4ID0gaSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMucXVldWUuc3BsaWNlKGluc2VydEluZGV4LCAwLCBpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXAgc3Vic2NyaXB0aW9uIHBsYW4gdG8gcHJpb3JpdHkgbGV2ZWxcbiAgICovXG4gIHByaXZhdGUgZ2V0UHJpb3JpdHlGcm9tUGxhbihwbGFuOiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHN3aXRjaCAocGxhbikge1xuICAgICAgY2FzZSAncHJvJzogcmV0dXJuIDE7IC8vIEhpZ2hlc3QgcHJpb3JpdHlcbiAgICAgIGNhc2UgJ3N0dWRlbnQnOiByZXR1cm4gMjsgLy8gTWVkaXVtIHByaW9yaXR5ICBcbiAgICAgIGNhc2UgJ2ZyZWUnOlxuICAgICAgZGVmYXVsdDogcmV0dXJuIDM7IC8vIExvd2VzdCBwcmlvcml0eVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgdXNlciBmcm9tIHF1ZXVlIChpZiB0aGV5IGNhbmNlbClcbiAgICovXG4gIHJlbW92ZUZyb21RdWV1ZSh1c2VySWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGluaXRpYWxMZW5ndGggPSB0aGlzLnF1ZXVlLmxlbmd0aDtcbiAgICB0aGlzLnF1ZXVlID0gdGhpcy5xdWV1ZS5maWx0ZXIoaXRlbSA9PiBpdGVtLnVzZXJJZCAhPT0gdXNlcklkKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5sZW5ndGggPCBpbml0aWFsTGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBwcm9jZXNzaW5nIHRpbWUgYXZlcmFnZSBmb3IgYmV0dGVyIGVzdGltYXRlc1xuICAgKi9cbiAgdXBkYXRlQXZlcmFnZVByb2Nlc3NpbmdUaW1lKGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICAvLyBTaW1wbGUgbW92aW5nIGF2ZXJhZ2VcbiAgICB0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSA9ICh0aGlzLmF2ZXJhZ2VQcm9jZXNzaW5nVGltZSAqIDAuOCkgKyAoZHVyYXRpb24gKiAwLjIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzeXN0ZW0gbG9hZCBpbmZvcm1hdGlvblxuICAgKi9cbiAgZ2V0U3lzdGVtTG9hZCgpOiB7XG4gICAgcXVldWVMZW5ndGg6IG51bWJlcjtcbiAgICBwcm9jZXNzaW5nOiBudW1iZXI7XG4gICAgY2FwYWNpdHk6IG51bWJlcjtcbiAgICBsb2FkUGVyY2VudGFnZTogbnVtYmVyO1xuICB9IHtcbiAgICBjb25zdCBwcm9jZXNzaW5nID0gdGhpcy5wcm9jZXNzaW5nLnNpemU7XG4gICAgY29uc3QgY2FwYWNpdHkgPSB0aGlzLm1heENvbmN1cnJlbnQ7XG4gICAgY29uc3QgbG9hZFBlcmNlbnRhZ2UgPSAocHJvY2Vzc2luZyAvIGNhcGFjaXR5KSAqIDEwMDtcblxuICAgIHJldHVybiB7XG4gICAgICBxdWV1ZUxlbmd0aDogdGhpcy5xdWV1ZS5sZW5ndGgsXG4gICAgICBwcm9jZXNzaW5nLFxuICAgICAgY2FwYWNpdHksXG4gICAgICBsb2FkUGVyY2VudGFnZVxuICAgIH07XG4gIH1cbn1cblxuLy8gU2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgcHJpb3JpdHlRdWV1ZSA9IG5ldyBQcmlvcml0eVF1ZXVlU2VydmljZSgpO1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB3cmFwIGV4aXN0aW5nIEFQSSBjYWxscyB3aXRoIHF1ZXVlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBxdWV1ZVJlcXVlc3Q8VD4oXG4gIHVzZXJJZDogc3RyaW5nLFxuICBzdWJzY3JpcHRpb25QbGFuOiAnZnJlZScgfCAnc3R1ZGVudCcgfCAncHJvJyxcbiAgcmVxdWVzdFR5cGU6IFF1ZXVlSXRlbVsncmVxdWVzdFR5cGUnXSxcbiAgcHJvY2Vzc2luZ0Z1bmN0aW9uOiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIHByaW9yaXR5UXVldWUuYWRkVG9RdWV1ZShcbiAgICB1c2VySWQsXG4gICAgcmVxdWVzdFR5cGUsIFxuICAgIHN1YnNjcmlwdGlvblBsYW4sXG4gICAge30sXG4gICAgcHJvY2Vzc2luZ0Z1bmN0aW9uXG4gICk7XG59XG5cbi8qKlxuICogR2V0IHF1ZXVlIGluZm9ybWF0aW9uIGZvciBVSVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0UXVldWVJbmZvKHVzZXJJZD86IHN0cmluZykge1xuICByZXR1cm4ge1xuICAgIHN0YXRzOiBwcmlvcml0eVF1ZXVlLmdldFF1ZXVlU3RhdHModXNlcklkKSxcbiAgICBwb3NpdGlvbjogdXNlcklkID8gcHJpb3JpdHlRdWV1ZS5nZXRVc2VyUG9zaXRpb24odXNlcklkKSA6IG51bGwsXG4gICAgc3lzdGVtTG9hZDogcHJpb3JpdHlRdWV1ZS5nZXRTeXN0ZW1Mb2FkKClcbiAgfTtcbn0gIl0sIm5hbWVzIjpbIlByaW9yaXR5UXVldWVTZXJ2aWNlIiwiYWRkVG9RdWV1ZSIsInVzZXJJZCIsInJlcXVlc3RUeXBlIiwic3Vic2NyaXB0aW9uUGxhbiIsInBheWxvYWQiLCJwcm9jZXNzaW5nRnVuY3Rpb24iLCJwcmlvcml0eSIsImdldFByaW9yaXR5RnJvbVBsYW4iLCJpdGVtSWQiLCJEYXRlIiwibm93IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJxdWV1ZUl0ZW0iLCJpZCIsInZhbHVlIiwicmVzdWx0IiwiZXJyb3IiLCJwcm9jZXNzaW5nIiwiZGVsZXRlIiwicHJvY2Vzc05leHQiLCJ0aW1lc3RhbXAiLCJpbnNlcnRCeVByaW9yaXR5IiwiY29uc29sZSIsImxvZyIsImdldFF1ZXVlU3RhdHMiLCJ1c2VyUG9zaXRpb24iLCJnZXRVc2VyUG9zaXRpb24iLCJwcmlvcml0eUJyZWFrZG93biIsInF1ZXVlIiwicmVkdWNlIiwiYWNjIiwiaXRlbSIsImhpZ2giLCJtZWRpdW0iLCJsb3ciLCJlc3RpbWF0ZWRXYWl0VGltZSIsImF2ZXJhZ2VQcm9jZXNzaW5nVGltZSIsImxlbmd0aCIsInRvdGFsSXRlbXMiLCJpbmRleCIsImZpbmRJbmRleCIsImN1cnJlbnRseVByb2Nlc3NpbmciLCJzaXplIiwibWF4Q29uY3VycmVudCIsIm5leHRJdGVtIiwic2hpZnQiLCJzZXQiLCJzZXRUaW1lb3V0IiwiaW5zZXJ0SW5kZXgiLCJpIiwiZXhpc3RpbmdJdGVtIiwic3BsaWNlIiwicGxhbiIsInJlbW92ZUZyb21RdWV1ZSIsImluaXRpYWxMZW5ndGgiLCJmaWx0ZXIiLCJ1cGRhdGVBdmVyYWdlUHJvY2Vzc2luZ1RpbWUiLCJkdXJhdGlvbiIsImdldFN5c3RlbUxvYWQiLCJjYXBhY2l0eSIsImxvYWRQZXJjZW50YWdlIiwicXVldWVMZW5ndGgiLCJNYXAiLCJwcmlvcml0eVF1ZXVlIiwicXVldWVSZXF1ZXN0IiwiZ2V0UXVldWVJbmZvIiwic3RhdHMiLCJwb3NpdGlvbiIsInN5c3RlbUxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/queue.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/subscription.ts":
/*!**************************************!*\
  !*** ./src/services/subscription.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignUserSubscription: () => (/* binding */ assignUserSubscription),\n/* harmony export */   checkUsageLimits: () => (/* binding */ checkUsageLimits),\n/* harmony export */   getPlanPricing: () => (/* binding */ getPlanPricing),\n/* harmony export */   getSubscriptionPlan: () => (/* binding */ getSubscriptionPlan),\n/* harmony export */   getSubscriptionPlans: () => (/* binding */ getSubscriptionPlans),\n/* harmony export */   getUserSubscription: () => (/* binding */ getUserSubscription),\n/* harmony export */   hasFeatureAccess: () => (/* binding */ hasFeatureAccess),\n/* harmony export */   incrementUsage: () => (/* binding */ incrementUsage),\n/* harmony export */   refreshSavedNotesCount: () => (/* binding */ refreshSavedNotesCount),\n/* harmony export */   updateSavedNotesCount: () => (/* binding */ updateSavedNotesCount)\n/* harmony export */ });\n/* harmony import */ var _supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/supabase-js */ \"(rsc)/./node_modules/@supabase/supabase-js/dist/module/index.js\");\n/**\n * Subscription Service\n * \n * Handles subscription plans, usage tracking, and feature access control\n */ \n// Initialize Supabase client\nconst supabaseUrl = \"https://xhljckmlzdshxibnqsbj.supabase.co\";\nconst supabaseAnonKey = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhobGpja21semRzaHhpYm5xc2JqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDc4NDIwNzIsImV4cCI6MjA2MzQxODA3Mn0.UuU3QBxwY3-DsSpXB-UiKarjgZWiFAFIzFbgUqacmIA\";\n/**\n * Get all available subscription plans\n */ async function getSubscriptionPlans() {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"is_active\", true).order(\"price_monthly\", {\n        ascending: true\n    });\n    if (error) {\n        console.error(\"[Subscription] Error fetching plans:\", error);\n        throw new Error(\"Failed to fetch subscription plans\");\n    }\n    return data || [];\n}\n/**\n * Get user's current subscription with plan details\n */ async function getUserSubscription(userId, token) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Use direct table query instead of RPC function\n        const { data: userSub, error } = await supabase.from(\"user_subscriptions\").select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        if (error) {\n            console.error(\"[Subscription] Error fetching user subscription:\", error);\n            return null;\n        }\n        if (!userSub || !userSub.subscription_plans) {\n            return null;\n        }\n        const planData = userSub.subscription_plans;\n        return {\n            subscription_id: userSub.id,\n            plan_id: userSub.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: userSub.billing_cycle,\n            status: userSub.status,\n            current_period_end: userSub.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in getUserSubscription:\", error);\n        return null;\n    }\n}\n/**\n * Get a specific subscription plan by ID\n */ async function getSubscriptionPlan(planId) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey);\n    const { data, error } = await supabase.from(\"subscription_plans\").select(\"*\").eq(\"id\", planId).eq(\"is_active\", true).single();\n    if (error) {\n        console.error(\"[Subscription] Error fetching plan:\", error);\n        return null;\n    }\n    return data;\n}\n/**\n * Check if user can generate notes based on their plan and usage\n */ async function checkUsageLimits(userId, token, noteType = \"text\") {\n    try {\n        // Use direct table queries instead of RPC functions to avoid issues\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Checking usage limits for user:\", userId);\n        // Get user's subscription directly\n        const { data: userSub, error: subError } = await supabase.from(\"user_subscriptions\").select(`\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).eq(\"user_id\", userId).eq(\"status\", \"active\").single();\n        // Get current month usage directly\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { data: usage, error: usageError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        // Default free plan limits\n        const freePlanLimits = {\n            notes_per_month: 2,\n            max_saved_notes: 3,\n            max_text_length: 5000\n        };\n        const currentUsage = usage || {\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            month_year: currentMonth\n        };\n        // If usage record doesn't exist, create it\n        if (!usage) {\n            console.log(\"[Subscription] Creating usage record for current month:\", currentMonth);\n            const { error: createUsageError } = await supabase.from(\"user_usage\").insert({\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 0,\n                video_notes_count: 0,\n                file_notes_count: 0,\n                text_notes_count: 0,\n                total_saved_notes: 0,\n                updated_at: new Date().toISOString()\n            });\n            if (createUsageError) {\n                console.error(\"[Subscription] Warning: Could not create usage record:\", createUsageError);\n            }\n        }\n        // If no subscription found or error, try to create a free subscription\n        if (!userSub || subError) {\n            console.log(\"[Subscription] No active subscription found, attempting to create free subscription\");\n            if (subError) {\n                console.error(\"[Subscription] Subscription query error:\", subError);\n            }\n            // Try to create a free subscription for the user\n            const { error: createSubError } = await supabase.from(\"user_subscriptions\").insert({\n                user_id: userId,\n                plan_id: \"free\",\n                billing_cycle: \"monthly\",\n                status: \"active\",\n                current_period_start: new Date().toISOString(),\n                current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n                updated_at: new Date().toISOString()\n            }).select();\n            if (createSubError) {\n                console.error(\"[Subscription] Could not create free subscription:\", createSubError);\n            } else {\n                console.log(\"[Subscription] Created free subscription for user\");\n            }\n            // Return free plan limits regardless of whether we could create the subscription\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: !canGenerate ? `Monthly limit reached (${freePlanLimits.notes_per_month} notes per month)` : !canSave ? `Storage limit reached (${freePlanLimits.max_saved_notes} saved notes maximum)` : undefined,\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        const subscription = userSub;\n        const planData = subscription.subscription_plans;\n        if (!planData) {\n            console.error(\"[Subscription] Plan data not found for subscription:\", subscription);\n            // Fallback to free plan\n            const canGenerate = currentUsage.notes_generated < freePlanLimits.notes_per_month;\n            const canSave = currentUsage.total_saved_notes < freePlanLimits.max_saved_notes;\n            return {\n                canGenerate,\n                canSave,\n                reason: \"Plan data not found - using free plan limits\",\n                usage: currentUsage,\n                limits: freePlanLimits\n            };\n        }\n        console.log(\"[Subscription] Found subscription:\", {\n            planId: subscription.plan_id,\n            planLimits: planData.limits,\n            currentUsage: currentUsage\n        });\n        // Check monthly generation limit (handle unlimited case)\n        const monthlyLimit = planData.limits.notes_per_month;\n        const canGenerate = monthlyLimit === -1 || currentUsage.notes_generated < monthlyLimit;\n        // Check saved notes limit\n        const canSave = currentUsage.total_saved_notes < planData.limits.max_saved_notes;\n        let reason;\n        if (!canGenerate && monthlyLimit !== -1) {\n            reason = `Monthly limit reached (${monthlyLimit} notes per month)`;\n        } else if (!canSave) {\n            reason = `Storage limit reached (${planData.limits.max_saved_notes} saved notes maximum)`;\n        }\n        return {\n            canGenerate,\n            canSave,\n            reason,\n            usage: currentUsage,\n            limits: planData.limits\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error checking usage limits:\", error);\n        // Return restrictive fallback\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const fallbackUsage = {\n            notes_generated: 999,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 999,\n            month_year: currentMonth\n        };\n        return {\n            canGenerate: false,\n            canSave: false,\n            reason: \"Error checking subscription limits. Please try again.\",\n            usage: fallbackUsage,\n            limits: {\n                notes_per_month: 2,\n                max_saved_notes: 3,\n                max_text_length: 5000\n            }\n        };\n    }\n}\n/**\n * Increment user's usage count after successful note generation\n */ async function incrementUsage(userId, token, noteType = \"text\") {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Incrementing usage for user:\", userId, \"type:\", noteType);\n        // Get current usage\n        const { data: currentUsage, error: fetchError } = await supabase.from(\"user_usage\").select(\"*\").eq(\"user_id\", userId).eq(\"month_year\", currentMonth).single();\n        if (fetchError && fetchError.code !== \"PGRST116\") {\n            console.error(\"[Subscription] Error fetching current usage:\", fetchError);\n            return false;\n        }\n        // Prepare update data\n        const updateData = {\n            notes_generated: (currentUsage?.notes_generated || 0) + 1,\n            updated_at: new Date().toISOString()\n        };\n        // Increment specific note type counter\n        if (noteType === \"video\") {\n            updateData.video_notes_count = (currentUsage?.video_notes_count || 0) + 1;\n        } else if (noteType === \"file\") {\n            updateData.file_notes_count = (currentUsage?.file_notes_count || 0) + 1;\n        } else if (noteType === \"text\") {\n            updateData.text_notes_count = (currentUsage?.text_notes_count || 0) + 1;\n        }\n        // Update or insert usage record\n        if (currentUsage) {\n            const { error: updateError } = await supabase.from(\"user_usage\").update(updateData).eq(\"user_id\", userId).eq(\"month_year\", currentMonth);\n            if (updateError) {\n                console.error(\"[Subscription] Error updating usage:\", updateError);\n                return false;\n            }\n        } else {\n            // Create new usage record\n            const insertData = {\n                user_id: userId,\n                month_year: currentMonth,\n                notes_generated: 1,\n                video_notes_count: noteType === \"video\" ? 1 : 0,\n                file_notes_count: noteType === \"file\" ? 1 : 0,\n                text_notes_count: noteType === \"text\" ? 1 : 0,\n                total_saved_notes: 0,\n                created_at: new Date().toISOString(),\n                updated_at: new Date().toISOString()\n            };\n            const { error: insertError } = await supabase.from(\"user_usage\").insert(insertData);\n            if (insertError) {\n                console.error(\"[Subscription] Error creating usage record:\", insertError);\n                return false;\n            }\n        }\n        console.log(\"[Subscription] Successfully incremented usage\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error incrementing usage:\", error);\n        return false;\n    }\n}\n/**\n * Update saved notes count (used when notes are saved or deleted)\n */ async function updateSavedNotesCount(userId, token, count) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        console.log(\"[Subscription] Updating saved notes count for user:\", userId, \"count:\", count);\n        // Upsert the saved notes count\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: Math.max(0, count),\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully updated saved notes count\");\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error updating saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Refresh saved notes count by counting all notes from all tables\n */ async function refreshSavedNotesCount(userId, token) {\n    try {\n        const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n            global: {\n                headers: {\n                    Authorization: `Bearer ${token}`\n                }\n            }\n        });\n        console.log(\"[Subscription] Refreshing saved notes count for user:\", userId);\n        // Count notes from all tables\n        const [videoResult, fileResult, textResult] = await Promise.all([\n            supabase.from(\"video_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"file_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId),\n            supabase.from(\"text_notes\").select(\"id\", {\n                count: \"exact\",\n                head: true\n            }).eq(\"user_id\", userId)\n        ]);\n        const videoCount = videoResult.count || 0;\n        const fileCount = fileResult.count || 0;\n        const textCount = textResult.count || 0;\n        const totalCount = videoCount + fileCount + textCount;\n        console.log(\"[Subscription] Note counts:\", {\n            video: videoCount,\n            file: fileCount,\n            text: textCount,\n            total: totalCount\n        });\n        // Update the usage record with the actual count\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            total_saved_notes: totalCount,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\"\n        });\n        if (error) {\n            console.error(\"[Subscription] Error updating saved notes count:\", error);\n            return false;\n        }\n        console.log(\"[Subscription] Successfully refreshed saved notes count to:\", totalCount);\n        return true;\n    } catch (error) {\n        console.error(\"[Subscription] Error refreshing saved notes count:\", error);\n        return false;\n    }\n}\n/**\n * Get plan pricing with discount calculation\n */ function getPlanPricing(plan) {\n    const monthlyPrice = plan.price_monthly;\n    const yearlyPrice = plan.price_yearly;\n    const yearlyMonthlyEquivalent = yearlyPrice / 12;\n    const discountPercentage = monthlyPrice > 0 ? Math.round((1 - yearlyMonthlyEquivalent / monthlyPrice) * 100) : 0;\n    const yearlySavings = monthlyPrice * 12 - yearlyPrice;\n    return {\n        monthly: monthlyPrice,\n        yearly: yearlyPrice,\n        yearlyMonthlyEquivalent,\n        discountPercentage,\n        yearlySavings,\n        currency: plan.currency\n    };\n}\n/**\n * Check if user has access to a specific feature\n */ async function hasFeatureAccess(userId, token, feature) {\n    try {\n        const subscription = await getUserSubscription(userId, token);\n        if (!subscription) {\n            // Default free plan features\n            const freeFeatures = {\n                notes_generation: true,\n                quizzes: false,\n                youtube_support: true,\n                ppt_support: false,\n                export: false,\n                copy_paste: true,\n                upload_video: false,\n                priority_generation: false\n            };\n            return freeFeatures[feature] || false;\n        }\n        return subscription.features[feature] || false;\n    } catch (error) {\n        console.error(\"[Subscription] Error checking feature access:\", error);\n        return false; // Default to no access on error\n    }\n}\n/**\n * Assign subscription to user after successful payment\n */ async function assignUserSubscription(userId, token, planId, billingCycle, paymentData) {\n    const supabase = (0,_supabase_supabase_js__WEBPACK_IMPORTED_MODULE_0__.createClient)(supabaseUrl, supabaseAnonKey, {\n        global: {\n            headers: {\n                Authorization: `Bearer ${token}`\n            }\n        }\n    });\n    try {\n        // Calculate period dates\n        const currentPeriodStart = new Date();\n        const currentPeriodEnd = new Date();\n        if (billingCycle === \"yearly\") {\n            currentPeriodEnd.setFullYear(currentPeriodEnd.getFullYear() + 1);\n        } else {\n            currentPeriodEnd.setMonth(currentPeriodEnd.getMonth() + 1);\n        }\n        // Prepare subscription data\n        const subscriptionData = {\n            user_id: userId,\n            plan_id: planId,\n            billing_cycle: billingCycle,\n            status: \"active\",\n            current_period_start: currentPeriodStart.toISOString(),\n            current_period_end: currentPeriodEnd.toISOString(),\n            cancel_at_period_end: false,\n            stripe_subscription_id: paymentData?.stripeSubscriptionId || null,\n            stripe_customer_id: paymentData?.stripeCustomerId || null,\n            updated_at: new Date().toISOString()\n        };\n        // Upsert subscription (update if exists, insert if new)\n        const { data: subscription, error: subscriptionError } = await supabase.from(\"user_subscriptions\").upsert(subscriptionData, {\n            onConflict: \"user_id\"\n        }).select(`\n        id,\n        plan_id,\n        billing_cycle,\n        status,\n        current_period_end,\n        subscription_plans (\n          name,\n          display_name,\n          features,\n          limits,\n          price_monthly,\n          price_yearly\n        )\n      `).single();\n        if (subscriptionError) {\n            console.error(\"[Subscription] Error assigning subscription:\", subscriptionError);\n            throw new Error(\"Failed to assign subscription\");\n        }\n        if (!subscription || !subscription.subscription_plans) {\n            throw new Error(\"Failed to retrieve subscription details\");\n        }\n        // Initialize usage tracking for current month\n        const currentMonth = new Date().toISOString().slice(0, 7);\n        const { error: usageError } = await supabase.from(\"user_usage\").upsert({\n            user_id: userId,\n            month_year: currentMonth,\n            notes_generated: 0,\n            video_notes_count: 0,\n            file_notes_count: 0,\n            text_notes_count: 0,\n            total_saved_notes: 0,\n            updated_at: new Date().toISOString()\n        }, {\n            onConflict: \"user_id,month_year\",\n            ignoreDuplicates: true\n        });\n        if (usageError) {\n            console.error(\"[Subscription] Warning: Failed to initialize usage tracking:\", usageError);\n        // Don't throw error here as subscription assignment was successful\n        }\n        const planData = subscription.subscription_plans;\n        return {\n            subscription_id: subscription.id,\n            plan_id: subscription.plan_id,\n            plan_name: planData.name,\n            plan_display_name: planData.display_name,\n            billing_cycle: subscription.billing_cycle,\n            status: subscription.status,\n            current_period_end: subscription.current_period_end,\n            features: planData.features,\n            limits: planData.limits,\n            price_monthly: planData.price_monthly,\n            price_yearly: planData.price_yearly\n        };\n    } catch (error) {\n        console.error(\"[Subscription] Error in assignUserSubscription:\", error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YXpDLGFBQWE7WUFDekNDLFFBQVF3QyxhQUFheEMsTUFBTTtZQUMzQkMsb0JBQW9CdUMsYUFBYXZDLGtCQUFrQjtZQUNuREMsVUFBVVgsU0FBU1csUUFBUTtZQUMzQkMsUUFBUVosU0FBU1ksTUFBTTtZQUN2QkMsZUFBZWIsU0FBU2EsYUFBYTtZQUNyQ0MsY0FBY2QsU0FBU2MsWUFBWTtRQUNyQztJQUNGLEVBQUUsT0FBTy9CLE9BQU87UUFDZE0sUUFBUU4sS0FBSyxDQUFDLG1EQUFtREE7UUFDakUsTUFBTUE7SUFDUjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL3NlcnZpY2VzL3N1YnNjcmlwdGlvbi50cz8wNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU3Vic2NyaXB0aW9uIFNlcnZpY2VcbiAqIFxuICogSGFuZGxlcyBzdWJzY3JpcHRpb24gcGxhbnMsIHVzYWdlIHRyYWNraW5nLCBhbmQgZmVhdHVyZSBhY2Nlc3MgY29udHJvbFxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcyc7XG5cbi8vIEluaXRpYWxpemUgU3VwYWJhc2UgY2xpZW50XG5jb25zdCBzdXBhYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NVUEFCQVNFX1VSTCE7XG5jb25zdCBzdXBhYmFzZUFub25LZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVVBBQkFTRV9BTk9OX0tFWSE7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NyaXB0aW9uUGxhbiB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIHByaWNlX21vbnRobHk6IG51bWJlcjtcbiAgcHJpY2VfeWVhcmx5OiBudW1iZXI7XG4gIGN1cnJlbmN5OiBzdHJpbmc7XG4gIGZlYXR1cmVzOiB7XG4gICAgbm90ZXNfZ2VuZXJhdGlvbjogYm9vbGVhbjtcbiAgICBxdWl6emVzOiBib29sZWFuO1xuICAgIHlvdXR1YmVfc3VwcG9ydDogYm9vbGVhbjtcbiAgICBwcHRfc3VwcG9ydDogYm9vbGVhbjtcbiAgICBleHBvcnQ6IGJvb2xlYW47XG4gICAgY29weV9wYXN0ZTogYm9vbGVhbjtcbiAgICB1cGxvYWRfdmlkZW8/OiBib29sZWFuO1xuICAgIHByaW9yaXR5X2dlbmVyYXRpb24/OiBib29sZWFuO1xuICB9O1xuICBsaW1pdHM6IHtcbiAgICBub3Rlc19wZXJfbW9udGg6IG51bWJlcjsgLy8gLTEgbWVhbnMgdW5saW1pdGVkXG4gICAgbWF4X3NhdmVkX25vdGVzOiBudW1iZXI7XG4gICAgbWF4X3RleHRfbGVuZ3RoOiBudW1iZXI7XG4gIH07XG4gIGlzX2FjdGl2ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VyU3Vic2NyaXB0aW9uIHtcbiAgc3Vic2NyaXB0aW9uX2lkOiBzdHJpbmc7XG4gIHBsYW5faWQ6IHN0cmluZztcbiAgcGxhbl9uYW1lOiBzdHJpbmc7XG4gIHBsYW5fZGlzcGxheV9uYW1lOiBzdHJpbmc7XG4gIGJpbGxpbmdfY3ljbGU6ICdtb250aGx5JyB8ICd5ZWFybHknO1xuICBzdGF0dXM6ICdhY3RpdmUnIHwgJ2NhbmNlbGxlZCcgfCAnZXhwaXJlZCcgfCAndHJpYWwnO1xuICBjdXJyZW50X3BlcmlvZF9lbmQ6IHN0cmluZztcbiAgZmVhdHVyZXM6IFN1YnNjcmlwdGlvblBsYW5bJ2ZlYXR1cmVzJ107XG4gIGxpbWl0czogU3Vic2NyaXB0aW9uUGxhblsnbGltaXRzJ107XG4gIHByaWNlX21vbnRobHk6IG51bWJlcjtcbiAgcHJpY2VfeWVhcmx5OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlclVzYWdlIHtcbiAgbm90ZXNfZ2VuZXJhdGVkOiBudW1iZXI7XG4gIHZpZGVvX25vdGVzX2NvdW50OiBudW1iZXI7XG4gIGZpbGVfbm90ZXNfY291bnQ6IG51bWJlcjtcbiAgdGV4dF9ub3Rlc19jb3VudDogbnVtYmVyO1xuICB0b3RhbF9zYXZlZF9ub3RlczogbnVtYmVyO1xuICBtb250aF95ZWFyOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNhZ2VDaGVjayB7XG4gIGNhbkdlbmVyYXRlOiBib29sZWFuO1xuICBjYW5TYXZlOiBib29sZWFuO1xuICByZWFzb24/OiBzdHJpbmc7XG4gIHVzYWdlOiBVc2VyVXNhZ2U7XG4gIGxpbWl0czogU3Vic2NyaXB0aW9uUGxhblsnbGltaXRzJ107XG59XG5cbi8qKlxuICogR2V0IGFsbCBhdmFpbGFibGUgc3Vic2NyaXB0aW9uIHBsYW5zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25QbGFucygpOiBQcm9taXNlPFN1YnNjcmlwdGlvblBsYW5bXT4ge1xuICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5KTtcbiAgXG4gIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgLmZyb20oJ3N1YnNjcmlwdGlvbl9wbGFucycpXG4gICAgLnNlbGVjdCgnKicpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5vcmRlcigncHJpY2VfbW9udGhseScsIHsgYXNjZW5kaW5nOiB0cnVlIH0pO1xuICAgIFxuICBpZiAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBmZXRjaGluZyBwbGFuczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggc3Vic2NyaXB0aW9uIHBsYW5zJyk7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhIHx8IFtdO1xufVxuXG4vKipcbiAqIEdldCB1c2VyJ3MgY3VycmVudCBzdWJzY3JpcHRpb24gd2l0aCBwbGFuIGRldGFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFVzZXJTdWJzY3JpcHRpb24odXNlcklkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJTdWJzY3JpcHRpb24gfCBudWxsPiB7XG4gIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICBnbG9iYWw6IHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBVc2UgZGlyZWN0IHRhYmxlIHF1ZXJ5IGluc3RlYWQgb2YgUlBDIGZ1bmN0aW9uXG4gICAgY29uc3QgeyBkYXRhOiB1c2VyU3ViLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIGlkLFxuICAgICAgICBwbGFuX2lkLFxuICAgICAgICBiaWxsaW5nX2N5Y2xlLFxuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgICAgc3Vic2NyaXB0aW9uX3BsYW5zIChcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRpc3BsYXlfbmFtZSxcbiAgICAgICAgICBmZWF0dXJlcyxcbiAgICAgICAgICBsaW1pdHMsXG4gICAgICAgICAgcHJpY2VfbW9udGhseSxcbiAgICAgICAgICBwcmljZV95ZWFybHlcbiAgICAgICAgKVxuICAgICAgYClcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnc3RhdHVzJywgJ2FjdGl2ZScpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGZldGNoaW5nIHVzZXIgc3Vic2NyaXB0aW9uOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdXNlclN1YiB8fCAhdXNlclN1Yi5zdWJzY3JpcHRpb25fcGxhbnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYW5EYXRhID0gdXNlclN1Yi5zdWJzY3JpcHRpb25fcGxhbnMgYXMgYW55O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBzdWJzY3JpcHRpb25faWQ6IHVzZXJTdWIuaWQsXG4gICAgICBwbGFuX2lkOiB1c2VyU3ViLnBsYW5faWQsXG4gICAgICBwbGFuX25hbWU6IHBsYW5EYXRhLm5hbWUsXG4gICAgICBwbGFuX2Rpc3BsYXlfbmFtZTogcGxhbkRhdGEuZGlzcGxheV9uYW1lLFxuICAgICAgYmlsbGluZ19jeWNsZTogdXNlclN1Yi5iaWxsaW5nX2N5Y2xlLFxuICAgICAgc3RhdHVzOiB1c2VyU3ViLnN0YXR1cyxcbiAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogdXNlclN1Yi5jdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICBmZWF0dXJlczogcGxhbkRhdGEuZmVhdHVyZXMsXG4gICAgICBsaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIHByaWNlX21vbnRobHk6IHBsYW5EYXRhLnByaWNlX21vbnRobHksXG4gICAgICBwcmljZV95ZWFybHk6IHBsYW5EYXRhLnByaWNlX3llYXJseVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgaW4gZ2V0VXNlclN1YnNjcmlwdGlvbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgYSBzcGVjaWZpYyBzdWJzY3JpcHRpb24gcGxhbiBieSBJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3Vic2NyaXB0aW9uUGxhbihwbGFuSWQ6IHN0cmluZyk6IFByb21pc2U8U3Vic2NyaXB0aW9uUGxhbiB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSk7XG4gIFxuICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgIC5mcm9tKCdzdWJzY3JpcHRpb25fcGxhbnMnKVxuICAgIC5zZWxlY3QoJyonKVxuICAgIC5lcSgnaWQnLCBwbGFuSWQpXG4gICAgLmVxKCdpc19hY3RpdmUnLCB0cnVlKVxuICAgIC5zaW5nbGUoKTtcbiAgICBcbiAgaWYgKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgcGxhbjonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgY2FuIGdlbmVyYXRlIG5vdGVzIGJhc2VkIG9uIHRoZWlyIHBsYW4gYW5kIHVzYWdlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjaGVja1VzYWdlTGltaXRzKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBub3RlVHlwZTogJ3ZpZGVvJyB8ICdmaWxlJyB8ICd0ZXh0JyA9ICd0ZXh0J1xuKTogUHJvbWlzZTxVc2FnZUNoZWNrPiB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGRpcmVjdCB0YWJsZSBxdWVyaWVzIGluc3RlYWQgb2YgUlBDIGZ1bmN0aW9ucyB0byBhdm9pZCBpc3N1ZXNcbiAgICBjb25zdCBzdXBhYmFzZSA9IGNyZWF0ZUNsaWVudChzdXBhYmFzZVVybCwgc3VwYWJhc2VBbm9uS2V5LCB7XG4gICAgICBnbG9iYWw6IHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0b2tlbn1gXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBDaGVja2luZyB1c2FnZSBsaW1pdHMgZm9yIHVzZXI6JywgdXNlcklkKVxuXG4gICAgLy8gR2V0IHVzZXIncyBzdWJzY3JpcHRpb24gZGlyZWN0bHlcbiAgICBjb25zdCB7IGRhdGE6IHVzZXJTdWIsIGVycm9yOiBzdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnNlbGVjdChgXG4gICAgICAgIHBsYW5faWQsXG4gICAgICAgIGJpbGxpbmdfY3ljbGUsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgY3VycmVudF9wZXJpb2RfZW5kLFxuICAgICAgICBzdWJzY3JpcHRpb25fcGxhbnMgKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGlzcGxheV9uYW1lLFxuICAgICAgICAgIGZlYXR1cmVzLFxuICAgICAgICAgIGxpbWl0cyxcbiAgICAgICAgICBwcmljZV9tb250aGx5LFxuICAgICAgICAgIHByaWNlX3llYXJseVxuICAgICAgICApXG4gICAgICBgKVxuICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKVxuICAgICAgLmVxKCdzdGF0dXMnLCAnYWN0aXZlJylcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIC8vIEdldCBjdXJyZW50IG1vbnRoIHVzYWdlIGRpcmVjdGx5XG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZGF0YTogdXNhZ2UsIGVycm9yOiB1c2FnZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpXG4gICAgICAuZXEoJ21vbnRoX3llYXInLCBjdXJyZW50TW9udGgpXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICAvLyBEZWZhdWx0IGZyZWUgcGxhbiBsaW1pdHNcbiAgICBjb25zdCBmcmVlUGxhbkxpbWl0cyA9IHsgXG4gICAgICBub3Rlc19wZXJfbW9udGg6IDIsIFxuICAgICAgbWF4X3NhdmVkX25vdGVzOiAzLCBcbiAgICAgIG1heF90ZXh0X2xlbmd0aDogNTAwMCBcbiAgICB9O1xuXG4gICAgY29uc3QgY3VycmVudFVzYWdlID0gdXNhZ2UgfHwge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICBmaWxlX25vdGVzX2NvdW50OiAwLFxuICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoXG4gICAgfTtcblxuICAgIC8vIElmIHVzYWdlIHJlY29yZCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXRcbiAgICBpZiAoIXVzYWdlKSB7XG4gICAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gQ3JlYXRpbmcgdXNhZ2UgcmVjb3JkIGZvciBjdXJyZW50IG1vbnRoOicsIGN1cnJlbnRNb250aClcbiAgICAgIGNvbnN0IHsgZXJyb3I6IGNyZWF0ZVVzYWdlRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgICBub3Rlc19nZW5lcmF0ZWQ6IDAsXG4gICAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IDAsXG4gICAgICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgICB0ZXh0X25vdGVzX2NvdW50OiAwLFxuICAgICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiAwLFxuICAgICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKGNyZWF0ZVVzYWdlRXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gV2FybmluZzogQ291bGQgbm90IGNyZWF0ZSB1c2FnZSByZWNvcmQ6JywgY3JlYXRlVXNhZ2VFcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gc3Vic2NyaXB0aW9uIGZvdW5kIG9yIGVycm9yLCB0cnkgdG8gY3JlYXRlIGEgZnJlZSBzdWJzY3JpcHRpb25cbiAgICBpZiAoIXVzZXJTdWIgfHwgc3ViRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBObyBhY3RpdmUgc3Vic2NyaXB0aW9uIGZvdW5kLCBhdHRlbXB0aW5nIHRvIGNyZWF0ZSBmcmVlIHN1YnNjcmlwdGlvbicpXG4gICAgICBcbiAgICAgIGlmIChzdWJFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBTdWJzY3JpcHRpb24gcXVlcnkgZXJyb3I6Jywgc3ViRXJyb3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgZnJlZSBzdWJzY3JpcHRpb24gZm9yIHRoZSB1c2VyXG4gICAgICBjb25zdCB7IGVycm9yOiBjcmVhdGVTdWJFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfc3Vic2NyaXB0aW9ucycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBwbGFuX2lkOiAnZnJlZScsXG4gICAgICAgICAgYmlsbGluZ19jeWNsZTogJ21vbnRobHknLFxuICAgICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgICAgY3VycmVudF9wZXJpb2Rfc3RhcnQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IG5ldyBEYXRlKERhdGUubm93KCkgKyAzMCAqIDI0ICogNjAgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKTtcblxuICAgICAgaWYgKGNyZWF0ZVN1YkVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIENvdWxkIG5vdCBjcmVhdGUgZnJlZSBzdWJzY3JpcHRpb246JywgY3JlYXRlU3ViRXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIENyZWF0ZWQgZnJlZSBzdWJzY3JpcHRpb24gZm9yIHVzZXInKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIGZyZWUgcGxhbiBsaW1pdHMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlIGNvdWxkIGNyZWF0ZSB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICBjb25zdCBjYW5HZW5lcmF0ZSA9IGN1cnJlbnRVc2FnZS5ub3Rlc19nZW5lcmF0ZWQgPCBmcmVlUGxhbkxpbWl0cy5ub3Rlc19wZXJfbW9udGg7XG4gICAgICBjb25zdCBjYW5TYXZlID0gY3VycmVudFVzYWdlLnRvdGFsX3NhdmVkX25vdGVzIDwgZnJlZVBsYW5MaW1pdHMubWF4X3NhdmVkX25vdGVzO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjYW5HZW5lcmF0ZSxcbiAgICAgICAgY2FuU2F2ZSxcbiAgICAgICAgcmVhc29uOiAhY2FuR2VuZXJhdGUgPyBgTW9udGhseSBsaW1pdCByZWFjaGVkICgke2ZyZWVQbGFuTGltaXRzLm5vdGVzX3Blcl9tb250aH0gbm90ZXMgcGVyIG1vbnRoKWAgOlxuICAgICAgICAgICAgICAgICFjYW5TYXZlID8gYFN0b3JhZ2UgbGltaXQgcmVhY2hlZCAoJHtmcmVlUGxhbkxpbWl0cy5tYXhfc2F2ZWRfbm90ZXN9IHNhdmVkIG5vdGVzIG1heGltdW0pYCA6IHVuZGVmaW5lZCxcbiAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgbGltaXRzOiBmcmVlUGxhbkxpbWl0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB1c2VyU3ViO1xuICAgIGNvbnN0IHBsYW5EYXRhID0gc3Vic2NyaXB0aW9uLnN1YnNjcmlwdGlvbl9wbGFucyBhcyBhbnk7XG4gICAgXG4gICAgaWYgKCFwbGFuRGF0YSkge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gUGxhbiBkYXRhIG5vdCBmb3VuZCBmb3Igc3Vic2NyaXB0aW9uOicsIHN1YnNjcmlwdGlvbik7XG4gICAgICAvLyBGYWxsYmFjayB0byBmcmVlIHBsYW5cbiAgICAgIGNvbnN0IGNhbkdlbmVyYXRlID0gY3VycmVudFVzYWdlLm5vdGVzX2dlbmVyYXRlZCA8IGZyZWVQbGFuTGltaXRzLm5vdGVzX3Blcl9tb250aDtcbiAgICAgIGNvbnN0IGNhblNhdmUgPSBjdXJyZW50VXNhZ2UudG90YWxfc2F2ZWRfbm90ZXMgPCBmcmVlUGxhbkxpbWl0cy5tYXhfc2F2ZWRfbm90ZXM7XG4gICAgICBcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbkdlbmVyYXRlLFxuICAgICAgICBjYW5TYXZlLFxuICAgICAgICByZWFzb246ICdQbGFuIGRhdGEgbm90IGZvdW5kIC0gdXNpbmcgZnJlZSBwbGFuIGxpbWl0cycsXG4gICAgICAgIHVzYWdlOiBjdXJyZW50VXNhZ2UsXG4gICAgICAgIGxpbWl0czogZnJlZVBsYW5MaW1pdHNcbiAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBGb3VuZCBzdWJzY3JpcHRpb246Jywge1xuICAgICAgcGxhbklkOiBzdWJzY3JpcHRpb24ucGxhbl9pZCxcbiAgICAgIHBsYW5MaW1pdHM6IHBsYW5EYXRhLmxpbWl0cyxcbiAgICAgIGN1cnJlbnRVc2FnZTogY3VycmVudFVzYWdlXG4gICAgfSk7XG5cbiAgICAvLyBDaGVjayBtb250aGx5IGdlbmVyYXRpb24gbGltaXQgKGhhbmRsZSB1bmxpbWl0ZWQgY2FzZSlcbiAgICBjb25zdCBtb250aGx5TGltaXQgPSBwbGFuRGF0YS5saW1pdHMubm90ZXNfcGVyX21vbnRoO1xuICAgIGNvbnN0IGNhbkdlbmVyYXRlID0gbW9udGhseUxpbWl0ID09PSAtMSB8fCBjdXJyZW50VXNhZ2Uubm90ZXNfZ2VuZXJhdGVkIDwgbW9udGhseUxpbWl0O1xuICAgIFxuICAgIC8vIENoZWNrIHNhdmVkIG5vdGVzIGxpbWl0XG4gICAgY29uc3QgY2FuU2F2ZSA9IGN1cnJlbnRVc2FnZS50b3RhbF9zYXZlZF9ub3RlcyA8IHBsYW5EYXRhLmxpbWl0cy5tYXhfc2F2ZWRfbm90ZXM7XG4gICAgXG4gICAgbGV0IHJlYXNvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgIGlmICghY2FuR2VuZXJhdGUgJiYgbW9udGhseUxpbWl0ICE9PSAtMSkge1xuICAgICAgcmVhc29uID0gYE1vbnRobHkgbGltaXQgcmVhY2hlZCAoJHttb250aGx5TGltaXR9IG5vdGVzIHBlciBtb250aClgO1xuICAgIH0gZWxzZSBpZiAoIWNhblNhdmUpIHtcbiAgICAgIHJlYXNvbiA9IGBTdG9yYWdlIGxpbWl0IHJlYWNoZWQgKCR7cGxhbkRhdGEubGltaXRzLm1heF9zYXZlZF9ub3Rlc30gc2F2ZWQgbm90ZXMgbWF4aW11bSlgO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgY2FuR2VuZXJhdGUsXG4gICAgICBjYW5TYXZlLFxuICAgICAgcmVhc29uLFxuICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgIGxpbWl0czogcGxhbkRhdGEubGltaXRzXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjaGVja2luZyB1c2FnZSBsaW1pdHM6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFJldHVybiByZXN0cmljdGl2ZSBmYWxsYmFja1xuICAgIGNvbnN0IGN1cnJlbnRNb250aCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zbGljZSgwLCA3KTtcbiAgICBjb25zdCBmYWxsYmFja1VzYWdlID0ge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiA5OTksXG4gICAgICB2aWRlb19ub3Rlc19jb3VudDogMCxcbiAgICAgIGZpbGVfbm90ZXNfY291bnQ6IDAsXG4gICAgICB0ZXh0X25vdGVzX2NvdW50OiAwLFxuICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDk5OSxcbiAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aFxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbkdlbmVyYXRlOiBmYWxzZSxcbiAgICAgIGNhblNhdmU6IGZhbHNlLFxuICAgICAgcmVhc29uOiAnRXJyb3IgY2hlY2tpbmcgc3Vic2NyaXB0aW9uIGxpbWl0cy4gUGxlYXNlIHRyeSBhZ2Fpbi4nLFxuICAgICAgdXNhZ2U6IGZhbGxiYWNrVXNhZ2UsXG4gICAgICBsaW1pdHM6IHsgbm90ZXNfcGVyX21vbnRoOiAyLCBtYXhfc2F2ZWRfbm90ZXM6IDMsIG1heF90ZXh0X2xlbmd0aDogNTAwMCB9XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIEluY3JlbWVudCB1c2VyJ3MgdXNhZ2UgY291bnQgYWZ0ZXIgc3VjY2Vzc2Z1bCBub3RlIGdlbmVyYXRpb25cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluY3JlbWVudFVzYWdlKFxuICB1c2VySWQ6IHN0cmluZywgXG4gIHRva2VuOiBzdHJpbmcsIFxuICBub3RlVHlwZTogJ3ZpZGVvJyB8ICdmaWxlJyB8ICd0ZXh0JyA9ICd0ZXh0J1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIEluY3JlbWVudGluZyB1c2FnZSBmb3IgdXNlcjonLCB1c2VySWQsICd0eXBlOicsIG5vdGVUeXBlKVxuXG4gICAgLy8gR2V0IGN1cnJlbnQgdXNhZ2VcbiAgICBjb25zdCB7IGRhdGE6IGN1cnJlbnRVc2FnZSwgZXJyb3I6IGZldGNoRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAuc2VsZWN0KCcqJylcbiAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgIC5lcSgnbW9udGhfeWVhcicsIGN1cnJlbnRNb250aClcbiAgICAgIC5zaW5nbGUoKTtcblxuICAgIGlmIChmZXRjaEVycm9yICYmIGZldGNoRXJyb3IuY29kZSAhPT0gJ1BHUlNUMTE2Jykge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgZmV0Y2hpbmcgY3VycmVudCB1c2FnZTonLCBmZXRjaEVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHVwZGF0ZSBkYXRhXG4gICAgY29uc3QgdXBkYXRlRGF0YTogYW55ID0ge1xuICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAoY3VycmVudFVzYWdlPy5ub3Rlc19nZW5lcmF0ZWQgfHwgMCkgKyAxLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIC8vIEluY3JlbWVudCBzcGVjaWZpYyBub3RlIHR5cGUgY291bnRlclxuICAgIGlmIChub3RlVHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgdXBkYXRlRGF0YS52aWRlb19ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LnZpZGVvX25vdGVzX2NvdW50IHx8IDApICsgMTtcbiAgICB9IGVsc2UgaWYgKG5vdGVUeXBlID09PSAnZmlsZScpIHtcbiAgICAgIHVwZGF0ZURhdGEuZmlsZV9ub3Rlc19jb3VudCA9IChjdXJyZW50VXNhZ2U/LmZpbGVfbm90ZXNfY291bnQgfHwgMCkgKyAxO1xuICAgIH0gZWxzZSBpZiAobm90ZVR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgdXBkYXRlRGF0YS50ZXh0X25vdGVzX2NvdW50ID0gKGN1cnJlbnRVc2FnZT8udGV4dF9ub3Rlc19jb3VudCB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIG9yIGluc2VydCB1c2FnZSByZWNvcmRcbiAgICBpZiAoY3VycmVudFVzYWdlKSB7XG4gICAgICBjb25zdCB7IGVycm9yOiB1cGRhdGVFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgICAudXBkYXRlKHVwZGF0ZURhdGEpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICAgICAgLmVxKCdtb250aF95ZWFyJywgY3VycmVudE1vbnRoKTtcblxuICAgICAgaWYgKHVwZGF0ZUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHVwZGF0aW5nIHVzYWdlOicsIHVwZGF0ZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgbmV3IHVzYWdlIHJlY29yZFxuICAgICAgY29uc3QgaW5zZXJ0RGF0YSA9IHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIG5vdGVzX2dlbmVyYXRlZDogMSxcbiAgICAgICAgdmlkZW9fbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAndmlkZW8nID8gMSA6IDAsXG4gICAgICAgIGZpbGVfbm90ZXNfY291bnQ6IG5vdGVUeXBlID09PSAnZmlsZScgPyAxIDogMCxcbiAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogbm90ZVR5cGUgPT09ICd0ZXh0JyA/IDEgOiAwLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogMCxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHsgZXJyb3I6IGluc2VydEVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAgIC5pbnNlcnQoaW5zZXJ0RGF0YSk7XG5cbiAgICAgIGlmIChpbnNlcnRFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBjcmVhdGluZyB1c2FnZSByZWNvcmQ6JywgaW5zZXJ0RXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSBpbmNyZW1lbnRlZCB1c2FnZScpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGluY3JlbWVudGluZyB1c2FnZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVXBkYXRlIHNhdmVkIG5vdGVzIGNvdW50ICh1c2VkIHdoZW4gbm90ZXMgYXJlIHNhdmVkIG9yIGRlbGV0ZWQpXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVTYXZlZE5vdGVzQ291bnQoXG4gIHVzZXJJZDogc3RyaW5nLCBcbiAgdG9rZW46IHN0cmluZywgXG4gIGNvdW50OiBudW1iZXJcbik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN1cGFiYXNlID0gY3JlYXRlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUFub25LZXksIHtcbiAgICAgIGdsb2JhbDoge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3Rva2VufWBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnNvbGUubG9nKCdbU3Vic2NyaXB0aW9uXSBVcGRhdGluZyBzYXZlZCBub3RlcyBjb3VudCBmb3IgdXNlcjonLCB1c2VySWQsICdjb3VudDonLCBjb3VudClcblxuICAgIC8vIFVwc2VydCB0aGUgc2F2ZWQgbm90ZXMgY291bnRcbiAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgLmZyb20oJ3VzZXJfdXNhZ2UnKVxuICAgICAgLnVwc2VydCh7XG4gICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgbW9udGhfeWVhcjogY3VycmVudE1vbnRoLFxuICAgICAgICB0b3RhbF9zYXZlZF9ub3RlczogTWF0aC5tYXgoMCwgY291bnQpLCAvLyBFbnN1cmUgbm9uLW5lZ2F0aXZlXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCxtb250aF95ZWFyJ1xuICAgICAgfSk7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIHVwZGF0aW5nIHNhdmVkIG5vdGVzIGNvdW50OicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gU3VjY2Vzc2Z1bGx5IHVwZGF0ZWQgc2F2ZWQgbm90ZXMgY291bnQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogUmVmcmVzaCBzYXZlZCBub3RlcyBjb3VudCBieSBjb3VudGluZyBhbGwgbm90ZXMgZnJvbSBhbGwgdGFibGVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWZyZXNoU2F2ZWROb3Rlc0NvdW50KFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgICAgZ2xvYmFsOiB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gUmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudCBmb3IgdXNlcjonLCB1c2VySWQpO1xuXG4gICAgLy8gQ291bnQgbm90ZXMgZnJvbSBhbGwgdGFibGVzXG4gICAgY29uc3QgW3ZpZGVvUmVzdWx0LCBmaWxlUmVzdWx0LCB0ZXh0UmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd2aWRlb19ub3RlcycpXG4gICAgICAgIC5zZWxlY3QoJ2lkJywgeyBjb3VudDogJ2V4YWN0JywgaGVhZDogdHJ1ZSB9KVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VySWQpLFxuICAgICAgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2ZpbGVfbm90ZXMnKVxuICAgICAgICAuc2VsZWN0KCdpZCcsIHsgY291bnQ6ICdleGFjdCcsIGhlYWQ6IHRydWUgfSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKSxcbiAgICAgIHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd0ZXh0X25vdGVzJylcbiAgICAgICAgLnNlbGVjdCgnaWQnLCB7IGNvdW50OiAnZXhhY3QnLCBoZWFkOiB0cnVlIH0pXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZClcbiAgICBdKTtcblxuICAgIGNvbnN0IHZpZGVvQ291bnQgPSB2aWRlb1Jlc3VsdC5jb3VudCB8fCAwO1xuICAgIGNvbnN0IGZpbGVDb3VudCA9IGZpbGVSZXN1bHQuY291bnQgfHwgMDtcbiAgICBjb25zdCB0ZXh0Q291bnQgPSB0ZXh0UmVzdWx0LmNvdW50IHx8IDA7XG4gICAgY29uc3QgdG90YWxDb3VudCA9IHZpZGVvQ291bnQgKyBmaWxlQ291bnQgKyB0ZXh0Q291bnQ7XG5cbiAgICBjb25zb2xlLmxvZygnW1N1YnNjcmlwdGlvbl0gTm90ZSBjb3VudHM6Jywge1xuICAgICAgdmlkZW86IHZpZGVvQ291bnQsXG4gICAgICBmaWxlOiBmaWxlQ291bnQsXG4gICAgICB0ZXh0OiB0ZXh0Q291bnQsXG4gICAgICB0b3RhbDogdG90YWxDb3VudFxuICAgIH0pO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB1c2FnZSByZWNvcmQgd2l0aCB0aGUgYWN0dWFsIGNvdW50XG4gICAgY29uc3QgY3VycmVudE1vbnRoID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDcpO1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgndXNlcl91c2FnZScpXG4gICAgICAudXBzZXJ0KHtcbiAgICAgICAgdXNlcl9pZDogdXNlcklkLFxuICAgICAgICBtb250aF95ZWFyOiBjdXJyZW50TW9udGgsXG4gICAgICAgIHRvdGFsX3NhdmVkX25vdGVzOiB0b3RhbENvdW50LFxuICAgICAgICB1cGRhdGVkX2F0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgIH0sIHtcbiAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsbW9udGhfeWVhcidcbiAgICAgIH0pO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciB1cGRhdGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1tTdWJzY3JpcHRpb25dIFN1Y2Nlc3NmdWxseSByZWZyZXNoZWQgc2F2ZWQgbm90ZXMgY291bnQgdG86JywgdG90YWxDb3VudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gRXJyb3IgcmVmcmVzaGluZyBzYXZlZCBub3RlcyBjb3VudDonLCBlcnJvcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHBsYW4gcHJpY2luZyB3aXRoIGRpc2NvdW50IGNhbGN1bGF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbGFuUHJpY2luZyhwbGFuOiBTdWJzY3JpcHRpb25QbGFuKSB7XG4gIGNvbnN0IG1vbnRobHlQcmljZSA9IHBsYW4ucHJpY2VfbW9udGhseTtcbiAgY29uc3QgeWVhcmx5UHJpY2UgPSBwbGFuLnByaWNlX3llYXJseTtcbiAgY29uc3QgeWVhcmx5TW9udGhseUVxdWl2YWxlbnQgPSB5ZWFybHlQcmljZSAvIDEyO1xuICBjb25zdCBkaXNjb3VudFBlcmNlbnRhZ2UgPSBtb250aGx5UHJpY2UgPiAwID8gTWF0aC5yb3VuZCgoMSAtIHllYXJseU1vbnRobHlFcXVpdmFsZW50IC8gbW9udGhseVByaWNlKSAqIDEwMCkgOiAwO1xuICBjb25zdCB5ZWFybHlTYXZpbmdzID0gKG1vbnRobHlQcmljZSAqIDEyKSAtIHllYXJseVByaWNlO1xuICBcbiAgcmV0dXJuIHtcbiAgICBtb250aGx5OiBtb250aGx5UHJpY2UsXG4gICAgeWVhcmx5OiB5ZWFybHlQcmljZSxcbiAgICB5ZWFybHlNb250aGx5RXF1aXZhbGVudCxcbiAgICBkaXNjb3VudFBlcmNlbnRhZ2UsXG4gICAgeWVhcmx5U2F2aW5ncyxcbiAgICBjdXJyZW5jeTogcGxhbi5jdXJyZW5jeVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHVzZXIgaGFzIGFjY2VzcyB0byBhIHNwZWNpZmljIGZlYXR1cmVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhc0ZlYXR1cmVBY2Nlc3MoXG4gIHVzZXJJZDogc3RyaW5nLFxuICB0b2tlbjogc3RyaW5nLFxuICBmZWF0dXJlOiBrZXlvZiBTdWJzY3JpcHRpb25QbGFuWydmZWF0dXJlcyddXG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhd2FpdCBnZXRVc2VyU3Vic2NyaXB0aW9uKHVzZXJJZCwgdG9rZW4pO1xuICAgIFxuICAgIGlmICghc3Vic2NyaXB0aW9uKSB7XG4gICAgICAvLyBEZWZhdWx0IGZyZWUgcGxhbiBmZWF0dXJlc1xuICAgICAgY29uc3QgZnJlZUZlYXR1cmVzID0ge1xuICAgICAgICBub3Rlc19nZW5lcmF0aW9uOiB0cnVlLFxuICAgICAgICBxdWl6emVzOiBmYWxzZSxcbiAgICAgICAgeW91dHViZV9zdXBwb3J0OiB0cnVlLFxuICAgICAgICBwcHRfc3VwcG9ydDogZmFsc2UsXG4gICAgICAgIGV4cG9ydDogZmFsc2UsXG4gICAgICAgIGNvcHlfcGFzdGU6IHRydWUsXG4gICAgICAgIHVwbG9hZF92aWRlbzogZmFsc2UsXG4gICAgICAgIHByaW9yaXR5X2dlbmVyYXRpb246IGZhbHNlXG4gICAgICB9O1xuICAgICAgXG4gICAgICByZXR1cm4gZnJlZUZlYXR1cmVzW2ZlYXR1cmVdIHx8IGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uLmZlYXR1cmVzW2ZlYXR1cmVdIHx8IGZhbHNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGNoZWNraW5nIGZlYXR1cmUgYWNjZXNzOicsIGVycm9yKTtcbiAgICByZXR1cm4gZmFsc2U7IC8vIERlZmF1bHQgdG8gbm8gYWNjZXNzIG9uIGVycm9yXG4gIH1cbn1cblxuLyoqXG4gKiBBc3NpZ24gc3Vic2NyaXB0aW9uIHRvIHVzZXIgYWZ0ZXIgc3VjY2Vzc2Z1bCBwYXltZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgdG9rZW46IHN0cmluZyxcbiAgcGxhbklkOiBzdHJpbmcsXG4gIGJpbGxpbmdDeWNsZTogJ21vbnRobHknIHwgJ3llYXJseScsXG4gIHBheW1lbnREYXRhPzoge1xuICAgIHN0cmlwZVN1YnNjcmlwdGlvbklkPzogc3RyaW5nO1xuICAgIHN0cmlwZUN1c3RvbWVySWQ/OiBzdHJpbmc7XG4gIH1cbik6IFByb21pc2U8VXNlclN1YnNjcmlwdGlvbiB8IG51bGw+IHtcbiAgY29uc3Qgc3VwYWJhc2UgPSBjcmVhdGVDbGllbnQoc3VwYWJhc2VVcmwsIHN1cGFiYXNlQW5vbktleSwge1xuICAgIGdsb2JhbDoge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICAvLyBDYWxjdWxhdGUgcGVyaW9kIGRhdGVzXG4gICAgY29uc3QgY3VycmVudFBlcmlvZFN0YXJ0ID0gbmV3IERhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50UGVyaW9kRW5kID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICBpZiAoYmlsbGluZ0N5Y2xlID09PSAneWVhcmx5Jykge1xuICAgICAgY3VycmVudFBlcmlvZEVuZC5zZXRGdWxsWWVhcihjdXJyZW50UGVyaW9kRW5kLmdldEZ1bGxZZWFyKCkgKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFBlcmlvZEVuZC5zZXRNb250aChjdXJyZW50UGVyaW9kRW5kLmdldE1vbnRoKCkgKyAxKTtcbiAgICB9XG5cbiAgICAvLyBQcmVwYXJlIHN1YnNjcmlwdGlvbiBkYXRhXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uRGF0YSA9IHtcbiAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgIHBsYW5faWQ6IHBsYW5JZCxcbiAgICAgIGJpbGxpbmdfY3ljbGU6IGJpbGxpbmdDeWNsZSxcbiAgICAgIHN0YXR1czogJ2FjdGl2ZScgYXMgY29uc3QsXG4gICAgICBjdXJyZW50X3BlcmlvZF9zdGFydDogY3VycmVudFBlcmlvZFN0YXJ0LnRvSVNPU3RyaW5nKCksXG4gICAgICBjdXJyZW50X3BlcmlvZF9lbmQ6IGN1cnJlbnRQZXJpb2RFbmQudG9JU09TdHJpbmcoKSxcbiAgICAgIGNhbmNlbF9hdF9wZXJpb2RfZW5kOiBmYWxzZSxcbiAgICAgIHN0cmlwZV9zdWJzY3JpcHRpb25faWQ6IHBheW1lbnREYXRhPy5zdHJpcGVTdWJzY3JpcHRpb25JZCB8fCBudWxsLFxuICAgICAgc3RyaXBlX2N1c3RvbWVyX2lkOiBwYXltZW50RGF0YT8uc3RyaXBlQ3VzdG9tZXJJZCB8fCBudWxsLFxuICAgICAgdXBkYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgfTtcblxuICAgIC8vIFVwc2VydCBzdWJzY3JpcHRpb24gKHVwZGF0ZSBpZiBleGlzdHMsIGluc2VydCBpZiBuZXcpXG4gICAgY29uc3QgeyBkYXRhOiBzdWJzY3JpcHRpb24sIGVycm9yOiBzdWJzY3JpcHRpb25FcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3N1YnNjcmlwdGlvbnMnKVxuICAgICAgLnVwc2VydChzdWJzY3JpcHRpb25EYXRhLCB7XG4gICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkJ1xuICAgICAgfSlcbiAgICAgIC5zZWxlY3QoYFxuICAgICAgICBpZCxcbiAgICAgICAgcGxhbl9pZCxcbiAgICAgICAgYmlsbGluZ19jeWNsZSxcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBjdXJyZW50X3BlcmlvZF9lbmQsXG4gICAgICAgIHN1YnNjcmlwdGlvbl9wbGFucyAoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkaXNwbGF5X25hbWUsXG4gICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgbGltaXRzLFxuICAgICAgICAgIHByaWNlX21vbnRobHksXG4gICAgICAgICAgcHJpY2VfeWVhcmx5XG4gICAgICAgIClcbiAgICAgIGApXG4gICAgICAuc2luZ2xlKCk7XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJzY3JpcHRpb25dIEVycm9yIGFzc2lnbmluZyBzdWJzY3JpcHRpb246Jywgc3Vic2NyaXB0aW9uRXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXNzaWduIHN1YnNjcmlwdGlvbicpO1xuICAgIH1cblxuICAgIGlmICghc3Vic2NyaXB0aW9uIHx8ICFzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uX3BsYW5zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXRyaWV2ZSBzdWJzY3JpcHRpb24gZGV0YWlscycpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgdXNhZ2UgdHJhY2tpbmcgZm9yIGN1cnJlbnQgbW9udGhcbiAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkuc2xpY2UoMCwgNyk7XG4gICAgY29uc3QgeyBlcnJvcjogdXNhZ2VFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgIC5mcm9tKCd1c2VyX3VzYWdlJylcbiAgICAgIC51cHNlcnQoe1xuICAgICAgICB1c2VyX2lkOiB1c2VySWQsXG4gICAgICAgIG1vbnRoX3llYXI6IGN1cnJlbnRNb250aCxcbiAgICAgICAgbm90ZXNfZ2VuZXJhdGVkOiAwLFxuICAgICAgICB2aWRlb19ub3Rlc19jb3VudDogMCxcbiAgICAgICAgZmlsZV9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgdGV4dF9ub3Rlc19jb3VudDogMCxcbiAgICAgICAgdG90YWxfc2F2ZWRfbm90ZXM6IDAsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxuICAgICAgfSwge1xuICAgICAgICBvbkNvbmZsaWN0OiAndXNlcl9pZCxtb250aF95ZWFyJyxcbiAgICAgICAgaWdub3JlRHVwbGljYXRlczogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICBpZiAodXNhZ2VFcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnNjcmlwdGlvbl0gV2FybmluZzogRmFpbGVkIHRvIGluaXRpYWxpemUgdXNhZ2UgdHJhY2tpbmc6JywgdXNhZ2VFcnJvcik7XG4gICAgICAvLyBEb24ndCB0aHJvdyBlcnJvciBoZXJlIGFzIHN1YnNjcmlwdGlvbiBhc3NpZ25tZW50IHdhcyBzdWNjZXNzZnVsXG4gICAgfVxuXG4gICAgY29uc3QgcGxhbkRhdGEgPSBzdWJzY3JpcHRpb24uc3Vic2NyaXB0aW9uX3BsYW5zIGFzIGFueTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgc3Vic2NyaXB0aW9uX2lkOiBzdWJzY3JpcHRpb24uaWQsXG4gICAgICBwbGFuX2lkOiBzdWJzY3JpcHRpb24ucGxhbl9pZCxcbiAgICAgIHBsYW5fbmFtZTogcGxhbkRhdGEubmFtZSxcbiAgICAgIHBsYW5fZGlzcGxheV9uYW1lOiBwbGFuRGF0YS5kaXNwbGF5X25hbWUsXG4gICAgICBiaWxsaW5nX2N5Y2xlOiBzdWJzY3JpcHRpb24uYmlsbGluZ19jeWNsZSxcbiAgICAgIHN0YXR1czogc3Vic2NyaXB0aW9uLnN0YXR1cyxcbiAgICAgIGN1cnJlbnRfcGVyaW9kX2VuZDogc3Vic2NyaXB0aW9uLmN1cnJlbnRfcGVyaW9kX2VuZCxcbiAgICAgIGZlYXR1cmVzOiBwbGFuRGF0YS5mZWF0dXJlcyxcbiAgICAgIGxpbWl0czogcGxhbkRhdGEubGltaXRzLFxuICAgICAgcHJpY2VfbW9udGhseTogcGxhbkRhdGEucHJpY2VfbW9udGhseSxcbiAgICAgIHByaWNlX3llYXJseTogcGxhbkRhdGEucHJpY2VfeWVhcmx5XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3Vic2NyaXB0aW9uXSBFcnJvciBpbiBhc3NpZ25Vc2VyU3Vic2NyaXB0aW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufSAiXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfVVJMIiwic3VwYWJhc2VBbm9uS2V5IiwiTkVYVF9QVUJMSUNfU1VQQUJBU0VfQU5PTl9LRVkiLCJnZXRTdWJzY3JpcHRpb25QbGFucyIsInN1cGFiYXNlIiwiZGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJjb25zb2xlIiwiRXJyb3IiLCJnZXRVc2VyU3Vic2NyaXB0aW9uIiwidXNlcklkIiwidG9rZW4iLCJnbG9iYWwiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInVzZXJTdWIiLCJzaW5nbGUiLCJzdWJzY3JpcHRpb25fcGxhbnMiLCJwbGFuRGF0YSIsInN1YnNjcmlwdGlvbl9pZCIsImlkIiwicGxhbl9pZCIsInBsYW5fbmFtZSIsIm5hbWUiLCJwbGFuX2Rpc3BsYXlfbmFtZSIsImRpc3BsYXlfbmFtZSIsImJpbGxpbmdfY3ljbGUiLCJzdGF0dXMiLCJjdXJyZW50X3BlcmlvZF9lbmQiLCJmZWF0dXJlcyIsImxpbWl0cyIsInByaWNlX21vbnRobHkiLCJwcmljZV95ZWFybHkiLCJnZXRTdWJzY3JpcHRpb25QbGFuIiwicGxhbklkIiwiY2hlY2tVc2FnZUxpbWl0cyIsIm5vdGVUeXBlIiwibG9nIiwic3ViRXJyb3IiLCJjdXJyZW50TW9udGgiLCJEYXRlIiwidG9JU09TdHJpbmciLCJzbGljZSIsInVzYWdlIiwidXNhZ2VFcnJvciIsImZyZWVQbGFuTGltaXRzIiwibm90ZXNfcGVyX21vbnRoIiwibWF4X3NhdmVkX25vdGVzIiwibWF4X3RleHRfbGVuZ3RoIiwiY3VycmVudFVzYWdlIiwibm90ZXNfZ2VuZXJhdGVkIiwidmlkZW9fbm90ZXNfY291bnQiLCJmaWxlX25vdGVzX2NvdW50IiwidGV4dF9ub3Rlc19jb3VudCIsInRvdGFsX3NhdmVkX25vdGVzIiwibW9udGhfeWVhciIsImNyZWF0ZVVzYWdlRXJyb3IiLCJpbnNlcnQiLCJ1c2VyX2lkIiwidXBkYXRlZF9hdCIsImNyZWF0ZVN1YkVycm9yIiwiY3VycmVudF9wZXJpb2Rfc3RhcnQiLCJub3ciLCJjYW5HZW5lcmF0ZSIsImNhblNhdmUiLCJyZWFzb24iLCJ1bmRlZmluZWQiLCJzdWJzY3JpcHRpb24iLCJwbGFuTGltaXRzIiwibW9udGhseUxpbWl0IiwiZmFsbGJhY2tVc2FnZSIsImluY3JlbWVudFVzYWdlIiwiZmV0Y2hFcnJvciIsImNvZGUiLCJ1cGRhdGVEYXRhIiwidXBkYXRlRXJyb3IiLCJ1cGRhdGUiLCJpbnNlcnREYXRhIiwiY3JlYXRlZF9hdCIsImluc2VydEVycm9yIiwidXBkYXRlU2F2ZWROb3Rlc0NvdW50IiwiY291bnQiLCJ1cHNlcnQiLCJNYXRoIiwibWF4Iiwib25Db25mbGljdCIsInJlZnJlc2hTYXZlZE5vdGVzQ291bnQiLCJ2aWRlb1Jlc3VsdCIsImZpbGVSZXN1bHQiLCJ0ZXh0UmVzdWx0IiwiUHJvbWlzZSIsImFsbCIsImhlYWQiLCJ2aWRlb0NvdW50IiwiZmlsZUNvdW50IiwidGV4dENvdW50IiwidG90YWxDb3VudCIsInZpZGVvIiwiZmlsZSIsInRleHQiLCJ0b3RhbCIsImdldFBsYW5QcmljaW5nIiwicGxhbiIsIm1vbnRobHlQcmljZSIsInllYXJseVByaWNlIiwieWVhcmx5TW9udGhseUVxdWl2YWxlbnQiLCJkaXNjb3VudFBlcmNlbnRhZ2UiLCJyb3VuZCIsInllYXJseVNhdmluZ3MiLCJtb250aGx5IiwieWVhcmx5IiwiY3VycmVuY3kiLCJoYXNGZWF0dXJlQWNjZXNzIiwiZmVhdHVyZSIsImZyZWVGZWF0dXJlcyIsIm5vdGVzX2dlbmVyYXRpb24iLCJxdWl6emVzIiwieW91dHViZV9zdXBwb3J0IiwicHB0X3N1cHBvcnQiLCJleHBvcnQiLCJjb3B5X3Bhc3RlIiwidXBsb2FkX3ZpZGVvIiwicHJpb3JpdHlfZ2VuZXJhdGlvbiIsImFzc2lnblVzZXJTdWJzY3JpcHRpb24iLCJiaWxsaW5nQ3ljbGUiLCJwYXltZW50RGF0YSIsImN1cnJlbnRQZXJpb2RTdGFydCIsImN1cnJlbnRQZXJpb2RFbmQiLCJzZXRGdWxsWWVhciIsImdldEZ1bGxZZWFyIiwic2V0TW9udGgiLCJnZXRNb250aCIsInN1YnNjcmlwdGlvbkRhdGEiLCJjYW5jZWxfYXRfcGVyaW9kX2VuZCIsInN0cmlwZV9zdWJzY3JpcHRpb25faWQiLCJzdHJpcGVTdWJzY3JpcHRpb25JZCIsInN0cmlwZV9jdXN0b21lcl9pZCIsInN0cmlwZUN1c3RvbWVySWQiLCJzdWJzY3JpcHRpb25FcnJvciIsImlnbm9yZUR1cGxpY2F0ZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/subscription.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/subtitles.ts":
/*!***********************************!*\
  !*** ./src/services/subtitles.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   downloadSubtitles: () => (/* binding */ downloadSubtitles),\n/* harmony export */   extractSubtitles: () => (/* binding */ extractSubtitles),\n/* harmony export */   getVideoSubtitles: () => (/* binding */ getVideoSubtitles),\n/* harmony export */   isYtDlpAvailable: () => (/* binding */ isYtDlpAvailable),\n/* harmony export */   parseSubtitlesFile: () => (/* binding */ parseSubtitlesFile)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var execa__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! execa */ \"(rsc)/./node_modules/execa/index.js\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var subtitle__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! subtitle */ \"(rsc)/./node_modules/subtitle/dist/subtitle.esm.js\");\n/* harmony import */ var _youtube__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./youtube */ \"(rsc)/./src/services/youtube.ts\");\n/* harmony import */ var ytdl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ytdl-core */ \"(rsc)/./node_modules/ytdl-core/lib/index.js\");\n/* harmony import */ var ytdl_core__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(ytdl_core__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_7__);\n\n\n\n\n\n\n\n\n\nconst readFile = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)((fs__WEBPACK_IMPORTED_MODULE_0___default().readFile));\nconst writeFile = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)((fs__WEBPACK_IMPORTED_MODULE_0___default().writeFile));\nconst unlink = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)((fs__WEBPACK_IMPORTED_MODULE_0___default().unlink));\nconst exists = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)((fs__WEBPACK_IMPORTED_MODULE_0___default().exists));\n// Flag to ensure we only show the warning once per session\nlet ytDlpWarningShown = false;\n/**\n * Checks if yt-dlp is installed on the system\n * @returns true if yt-dlp is available, false otherwise\n */ async function isYtDlpAvailable() {\n    try {\n        // First try using 'which' on Unix-like systems\n        try {\n            await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(\"which yt-dlp\", {\n                shell: true\n            });\n            return true;\n        } catch  {\n            // If 'which' fails, try to execute yt-dlp directly\n            await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(\"yt-dlp --version\", {\n                shell: true\n            });\n            return true;\n        }\n    } catch (error) {\n        if (!ytDlpWarningShown && \"development\" === \"development\") {\n            console.warn(\"\\n⚠️ WARNING: yt-dlp is not available on this system!\");\n            console.warn(\"⚠️ YouTube subtitle extraction will fail without yt-dlp.\");\n            console.warn(\"For subtitle support, please install yt-dlp:\");\n            console.warn(\"  • macOS: brew install yt-dlp\");\n            console.warn(\"  • Linux/macOS: pip install yt-dlp\");\n            console.warn(\"  • Windows: pip install yt-dlp or choco install yt-dlp\\n\");\n            ytDlpWarningShown = true;\n        }\n        return false;\n    }\n}\n/**\n * Downloads subtitles from a YouTube video using yt-dlp\n * @param videoId YouTube video ID\n * @param languages Languages to try, in order of preference\n * @returns The path to the downloaded subtitle file or null if not available\n */ async function downloadSubtitles(videoId, languages = [\n    \"pl\",\n    \"en\"\n]) {\n    if (!(0,_youtube__WEBPACK_IMPORTED_MODULE_5__.isValidYouTubeId)(videoId)) {\n        console.error(\"[Subtitles] Invalid video ID:\", videoId);\n        return null;\n    }\n    // Check if yt-dlp is available\n    const ytDlpAvailable = await isYtDlpAvailable();\n    if (ytDlpAvailable) {\n        // Use yt-dlp if available\n        return downloadWithYtDlp(videoId, languages);\n    } else {\n        // No fallback to ytdl-core - it's not reliable enough\n        console.error(\"[Subtitles] yt-dlp is not installed. Cannot download subtitles reliably.\");\n        throw new Error(\"yt-dlp is required for reliable subtitle extraction. Please install yt-dlp on your system:\\n\" + \"• macOS: brew install yt-dlp\\n\" + \"• Linux/macOS: pip install yt-dlp\\n\" + \"• Windows: pip install yt-dlp or choco install yt-dlp\");\n    }\n}\n/**\n * Downloads subtitles using yt-dlp\n * @param videoId YouTube video ID\n * @param languages Languages to try, in order of preference\n * @returns The path to the downloaded subtitle file or null if not available\n */ async function downloadWithYtDlp(videoId, languages = [\n    \"pl\",\n    \"en\"\n]) {\n    // Create a temporary directory for downloads\n    const tempDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp\");\n    try {\n        // Ensure temp directory exists with proper permissions\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(tempDir)) {\n            try {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(tempDir, {\n                    recursive: true,\n                    mode: 493\n                });\n                console.log(`[Subtitles] Created temporary directory: ${tempDir}`);\n            } catch (mkdirError) {\n                console.error(`[Subtitles] Failed to create temporary directory: ${tempDir}`, mkdirError);\n                throw new Error(`Permission denied: Could not create temporary directory: ${mkdirError.message}`);\n            }\n        } else {\n            // Verify we can write to the temp directory\n            try {\n                const testFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `test-${Date.now()}.txt`);\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFileSync(testFile, \"test\", {\n                    mode: 420\n                });\n                fs__WEBPACK_IMPORTED_MODULE_0___default().unlinkSync(testFile);\n                console.log(`[Subtitles] Verified write access to temp directory: ${tempDir}`);\n            } catch (accessError) {\n                console.error(`[Subtitles] No write access to temp directory: ${tempDir}`, accessError);\n                throw new Error(`Permission denied: Cannot write to temporary directory: ${accessError.message}`);\n            }\n        }\n        // Generate a unique output filename\n        const uniqueId = (0,crypto__WEBPACK_IMPORTED_MODULE_3__.randomUUID)();\n        const outputTemplate = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-%(id)s.%(ext)s`);\n        // Build language preference string\n        const langPref = languages.join(\",\");\n        console.log(`[Subtitles] Downloading subtitles for video ${videoId} in languages: ${langPref}`);\n        // First get info about available subtitle tracks\n        try {\n            console.log(\"[Subtitles] Checking available subtitle tracks...\");\n            const { stdout: listOutput } = await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(`yt-dlp --list-subs https://www.youtube.com/watch?v=${videoId}`, {\n                shell: true,\n                timeout: 20000\n            });\n            console.log(\"[Subtitles] Available subtitle info:\");\n            console.log(listOutput);\n            // Check if the output indicates any subtitles are available\n            const hasManualSubs = listOutput.includes(\"has no subtitles\") ? false : true;\n            const hasAutoSubs = listOutput.includes(\"has no automatic captions\") ? false : true;\n            console.log(`[Subtitles] Manual subtitles available: ${hasManualSubs}`);\n            console.log(`[Subtitles] Auto-generated subtitles available: ${hasAutoSubs}`);\n        } catch (infoError) {\n            console.warn(\"[Subtitles] Error checking subtitle availability:\", infoError);\n        // Continue anyway, as this is just informational\n        }\n        try {\n            // First try to get regular subtitles (manually created)\n            let subtitleFile = null;\n            const possibleExtensions = [\n                \".vtt\",\n                \".srt\"\n            ];\n            try {\n                console.log(\"[Subtitles] Trying to download regular subtitles first...\");\n                // Add verbosity for debugging\n                const ytDlpCommand = `yt-dlp --verbose --write-sub --sub-lang ${langPref} --skip-download --output \"${outputTemplate}\" https://www.youtube.com/watch?v=${videoId}`;\n                console.log(`[Subtitles] Running command: ${ytDlpCommand}`);\n                const { stdout, stderr } = await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(ytDlpCommand, {\n                    shell: true,\n                    timeout: 30000\n                } // Add a timeout of 30 seconds\n                );\n                console.log(\"[Subtitles] yt-dlp stdout:\", stdout);\n                if (stderr) console.warn(\"[Subtitles] yt-dlp stderr:\", stderr);\n                // Check if a subtitle file was created\n                for (const ext of possibleExtensions){\n                    const potentialFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}${ext}`);\n                    if (await exists(potentialFile)) {\n                        subtitleFile = potentialFile;\n                        console.log(\"[Subtitles] Successfully downloaded regular subtitles:\", path__WEBPACK_IMPORTED_MODULE_1___default().basename(potentialFile));\n                        break;\n                    }\n                }\n                // Also check for language-specific filename patterns\n                if (!subtitleFile) {\n                    for (const lang of languages){\n                        for (const ext of possibleExtensions){\n                            // Check patterns like: uniqueId-videoId.lang.ext or uniqueId-videoId.lang_type.ext\n                            const langFilePatterns = [\n                                path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}.${lang}${ext}`),\n                                path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}.${lang}_*${ext}`)\n                            ];\n                            for (const pattern of langFilePatterns){\n                                // Need to use glob pattern matching here\n                                const { stdout: globResult } = await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(`ls ${pattern} 2>/dev/null || echo ''`, {\n                                    shell: true\n                                });\n                                if (globResult && globResult.trim() !== \"\") {\n                                    const files = globResult.trim().split(\"\\n\");\n                                    if (files.length > 0 && files[0] !== \"\") {\n                                        subtitleFile = files[0];\n                                        console.log(\"[Subtitles] Found language-specific subtitle file:\", path__WEBPACK_IMPORTED_MODULE_1___default().basename(subtitleFile));\n                                        break;\n                                    }\n                                }\n                            }\n                            if (subtitleFile) break;\n                        }\n                        if (subtitleFile) break;\n                    }\n                }\n                if (subtitleFile) {\n                    // Verify file is not empty\n                    const stats = await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.stat(subtitleFile);\n                    if (stats.size === 0) {\n                        console.warn(\"[Subtitles] Downloaded subtitle file is empty, will try auto-generated subtitles\");\n                        subtitleFile = null;\n                    } else {\n                        return subtitleFile;\n                    }\n                }\n                console.log(\"[Subtitles] No regular subtitles found, trying auto-generated...\");\n            } catch (error) {\n                console.warn(\"[Subtitles] Error downloading regular subtitles, trying auto-generated:\", error);\n            }\n            // If we reach here, no regular subtitles were found, try auto-generated\n            try {\n                // Add verbosity for debugging\n                const autoSubCommand = `yt-dlp --verbose --write-auto-sub --sub-lang ${langPref} --skip-download --output \"${outputTemplate}\" https://www.youtube.com/watch?v=${videoId}`;\n                console.log(`[Subtitles] Running command: ${autoSubCommand}`);\n                const { stdout, stderr } = await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(autoSubCommand, {\n                    shell: true,\n                    timeout: 30000\n                } // Add a timeout of 30 seconds\n                );\n                console.log(\"[Subtitles] yt-dlp auto-sub stdout:\", stdout);\n                if (stderr) console.warn(\"[Subtitles] yt-dlp auto-sub stderr:\", stderr);\n                // Find the generated subtitle file (vtt or srt)\n                for (const ext of possibleExtensions){\n                    const potentialFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}${ext}`);\n                    if (await exists(potentialFile)) {\n                        // Verify file is not empty\n                        const stats = await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.stat(potentialFile);\n                        if (stats.size === 0) {\n                            console.warn(`[Subtitles] Auto-generated subtitle file ${path__WEBPACK_IMPORTED_MODULE_1___default().basename(potentialFile)} is empty`);\n                            continue;\n                        }\n                        subtitleFile = potentialFile;\n                        console.log(\"[Subtitles] Found auto-generated subtitles file:\", path__WEBPACK_IMPORTED_MODULE_1___default().basename(subtitleFile));\n                        break;\n                    }\n                }\n                // Also check for language-specific auto-generated subtitles\n                if (!subtitleFile) {\n                    for (const lang of languages){\n                        for (const ext of possibleExtensions){\n                            // Check patterns like: uniqueId-videoId.lang.ext or uniqueId-videoId.lang_type.ext\n                            const langFilePatterns = [\n                                path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}.${lang}${ext}`),\n                                path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}.${lang}_*${ext}`)\n                            ];\n                            for (const pattern of langFilePatterns){\n                                // Need to use glob pattern matching here\n                                const { stdout: globResult } = await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(`ls ${pattern} 2>/dev/null || echo ''`, {\n                                    shell: true\n                                });\n                                if (globResult && globResult.trim() !== \"\") {\n                                    const files = globResult.trim().split(\"\\n\");\n                                    if (files.length > 0 && files[0] !== \"\") {\n                                        // Verify file is not empty\n                                        const stats = await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.stat(files[0]);\n                                        if (stats.size === 0) {\n                                            console.warn(`[Subtitles] Auto-generated subtitle file ${path__WEBPACK_IMPORTED_MODULE_1___default().basename(files[0])} is empty`);\n                                            continue;\n                                        }\n                                        subtitleFile = files[0];\n                                        console.log(\"[Subtitles] Found language-specific auto-generated subtitle file:\", path__WEBPACK_IMPORTED_MODULE_1___default().basename(subtitleFile));\n                                        break;\n                                    }\n                                }\n                            }\n                            if (subtitleFile) break;\n                        }\n                        if (subtitleFile) break;\n                    }\n                }\n            } catch (error) {\n                console.error(\"[Subtitles] Error downloading auto-generated subtitles:\", error);\n            }\n            if (!subtitleFile) {\n                // Try one more time with different format selections\n                try {\n                    console.log(\"[Subtitles] Trying format-specific subtitle download as last resort...\");\n                    // Try different format options\n                    const formatOptions = [\n                        \"--write-subs\",\n                        \"--write-auto-subs\",\n                        \"--sub-format vtt\",\n                        \"--sub-format srt\"\n                    ];\n                    for (const format of formatOptions){\n                        for (const lang of languages){\n                            const lastResortCommand = `yt-dlp --verbose --sub-langs ${lang} ${format} --skip-download --output \"${outputTemplate}\" https://www.youtube.com/watch?v=${videoId}`;\n                            console.log(`[Subtitles] Running last resort command: ${lastResortCommand}`);\n                            try {\n                                const { stdout, stderr } = await (0,execa__WEBPACK_IMPORTED_MODULE_8__.execaCommand)(lastResortCommand, {\n                                    shell: true,\n                                    timeout: 30000\n                                });\n                                console.log(`[Subtitles] Last resort attempt for ${format} ${lang} stdout:`, stdout);\n                                if (stderr) console.warn(`[Subtitles] Last resort attempt stderr:`, stderr);\n                                // Check for files again\n                                for (const ext of possibleExtensions){\n                                    const potentialFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}${ext}`);\n                                    if (await exists(potentialFile)) {\n                                        // Verify file is not empty\n                                        const stats = await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.stat(potentialFile);\n                                        if (stats.size === 0) {\n                                            console.warn(`[Subtitles] Last resort subtitle file ${path__WEBPACK_IMPORTED_MODULE_1___default().basename(potentialFile)} is empty`);\n                                            continue;\n                                        }\n                                        subtitleFile = potentialFile;\n                                        console.log(\"[Subtitles] Found subtitles with last resort method:\", path__WEBPACK_IMPORTED_MODULE_1___default().basename(subtitleFile));\n                                        break;\n                                    }\n                                    // Check language variant\n                                    const langFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}.${lang}${ext}`);\n                                    if (await exists(langFile)) {\n                                        // Verify file is not empty\n                                        const stats = await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.stat(langFile);\n                                        if (stats.size === 0) {\n                                            console.warn(`[Subtitles] Last resort subtitle file ${path__WEBPACK_IMPORTED_MODULE_1___default().basename(langFile)} is empty`);\n                                            continue;\n                                        }\n                                        subtitleFile = langFile;\n                                        console.log(\"[Subtitles] Found language-specific subtitles with last resort method:\", path__WEBPACK_IMPORTED_MODULE_1___default().basename(subtitleFile));\n                                        break;\n                                    }\n                                }\n                                if (subtitleFile) break;\n                            } catch (formatError) {\n                                console.warn(`[Subtitles] Format option ${format} failed:`, formatError);\n                            // Continue to next format\n                            }\n                        }\n                        if (subtitleFile) break;\n                    }\n                } catch (error) {\n                    console.error(\"[Subtitles] Last resort subtitle extraction failed:\", error);\n                }\n            }\n            if (!subtitleFile) {\n                console.error(\"[Subtitles] No subtitle file was created by yt-dlp (neither regular nor auto-generated)\");\n                return null;\n            }\n            return subtitleFile;\n        } catch (error) {\n            console.error(\"[Subtitles] Error downloading subtitles with yt-dlp:\", error);\n            return null;\n        }\n    } catch (error) {\n        console.error(\"[Subtitles] Error downloading subtitles with yt-dlp:\", error);\n        return null;\n    }\n}\n/**\n * Downloads subtitles using ytdl-core\n * @param videoId YouTube video ID\n * @param languages Languages to try, in order of preference\n * @returns The path to the downloaded subtitle file or null if not available\n */ async function downloadWithYtdlCore(videoId, languages = [\n    \"pl\",\n    \"en\"\n]) {\n    console.log(`[Subtitles] Using ytdl-core to get subtitles for video ${videoId}`);\n    try {\n        // Get video info\n        const videoInfo = await ytdl_core__WEBPACK_IMPORTED_MODULE_6___default().getInfo(`https://www.youtube.com/watch?v=${videoId}`);\n        // Find caption tracks\n        const captionTracks = videoInfo.player_response.captions?.playerCaptionsTracklistRenderer?.captionTracks;\n        if (!captionTracks || captionTracks.length === 0) {\n            console.error(\"[Subtitles] No caption tracks found for video:\", videoId);\n            return null;\n        }\n        // Try to find caption in preferred languages\n        let selectedCaptionTrack = null;\n        for (const lang of languages){\n            selectedCaptionTrack = captionTracks.find((track)=>track.languageCode.toLowerCase() === lang.toLowerCase());\n            if (selectedCaptionTrack) {\n                console.log(`[Subtitles] Found caption track in language: ${lang}`);\n                break;\n            }\n        }\n        // If no preferred language found, take the first available\n        if (!selectedCaptionTrack) {\n            console.log(\"[Subtitles] No captions in preferred languages, using first available track\");\n            selectedCaptionTrack = captionTracks[0];\n        }\n        // Check if we have a baseUrl to download from\n        if (!selectedCaptionTrack.baseUrl) {\n            console.error(\"[Subtitles] No baseUrl found for caption track\");\n            return null;\n        }\n        // Create temp directory if it doesn't exist\n        const tempDir = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"temp\");\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(tempDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().mkdirSync(tempDir, {\n                recursive: true\n            });\n        }\n        // Generate unique file name\n        const uniqueId = (0,crypto__WEBPACK_IMPORTED_MODULE_3__.randomUUID)();\n        const subtitleFile = path__WEBPACK_IMPORTED_MODULE_1___default().join(tempDir, `${uniqueId}-${videoId}.xml`);\n        // Download the caption file\n        await new Promise((resolve, reject)=>{\n            https__WEBPACK_IMPORTED_MODULE_7___default().get(selectedCaptionTrack.baseUrl, async (response)=>{\n                if (response.statusCode !== 200) {\n                    reject(new Error(`HTTP Error: ${response.statusCode}`));\n                    return;\n                }\n                let data = \"\";\n                response.on(\"data\", (chunk)=>{\n                    data += chunk;\n                });\n                response.on(\"end\", async ()=>{\n                    try {\n                        await writeFile(subtitleFile, data, \"utf8\");\n                        resolve();\n                    } catch (err) {\n                        reject(err);\n                    }\n                });\n                response.on(\"error\", (err)=>{\n                    reject(err);\n                });\n            });\n        });\n        return subtitleFile;\n    } catch (error) {\n        // Check for specific error messages from ytdl-core that indicate signature issues\n        const errorMessage = error?.message || \"\";\n        if (errorMessage.includes(\"Could not extract signature deciphering functions\") || errorMessage.includes(\"Could not find player\") || errorMessage.includes(\"cipher\") || errorMessage.includes(\"decipher\")) {\n            console.error(\"[Subtitles] YouTube signature extraction failed. This video requires yt-dlp.\");\n            throw new Error(\"This video requires yt-dlp to extract subtitles. Please install yt-dlp to support this video.\");\n        }\n        console.error(\"[Subtitles] Error downloading subtitles with ytdl-core:\", error);\n        return null;\n    }\n}\n/**\n * Parses subtitle file content into plain text\n * @param filePath Path to the subtitle file\n * @returns Plain text from subtitles or null if parsing failed\n */ async function parseSubtitlesFile(filePath) {\n    try {\n        if (!filePath || !await exists(filePath)) {\n            console.error(\"[Subtitles] Invalid subtitle file path:\", filePath);\n            return null;\n        }\n        // Read the file content\n        const content = await readFile(filePath, \"utf8\");\n        const extension = path__WEBPACK_IMPORTED_MODULE_1___default().extname(filePath).toLowerCase();\n        console.log(`[Subtitles] Parsing subtitle file: ${path__WEBPACK_IMPORTED_MODULE_1___default().basename(filePath)} (${content.length} bytes)`);\n        // Log the first 1000 characters of raw subtitle content\n        console.log(`[Subtitles] Raw content (first 1000 chars):\\n${content.substring(0, 1000)}`);\n        let text = \"\";\n        let parseSuccess = false;\n        // Primary parsing approach\n        try {\n            if (extension === \".vtt\" || extension === \".srt\") {\n                // Use subtitle package for initial parsing attempt\n                const captions = subtitle__WEBPACK_IMPORTED_MODULE_4__.parseSync(content);\n                text = captions.map((item)=>item.text || \"\").filter(Boolean).join(\" \");\n                parseSuccess = text.length > 0;\n                if (parseSuccess) {\n                    console.log(`[Subtitles] Successfully parsed ${captions.length} captions with primary parser`);\n                } else {\n                    console.warn(\"[Subtitles] Primary parser returned empty text, will try fallback methods\");\n                }\n            } else if (extension === \".xml\") {\n                // Parse YouTube XML format\n                text = parseYouTubeXmlCaptions(content);\n                parseSuccess = text.length > 0;\n            } else {\n                console.error(\"[Subtitles] Unsupported subtitle format:\", extension);\n                return null;\n            }\n        } catch (parseError) {\n            console.warn(\"[Subtitles] Primary parsing failed:\", parseError);\n            // Log the first 500 chars of content for debugging\n            console.warn(\"[Subtitles] Content sample:\", content.substring(0, 500));\n        }\n        // Fallback parsing approach if primary method failed\n        if (!parseSuccess) {\n            console.log(\"[Subtitles] Attempting fallback parsing methods\");\n            try {\n                // Fallback 1: Manual line-by-line parsing for VTT/SRT\n                if (extension === \".vtt\" || extension === \".srt\") {\n                    console.log(\"[Subtitles] Trying manual line-by-line parsing\");\n                    // Simple manual parser that extracts text between timestamps\n                    const lines = content.split(\"\\n\");\n                    const textLines = [];\n                    // Look for lines that don't have timestamps and aren't numeric-only indices\n                    for(let i = 0; i < lines.length; i++){\n                        const line = lines[i].trim();\n                        // Skip empty lines, numeric-only lines (indices), and timestamp lines\n                        if (line && !/^\\d+$/.test(line) && // Skip indices\n                        !line.includes(\"-->\") && // Skip timestamps\n                        !line.startsWith(\"WEBVTT\") && // Skip headers\n                        !line.startsWith(\"NOTE\") && // Skip notes\n                        !line.startsWith(\"STYLE\") // Skip style info\n                        ) {\n                            textLines.push(line);\n                        }\n                    }\n                    text = textLines.join(\" \");\n                    parseSuccess = text.length > 0;\n                    if (parseSuccess) {\n                        console.log(`[Subtitles] Successfully extracted ${textLines.length} lines with manual parsing`);\n                    }\n                }\n                // If all parsing methods failed, log an error\n                if (!parseSuccess) {\n                    console.error(\"[Subtitles] All parsing methods failed for:\", filePath);\n                    throw new Error(\"Failed to parse subtitle content with all available methods\");\n                }\n            } catch (fallbackError) {\n                console.error(\"[Subtitles] Fallback parsing also failed:\", fallbackError);\n                return null;\n            }\n        }\n        // Clean up the text\n        // Remove HTML tags, extra whitespace, etc.\n        text = text.replace(/<[^>]*>/g, \"\") // Remove HTML tags\n        .replace(/\\s+/g, \" \") // Replace multiple spaces with a single space\n        .replace(/\\{.*?\\}/g, \"\") // Remove curly brace formatting (common in SRT)\n        .trim();\n        // Log the first 1000 characters of cleaned text\n        console.log(`[Subtitles] Cleaned text (first 1000 chars):\\n${text.substring(0, 1000)}`);\n        console.log(`[Subtitles] Final extracted text: ${text.length} characters`);\n        return text;\n    } catch (error) {\n        console.error(\"[Subtitles] Error parsing subtitle file:\", error);\n        return null;\n    } finally{\n        // Clean up the file regardless of success/failure\n        try {\n            await unlink(filePath);\n            console.log(\"[Subtitles] Deleted temporary file:\", filePath);\n        } catch (cleanupError) {\n            console.warn(\"[Subtitles] Error deleting temporary file:\", cleanupError);\n        }\n    }\n}\n/**\n * Parses YouTube XML captions format\n * @param content XML content as string\n * @returns Plain text from captions\n */ function parseYouTubeXmlCaptions(content) {\n    // Simple XML parsing to extract text from <text> elements\n    const textMatches = content.match(/<text[^>]*>(.*?)<\\/text>/g) || [];\n    const cleanedText = textMatches.map((match)=>{\n        // Extract content between tags\n        const text = match.replace(/<text[^>]*>(.*?)<\\/text>/g, \"$1\");\n        // Decode HTML entities\n        return text.replace(/&amp;/g, \"&\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\").replace(/&quot;/g, '\"').replace(/&#39;/g, \"'\");\n    }).join(\" \");\n    return cleanedText;\n}\n/**\n * Downloads and parses subtitles from a YouTube video\n * @param videoId YouTube video ID\n * @param languages Languages to try, in order of preference\n * @returns Plain text from subtitles or null if unavailable\n */ async function getVideoSubtitles(videoId, languages = [\n    \"pl\",\n    \"en\"\n]) {\n    try {\n        // Input validation\n        if (!videoId || typeof videoId !== \"string\") {\n            console.error(\"[Subtitles] Invalid videoId:\", videoId);\n            throw new Error(\"Invalid YouTube video ID\");\n        }\n        // First check if yt-dlp is available to provide clearer error messages\n        const ytDlpAvailable = await isYtDlpAvailable().catch((error)=>{\n            console.error(\"[Subtitles] Error checking yt-dlp availability:\", error);\n            return false;\n        });\n        if (!ytDlpAvailable) {\n            const errorMsg = \"yt-dlp is required for reliable subtitle extraction. Please install yt-dlp on your system:\\n\" + \"• macOS: brew install yt-dlp\\n\" + \"• Linux/macOS: pip install yt-dlp\\n\" + \"• Windows: pip install yt-dlp or choco install yt-dlp\";\n            console.error(\"[Subtitles] \" + errorMsg);\n            throw new Error(errorMsg);\n        }\n        // Download subtitles\n        console.log(`[Subtitles] Starting subtitle extraction for video: ${videoId}`);\n        const startTime = Date.now();\n        // Add timeout for subprocess calls\n        const downloadPromise = downloadSubtitles(videoId, languages);\n        const timeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Subtitle download timeout after 30 seconds\")), 30000);\n        });\n        const subtitlePath = await Promise.race([\n            downloadPromise,\n            timeoutPromise\n        ]);\n        if (!subtitlePath) {\n            const errorMsg = `No subtitles available for video ${videoId}. Either the video doesn't have subtitles, or they couldn't be downloaded.`;\n            console.error(\"[Subtitles] \" + errorMsg);\n            return null;\n        }\n        // Verify file exists before attempting to parse\n        if (!fs__WEBPACK_IMPORTED_MODULE_0___default().existsSync(subtitlePath)) {\n            console.error(`[Subtitles] Subtitle file does not exist: ${subtitlePath}`);\n            throw new Error(`Subtitle file does not exist at ${subtitlePath}`);\n        }\n        // Parse the subtitle file with timeout\n        const parsePromise = parseSubtitlesFile(subtitlePath);\n        const parseTimeoutPromise = new Promise((_, reject)=>{\n            setTimeout(()=>reject(new Error(\"Subtitle parsing timeout after 10 seconds\")), 10000);\n        });\n        const text = await Promise.race([\n            parsePromise,\n            parseTimeoutPromise\n        ]);\n        if (!text) {\n            const errorMsg = `Failed to parse subtitle file for video ${videoId}. The subtitle format may be unsupported or corrupted.`;\n            console.error(\"[Subtitles] \" + errorMsg);\n            return null;\n        }\n        const duration = Date.now() - startTime;\n        console.log(`[Subtitles] Successfully extracted subtitles (${text.length} chars) for video: ${videoId} in ${duration}ms`);\n        // Return a summary/sample for debugging\n        if (text.length > 500) {\n            console.log(\"[Subtitles] Text sample:\", text.substring(0, 500) + \"...\");\n        }\n        return text;\n    } catch (error) {\n        // Propagate the yt-dlp requirement error\n        if (error?.message?.includes(\"yt-dlp is required\")) {\n            console.error(\"[Subtitles] yt-dlp requirement error:\", error.message);\n            throw error;\n        }\n        // Handle timeout errors specifically\n        if (error?.message?.includes(\"timeout\")) {\n            console.error(\"[Subtitles] Operation timed out:\", error.message);\n            throw new Error(`Subtitle extraction timed out: ${error.message}`);\n        }\n        // Handle permission errors specifically\n        if (error?.message?.includes(\"permission denied\") || error?.message?.includes(\"EACCES\") || error?.message?.includes(\"Permission denied\")) {\n            console.error(\"[Subtitles] Permission error:\", error.message);\n            throw new Error(`Permission error during subtitle extraction: ${error.message}`);\n        }\n        // Create more informative error for the caller\n        let errorMsg = `Error extracting subtitles for video ${videoId}: ${error?.message || \"Unknown error\"}`;\n        // Add troubleshooting hints\n        if (error?.message?.includes(\"unavailable video\")) {\n            errorMsg += \"\\nThe video might be private, age-restricted, or requires login.\";\n        } else if (error?.message?.includes(\"permission\")) {\n            errorMsg += \"\\nCheck file system permissions in the temporary directory.\";\n        } else if (error?.message?.includes(\"network\")) {\n            errorMsg += \"\\nCheck your internet connection and try again.\";\n        }\n        console.error(\"[Subtitles] \" + errorMsg);\n        return null;\n    }\n}\n/**\n * Extracts subtitles from a YouTube video and returns the transcript text\n * Wrapper around getVideoSubtitles for the isolated video notes system\n * \n * @param videoId YouTube video ID\n * @returns The transcript text\n */ async function extractSubtitles(videoId) {\n    try {\n        // Use existing getVideoSubtitles function with default language preferences\n        const transcript = await getVideoSubtitles(videoId);\n        if (!transcript) {\n            throw new Error(\"No subtitles available for this video\");\n        }\n        return transcript;\n    } catch (error) {\n        // Log and re-throw to ensure error handling is consistent\n        console.error(`[Subtitles] Error extracting subtitles for video ${videoId}:`, error);\n        throw error;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQzlDa0YsWUFBWTtRQUNkO1FBRUFqSCxRQUFRRixLQUFLLENBQUMsaUJBQWlCbUg7UUFDL0IsT0FBTztJQUNUO0FBQ0Y7QUFFQTs7Ozs7O0NBTUMsR0FDTSxlQUFlVyxpQkFBaUJ6SCxPQUFlO0lBQ3BELElBQUk7UUFDRiw0RUFBNEU7UUFDNUUsTUFBTTBILGFBQWEsTUFBTWQsa0JBQWtCNUc7UUFFM0MsSUFBSSxDQUFDMEgsWUFBWTtZQUNmLE1BQU0sSUFBSXRILE1BQU07UUFDbEI7UUFFQSxPQUFPc0g7SUFDVCxFQUFFLE9BQU8vSCxPQUFZO1FBQ25CLDBEQUEwRDtRQUMxREUsUUFBUUYsS0FBSyxDQUFDLENBQUMsaURBQWlELEVBQUVLLFFBQVEsQ0FBQyxDQUFDLEVBQUVMO1FBQzlFLE1BQU1BO0lBQ1I7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy9zdWJ0aXRsZXMudHM/MTViYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBleGVjYUNvbW1hbmQgfSBmcm9tICdleGVjYSc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJztcbmltcG9ydCB7IHJhbmRvbVVVSUQgfSBmcm9tICdjcnlwdG8nO1xuaW1wb3J0ICogYXMgc3VidGl0bGUgZnJvbSAnc3VidGl0bGUnO1xuaW1wb3J0IHsgaXNWYWxpZFlvdVR1YmVJZCB9IGZyb20gJy4veW91dHViZSc7XG5pbXBvcnQgeXRkbCBmcm9tICd5dGRsLWNvcmUnO1xuaW1wb3J0IGh0dHBzIGZyb20gJ2h0dHBzJztcblxuY29uc3QgcmVhZEZpbGUgPSBwcm9taXNpZnkoZnMucmVhZEZpbGUpO1xuY29uc3Qgd3JpdGVGaWxlID0gcHJvbWlzaWZ5KGZzLndyaXRlRmlsZSk7XG5jb25zdCB1bmxpbmsgPSBwcm9taXNpZnkoZnMudW5saW5rKTtcbmNvbnN0IGV4aXN0cyA9IHByb21pc2lmeShmcy5leGlzdHMpO1xuXG4vLyBGbGFnIHRvIGVuc3VyZSB3ZSBvbmx5IHNob3cgdGhlIHdhcm5pbmcgb25jZSBwZXIgc2Vzc2lvblxubGV0IHl0RGxwV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIHl0LWRscCBpcyBpbnN0YWxsZWQgb24gdGhlIHN5c3RlbVxuICogQHJldHVybnMgdHJ1ZSBpZiB5dC1kbHAgaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzWXREbHBBdmFpbGFibGUoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QgdHJ5IHVzaW5nICd3aGljaCcgb24gVW5peC1saWtlIHN5c3RlbXNcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZXhlY2FDb21tYW5kKCd3aGljaCB5dC1kbHAnLCB7IHNoZWxsOiB0cnVlIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCB7XG4gICAgICAvLyBJZiAnd2hpY2gnIGZhaWxzLCB0cnkgdG8gZXhlY3V0ZSB5dC1kbHAgZGlyZWN0bHlcbiAgICAgIGF3YWl0IGV4ZWNhQ29tbWFuZCgneXQtZGxwIC0tdmVyc2lvbicsIHsgc2hlbGw6IHRydWUgfSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCF5dERscFdhcm5pbmdTaG93biAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgY29uc29sZS53YXJuKCdcXG7imqDvuI8gV0FSTklORzogeXQtZGxwIGlzIG5vdCBhdmFpbGFibGUgb24gdGhpcyBzeXN0ZW0hJyk7XG4gICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBZb3VUdWJlIHN1YnRpdGxlIGV4dHJhY3Rpb24gd2lsbCBmYWlsIHdpdGhvdXQgeXQtZGxwLicpO1xuICAgICAgY29uc29sZS53YXJuKCdGb3Igc3VidGl0bGUgc3VwcG9ydCwgcGxlYXNlIGluc3RhbGwgeXQtZGxwOicpO1xuICAgICAgY29uc29sZS53YXJuKCcgIOKAoiBtYWNPUzogYnJldyBpbnN0YWxsIHl0LWRscCcpO1xuICAgICAgY29uc29sZS53YXJuKCcgIOKAoiBMaW51eC9tYWNPUzogcGlwIGluc3RhbGwgeXQtZGxwJyk7XG4gICAgICBjb25zb2xlLndhcm4oJyAg4oCiIFdpbmRvd3M6IHBpcCBpbnN0YWxsIHl0LWRscCBvciBjaG9jbyBpbnN0YWxsIHl0LWRscFxcbicpO1xuICAgICAgeXREbHBXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBEb3dubG9hZHMgc3VidGl0bGVzIGZyb20gYSBZb3VUdWJlIHZpZGVvIHVzaW5nIHl0LWRscFxuICogQHBhcmFtIHZpZGVvSWQgWW91VHViZSB2aWRlbyBJRFxuICogQHBhcmFtIGxhbmd1YWdlcyBMYW5ndWFnZXMgdG8gdHJ5LCBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gKiBAcmV0dXJucyBUaGUgcGF0aCB0byB0aGUgZG93bmxvYWRlZCBzdWJ0aXRsZSBmaWxlIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRTdWJ0aXRsZXMoXG4gIHZpZGVvSWQ6IHN0cmluZyxcbiAgbGFuZ3VhZ2VzOiBzdHJpbmdbXSA9IFsncGwnLCAnZW4nXVxuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGlmICghaXNWYWxpZFlvdVR1YmVJZCh2aWRlb0lkKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdIEludmFsaWQgdmlkZW8gSUQ6JywgdmlkZW9JZCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBDaGVjayBpZiB5dC1kbHAgaXMgYXZhaWxhYmxlXG4gIGNvbnN0IHl0RGxwQXZhaWxhYmxlID0gYXdhaXQgaXNZdERscEF2YWlsYWJsZSgpO1xuICBcbiAgaWYgKHl0RGxwQXZhaWxhYmxlKSB7XG4gICAgLy8gVXNlIHl0LWRscCBpZiBhdmFpbGFibGVcbiAgICByZXR1cm4gZG93bmxvYWRXaXRoWXREbHAodmlkZW9JZCwgbGFuZ3VhZ2VzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBmYWxsYmFjayB0byB5dGRsLWNvcmUgLSBpdCdzIG5vdCByZWxpYWJsZSBlbm91Z2hcbiAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSB5dC1kbHAgaXMgbm90IGluc3RhbGxlZC4gQ2Fubm90IGRvd25sb2FkIHN1YnRpdGxlcyByZWxpYWJseS4nKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAneXQtZGxwIGlzIHJlcXVpcmVkIGZvciByZWxpYWJsZSBzdWJ0aXRsZSBleHRyYWN0aW9uLiBQbGVhc2UgaW5zdGFsbCB5dC1kbHAgb24geW91ciBzeXN0ZW06XFxuJyArXG4gICAgICAn4oCiIG1hY09TOiBicmV3IGluc3RhbGwgeXQtZGxwXFxuJyArXG4gICAgICAn4oCiIExpbnV4L21hY09TOiBwaXAgaW5zdGFsbCB5dC1kbHBcXG4nICtcbiAgICAgICfigKIgV2luZG93czogcGlwIGluc3RhbGwgeXQtZGxwIG9yIGNob2NvIGluc3RhbGwgeXQtZGxwJ1xuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBEb3dubG9hZHMgc3VidGl0bGVzIHVzaW5nIHl0LWRscFxuICogQHBhcmFtIHZpZGVvSWQgWW91VHViZSB2aWRlbyBJRFxuICogQHBhcmFtIGxhbmd1YWdlcyBMYW5ndWFnZXMgdG8gdHJ5LCBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gKiBAcmV0dXJucyBUaGUgcGF0aCB0byB0aGUgZG93bmxvYWRlZCBzdWJ0aXRsZSBmaWxlIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICovXG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZFdpdGhZdERscChcbiAgdmlkZW9JZDogc3RyaW5nLFxuICBsYW5ndWFnZXM6IHN0cmluZ1tdID0gWydwbCcsICdlbiddXG4pOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGRpcmVjdG9yeSBmb3IgZG93bmxvYWRzXG4gIGNvbnN0IHRlbXBEaXIgPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJ3RlbXAnKTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gRW5zdXJlIHRlbXAgZGlyZWN0b3J5IGV4aXN0cyB3aXRoIHByb3BlciBwZXJtaXNzaW9uc1xuICAgIGlmICghZnMuZXhpc3RzU3luYyh0ZW1wRGlyKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMubWtkaXJTeW5jKHRlbXBEaXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBtb2RlOiAwbzc1NSB9KTtcbiAgICAgICAgY29uc29sZS5sb2coYFtTdWJ0aXRsZXNdIENyZWF0ZWQgdGVtcG9yYXJ5IGRpcmVjdG9yeTogJHt0ZW1wRGlyfWApO1xuICAgICAgfSBjYXRjaCAobWtkaXJFcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFtTdWJ0aXRsZXNdIEZhaWxlZCB0byBjcmVhdGUgdGVtcG9yYXJ5IGRpcmVjdG9yeTogJHt0ZW1wRGlyfWAsIG1rZGlyRXJyb3IpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBlcm1pc3Npb24gZGVuaWVkOiBDb3VsZCBub3QgY3JlYXRlIHRlbXBvcmFyeSBkaXJlY3Rvcnk6ICR7bWtkaXJFcnJvci5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWZXJpZnkgd2UgY2FuIHdyaXRlIHRvIHRoZSB0ZW1wIGRpcmVjdG9yeVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGVzdEZpbGUgPSBwYXRoLmpvaW4odGVtcERpciwgYHRlc3QtJHtEYXRlLm5vdygpfS50eHRgKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyh0ZXN0RmlsZSwgJ3Rlc3QnLCB7IG1vZGU6IDBvNjQ0IH0pO1xuICAgICAgICBmcy51bmxpbmtTeW5jKHRlc3RGaWxlKTtcbiAgICAgICAgY29uc29sZS5sb2coYFtTdWJ0aXRsZXNdIFZlcmlmaWVkIHdyaXRlIGFjY2VzcyB0byB0ZW1wIGRpcmVjdG9yeTogJHt0ZW1wRGlyfWApO1xuICAgICAgfSBjYXRjaCAoYWNjZXNzRXJyb3I6IGFueSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBbU3VidGl0bGVzXSBObyB3cml0ZSBhY2Nlc3MgdG8gdGVtcCBkaXJlY3Rvcnk6ICR7dGVtcERpcn1gLCBhY2Nlc3NFcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGVybWlzc2lvbiBkZW5pZWQ6IENhbm5vdCB3cml0ZSB0byB0ZW1wb3JhcnkgZGlyZWN0b3J5OiAke2FjY2Vzc0Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgb3V0cHV0IGZpbGVuYW1lXG4gICAgY29uc3QgdW5pcXVlSWQgPSByYW5kb21VVUlEKCk7XG4gICAgY29uc3Qgb3V0cHV0VGVtcGxhdGUgPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dW5pcXVlSWR9LSUoaWQpcy4lKGV4dClzYCk7XG5cbiAgICAvLyBCdWlsZCBsYW5ndWFnZSBwcmVmZXJlbmNlIHN0cmluZ1xuICAgIGNvbnN0IGxhbmdQcmVmID0gbGFuZ3VhZ2VzLmpvaW4oJywnKTtcbiAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gRG93bmxvYWRpbmcgc3VidGl0bGVzIGZvciB2aWRlbyAke3ZpZGVvSWR9IGluIGxhbmd1YWdlczogJHtsYW5nUHJlZn1gKTtcblxuICAgIC8vIEZpcnN0IGdldCBpbmZvIGFib3V0IGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3NcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIENoZWNraW5nIGF2YWlsYWJsZSBzdWJ0aXRsZSB0cmFja3MuLi4nKTtcbiAgICAgIGNvbnN0IHsgc3Rkb3V0OiBsaXN0T3V0cHV0IH0gPSBhd2FpdCBleGVjYUNvbW1hbmQoXG4gICAgICAgIGB5dC1kbHAgLS1saXN0LXN1YnMgaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0ke3ZpZGVvSWR9YCxcbiAgICAgICAgeyBzaGVsbDogdHJ1ZSwgdGltZW91dDogMjAwMDAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIEF2YWlsYWJsZSBzdWJ0aXRsZSBpbmZvOicpO1xuICAgICAgY29uc29sZS5sb2cobGlzdE91dHB1dCk7XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBvdXRwdXQgaW5kaWNhdGVzIGFueSBzdWJ0aXRsZXMgYXJlIGF2YWlsYWJsZVxuICAgICAgY29uc3QgaGFzTWFudWFsU3VicyA9IGxpc3RPdXRwdXQuaW5jbHVkZXMoJ2hhcyBubyBzdWJ0aXRsZXMnKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgIGNvbnN0IGhhc0F1dG9TdWJzID0gbGlzdE91dHB1dC5pbmNsdWRlcygnaGFzIG5vIGF1dG9tYXRpYyBjYXB0aW9ucycpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gTWFudWFsIHN1YnRpdGxlcyBhdmFpbGFibGU6ICR7aGFzTWFudWFsU3Vic31gKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbU3VidGl0bGVzXSBBdXRvLWdlbmVyYXRlZCBzdWJ0aXRsZXMgYXZhaWxhYmxlOiAke2hhc0F1dG9TdWJzfWApO1xuICAgIH0gY2F0Y2ggKGluZm9FcnJvcikge1xuICAgICAgY29uc29sZS53YXJuKCdbU3VidGl0bGVzXSBFcnJvciBjaGVja2luZyBzdWJ0aXRsZSBhdmFpbGFiaWxpdHk6JywgaW5mb0Vycm9yKTtcbiAgICAgIC8vIENvbnRpbnVlIGFueXdheSwgYXMgdGhpcyBpcyBqdXN0IGluZm9ybWF0aW9uYWxcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIGdldCByZWd1bGFyIHN1YnRpdGxlcyAobWFudWFsbHkgY3JlYXRlZClcbiAgICAgIGxldCBzdWJ0aXRsZUZpbGUgPSBudWxsO1xuICAgICAgY29uc3QgcG9zc2libGVFeHRlbnNpb25zID0gWycudnR0JywgJy5zcnQnXTtcbiAgICAgIFxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIFRyeWluZyB0byBkb3dubG9hZCByZWd1bGFyIHN1YnRpdGxlcyBmaXJzdC4uLicpO1xuICAgICAgICBcbiAgICAgICAgLy8gQWRkIHZlcmJvc2l0eSBmb3IgZGVidWdnaW5nXG4gICAgICAgIGNvbnN0IHl0RGxwQ29tbWFuZCA9IGB5dC1kbHAgLS12ZXJib3NlIC0td3JpdGUtc3ViIC0tc3ViLWxhbmcgJHtsYW5nUHJlZn0gLS1za2lwLWRvd25sb2FkIC0tb3V0cHV0IFwiJHtvdXRwdXRUZW1wbGF0ZX1cIiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PSR7dmlkZW9JZH1gO1xuICAgICAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gUnVubmluZyBjb21tYW5kOiAke3l0RGxwQ29tbWFuZH1gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHsgc3Rkb3V0LCBzdGRlcnIgfSA9IGF3YWl0IGV4ZWNhQ29tbWFuZChcbiAgICAgICAgICB5dERscENvbW1hbmQsXG4gICAgICAgICAgeyBzaGVsbDogdHJ1ZSwgdGltZW91dDogMzAwMDAgfSAvLyBBZGQgYSB0aW1lb3V0IG9mIDMwIHNlY29uZHNcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKCdbU3VidGl0bGVzXSB5dC1kbHAgc3Rkb3V0OicsIHN0ZG91dCk7XG4gICAgICAgIGlmIChzdGRlcnIpIGNvbnNvbGUud2FybignW1N1YnRpdGxlc10geXQtZGxwIHN0ZGVycjonLCBzdGRlcnIpO1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgaWYgYSBzdWJ0aXRsZSBmaWxlIHdhcyBjcmVhdGVkXG4gICAgICAgIGZvciAoY29uc3QgZXh0IG9mIHBvc3NpYmxlRXh0ZW5zaW9ucykge1xuICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEZpbGUgPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dW5pcXVlSWR9LSR7dmlkZW9JZH0ke2V4dH1gKTtcbiAgICAgICAgICBpZiAoYXdhaXQgZXhpc3RzKHBvdGVudGlhbEZpbGUpKSB7XG4gICAgICAgICAgICBzdWJ0aXRsZUZpbGUgPSBwb3RlbnRpYWxGaWxlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIFN1Y2Nlc3NmdWxseSBkb3dubG9hZGVkIHJlZ3VsYXIgc3VidGl0bGVzOicsIHBhdGguYmFzZW5hbWUocG90ZW50aWFsRmlsZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBBbHNvIGNoZWNrIGZvciBsYW5ndWFnZS1zcGVjaWZpYyBmaWxlbmFtZSBwYXR0ZXJuc1xuICAgICAgICBpZiAoIXN1YnRpdGxlRmlsZSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBsYW5ndWFnZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIHBvc3NpYmxlRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAvLyBDaGVjayBwYXR0ZXJucyBsaWtlOiB1bmlxdWVJZC12aWRlb0lkLmxhbmcuZXh0IG9yIHVuaXF1ZUlkLXZpZGVvSWQubGFuZ190eXBlLmV4dFxuICAgICAgICAgICAgICBjb25zdCBsYW5nRmlsZVBhdHRlcm5zID0gW1xuICAgICAgICAgICAgICAgIHBhdGguam9pbih0ZW1wRGlyLCBgJHt1bmlxdWVJZH0tJHt2aWRlb0lkfS4ke2xhbmd9JHtleHR9YCksXG4gICAgICAgICAgICAgICAgcGF0aC5qb2luKHRlbXBEaXIsIGAke3VuaXF1ZUlkfS0ke3ZpZGVvSWR9LiR7bGFuZ31fKiR7ZXh0fWApXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ0ZpbGVQYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gdXNlIGdsb2IgcGF0dGVybiBtYXRjaGluZyBoZXJlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGRvdXQ6IGdsb2JSZXN1bHQgfSA9IGF3YWl0IGV4ZWNhQ29tbWFuZChgbHMgJHtwYXR0ZXJufSAyPi9kZXYvbnVsbCB8fCBlY2hvICcnYCwgeyBzaGVsbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYlJlc3VsdCAmJiBnbG9iUmVzdWx0LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZ2xvYlJlc3VsdC50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDAgJiYgZmlsZXNbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlRmlsZSA9IGZpbGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1N1YnRpdGxlc10gRm91bmQgbGFuZ3VhZ2Utc3BlY2lmaWMgc3VidGl0bGUgZmlsZTonLCBwYXRoLmJhc2VuYW1lKHN1YnRpdGxlRmlsZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChzdWJ0aXRsZUZpbGUpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1YnRpdGxlRmlsZSkgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoc3VidGl0bGVGaWxlKSB7XG4gICAgICAgICAgLy8gVmVyaWZ5IGZpbGUgaXMgbm90IGVtcHR5XG4gICAgICAgICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmcy5wcm9taXNlcy5zdGF0KHN1YnRpdGxlRmlsZSk7XG4gICAgICAgICAgaWYgKHN0YXRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW1N1YnRpdGxlc10gRG93bmxvYWRlZCBzdWJ0aXRsZSBmaWxlIGlzIGVtcHR5LCB3aWxsIHRyeSBhdXRvLWdlbmVyYXRlZCBzdWJ0aXRsZXMnKTtcbiAgICAgICAgICAgIHN1YnRpdGxlRmlsZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0aXRsZUZpbGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZygnW1N1YnRpdGxlc10gTm8gcmVndWxhciBzdWJ0aXRsZXMgZm91bmQsIHRyeWluZyBhdXRvLWdlbmVyYXRlZC4uLicpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbU3VidGl0bGVzXSBFcnJvciBkb3dubG9hZGluZyByZWd1bGFyIHN1YnRpdGxlcywgdHJ5aW5nIGF1dG8tZ2VuZXJhdGVkOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgd2UgcmVhY2ggaGVyZSwgbm8gcmVndWxhciBzdWJ0aXRsZXMgd2VyZSBmb3VuZCwgdHJ5IGF1dG8tZ2VuZXJhdGVkXG4gICAgICB0cnkge1xuICAgICAgICAvLyBBZGQgdmVyYm9zaXR5IGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgY29uc3QgYXV0b1N1YkNvbW1hbmQgPSBgeXQtZGxwIC0tdmVyYm9zZSAtLXdyaXRlLWF1dG8tc3ViIC0tc3ViLWxhbmcgJHtsYW5nUHJlZn0gLS1za2lwLWRvd25sb2FkIC0tb3V0cHV0IFwiJHtvdXRwdXRUZW1wbGF0ZX1cIiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PSR7dmlkZW9JZH1gO1xuICAgICAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gUnVubmluZyBjb21tYW5kOiAke2F1dG9TdWJDb21tYW5kfWApO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgeyBzdGRvdXQsIHN0ZGVyciB9ID0gYXdhaXQgZXhlY2FDb21tYW5kKFxuICAgICAgICAgIGF1dG9TdWJDb21tYW5kLFxuICAgICAgICAgIHsgc2hlbGw6IHRydWUsIHRpbWVvdXQ6IDMwMDAwIH0gLy8gQWRkIGEgdGltZW91dCBvZiAzMCBzZWNvbmRzXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIHl0LWRscCBhdXRvLXN1YiBzdGRvdXQ6Jywgc3Rkb3V0KTtcbiAgICAgICAgaWYgKHN0ZGVycikgY29uc29sZS53YXJuKCdbU3VidGl0bGVzXSB5dC1kbHAgYXV0by1zdWIgc3RkZXJyOicsIHN0ZGVycik7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZ2VuZXJhdGVkIHN1YnRpdGxlIGZpbGUgKHZ0dCBvciBzcnQpXG4gICAgICAgIGZvciAoY29uc3QgZXh0IG9mIHBvc3NpYmxlRXh0ZW5zaW9ucykge1xuICAgICAgICAgIGNvbnN0IHBvdGVudGlhbEZpbGUgPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dW5pcXVlSWR9LSR7dmlkZW9JZH0ke2V4dH1gKTtcbiAgICAgICAgICBpZiAoYXdhaXQgZXhpc3RzKHBvdGVudGlhbEZpbGUpKSB7XG4gICAgICAgICAgICAvLyBWZXJpZnkgZmlsZSBpcyBub3QgZW1wdHlcbiAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMucHJvbWlzZXMuc3RhdChwb3RlbnRpYWxGaWxlKTtcbiAgICAgICAgICAgIGlmIChzdGF0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1N1YnRpdGxlc10gQXV0by1nZW5lcmF0ZWQgc3VidGl0bGUgZmlsZSAke3BhdGguYmFzZW5hbWUocG90ZW50aWFsRmlsZSl9IGlzIGVtcHR5YCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdWJ0aXRsZUZpbGUgPSBwb3RlbnRpYWxGaWxlO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIEZvdW5kIGF1dG8tZ2VuZXJhdGVkIHN1YnRpdGxlcyBmaWxlOicsIHBhdGguYmFzZW5hbWUoc3VidGl0bGVGaWxlKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFsc28gY2hlY2sgZm9yIGxhbmd1YWdlLXNwZWNpZmljIGF1dG8tZ2VuZXJhdGVkIHN1YnRpdGxlc1xuICAgICAgICBpZiAoIXN1YnRpdGxlRmlsZSkge1xuICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBsYW5ndWFnZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIHBvc3NpYmxlRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAvLyBDaGVjayBwYXR0ZXJucyBsaWtlOiB1bmlxdWVJZC12aWRlb0lkLmxhbmcuZXh0IG9yIHVuaXF1ZUlkLXZpZGVvSWQubGFuZ190eXBlLmV4dFxuICAgICAgICAgICAgICBjb25zdCBsYW5nRmlsZVBhdHRlcm5zID0gW1xuICAgICAgICAgICAgICAgIHBhdGguam9pbih0ZW1wRGlyLCBgJHt1bmlxdWVJZH0tJHt2aWRlb0lkfS4ke2xhbmd9JHtleHR9YCksXG4gICAgICAgICAgICAgICAgcGF0aC5qb2luKHRlbXBEaXIsIGAke3VuaXF1ZUlkfS0ke3ZpZGVvSWR9LiR7bGFuZ31fKiR7ZXh0fWApXG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGFuZ0ZpbGVQYXR0ZXJucykge1xuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gdXNlIGdsb2IgcGF0dGVybiBtYXRjaGluZyBoZXJlXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGRvdXQ6IGdsb2JSZXN1bHQgfSA9IGF3YWl0IGV4ZWNhQ29tbWFuZChgbHMgJHtwYXR0ZXJufSAyPi9kZXYvbnVsbCB8fCBlY2hvICcnYCwgeyBzaGVsbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYlJlc3VsdCAmJiBnbG9iUmVzdWx0LnRyaW0oKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVzID0gZ2xvYlJlc3VsdC50cmltKCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgaWYgKGZpbGVzLmxlbmd0aCA+IDAgJiYgZmlsZXNbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBmaWxlIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnByb21pc2VzLnN0YXQoZmlsZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW1N1YnRpdGxlc10gQXV0by1nZW5lcmF0ZWQgc3VidGl0bGUgZmlsZSAke3BhdGguYmFzZW5hbWUoZmlsZXNbMF0pfSBpcyBlbXB0eWApO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzdWJ0aXRsZUZpbGUgPSBmaWxlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIEZvdW5kIGxhbmd1YWdlLXNwZWNpZmljIGF1dG8tZ2VuZXJhdGVkIHN1YnRpdGxlIGZpbGU6JywgcGF0aC5iYXNlbmFtZShzdWJ0aXRsZUZpbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBpZiAoc3VidGl0bGVGaWxlKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWJ0aXRsZUZpbGUpIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnRpdGxlc10gRXJyb3IgZG93bmxvYWRpbmcgYXV0by1nZW5lcmF0ZWQgc3VidGl0bGVzOicsIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzdWJ0aXRsZUZpbGUpIHtcbiAgICAgICAgLy8gVHJ5IG9uZSBtb3JlIHRpbWUgd2l0aCBkaWZmZXJlbnQgZm9ybWF0IHNlbGVjdGlvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1N1YnRpdGxlc10gVHJ5aW5nIGZvcm1hdC1zcGVjaWZpYyBzdWJ0aXRsZSBkb3dubG9hZCBhcyBsYXN0IHJlc29ydC4uLicpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFRyeSBkaWZmZXJlbnQgZm9ybWF0IG9wdGlvbnNcbiAgICAgICAgICBjb25zdCBmb3JtYXRPcHRpb25zID0gW1xuICAgICAgICAgICAgJy0td3JpdGUtc3VicycsIFxuICAgICAgICAgICAgJy0td3JpdGUtYXV0by1zdWJzJywgXG4gICAgICAgICAgICAnLS1zdWItZm9ybWF0IHZ0dCcsIFxuICAgICAgICAgICAgJy0tc3ViLWZvcm1hdCBzcnQnXG4gICAgICAgICAgXTtcbiAgICAgICAgICBcbiAgICAgICAgICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBmb3JtYXRPcHRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmcgb2YgbGFuZ3VhZ2VzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RSZXNvcnRDb21tYW5kID0gYHl0LWRscCAtLXZlcmJvc2UgLS1zdWItbGFuZ3MgJHtsYW5nfSAke2Zvcm1hdH0gLS1za2lwLWRvd25sb2FkIC0tb3V0cHV0IFwiJHtvdXRwdXRUZW1wbGF0ZX1cIiBodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PSR7dmlkZW9JZH1gO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gUnVubmluZyBsYXN0IHJlc29ydCBjb21tYW5kOiAke2xhc3RSZXNvcnRDb21tYW5kfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0ZG91dCwgc3RkZXJyIH0gPSBhd2FpdCBleGVjYUNvbW1hbmQoXG4gICAgICAgICAgICAgICAgICBsYXN0UmVzb3J0Q29tbWFuZCxcbiAgICAgICAgICAgICAgICAgIHsgc2hlbGw6IHRydWUsIHRpbWVvdXQ6IDMwMDAwIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBbU3VidGl0bGVzXSBMYXN0IHJlc29ydCBhdHRlbXB0IGZvciAke2Zvcm1hdH0gJHtsYW5nfSBzdGRvdXQ6YCwgc3Rkb3V0KTtcbiAgICAgICAgICAgICAgICBpZiAoc3RkZXJyKSBjb25zb2xlLndhcm4oYFtTdWJ0aXRsZXNdIExhc3QgcmVzb3J0IGF0dGVtcHQgc3RkZXJyOmAsIHN0ZGVycik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGZpbGVzIGFnYWluXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBleHQgb2YgcG9zc2libGVFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwb3RlbnRpYWxGaWxlID0gcGF0aC5qb2luKHRlbXBEaXIsIGAke3VuaXF1ZUlkfS0ke3ZpZGVvSWR9JHtleHR9YCk7XG4gICAgICAgICAgICAgICAgICBpZiAoYXdhaXQgZXhpc3RzKHBvdGVudGlhbEZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBmaWxlIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzLnByb21pc2VzLnN0YXQocG90ZW50aWFsRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbU3VidGl0bGVzXSBMYXN0IHJlc29ydCBzdWJ0aXRsZSBmaWxlICR7cGF0aC5iYXNlbmFtZShwb3RlbnRpYWxGaWxlKX0gaXMgZW1wdHlgKTtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc3VidGl0bGVGaWxlID0gcG90ZW50aWFsRmlsZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIEZvdW5kIHN1YnRpdGxlcyB3aXRoIGxhc3QgcmVzb3J0IG1ldGhvZDonLCBwYXRoLmJhc2VuYW1lKHN1YnRpdGxlRmlsZSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgbGFuZ3VhZ2UgdmFyaWFudFxuICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ0ZpbGUgPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dW5pcXVlSWR9LSR7dmlkZW9JZH0uJHtsYW5nfSR7ZXh0fWApO1xuICAgICAgICAgICAgICAgICAgaWYgKGF3YWl0IGV4aXN0cyhsYW5nRmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVmVyaWZ5IGZpbGUgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgZnMucHJvbWlzZXMuc3RhdChsYW5nRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBbU3VidGl0bGVzXSBMYXN0IHJlc29ydCBzdWJ0aXRsZSBmaWxlICR7cGF0aC5iYXNlbmFtZShsYW5nRmlsZSl9IGlzIGVtcHR5YCk7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHN1YnRpdGxlRmlsZSA9IGxhbmdGaWxlO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1N1YnRpdGxlc10gRm91bmQgbGFuZ3VhZ2Utc3BlY2lmaWMgc3VidGl0bGVzIHdpdGggbGFzdCByZXNvcnQgbWV0aG9kOicsIHBhdGguYmFzZW5hbWUoc3VidGl0bGVGaWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoc3VidGl0bGVGaWxlKSBicmVhaztcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZm9ybWF0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFtTdWJ0aXRsZXNdIEZvcm1hdCBvcHRpb24gJHtmb3JtYXR9IGZhaWxlZDpgLCBmb3JtYXRFcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBmb3JtYXRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc3VidGl0bGVGaWxlKSBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignW1N1YnRpdGxlc10gTGFzdCByZXNvcnQgc3VidGl0bGUgZXh0cmFjdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc3VidGl0bGVGaWxlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdIE5vIHN1YnRpdGxlIGZpbGUgd2FzIGNyZWF0ZWQgYnkgeXQtZGxwIChuZWl0aGVyIHJlZ3VsYXIgbm9yIGF1dG8tZ2VuZXJhdGVkKScpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN1YnRpdGxlRmlsZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnRpdGxlc10gRXJyb3IgZG93bmxvYWRpbmcgc3VidGl0bGVzIHdpdGggeXQtZGxwOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBFcnJvciBkb3dubG9hZGluZyBzdWJ0aXRsZXMgd2l0aCB5dC1kbHA6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRG93bmxvYWRzIHN1YnRpdGxlcyB1c2luZyB5dGRsLWNvcmVcbiAqIEBwYXJhbSB2aWRlb0lkIFlvdVR1YmUgdmlkZW8gSURcbiAqIEBwYXJhbSBsYW5ndWFnZXMgTGFuZ3VhZ2VzIHRvIHRyeSwgaW4gb3JkZXIgb2YgcHJlZmVyZW5jZVxuICogQHJldHVybnMgVGhlIHBhdGggdG8gdGhlIGRvd25sb2FkZWQgc3VidGl0bGUgZmlsZSBvciBudWxsIGlmIG5vdCBhdmFpbGFibGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRXaXRoWXRkbENvcmUoXG4gIHZpZGVvSWQ6IHN0cmluZyxcbiAgbGFuZ3VhZ2VzOiBzdHJpbmdbXSA9IFsncGwnLCAnZW4nXVxuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIGNvbnNvbGUubG9nKGBbU3VidGl0bGVzXSBVc2luZyB5dGRsLWNvcmUgdG8gZ2V0IHN1YnRpdGxlcyBmb3IgdmlkZW8gJHt2aWRlb0lkfWApO1xuICBcbiAgdHJ5IHtcbiAgICAvLyBHZXQgdmlkZW8gaW5mb1xuICAgIGNvbnN0IHZpZGVvSW5mbyA9IGF3YWl0IHl0ZGwuZ2V0SW5mbyhgaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj0ke3ZpZGVvSWR9YCk7XG4gICAgXG4gICAgLy8gRmluZCBjYXB0aW9uIHRyYWNrc1xuICAgIGNvbnN0IGNhcHRpb25UcmFja3MgPSB2aWRlb0luZm8ucGxheWVyX3Jlc3BvbnNlLmNhcHRpb25zPy5wbGF5ZXJDYXB0aW9uc1RyYWNrbGlzdFJlbmRlcmVyPy5jYXB0aW9uVHJhY2tzO1xuICAgIFxuICAgIGlmICghY2FwdGlvblRyYWNrcyB8fCBjYXB0aW9uVHJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnRpdGxlc10gTm8gY2FwdGlvbiB0cmFja3MgZm91bmQgZm9yIHZpZGVvOicsIHZpZGVvSWQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIFRyeSB0byBmaW5kIGNhcHRpb24gaW4gcHJlZmVycmVkIGxhbmd1YWdlc1xuICAgIGxldCBzZWxlY3RlZENhcHRpb25UcmFjayA9IG51bGw7XG4gICAgXG4gICAgZm9yIChjb25zdCBsYW5nIG9mIGxhbmd1YWdlcykge1xuICAgICAgc2VsZWN0ZWRDYXB0aW9uVHJhY2sgPSBjYXB0aW9uVHJhY2tzLmZpbmQoXG4gICAgICAgICh0cmFjazogYW55KSA9PiB0cmFjay5sYW5ndWFnZUNvZGUudG9Mb3dlckNhc2UoKSA9PT0gbGFuZy50b0xvd2VyQ2FzZSgpXG4gICAgICApO1xuICAgICAgXG4gICAgICBpZiAoc2VsZWN0ZWRDYXB0aW9uVHJhY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtTdWJ0aXRsZXNdIEZvdW5kIGNhcHRpb24gdHJhY2sgaW4gbGFuZ3VhZ2U6ICR7bGFuZ31gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIElmIG5vIHByZWZlcnJlZCBsYW5ndWFnZSBmb3VuZCwgdGFrZSB0aGUgZmlyc3QgYXZhaWxhYmxlXG4gICAgaWYgKCFzZWxlY3RlZENhcHRpb25UcmFjaykge1xuICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIE5vIGNhcHRpb25zIGluIHByZWZlcnJlZCBsYW5ndWFnZXMsIHVzaW5nIGZpcnN0IGF2YWlsYWJsZSB0cmFjaycpO1xuICAgICAgc2VsZWN0ZWRDYXB0aW9uVHJhY2sgPSBjYXB0aW9uVHJhY2tzWzBdO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGEgYmFzZVVybCB0byBkb3dubG9hZCBmcm9tXG4gICAgaWYgKCFzZWxlY3RlZENhcHRpb25UcmFjay5iYXNlVXJsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBObyBiYXNlVXJsIGZvdW5kIGZvciBjYXB0aW9uIHRyYWNrJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIHRlbXAgZGlyZWN0b3J5IGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAgICBjb25zdCB0ZW1wRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICd0ZW1wJyk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHRlbXBEaXIpKSB7XG4gICAgICBmcy5ta2RpclN5bmModGVtcERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEdlbmVyYXRlIHVuaXF1ZSBmaWxlIG5hbWVcbiAgICBjb25zdCB1bmlxdWVJZCA9IHJhbmRvbVVVSUQoKTtcbiAgICBjb25zdCBzdWJ0aXRsZUZpbGUgPSBwYXRoLmpvaW4odGVtcERpciwgYCR7dW5pcXVlSWR9LSR7dmlkZW9JZH0ueG1sYCk7XG4gICAgXG4gICAgLy8gRG93bmxvYWQgdGhlIGNhcHRpb24gZmlsZVxuICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGh0dHBzLmdldChzZWxlY3RlZENhcHRpb25UcmFjay5iYXNlVXJsLCBhc3luYyAocmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEhUVFAgRXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzQ29kZX1gKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICByZXNwb25zZS5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgIGRhdGEgKz0gY2h1bms7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgd3JpdGVGaWxlKHN1YnRpdGxlRmlsZSwgZGF0YSwgJ3V0ZjgnKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXNwb25zZS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHN1YnRpdGxlRmlsZTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIC8vIENoZWNrIGZvciBzcGVjaWZpYyBlcnJvciBtZXNzYWdlcyBmcm9tIHl0ZGwtY29yZSB0aGF0IGluZGljYXRlIHNpZ25hdHVyZSBpc3N1ZXNcbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnJvcj8ubWVzc2FnZSB8fCAnJztcbiAgICBcbiAgICBpZiAoXG4gICAgICBlcnJvck1lc3NhZ2UuaW5jbHVkZXMoJ0NvdWxkIG5vdCBleHRyYWN0IHNpZ25hdHVyZSBkZWNpcGhlcmluZyBmdW5jdGlvbnMnKSB8fFxuICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdDb3VsZCBub3QgZmluZCBwbGF5ZXInKSB8fFxuICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdjaXBoZXInKSB8fFxuICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdkZWNpcGhlcicpXG4gICAgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBZb3VUdWJlIHNpZ25hdHVyZSBleHRyYWN0aW9uIGZhaWxlZC4gVGhpcyB2aWRlbyByZXF1aXJlcyB5dC1kbHAuJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdmlkZW8gcmVxdWlyZXMgeXQtZGxwIHRvIGV4dHJhY3Qgc3VidGl0bGVzLiBQbGVhc2UgaW5zdGFsbCB5dC1kbHAgdG8gc3VwcG9ydCB0aGlzIHZpZGVvLicpO1xuICAgIH1cbiAgICBcbiAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBFcnJvciBkb3dubG9hZGluZyBzdWJ0aXRsZXMgd2l0aCB5dGRsLWNvcmU6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHN1YnRpdGxlIGZpbGUgY29udGVudCBpbnRvIHBsYWluIHRleHRcbiAqIEBwYXJhbSBmaWxlUGF0aCBQYXRoIHRvIHRoZSBzdWJ0aXRsZSBmaWxlXG4gKiBAcmV0dXJucyBQbGFpbiB0ZXh0IGZyb20gc3VidGl0bGVzIG9yIG51bGwgaWYgcGFyc2luZyBmYWlsZWRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlU3VidGl0bGVzRmlsZShmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgaWYgKCFmaWxlUGF0aCB8fCAhKGF3YWl0IGV4aXN0cyhmaWxlUGF0aCkpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBJbnZhbGlkIHN1YnRpdGxlIGZpbGUgcGF0aDonLCBmaWxlUGF0aCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBSZWFkIHRoZSBmaWxlIGNvbnRlbnRcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gcGF0aC5leHRuYW1lKGZpbGVQYXRoKS50b0xvd2VyQ2FzZSgpO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBbU3VidGl0bGVzXSBQYXJzaW5nIHN1YnRpdGxlIGZpbGU6ICR7cGF0aC5iYXNlbmFtZShmaWxlUGF0aCl9ICgke2NvbnRlbnQubGVuZ3RofSBieXRlcylgKTtcbiAgICAvLyBMb2cgdGhlIGZpcnN0IDEwMDAgY2hhcmFjdGVycyBvZiByYXcgc3VidGl0bGUgY29udGVudFxuICAgIGNvbnNvbGUubG9nKGBbU3VidGl0bGVzXSBSYXcgY29udGVudCAoZmlyc3QgMTAwMCBjaGFycyk6XFxuJHtjb250ZW50LnN1YnN0cmluZygwLCAxMDAwKX1gKTtcbiAgICBcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIGxldCBwYXJzZVN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgIC8vIFByaW1hcnkgcGFyc2luZyBhcHByb2FjaFxuICAgIHRyeSB7XG4gICAgICBpZiAoZXh0ZW5zaW9uID09PSAnLnZ0dCcgfHwgZXh0ZW5zaW9uID09PSAnLnNydCcpIHtcbiAgICAgICAgLy8gVXNlIHN1YnRpdGxlIHBhY2thZ2UgZm9yIGluaXRpYWwgcGFyc2luZyBhdHRlbXB0XG4gICAgICAgIGNvbnN0IGNhcHRpb25zID0gc3VidGl0bGUucGFyc2VTeW5jKGNvbnRlbnQpO1xuICAgICAgICB0ZXh0ID0gY2FwdGlvbnNcbiAgICAgICAgICAubWFwKChpdGVtOiBhbnkpID0+IGl0ZW0udGV4dCB8fCAnJylcbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgXG4gICAgICAgIHBhcnNlU3VjY2VzcyA9IHRleHQubGVuZ3RoID4gMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChwYXJzZVN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gU3VjY2Vzc2Z1bGx5IHBhcnNlZCAke2NhcHRpb25zLmxlbmd0aH0gY2FwdGlvbnMgd2l0aCBwcmltYXJ5IHBhcnNlcmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybignW1N1YnRpdGxlc10gUHJpbWFyeSBwYXJzZXIgcmV0dXJuZWQgZW1wdHkgdGV4dCwgd2lsbCB0cnkgZmFsbGJhY2sgbWV0aG9kcycpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV4dGVuc2lvbiA9PT0gJy54bWwnKSB7XG4gICAgICAgIC8vIFBhcnNlIFlvdVR1YmUgWE1MIGZvcm1hdFxuICAgICAgICB0ZXh0ID0gcGFyc2VZb3VUdWJlWG1sQ2FwdGlvbnMoY29udGVudCk7XG4gICAgICAgIHBhcnNlU3VjY2VzcyA9IHRleHQubGVuZ3RoID4gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdIFVuc3VwcG9ydGVkIHN1YnRpdGxlIGZvcm1hdDonLCBleHRlbnNpb24pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tTdWJ0aXRsZXNdIFByaW1hcnkgcGFyc2luZyBmYWlsZWQ6JywgcGFyc2VFcnJvcik7XG4gICAgICAvLyBMb2cgdGhlIGZpcnN0IDUwMCBjaGFycyBvZiBjb250ZW50IGZvciBkZWJ1Z2dpbmdcbiAgICAgIGNvbnNvbGUud2FybignW1N1YnRpdGxlc10gQ29udGVudCBzYW1wbGU6JywgY29udGVudC5zdWJzdHJpbmcoMCwgNTAwKSk7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgcGFyc2luZyBhcHByb2FjaCBpZiBwcmltYXJ5IG1ldGhvZCBmYWlsZWRcbiAgICBpZiAoIXBhcnNlU3VjY2Vzcykge1xuICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIEF0dGVtcHRpbmcgZmFsbGJhY2sgcGFyc2luZyBtZXRob2RzJyk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIDE6IE1hbnVhbCBsaW5lLWJ5LWxpbmUgcGFyc2luZyBmb3IgVlRUL1NSVFxuICAgICAgICBpZiAoZXh0ZW5zaW9uID09PSAnLnZ0dCcgfHwgZXh0ZW5zaW9uID09PSAnLnNydCcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnW1N1YnRpdGxlc10gVHJ5aW5nIG1hbnVhbCBsaW5lLWJ5LWxpbmUgcGFyc2luZycpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpbXBsZSBtYW51YWwgcGFyc2VyIHRoYXQgZXh0cmFjdHMgdGV4dCBiZXR3ZWVuIHRpbWVzdGFtcHNcbiAgICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgIGNvbnN0IHRleHRMaW5lczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBMb29rIGZvciBsaW5lcyB0aGF0IGRvbid0IGhhdmUgdGltZXN0YW1wcyBhbmQgYXJlbid0IG51bWVyaWMtb25seSBpbmRpY2VzXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgbGluZXMsIG51bWVyaWMtb25seSBsaW5lcyAoaW5kaWNlcyksIGFuZCB0aW1lc3RhbXAgbGluZXNcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbGluZSAmJiBcbiAgICAgICAgICAgICAgIS9eXFxkKyQvLnRlc3QobGluZSkgJiYgLy8gU2tpcCBpbmRpY2VzXG4gICAgICAgICAgICAgICFsaW5lLmluY2x1ZGVzKCctLT4nKSAmJiAvLyBTa2lwIHRpbWVzdGFtcHNcbiAgICAgICAgICAgICAgIWxpbmUuc3RhcnRzV2l0aCgnV0VCVlRUJykgJiYgLy8gU2tpcCBoZWFkZXJzXG4gICAgICAgICAgICAgICFsaW5lLnN0YXJ0c1dpdGgoJ05PVEUnKSAmJiAvLyBTa2lwIG5vdGVzXG4gICAgICAgICAgICAgICFsaW5lLnN0YXJ0c1dpdGgoJ1NUWUxFJykgLy8gU2tpcCBzdHlsZSBpbmZvXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGV4dExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRleHQgPSB0ZXh0TGluZXMuam9pbignICcpO1xuICAgICAgICAgIHBhcnNlU3VjY2VzcyA9IHRleHQubGVuZ3RoID4gMDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAocGFyc2VTdWNjZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCAke3RleHRMaW5lcy5sZW5ndGh9IGxpbmVzIHdpdGggbWFudWFsIHBhcnNpbmdgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIGFsbCBwYXJzaW5nIG1ldGhvZHMgZmFpbGVkLCBsb2cgYW4gZXJyb3JcbiAgICAgICAgaWYgKCFwYXJzZVN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBBbGwgcGFyc2luZyBtZXRob2RzIGZhaWxlZCBmb3I6JywgZmlsZVBhdGgpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHN1YnRpdGxlIGNvbnRlbnQgd2l0aCBhbGwgYXZhaWxhYmxlIG1ldGhvZHMnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZmFsbGJhY2tFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBGYWxsYmFjayBwYXJzaW5nIGFsc28gZmFpbGVkOicsIGZhbGxiYWNrRXJyb3IpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCB0aGUgdGV4dFxuICAgIC8vIFJlbW92ZSBIVE1MIHRhZ3MsIGV4dHJhIHdoaXRlc3BhY2UsIGV0Yy5cbiAgICB0ZXh0ID0gdGV4dFxuICAgICAgLnJlcGxhY2UoLzxbXj5dKj4vZywgJycpIC8vIFJlbW92ZSBIVE1MIHRhZ3NcbiAgICAgIC5yZXBsYWNlKC9cXHMrL2csICcgJykgICAgLy8gUmVwbGFjZSBtdWx0aXBsZSBzcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgLnJlcGxhY2UoL1xcey4qP1xcfS9nLCAnJykgLy8gUmVtb3ZlIGN1cmx5IGJyYWNlIGZvcm1hdHRpbmcgKGNvbW1vbiBpbiBTUlQpXG4gICAgICAudHJpbSgpO1xuXG4gICAgLy8gTG9nIHRoZSBmaXJzdCAxMDAwIGNoYXJhY3RlcnMgb2YgY2xlYW5lZCB0ZXh0XG4gICAgY29uc29sZS5sb2coYFtTdWJ0aXRsZXNdIENsZWFuZWQgdGV4dCAoZmlyc3QgMTAwMCBjaGFycyk6XFxuJHt0ZXh0LnN1YnN0cmluZygwLCAxMDAwKX1gKTtcbiAgICBcbiAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gRmluYWwgZXh0cmFjdGVkIHRleHQ6ICR7dGV4dC5sZW5ndGh9IGNoYXJhY3RlcnNgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBFcnJvciBwYXJzaW5nIHN1YnRpdGxlIGZpbGU6JywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIENsZWFuIHVwIHRoZSBmaWxlIHJlZ2FyZGxlc3Mgb2Ygc3VjY2Vzcy9mYWlsdXJlXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHVubGluayhmaWxlUGF0aCk7XG4gICAgICBjb25zb2xlLmxvZygnW1N1YnRpdGxlc10gRGVsZXRlZCB0ZW1wb3JhcnkgZmlsZTonLCBmaWxlUGF0aCk7XG4gICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1tTdWJ0aXRsZXNdIEVycm9yIGRlbGV0aW5nIHRlbXBvcmFyeSBmaWxlOicsIGNsZWFudXBFcnJvcik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIFlvdVR1YmUgWE1MIGNhcHRpb25zIGZvcm1hdFxuICogQHBhcmFtIGNvbnRlbnQgWE1MIGNvbnRlbnQgYXMgc3RyaW5nXG4gKiBAcmV0dXJucyBQbGFpbiB0ZXh0IGZyb20gY2FwdGlvbnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VZb3VUdWJlWG1sQ2FwdGlvbnMoY29udGVudDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gU2ltcGxlIFhNTCBwYXJzaW5nIHRvIGV4dHJhY3QgdGV4dCBmcm9tIDx0ZXh0PiBlbGVtZW50c1xuICBjb25zdCB0ZXh0TWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2goLzx0ZXh0W14+XSo+KC4qPyk8XFwvdGV4dD4vZykgfHwgW107XG4gIGNvbnN0IGNsZWFuZWRUZXh0ID0gdGV4dE1hdGNoZXNcbiAgICAubWFwKG1hdGNoID0+IHtcbiAgICAgIC8vIEV4dHJhY3QgY29udGVudCBiZXR3ZWVuIHRhZ3NcbiAgICAgIGNvbnN0IHRleHQgPSBtYXRjaC5yZXBsYWNlKC88dGV4dFtePl0qPiguKj8pPFxcL3RleHQ+L2csICckMScpO1xuICAgICAgXG4gICAgICAvLyBEZWNvZGUgSFRNTCBlbnRpdGllc1xuICAgICAgcmV0dXJuIHRleHRcbiAgICAgICAgLnJlcGxhY2UoLyZhbXA7L2csICcmJylcbiAgICAgICAgLnJlcGxhY2UoLyZsdDsvZywgJzwnKVxuICAgICAgICAucmVwbGFjZSgvJmd0Oy9nLCAnPicpXG4gICAgICAgIC5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJylcbiAgICAgICAgLnJlcGxhY2UoLyYjMzk7L2csIFwiJ1wiKTtcbiAgICB9KVxuICAgIC5qb2luKCcgJyk7XG4gIFxuICByZXR1cm4gY2xlYW5lZFRleHQ7XG59XG5cbi8qKlxuICogRG93bmxvYWRzIGFuZCBwYXJzZXMgc3VidGl0bGVzIGZyb20gYSBZb3VUdWJlIHZpZGVvXG4gKiBAcGFyYW0gdmlkZW9JZCBZb3VUdWJlIHZpZGVvIElEXG4gKiBAcGFyYW0gbGFuZ3VhZ2VzIExhbmd1YWdlcyB0byB0cnksIGluIG9yZGVyIG9mIHByZWZlcmVuY2VcbiAqIEByZXR1cm5zIFBsYWluIHRleHQgZnJvbSBzdWJ0aXRsZXMgb3IgbnVsbCBpZiB1bmF2YWlsYWJsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmlkZW9TdWJ0aXRsZXMoXG4gIHZpZGVvSWQ6IHN0cmluZyxcbiAgbGFuZ3VhZ2VzOiBzdHJpbmdbXSA9IFsncGwnLCAnZW4nXVxuKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICAgIGlmICghdmlkZW9JZCB8fCB0eXBlb2YgdmlkZW9JZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdIEludmFsaWQgdmlkZW9JZDonLCB2aWRlb0lkKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBZb3VUdWJlIHZpZGVvIElEJyk7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QgY2hlY2sgaWYgeXQtZGxwIGlzIGF2YWlsYWJsZSB0byBwcm92aWRlIGNsZWFyZXIgZXJyb3IgbWVzc2FnZXNcbiAgICBjb25zdCB5dERscEF2YWlsYWJsZSA9IGF3YWl0IGlzWXREbHBBdmFpbGFibGUoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSBFcnJvciBjaGVja2luZyB5dC1kbHAgYXZhaWxhYmlsaXR5OicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcblxuICAgIGlmICgheXREbHBBdmFpbGFibGUpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gJ3l0LWRscCBpcyByZXF1aXJlZCBmb3IgcmVsaWFibGUgc3VidGl0bGUgZXh0cmFjdGlvbi4gUGxlYXNlIGluc3RhbGwgeXQtZGxwIG9uIHlvdXIgc3lzdGVtOlxcbicgK1xuICAgICAgICAn4oCiIG1hY09TOiBicmV3IGluc3RhbGwgeXQtZGxwXFxuJyArXG4gICAgICAgICfigKIgTGludXgvbWFjT1M6IHBpcCBpbnN0YWxsIHl0LWRscFxcbicgK1xuICAgICAgICAn4oCiIFdpbmRvd3M6IHBpcCBpbnN0YWxsIHl0LWRscCBvciBjaG9jbyBpbnN0YWxsIHl0LWRscCc7XG4gICAgICBcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdICcgKyBlcnJvck1zZyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgIH1cbiAgICBcbiAgICAvLyBEb3dubG9hZCBzdWJ0aXRsZXNcbiAgICBjb25zb2xlLmxvZyhgW1N1YnRpdGxlc10gU3RhcnRpbmcgc3VidGl0bGUgZXh0cmFjdGlvbiBmb3IgdmlkZW86ICR7dmlkZW9JZH1gKTtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIFxuICAgIC8vIEFkZCB0aW1lb3V0IGZvciBzdWJwcm9jZXNzIGNhbGxzXG4gICAgY29uc3QgZG93bmxvYWRQcm9taXNlID0gZG93bmxvYWRTdWJ0aXRsZXModmlkZW9JZCwgbGFuZ3VhZ2VzKTtcbiAgICBjb25zdCB0aW1lb3V0UHJvbWlzZSA9IG5ldyBQcm9taXNlPG51bGw+KChfLCByZWplY3QpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVqZWN0KG5ldyBFcnJvcignU3VidGl0bGUgZG93bmxvYWQgdGltZW91dCBhZnRlciAzMCBzZWNvbmRzJykpLCAzMDAwMCk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3Qgc3VidGl0bGVQYXRoID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtkb3dubG9hZFByb21pc2UsIHRpbWVvdXRQcm9taXNlXSk7XG4gICAgXG4gICAgaWYgKCFzdWJ0aXRsZVBhdGgpIHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gYE5vIHN1YnRpdGxlcyBhdmFpbGFibGUgZm9yIHZpZGVvICR7dmlkZW9JZH0uIEVpdGhlciB0aGUgdmlkZW8gZG9lc24ndCBoYXZlIHN1YnRpdGxlcywgb3IgdGhleSBjb3VsZG4ndCBiZSBkb3dubG9hZGVkLmA7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSAnICsgZXJyb3JNc2cpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVmVyaWZ5IGZpbGUgZXhpc3RzIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHBhcnNlXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHN1YnRpdGxlUGF0aCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFtTdWJ0aXRsZXNdIFN1YnRpdGxlIGZpbGUgZG9lcyBub3QgZXhpc3Q6ICR7c3VidGl0bGVQYXRofWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJ0aXRsZSBmaWxlIGRvZXMgbm90IGV4aXN0IGF0ICR7c3VidGl0bGVQYXRofWApO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHRoZSBzdWJ0aXRsZSBmaWxlIHdpdGggdGltZW91dFxuICAgIGNvbnN0IHBhcnNlUHJvbWlzZSA9IHBhcnNlU3VidGl0bGVzRmlsZShzdWJ0aXRsZVBhdGgpO1xuICAgIGNvbnN0IHBhcnNlVGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZTxudWxsPigoXywgcmVqZWN0KSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgRXJyb3IoJ1N1YnRpdGxlIHBhcnNpbmcgdGltZW91dCBhZnRlciAxMCBzZWNvbmRzJykpLCAxMDAwMCk7XG4gICAgfSk7XG4gICAgXG4gICAgY29uc3QgdGV4dCA9IGF3YWl0IFByb21pc2UucmFjZShbcGFyc2VQcm9taXNlLCBwYXJzZVRpbWVvdXRQcm9taXNlXSk7XG4gICAgXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICBjb25zdCBlcnJvck1zZyA9IGBGYWlsZWQgdG8gcGFyc2Ugc3VidGl0bGUgZmlsZSBmb3IgdmlkZW8gJHt2aWRlb0lkfS4gVGhlIHN1YnRpdGxlIGZvcm1hdCBtYXkgYmUgdW5zdXBwb3J0ZWQgb3IgY29ycnVwdGVkLmA7XG4gICAgICBjb25zb2xlLmVycm9yKCdbU3VidGl0bGVzXSAnICsgZXJyb3JNc2cpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnNvbGUubG9nKGBbU3VidGl0bGVzXSBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIHN1YnRpdGxlcyAoJHt0ZXh0Lmxlbmd0aH0gY2hhcnMpIGZvciB2aWRlbzogJHt2aWRlb0lkfSBpbiAke2R1cmF0aW9ufW1zYCk7XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgc3VtbWFyeS9zYW1wbGUgZm9yIGRlYnVnZ2luZ1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDUwMCkge1xuICAgICAgY29uc29sZS5sb2coJ1tTdWJ0aXRsZXNdIFRleHQgc2FtcGxlOicsIHRleHQuc3Vic3RyaW5nKDAsIDUwMCkgKyAnLi4uJyk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0ZXh0O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgLy8gUHJvcGFnYXRlIHRoZSB5dC1kbHAgcmVxdWlyZW1lbnQgZXJyb3JcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKCd5dC1kbHAgaXMgcmVxdWlyZWQnKSkge1xuICAgICAgY29uc29sZS5lcnJvcignW1N1YnRpdGxlc10geXQtZGxwIHJlcXVpcmVtZW50IGVycm9yOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSB0aW1lb3V0IGVycm9ycyBzcGVjaWZpY2FsbHlcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKCd0aW1lb3V0JykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdIE9wZXJhdGlvbiB0aW1lZCBvdXQ6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1YnRpdGxlIGV4dHJhY3Rpb24gdGltZWQgb3V0OiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSBwZXJtaXNzaW9uIGVycm9ycyBzcGVjaWZpY2FsbHlcbiAgICBpZiAoZXJyb3I/Lm1lc3NhZ2U/LmluY2x1ZGVzKCdwZXJtaXNzaW9uIGRlbmllZCcpIHx8IFxuICAgICAgICBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ0VBQ0NFUycpIHx8IFxuICAgICAgICBlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ1Blcm1pc3Npb24gZGVuaWVkJykpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdIFBlcm1pc3Npb24gZXJyb3I6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBlcm1pc3Npb24gZXJyb3IgZHVyaW5nIHN1YnRpdGxlIGV4dHJhY3Rpb246ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ3JlYXRlIG1vcmUgaW5mb3JtYXRpdmUgZXJyb3IgZm9yIHRoZSBjYWxsZXJcbiAgICBsZXQgZXJyb3JNc2cgPSBgRXJyb3IgZXh0cmFjdGluZyBzdWJ0aXRsZXMgZm9yIHZpZGVvICR7dmlkZW9JZH06ICR7ZXJyb3I/Lm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InfWA7XG4gICAgXG4gICAgLy8gQWRkIHRyb3VibGVzaG9vdGluZyBoaW50c1xuICAgIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ3VuYXZhaWxhYmxlIHZpZGVvJykpIHtcbiAgICAgIGVycm9yTXNnICs9ICdcXG5UaGUgdmlkZW8gbWlnaHQgYmUgcHJpdmF0ZSwgYWdlLXJlc3RyaWN0ZWQsIG9yIHJlcXVpcmVzIGxvZ2luLic7XG4gICAgfSBlbHNlIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ3Blcm1pc3Npb24nKSkge1xuICAgICAgZXJyb3JNc2cgKz0gJ1xcbkNoZWNrIGZpbGUgc3lzdGVtIHBlcm1pc3Npb25zIGluIHRoZSB0ZW1wb3JhcnkgZGlyZWN0b3J5Lic7XG4gICAgfSBlbHNlIGlmIChlcnJvcj8ubWVzc2FnZT8uaW5jbHVkZXMoJ25ldHdvcmsnKSkge1xuICAgICAgZXJyb3JNc2cgKz0gJ1xcbkNoZWNrIHlvdXIgaW50ZXJuZXQgY29ubmVjdGlvbiBhbmQgdHJ5IGFnYWluLic7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUuZXJyb3IoJ1tTdWJ0aXRsZXNdICcgKyBlcnJvck1zZyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBzdWJ0aXRsZXMgZnJvbSBhIFlvdVR1YmUgdmlkZW8gYW5kIHJldHVybnMgdGhlIHRyYW5zY3JpcHQgdGV4dFxuICogV3JhcHBlciBhcm91bmQgZ2V0VmlkZW9TdWJ0aXRsZXMgZm9yIHRoZSBpc29sYXRlZCB2aWRlbyBub3RlcyBzeXN0ZW1cbiAqIFxuICogQHBhcmFtIHZpZGVvSWQgWW91VHViZSB2aWRlbyBJRFxuICogQHJldHVybnMgVGhlIHRyYW5zY3JpcHQgdGV4dFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdFN1YnRpdGxlcyh2aWRlb0lkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICB0cnkge1xuICAgIC8vIFVzZSBleGlzdGluZyBnZXRWaWRlb1N1YnRpdGxlcyBmdW5jdGlvbiB3aXRoIGRlZmF1bHQgbGFuZ3VhZ2UgcHJlZmVyZW5jZXNcbiAgICBjb25zdCB0cmFuc2NyaXB0ID0gYXdhaXQgZ2V0VmlkZW9TdWJ0aXRsZXModmlkZW9JZCk7XG4gICAgXG4gICAgaWYgKCF0cmFuc2NyaXB0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHN1YnRpdGxlcyBhdmFpbGFibGUgZm9yIHRoaXMgdmlkZW8nKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHRyYW5zY3JpcHQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBMb2cgYW5kIHJlLXRocm93IHRvIGVuc3VyZSBlcnJvciBoYW5kbGluZyBpcyBjb25zaXN0ZW50XG4gICAgY29uc29sZS5lcnJvcihgW1N1YnRpdGxlc10gRXJyb3IgZXh0cmFjdGluZyBzdWJ0aXRsZXMgZm9yIHZpZGVvICR7dmlkZW9JZH06YCwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59ICJdLCJuYW1lcyI6WyJmcyIsInBhdGgiLCJleGVjYUNvbW1hbmQiLCJwcm9taXNpZnkiLCJyYW5kb21VVUlEIiwic3VidGl0bGUiLCJpc1ZhbGlkWW91VHViZUlkIiwieXRkbCIsImh0dHBzIiwicmVhZEZpbGUiLCJ3cml0ZUZpbGUiLCJ1bmxpbmsiLCJleGlzdHMiLCJ5dERscFdhcm5pbmdTaG93biIsImlzWXREbHBBdmFpbGFibGUiLCJzaGVsbCIsImVycm9yIiwicHJvY2VzcyIsImNvbnNvbGUiLCJ3YXJuIiwiZG93bmxvYWRTdWJ0aXRsZXMiLCJ2aWRlb0lkIiwibGFuZ3VhZ2VzIiwieXREbHBBdmFpbGFibGUiLCJkb3dubG9hZFdpdGhZdERscCIsIkVycm9yIiwidGVtcERpciIsImpvaW4iLCJjd2QiLCJleGlzdHNTeW5jIiwibWtkaXJTeW5jIiwicmVjdXJzaXZlIiwibW9kZSIsImxvZyIsIm1rZGlyRXJyb3IiLCJtZXNzYWdlIiwidGVzdEZpbGUiLCJEYXRlIiwibm93Iiwid3JpdGVGaWxlU3luYyIsInVubGlua1N5bmMiLCJhY2Nlc3NFcnJvciIsInVuaXF1ZUlkIiwib3V0cHV0VGVtcGxhdGUiLCJsYW5nUHJlZiIsInN0ZG91dCIsImxpc3RPdXRwdXQiLCJ0aW1lb3V0IiwiaGFzTWFudWFsU3VicyIsImluY2x1ZGVzIiwiaGFzQXV0b1N1YnMiLCJpbmZvRXJyb3IiLCJzdWJ0aXRsZUZpbGUiLCJwb3NzaWJsZUV4dGVuc2lvbnMiLCJ5dERscENvbW1hbmQiLCJzdGRlcnIiLCJleHQiLCJwb3RlbnRpYWxGaWxlIiwiYmFzZW5hbWUiLCJsYW5nIiwibGFuZ0ZpbGVQYXR0ZXJucyIsInBhdHRlcm4iLCJnbG9iUmVzdWx0IiwidHJpbSIsImZpbGVzIiwic3BsaXQiLCJsZW5ndGgiLCJzdGF0cyIsInByb21pc2VzIiwic3RhdCIsInNpemUiLCJhdXRvU3ViQ29tbWFuZCIsImZvcm1hdE9wdGlvbnMiLCJmb3JtYXQiLCJsYXN0UmVzb3J0Q29tbWFuZCIsImxhbmdGaWxlIiwiZm9ybWF0RXJyb3IiLCJkb3dubG9hZFdpdGhZdGRsQ29yZSIsInZpZGVvSW5mbyIsImdldEluZm8iLCJjYXB0aW9uVHJhY2tzIiwicGxheWVyX3Jlc3BvbnNlIiwiY2FwdGlvbnMiLCJwbGF5ZXJDYXB0aW9uc1RyYWNrbGlzdFJlbmRlcmVyIiwic2VsZWN0ZWRDYXB0aW9uVHJhY2siLCJmaW5kIiwidHJhY2siLCJsYW5ndWFnZUNvZGUiLCJ0b0xvd2VyQ2FzZSIsImJhc2VVcmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdldCIsInJlc3BvbnNlIiwic3RhdHVzQ29kZSIsImRhdGEiLCJvbiIsImNodW5rIiwiZXJyIiwiZXJyb3JNZXNzYWdlIiwicGFyc2VTdWJ0aXRsZXNGaWxlIiwiZmlsZVBhdGgiLCJjb250ZW50IiwiZXh0ZW5zaW9uIiwiZXh0bmFtZSIsInN1YnN0cmluZyIsInRleHQiLCJwYXJzZVN1Y2Nlc3MiLCJwYXJzZVN5bmMiLCJtYXAiLCJpdGVtIiwiZmlsdGVyIiwiQm9vbGVhbiIsInBhcnNlWW91VHViZVhtbENhcHRpb25zIiwicGFyc2VFcnJvciIsImxpbmVzIiwidGV4dExpbmVzIiwiaSIsImxpbmUiLCJ0ZXN0Iiwic3RhcnRzV2l0aCIsInB1c2giLCJmYWxsYmFja0Vycm9yIiwicmVwbGFjZSIsImNsZWFudXBFcnJvciIsInRleHRNYXRjaGVzIiwibWF0Y2giLCJjbGVhbmVkVGV4dCIsImdldFZpZGVvU3VidGl0bGVzIiwiY2F0Y2giLCJlcnJvck1zZyIsInN0YXJ0VGltZSIsImRvd25sb2FkUHJvbWlzZSIsInRpbWVvdXRQcm9taXNlIiwiXyIsInNldFRpbWVvdXQiLCJzdWJ0aXRsZVBhdGgiLCJyYWNlIiwicGFyc2VQcm9taXNlIiwicGFyc2VUaW1lb3V0UHJvbWlzZSIsImR1cmF0aW9uIiwiZXh0cmFjdFN1YnRpdGxlcyIsInRyYW5zY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/subtitles.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/youtube.ts":
/*!*********************************!*\
  !*** ./src/services/youtube.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   extractYouTubeId: () => (/* binding */ extractYouTubeId),\n/* harmony export */   getVideoInfo: () => (/* binding */ getVideoInfo),\n/* harmony export */   getVideoTranscript: () => (/* binding */ getVideoTranscript),\n/* harmony export */   isLikelyUrl: () => (/* reexport safe */ _youtube_validators__WEBPACK_IMPORTED_MODULE_0__.isLikelyUrl),\n/* harmony export */   isValidYouTubeId: () => (/* binding */ isValidYouTubeId),\n/* harmony export */   safeParseUrl: () => (/* binding */ safeParseUrl)\n/* harmony export */ });\n/* harmony import */ var _youtube_validators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./youtube/validators */ \"(rsc)/./src/services/youtube/validators.ts\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! util */ \"util\");\n/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _subtitles__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./subtitles */ \"(rsc)/./src/services/subtitles.ts\");\n\n\n\n\n// Re-export the validators for backward compatibility\n\n// Promisify exec for async/await usage\nconst execAsync = (0,util__WEBPACK_IMPORTED_MODULE_2__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_1__.exec);\n/**\n * Safely attempts to parse a URL string\n * @param urlString The URL string to parse\n * @returns URL object if successful, null if not\n */ function safeParseUrl(urlString) {\n    try {\n        // Add protocol if missing\n        let normalizedUrl = urlString.trim();\n        if (normalizedUrl.startsWith(\"//\")) {\n            normalizedUrl = `https:${normalizedUrl}`;\n        } else if (!normalizedUrl.startsWith(\"http://\") && !normalizedUrl.startsWith(\"https://\")) {\n            normalizedUrl = `https://${normalizedUrl}`;\n        }\n        return new URL(normalizedUrl);\n    } catch (error) {\n        console.warn(\"[YouTube] Failed to parse URL:\", error);\n        return null;\n    }\n}\n/**\n * Extracts a YouTube video ID from a URL\n * Supports various YouTube URL formats\n */ function extractYouTubeId(url) {\n    if (!url) return null;\n    // Clean the URL by trimming and handling mobile URLs\n    let cleanUrl = url.trim();\n    // Convert mobile youtube URLs to standard format\n    if (cleanUrl.includes(\"youtu.be/\")) {\n        cleanUrl = cleanUrl.replace(\"youtu.be/\", \"youtube.com/watch?v=\");\n    }\n    try {\n        // Try to parse as URL and extract from searchParams (standard youtube.com/watch?v=ID format)\n        const urlObj = new URL(cleanUrl);\n        // Handle youtube.com/watch?v=ID format\n        if (urlObj.hostname.includes(\"youtube.com\") && urlObj.pathname.includes(\"/watch\")) {\n            const videoId = urlObj.searchParams.get(\"v\");\n            if (videoId) return videoId;\n        }\n        // Handle youtube.com/embed/ID format\n        if (urlObj.hostname.includes(\"youtube\") && urlObj.pathname.includes(\"/embed/\")) {\n            const parts = urlObj.pathname.split(\"/\");\n            return parts[parts.indexOf(\"embed\") + 1] || null;\n        }\n        // Handle youtu.be/ID format (already converted to standard format above, but just in case)\n        if (urlObj.hostname === \"youtu.be\") {\n            return urlObj.pathname.substring(1) || null;\n        }\n        // Handle youtube.com/v/ID format\n        if (urlObj.hostname.includes(\"youtube\") && urlObj.pathname.includes(\"/v/\")) {\n            const parts = urlObj.pathname.split(\"/\");\n            return parts[parts.indexOf(\"v\") + 1] || null;\n        }\n    } catch (e) {\n        // If URL parsing fails, try regex-based extraction\n        console.error(\"URL parsing failed, trying regex fallback:\", e);\n    }\n    // Fallback to regex for cases where URL parsing fails\n    const patterns = [\n        /(?:youtube\\.com\\/watch\\?v=|youtu\\.be\\/|youtube\\.com\\/embed\\/|youtube\\.com\\/v\\/)([^&\\n?#]+)/,\n        /^([a-zA-Z0-9_-]{11})$/ // Direct video ID (11 characters)\n    ];\n    for (const pattern of patterns){\n        const match = cleanUrl.match(pattern);\n        if (match && match[1]) {\n            return match[1];\n        }\n    }\n    return null;\n}\n/**\n * Validates if a string is a valid YouTube video ID\n */ function isValidYouTubeId(id) {\n    if (!id) return false;\n    // YouTube IDs are typically 11 characters and contain only certain characters\n    const validPattern = /^[a-zA-Z0-9_-]{11}$/;\n    return validPattern.test(id);\n}\n/**\n * Gets information about a YouTube video\n */ async function getVideoInfo(videoId) {\n    if (!videoId) {\n        return {\n            videoId: \"\",\n            title: \"\",\n            thumbnailUrl: \"\",\n            error: \"No video ID provided\"\n        };\n    }\n    try {\n        // Use YouTube API to get video info\n        const apiKey = \"AIzaSyCvUahUwoVQyozpRphtVWE0ev0ha46wo0I\";\n        if (!apiKey) {\n            console.error(\"[YouTube Service] No YouTube API key configured\");\n            return {\n                videoId,\n                title: `YouTube Video (${videoId})`,\n                thumbnailUrl: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,\n                error: \"YouTube API key not configured - using fallback data\"\n            };\n        }\n        const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet&id=${videoId}&key=${apiKey}`, {\n            next: {\n                revalidate: 3600\n            }\n        } // Cache for 1 hour\n        );\n        if (!response.ok) {\n            const errorData = await response.json();\n            console.error(\"[YouTube Service] YouTube API error:\", errorData);\n            // Fall back to basic info using video ID\n            return {\n                videoId,\n                title: `YouTube Video (${videoId})`,\n                thumbnailUrl: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,\n                error: `YouTube API error: ${errorData.error?.message || response.statusText}`\n            };\n        }\n        const data = await response.json();\n        if (!data.items || data.items.length === 0) {\n            console.error(\"[YouTube Service] Video not found:\", videoId);\n            return {\n                videoId,\n                title: `Video Not Found (${videoId})`,\n                thumbnailUrl: \"\",\n                error: \"Video not found\"\n            };\n        }\n        const videoDetails = data.items[0].snippet;\n        return {\n            videoId,\n            title: videoDetails.title,\n            description: videoDetails.description,\n            thumbnailUrl: videoDetails.thumbnails?.high?.url || videoDetails.thumbnails?.default?.url || \"\",\n            channelTitle: videoDetails.channelTitle,\n            publishedAt: videoDetails.publishedAt\n        };\n    } catch (error) {\n        console.error(\"[YouTube Service] Error fetching video info:\", error);\n        // Fall back to basic info using video ID\n        return {\n            videoId,\n            title: `YouTube Video (${videoId})`,\n            thumbnailUrl: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,\n            error: `Error fetching video info: ${error.message}`\n        };\n    }\n}\n/**\n * Gets the transcript for a YouTube video\n * Wraps the subtitle extraction service to provide consistent error handling\n */ async function getVideoTranscript(videoId) {\n    if (!videoId) {\n        return {\n            transcript: \"\",\n            error: \"No video ID provided\"\n        };\n    }\n    try {\n        // Use the subtitles service to extract transcript\n        const transcript = await (0,_subtitles__WEBPACK_IMPORTED_MODULE_3__.extractSubtitles)(videoId);\n        if (!transcript || transcript.trim().length === 0) {\n            return {\n                transcript: \"\",\n                error: \"No subtitles available for this video\"\n            };\n        }\n        return {\n            transcript\n        };\n    } catch (error) {\n        console.error(\"[YouTube Service] Error extracting transcript:\", error);\n        // Provide specific error messages for common issues\n        if (error.message?.includes(\"yt-dlp is required\")) {\n            return {\n                transcript: \"\",\n                error: \"yt-dlp is required but not installed\"\n            };\n        }\n        if (error.message?.includes(\"subtitles are disabled\")) {\n            return {\n                transcript: \"\",\n                error: \"This video has disabled subtitles\"\n            };\n        }\n        if (error.message?.includes(\"not available\")) {\n            return {\n                transcript: \"\",\n                error: \"No subtitles available for this video\"\n            };\n        }\n        return {\n            transcript: \"\",\n            error: `Error extracting transcript: ${error.message}`\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNMVSxZQUFZO2dCQUNadEQsT0FBTztZQUNUO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xzRDtRQUNGO0lBQ0YsRUFBRSxPQUFPdEQsT0FBWTtRQUNuQkMsUUFBUUQsS0FBSyxDQUFDLGtEQUFrREE7UUFFaEUsb0RBQW9EO1FBQ3BELElBQUlBLE1BQU13QyxPQUFPLEVBQUVsQyxTQUFTLHVCQUF1QjtZQUNqRCxPQUFPO2dCQUNMZ0QsWUFBWTtnQkFDWnRELE9BQU87WUFDVDtRQUNGO1FBRUEsSUFBSUEsTUFBTXdDLE9BQU8sRUFBRWxDLFNBQVMsMkJBQTJCO1lBQ3JELE9BQU87Z0JBQ0xnRCxZQUFZO2dCQUNadEQsT0FBTztZQUNUO1FBQ0Y7UUFFQSxJQUFJQSxNQUFNd0MsT0FBTyxFQUFFbEMsU0FBUyxrQkFBa0I7WUFDNUMsT0FBTztnQkFDTGdELFlBQVk7Z0JBQ1p0RCxPQUFPO1lBQ1Q7UUFDRjtRQUVBLE9BQU87WUFDTHNELFlBQVk7WUFDWnRELE9BQU8sQ0FBQyw2QkFBNkIsRUFBRUEsTUFBTXdDLE9BQU8sQ0FBQyxDQUFDO1FBQ3hEO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy95b3V0dWJlLnRzPzBiNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IGlzTGlrZWx5VXJsIH0gZnJvbSAnLi95b3V0dWJlL3ZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgcHJvbWlzZXMgYXMgZnMgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJztcbmltcG9ydCBvcyBmcm9tICdvcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCB7IGV4dHJhY3RTdWJ0aXRsZXMgfSBmcm9tICcuL3N1YnRpdGxlcyc7XG5cbi8vIFJlLWV4cG9ydCB0aGUgdmFsaWRhdG9ycyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuZXhwb3J0IHsgaXNMaWtlbHlVcmwgfTtcblxuLy8gUHJvbWlzaWZ5IGV4ZWMgZm9yIGFzeW5jL2F3YWl0IHVzYWdlXG5jb25zdCBleGVjQXN5bmMgPSBwcm9taXNpZnkoZXhlYyk7XG5cbi8qKlxuICogWW91VHViZSB2aWRlbyBpbmZvcm1hdGlvbiBvYmplY3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBZb3VUdWJlVmlkZW9JbmZvIHtcbiAgdmlkZW9JZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgdGh1bWJuYWlsVXJsOiBzdHJpbmc7XG4gIGNoYW5uZWxUaXRsZT86IHN0cmluZztcbiAgcHVibGlzaGVkQXQ/OiBzdHJpbmc7XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRyYW5zY3JpcHQgZXh0cmFjdGlvbiByZXN1bHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0UmVzdWx0IHtcbiAgdHJhbnNjcmlwdDogc3RyaW5nO1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTYWZlbHkgYXR0ZW1wdHMgdG8gcGFyc2UgYSBVUkwgc3RyaW5nXG4gKiBAcGFyYW0gdXJsU3RyaW5nIFRoZSBVUkwgc3RyaW5nIHRvIHBhcnNlXG4gKiBAcmV0dXJucyBVUkwgb2JqZWN0IGlmIHN1Y2Nlc3NmdWwsIG51bGwgaWYgbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzYWZlUGFyc2VVcmwodXJsU3RyaW5nOiBzdHJpbmcpOiBVUkwgfCBudWxsIHtcbiAgdHJ5IHtcbiAgICAvLyBBZGQgcHJvdG9jb2wgaWYgbWlzc2luZ1xuICAgIGxldCBub3JtYWxpemVkVXJsID0gdXJsU3RyaW5nLnRyaW0oKTtcbiAgICBpZiAobm9ybWFsaXplZFVybC5zdGFydHNXaXRoKCcvLycpKSB7XG4gICAgICBub3JtYWxpemVkVXJsID0gYGh0dHBzOiR7bm9ybWFsaXplZFVybH1gO1xuICAgIH0gZWxzZSBpZiAoIW5vcm1hbGl6ZWRVcmwuc3RhcnRzV2l0aCgnaHR0cDovLycpICYmICFub3JtYWxpemVkVXJsLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgIG5vcm1hbGl6ZWRVcmwgPSBgaHR0cHM6Ly8ke25vcm1hbGl6ZWRVcmx9YDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG5ldyBVUkwobm9ybWFsaXplZFVybCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS53YXJuKCdbWW91VHViZV0gRmFpbGVkIHRvIHBhcnNlIFVSTDonLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBhIFlvdVR1YmUgdmlkZW8gSUQgZnJvbSBhIFVSTFxuICogU3VwcG9ydHMgdmFyaW91cyBZb3VUdWJlIFVSTCBmb3JtYXRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0WW91VHViZUlkKHVybDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmICghdXJsKSByZXR1cm4gbnVsbDtcbiAgXG4gIC8vIENsZWFuIHRoZSBVUkwgYnkgdHJpbW1pbmcgYW5kIGhhbmRsaW5nIG1vYmlsZSBVUkxzXG4gIGxldCBjbGVhblVybCA9IHVybC50cmltKCk7XG4gIFxuICAvLyBDb252ZXJ0IG1vYmlsZSB5b3V0dWJlIFVSTHMgdG8gc3RhbmRhcmQgZm9ybWF0XG4gIGlmIChjbGVhblVybC5pbmNsdWRlcygneW91dHUuYmUvJykpIHtcbiAgICBjbGVhblVybCA9IGNsZWFuVXJsLnJlcGxhY2UoJ3lvdXR1LmJlLycsICd5b3V0dWJlLmNvbS93YXRjaD92PScpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIC8vIFRyeSB0byBwYXJzZSBhcyBVUkwgYW5kIGV4dHJhY3QgZnJvbSBzZWFyY2hQYXJhbXMgKHN0YW5kYXJkIHlvdXR1YmUuY29tL3dhdGNoP3Y9SUQgZm9ybWF0KVxuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwoY2xlYW5VcmwpO1xuICAgIFxuICAgIC8vIEhhbmRsZSB5b3V0dWJlLmNvbS93YXRjaD92PUlEIGZvcm1hdFxuICAgIGlmICh1cmxPYmouaG9zdG5hbWUuaW5jbHVkZXMoJ3lvdXR1YmUuY29tJykgJiYgdXJsT2JqLnBhdGhuYW1lLmluY2x1ZGVzKCcvd2F0Y2gnKSkge1xuICAgICAgY29uc3QgdmlkZW9JZCA9IHVybE9iai5zZWFyY2hQYXJhbXMuZ2V0KCd2Jyk7XG4gICAgICBpZiAodmlkZW9JZCkgcmV0dXJuIHZpZGVvSWQ7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSB5b3V0dWJlLmNvbS9lbWJlZC9JRCBmb3JtYXRcbiAgICBpZiAodXJsT2JqLmhvc3RuYW1lLmluY2x1ZGVzKCd5b3V0dWJlJykgJiYgdXJsT2JqLnBhdGhuYW1lLmluY2x1ZGVzKCcvZW1iZWQvJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdXJsT2JqLnBhdGhuYW1lLnNwbGl0KCcvJyk7XG4gICAgICByZXR1cm4gcGFydHNbcGFydHMuaW5kZXhPZignZW1iZWQnKSArIDFdIHx8IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIEhhbmRsZSB5b3V0dS5iZS9JRCBmb3JtYXQgKGFscmVhZHkgY29udmVydGVkIHRvIHN0YW5kYXJkIGZvcm1hdCBhYm92ZSwgYnV0IGp1c3QgaW4gY2FzZSlcbiAgICBpZiAodXJsT2JqLmhvc3RuYW1lID09PSAneW91dHUuYmUnKSB7XG4gICAgICByZXR1cm4gdXJsT2JqLnBhdGhuYW1lLnN1YnN0cmluZygxKSB8fCBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBIYW5kbGUgeW91dHViZS5jb20vdi9JRCBmb3JtYXRcbiAgICBpZiAodXJsT2JqLmhvc3RuYW1lLmluY2x1ZGVzKCd5b3V0dWJlJykgJiYgdXJsT2JqLnBhdGhuYW1lLmluY2x1ZGVzKCcvdi8nKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB1cmxPYmoucGF0aG5hbWUuc3BsaXQoJy8nKTtcbiAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5pbmRleE9mKCd2JykgKyAxXSB8fCBudWxsO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElmIFVSTCBwYXJzaW5nIGZhaWxzLCB0cnkgcmVnZXgtYmFzZWQgZXh0cmFjdGlvblxuICAgIGNvbnNvbGUuZXJyb3IoJ1VSTCBwYXJzaW5nIGZhaWxlZCwgdHJ5aW5nIHJlZ2V4IGZhbGxiYWNrOicsIGUpO1xuICB9XG4gIFxuICAvLyBGYWxsYmFjayB0byByZWdleCBmb3IgY2FzZXMgd2hlcmUgVVJMIHBhcnNpbmcgZmFpbHNcbiAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgLyg/OnlvdXR1YmVcXC5jb21cXC93YXRjaFxcP3Y9fHlvdXR1XFwuYmVcXC98eW91dHViZVxcLmNvbVxcL2VtYmVkXFwvfHlvdXR1YmVcXC5jb21cXC92XFwvKShbXiZcXG4/I10rKS8sXG4gICAgL14oW2EtekEtWjAtOV8tXXsxMX0pJC8gIC8vIERpcmVjdCB2aWRlbyBJRCAoMTEgY2hhcmFjdGVycylcbiAgXTtcbiAgXG4gIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgIGNvbnN0IG1hdGNoID0gY2xlYW5VcmwubWF0Y2gocGF0dGVybik7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMV07XG4gICAgfVxuICB9XG4gIFxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBZb3VUdWJlIHZpZGVvIElEXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkWW91VHViZUlkKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCFpZCkgcmV0dXJuIGZhbHNlO1xuICBcbiAgLy8gWW91VHViZSBJRHMgYXJlIHR5cGljYWxseSAxMSBjaGFyYWN0ZXJzIGFuZCBjb250YWluIG9ubHkgY2VydGFpbiBjaGFyYWN0ZXJzXG4gIGNvbnN0IHZhbGlkUGF0dGVybiA9IC9eW2EtekEtWjAtOV8tXXsxMX0kLztcbiAgcmV0dXJuIHZhbGlkUGF0dGVybi50ZXN0KGlkKTtcbn1cblxuLyoqXG4gKiBHZXRzIGluZm9ybWF0aW9uIGFib3V0IGEgWW91VHViZSB2aWRlb1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VmlkZW9JbmZvKHZpZGVvSWQ6IHN0cmluZyk6IFByb21pc2U8WW91VHViZVZpZGVvSW5mbz4ge1xuICBpZiAoIXZpZGVvSWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmlkZW9JZDogJycsXG4gICAgICB0aXRsZTogJycsXG4gICAgICB0aHVtYm5haWxVcmw6ICcnLFxuICAgICAgZXJyb3I6ICdObyB2aWRlbyBJRCBwcm92aWRlZCdcbiAgICB9O1xuICB9XG4gIFxuICB0cnkge1xuICAgIC8vIFVzZSBZb3VUdWJlIEFQSSB0byBnZXQgdmlkZW8gaW5mb1xuICAgIGNvbnN0IGFwaUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1lPVVRVQkVfQVBJX0tFWTtcbiAgICBcbiAgICBpZiAoIWFwaUtleSkge1xuICAgICAgY29uc29sZS5lcnJvcignW1lvdVR1YmUgU2VydmljZV0gTm8gWW91VHViZSBBUEkga2V5IGNvbmZpZ3VyZWQnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZpZGVvSWQsXG4gICAgICAgIHRpdGxlOiBgWW91VHViZSBWaWRlbyAoJHt2aWRlb0lkfSlgLFxuICAgICAgICB0aHVtYm5haWxVcmw6IGBodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8ke3ZpZGVvSWR9L2hxZGVmYXVsdC5qcGdgLFxuICAgICAgICBlcnJvcjogJ1lvdVR1YmUgQVBJIGtleSBub3QgY29uZmlndXJlZCAtIHVzaW5nIGZhbGxiYWNrIGRhdGEnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgYGh0dHBzOi8vd3d3Lmdvb2dsZWFwaXMuY29tL3lvdXR1YmUvdjMvdmlkZW9zP3BhcnQ9c25pcHBldCZpZD0ke3ZpZGVvSWR9JmtleT0ke2FwaUtleX1gLFxuICAgICAgeyBuZXh0OiB7IHJldmFsaWRhdGU6IDM2MDAgfSB9IC8vIENhY2hlIGZvciAxIGhvdXJcbiAgICApO1xuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tZb3VUdWJlIFNlcnZpY2VdIFlvdVR1YmUgQVBJIGVycm9yOicsIGVycm9yRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEZhbGwgYmFjayB0byBiYXNpYyBpbmZvIHVzaW5nIHZpZGVvIElEXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2aWRlb0lkLFxuICAgICAgICB0aXRsZTogYFlvdVR1YmUgVmlkZW8gKCR7dmlkZW9JZH0pYCxcbiAgICAgICAgdGh1bWJuYWlsVXJsOiBgaHR0cHM6Ly9pbWcueW91dHViZS5jb20vdmkvJHt2aWRlb0lkfS9ocWRlZmF1bHQuanBnYCxcbiAgICAgICAgZXJyb3I6IGBZb3VUdWJlIEFQSSBlcnJvcjogJHtlcnJvckRhdGEuZXJyb3I/Lm1lc3NhZ2UgfHwgcmVzcG9uc2Uuc3RhdHVzVGV4dH1gXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIFxuICAgIGlmICghZGF0YS5pdGVtcyB8fCBkYXRhLml0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc29sZS5lcnJvcignW1lvdVR1YmUgU2VydmljZV0gVmlkZW8gbm90IGZvdW5kOicsIHZpZGVvSWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmlkZW9JZCxcbiAgICAgICAgdGl0bGU6IGBWaWRlbyBOb3QgRm91bmQgKCR7dmlkZW9JZH0pYCxcbiAgICAgICAgdGh1bWJuYWlsVXJsOiAnJyxcbiAgICAgICAgZXJyb3I6ICdWaWRlbyBub3QgZm91bmQnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB2aWRlb0RldGFpbHMgPSBkYXRhLml0ZW1zWzBdLnNuaXBwZXQ7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHZpZGVvSWQsXG4gICAgICB0aXRsZTogdmlkZW9EZXRhaWxzLnRpdGxlLFxuICAgICAgZGVzY3JpcHRpb246IHZpZGVvRGV0YWlscy5kZXNjcmlwdGlvbixcbiAgICAgIHRodW1ibmFpbFVybDogdmlkZW9EZXRhaWxzLnRodW1ibmFpbHM/LmhpZ2g/LnVybCB8fCB2aWRlb0RldGFpbHMudGh1bWJuYWlscz8uZGVmYXVsdD8udXJsIHx8ICcnLFxuICAgICAgY2hhbm5lbFRpdGxlOiB2aWRlb0RldGFpbHMuY2hhbm5lbFRpdGxlLFxuICAgICAgcHVibGlzaGVkQXQ6IHZpZGVvRGV0YWlscy5wdWJsaXNoZWRBdFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbWW91VHViZSBTZXJ2aWNlXSBFcnJvciBmZXRjaGluZyB2aWRlbyBpbmZvOicsIGVycm9yKTtcbiAgICBcbiAgICAvLyBGYWxsIGJhY2sgdG8gYmFzaWMgaW5mbyB1c2luZyB2aWRlbyBJRFxuICAgIHJldHVybiB7XG4gICAgICB2aWRlb0lkLFxuICAgICAgdGl0bGU6IGBZb3VUdWJlIFZpZGVvICgke3ZpZGVvSWR9KWAsXG4gICAgICB0aHVtYm5haWxVcmw6IGBodHRwczovL2ltZy55b3V0dWJlLmNvbS92aS8ke3ZpZGVvSWR9L2hxZGVmYXVsdC5qcGdgLFxuICAgICAgZXJyb3I6IGBFcnJvciBmZXRjaGluZyB2aWRlbyBpbmZvOiAke2Vycm9yLm1lc3NhZ2V9YFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0cmFuc2NyaXB0IGZvciBhIFlvdVR1YmUgdmlkZW9cbiAqIFdyYXBzIHRoZSBzdWJ0aXRsZSBleHRyYWN0aW9uIHNlcnZpY2UgdG8gcHJvdmlkZSBjb25zaXN0ZW50IGVycm9yIGhhbmRsaW5nXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRWaWRlb1RyYW5zY3JpcHQodmlkZW9JZDogc3RyaW5nKTogUHJvbWlzZTxUcmFuc2NyaXB0UmVzdWx0PiB7XG4gIGlmICghdmlkZW9JZCkge1xuICAgIHJldHVybiB7XG4gICAgICB0cmFuc2NyaXB0OiAnJyxcbiAgICAgIGVycm9yOiAnTm8gdmlkZW8gSUQgcHJvdmlkZWQnXG4gICAgfTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICAvLyBVc2UgdGhlIHN1YnRpdGxlcyBzZXJ2aWNlIHRvIGV4dHJhY3QgdHJhbnNjcmlwdFxuICAgIGNvbnN0IHRyYW5zY3JpcHQgPSBhd2FpdCBleHRyYWN0U3VidGl0bGVzKHZpZGVvSWQpO1xuICAgIFxuICAgIGlmICghdHJhbnNjcmlwdCB8fCB0cmFuc2NyaXB0LnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxuICAgICAgICBlcnJvcjogJ05vIHN1YnRpdGxlcyBhdmFpbGFibGUgZm9yIHRoaXMgdmlkZW8nXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNjcmlwdFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbWW91VHViZSBTZXJ2aWNlXSBFcnJvciBleHRyYWN0aW5nIHRyYW5zY3JpcHQ6JywgZXJyb3IpO1xuICAgIFxuICAgIC8vIFByb3ZpZGUgc3BlY2lmaWMgZXJyb3IgbWVzc2FnZXMgZm9yIGNvbW1vbiBpc3N1ZXNcbiAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3l0LWRscCBpcyByZXF1aXJlZCcpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFuc2NyaXB0OiAnJyxcbiAgICAgICAgZXJyb3I6ICd5dC1kbHAgaXMgcmVxdWlyZWQgYnV0IG5vdCBpbnN0YWxsZWQnXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBpZiAoZXJyb3IubWVzc2FnZT8uaW5jbHVkZXMoJ3N1YnRpdGxlcyBhcmUgZGlzYWJsZWQnKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNjcmlwdDogJycsXG4gICAgICAgIGVycm9yOiAnVGhpcyB2aWRlbyBoYXMgZGlzYWJsZWQgc3VidGl0bGVzJ1xuICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGVycm9yLm1lc3NhZ2U/LmluY2x1ZGVzKCdub3QgYXZhaWxhYmxlJykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zY3JpcHQ6ICcnLFxuICAgICAgICBlcnJvcjogJ05vIHN1YnRpdGxlcyBhdmFpbGFibGUgZm9yIHRoaXMgdmlkZW8nXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgdHJhbnNjcmlwdDogJycsXG4gICAgICBlcnJvcjogYEVycm9yIGV4dHJhY3RpbmcgdHJhbnNjcmlwdDogJHtlcnJvci5tZXNzYWdlfWBcbiAgICB9O1xuICB9XG59ICJdLCJuYW1lcyI6WyJpc0xpa2VseVVybCIsImV4ZWMiLCJwcm9taXNpZnkiLCJleHRyYWN0U3VidGl0bGVzIiwiZXhlY0FzeW5jIiwic2FmZVBhcnNlVXJsIiwidXJsU3RyaW5nIiwibm9ybWFsaXplZFVybCIsInRyaW0iLCJzdGFydHNXaXRoIiwiVVJMIiwiZXJyb3IiLCJjb25zb2xlIiwid2FybiIsImV4dHJhY3RZb3VUdWJlSWQiLCJ1cmwiLCJjbGVhblVybCIsImluY2x1ZGVzIiwicmVwbGFjZSIsInVybE9iaiIsImhvc3RuYW1lIiwicGF0aG5hbWUiLCJ2aWRlb0lkIiwic2VhcmNoUGFyYW1zIiwiZ2V0IiwicGFydHMiLCJzcGxpdCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJlIiwicGF0dGVybnMiLCJwYXR0ZXJuIiwibWF0Y2giLCJpc1ZhbGlkWW91VHViZUlkIiwiaWQiLCJ2YWxpZFBhdHRlcm4iLCJ0ZXN0IiwiZ2V0VmlkZW9JbmZvIiwidGl0bGUiLCJ0aHVtYm5haWxVcmwiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfWU9VVFVCRV9BUElfS0VZIiwicmVzcG9uc2UiLCJmZXRjaCIsIm5leHQiLCJyZXZhbGlkYXRlIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwibWVzc2FnZSIsInN0YXR1c1RleHQiLCJkYXRhIiwiaXRlbXMiLCJsZW5ndGgiLCJ2aWRlb0RldGFpbHMiLCJzbmlwcGV0IiwiZGVzY3JpcHRpb24iLCJ0aHVtYm5haWxzIiwiaGlnaCIsImRlZmF1bHQiLCJjaGFubmVsVGl0bGUiLCJwdWJsaXNoZWRBdCIsImdldFZpZGVvVHJhbnNjcmlwdCIsInRyYW5zY3JpcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/services/youtube.ts\n");

/***/ }),

/***/ "(rsc)/./src/services/youtube/validators.ts":
/*!********************************************!*\
  !*** ./src/services/youtube/validators.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isLikelyUrl: () => (/* binding */ isLikelyUrl)\n/* harmony export */ });\n/**\n * Validators for YouTube-related functionality\n */ /**\n * Checks if a string is likely a URL\n * @param url The string to check\n * @returns boolean indicating if the string is a valid URL\n */ function isLikelyUrl(url) {\n    try {\n        new URL(url);\n        return true;\n    } catch  {\n        return false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvc2VydmljZXMveW91dHViZS92YWxpZGF0b3JzLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7Q0FFQyxHQUVEOzs7O0NBSUMsR0FDTSxTQUFTQSxZQUFZQyxHQUFXO0lBQ3JDLElBQUk7UUFDRixJQUFJQyxJQUFJRDtRQUNSLE9BQU87SUFDVCxFQUFFLE9BQU07UUFDTixPQUFPO0lBQ1Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2VkdXNjcmliZS8uL3NyYy9zZXJ2aWNlcy95b3V0dWJlL3ZhbGlkYXRvcnMudHM/ZmY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFZhbGlkYXRvcnMgZm9yIFlvdVR1YmUtcmVsYXRlZCBmdW5jdGlvbmFsaXR5XG4gKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgbGlrZWx5IGEgVVJMXG4gKiBAcGFyYW0gdXJsIFRoZSBzdHJpbmcgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgc3RyaW5nIGlzIGEgdmFsaWQgVVJMXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0xpa2VseVVybCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICB0cnkge1xuICAgIG5ldyBVUkwodXJsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59ICJdLCJuYW1lcyI6WyJpc0xpa2VseVVybCIsInVybCIsIlVSTCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/services/youtube/validators.ts\n");

/***/ }),

/***/ "(rsc)/./src/utils/splitTranscript.ts":
/*!**************************************!*\
  !*** ./src/utils/splitTranscript.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateTokenCount: () => (/* binding */ estimateTokenCount),\n/* harmony export */   isChunkWithinTokenLimit: () => (/* binding */ isChunkWithinTokenLimit),\n/* harmony export */   splitTranscriptIntoChunks: () => (/* binding */ splitTranscriptIntoChunks)\n/* harmony export */ });\n/**\n * Represents a chunk of text with metadata\n */ /**\n * Splits a transcript into chunks based on word count\n * @param transcript The full transcript text to split\n * @param maxWords Maximum number of words per chunk (default: 800)\n * @returns Array of TranscriptChunk objects\n */ function splitTranscriptIntoChunks(transcript, maxWords = 800) {\n    // Split into words and filter out empty strings\n    const words = transcript.split(/\\s+/).filter((word)=>word.length > 0);\n    const chunks = [];\n    for(let i = 0; i < words.length; i += maxWords){\n        const startWord = i;\n        const endWord = Math.min(i + maxWords, words.length);\n        const chunkWords = words.slice(startWord, endWord);\n        chunks.push({\n            content: chunkWords.join(\" \"),\n            index: chunks.length,\n            wordCount: chunkWords.length,\n            startWord,\n            endWord\n        });\n    }\n    return chunks;\n}\n/**\n * Estimates the number of tokens in a text string\n * This is a rough estimate: ~4 characters per token on average\n * @param text The text to estimate tokens for\n * @returns Estimated number of tokens\n */ function estimateTokenCount(text) {\n    return Math.ceil(text.length / 4);\n}\n/**\n * Validates if a chunk is within safe token limits\n * @param chunk The chunk to validate\n * @param maxTokens Maximum allowed tokens (default: 3000)\n * @returns boolean indicating if chunk is within limits\n */ function isChunkWithinTokenLimit(chunk, maxTokens = 3000) {\n    return estimateTokenCount(chunk.content) <= maxTokens;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvdXRpbHMvc3BsaXRUcmFuc2NyaXB0LnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOztDQUVDLEdBb0JEOzs7OztDQUtDLEdBQ00sU0FBU0EsMEJBQ2RDLFVBQWtCLEVBQ2xCQyxXQUFtQixHQUFHO0lBRXRCLGdEQUFnRDtJQUNoRCxNQUFNQyxRQUFRRixXQUFXRyxLQUFLLENBQUMsT0FBT0MsTUFBTSxDQUFDQyxDQUFBQSxPQUFRQSxLQUFLQyxNQUFNLEdBQUc7SUFDbkUsTUFBTUMsU0FBNEIsRUFBRTtJQUVwQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sTUFBTUksTUFBTSxFQUFFRSxLQUFLUCxTQUFVO1FBQy9DLE1BQU1RLFlBQVlEO1FBQ2xCLE1BQU1FLFVBQVVDLEtBQUtDLEdBQUcsQ0FBQ0osSUFBSVAsVUFBVUMsTUFBTUksTUFBTTtRQUNuRCxNQUFNTyxhQUFhWCxNQUFNWSxLQUFLLENBQUNMLFdBQVdDO1FBRTFDSCxPQUFPUSxJQUFJLENBQUM7WUFDVkMsU0FBU0gsV0FBV0ksSUFBSSxDQUFDO1lBQ3pCQyxPQUFPWCxPQUFPRCxNQUFNO1lBQ3BCYSxXQUFXTixXQUFXUCxNQUFNO1lBQzVCRztZQUNBQztRQUNGO0lBQ0Y7SUFFQSxPQUFPSDtBQUNUO0FBRUE7Ozs7O0NBS0MsR0FDTSxTQUFTYSxtQkFBbUJDLElBQVk7SUFDN0MsT0FBT1YsS0FBS1csSUFBSSxDQUFDRCxLQUFLZixNQUFNLEdBQUc7QUFDakM7QUFFQTs7Ozs7Q0FLQyxHQUNNLFNBQVNpQix3QkFDZEMsS0FBc0IsRUFDdEJDLFlBQW9CLElBQUk7SUFFeEIsT0FBT0wsbUJBQW1CSSxNQUFNUixPQUFPLEtBQUtTO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWR1c2NyaWJlLy4vc3JjL3V0aWxzL3NwbGl0VHJhbnNjcmlwdC50cz9jZmVlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmVwcmVzZW50cyBhIGNodW5rIG9mIHRleHQgd2l0aCBtZXRhZGF0YVxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRDaHVuayB7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgaW5kZXg6IG51bWJlcjtcbiAgd29yZENvdW50OiBudW1iZXI7XG4gIHN0YXJ0V29yZDogbnVtYmVyO1xuICBlbmRXb3JkOiBudW1iZXI7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGZhaWxlZCBjaHVuayBwcm9jZXNzaW5nIGF0dGVtcHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGYWlsZWRDaHVuayB7XG4gIGluZGV4OiBudW1iZXI7XG4gIHJlYXNvbjogc3RyaW5nO1xuICBhdHRlbXB0czogbnVtYmVyO1xuICBzdGFydFdvcmQ6IG51bWJlcjtcbiAgZW5kV29yZDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFNwbGl0cyBhIHRyYW5zY3JpcHQgaW50byBjaHVua3MgYmFzZWQgb24gd29yZCBjb3VudFxuICogQHBhcmFtIHRyYW5zY3JpcHQgVGhlIGZ1bGwgdHJhbnNjcmlwdCB0ZXh0IHRvIHNwbGl0XG4gKiBAcGFyYW0gbWF4V29yZHMgTWF4aW11bSBudW1iZXIgb2Ygd29yZHMgcGVyIGNodW5rIChkZWZhdWx0OiA4MDApXG4gKiBAcmV0dXJucyBBcnJheSBvZiBUcmFuc2NyaXB0Q2h1bmsgb2JqZWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRUcmFuc2NyaXB0SW50b0NodW5rcyhcbiAgdHJhbnNjcmlwdDogc3RyaW5nLFxuICBtYXhXb3JkczogbnVtYmVyID0gODAwXG4pOiBUcmFuc2NyaXB0Q2h1bmtbXSB7XG4gIC8vIFNwbGl0IGludG8gd29yZHMgYW5kIGZpbHRlciBvdXQgZW1wdHkgc3RyaW5nc1xuICBjb25zdCB3b3JkcyA9IHRyYW5zY3JpcHQuc3BsaXQoL1xccysvKS5maWx0ZXIod29yZCA9PiB3b3JkLmxlbmd0aCA+IDApO1xuICBjb25zdCBjaHVua3M6IFRyYW5zY3JpcHRDaHVua1tdID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkgKz0gbWF4V29yZHMpIHtcbiAgICBjb25zdCBzdGFydFdvcmQgPSBpO1xuICAgIGNvbnN0IGVuZFdvcmQgPSBNYXRoLm1pbihpICsgbWF4V29yZHMsIHdvcmRzLmxlbmd0aCk7XG4gICAgY29uc3QgY2h1bmtXb3JkcyA9IHdvcmRzLnNsaWNlKHN0YXJ0V29yZCwgZW5kV29yZCk7XG4gICAgXG4gICAgY2h1bmtzLnB1c2goe1xuICAgICAgY29udGVudDogY2h1bmtXb3Jkcy5qb2luKCcgJyksXG4gICAgICBpbmRleDogY2h1bmtzLmxlbmd0aCxcbiAgICAgIHdvcmRDb3VudDogY2h1bmtXb3Jkcy5sZW5ndGgsXG4gICAgICBzdGFydFdvcmQsXG4gICAgICBlbmRXb3JkXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY2h1bmtzO1xufVxuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgbnVtYmVyIG9mIHRva2VucyBpbiBhIHRleHQgc3RyaW5nXG4gKiBUaGlzIGlzIGEgcm91Z2ggZXN0aW1hdGU6IH40IGNoYXJhY3RlcnMgcGVyIHRva2VuIG9uIGF2ZXJhZ2VcbiAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGVzdGltYXRlIHRva2VucyBmb3JcbiAqIEByZXR1cm5zIEVzdGltYXRlZCBudW1iZXIgb2YgdG9rZW5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRva2VuQ291bnQodGV4dDogc3RyaW5nKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGguY2VpbCh0ZXh0Lmxlbmd0aCAvIDQpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIGNodW5rIGlzIHdpdGhpbiBzYWZlIHRva2VuIGxpbWl0c1xuICogQHBhcmFtIGNodW5rIFRoZSBjaHVuayB0byB2YWxpZGF0ZVxuICogQHBhcmFtIG1heFRva2VucyBNYXhpbXVtIGFsbG93ZWQgdG9rZW5zIChkZWZhdWx0OiAzMDAwKVxuICogQHJldHVybnMgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNodW5rIGlzIHdpdGhpbiBsaW1pdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2h1bmtXaXRoaW5Ub2tlbkxpbWl0KFxuICBjaHVuazogVHJhbnNjcmlwdENodW5rLFxuICBtYXhUb2tlbnM6IG51bWJlciA9IDMwMDBcbik6IGJvb2xlYW4ge1xuICByZXR1cm4gZXN0aW1hdGVUb2tlbkNvdW50KGNodW5rLmNvbnRlbnQpIDw9IG1heFRva2Vucztcbn0gIl0sIm5hbWVzIjpbInNwbGl0VHJhbnNjcmlwdEludG9DaHVua3MiLCJ0cmFuc2NyaXB0IiwibWF4V29yZHMiLCJ3b3JkcyIsInNwbGl0IiwiZmlsdGVyIiwid29yZCIsImxlbmd0aCIsImNodW5rcyIsImkiLCJzdGFydFdvcmQiLCJlbmRXb3JkIiwiTWF0aCIsIm1pbiIsImNodW5rV29yZHMiLCJzbGljZSIsInB1c2giLCJjb250ZW50Iiwiam9pbiIsImluZGV4Iiwid29yZENvdW50IiwiZXN0aW1hdGVUb2tlbkNvdW50IiwidGV4dCIsImNlaWwiLCJpc0NodW5rV2l0aGluVG9rZW5MaW1pdCIsImNodW5rIiwibWF4VG9rZW5zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/utils/splitTranscript.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/@supabase","vendor-chunks/tr46","vendor-chunks/whatwg-url","vendor-chunks/webidl-conversions","vendor-chunks/formdata-node","vendor-chunks/openai","vendor-chunks/web-streams-polyfill","vendor-chunks/event-target-shim","vendor-chunks/agentkeepalive","vendor-chunks/form-data-encoder","vendor-chunks/abort-controller","vendor-chunks/ms","vendor-chunks/humanize-ms","vendor-chunks/sax","vendor-chunks/isexe","vendor-chunks/execa","vendor-chunks/readable-stream","vendor-chunks/split2","vendor-chunks/duplexer2","vendor-chunks/ytdl-core","vendor-chunks/get-stream","vendor-chunks/cross-spawn","vendor-chunks/m3u8stream","vendor-chunks/human-signals","vendor-chunks/@sec-ant","vendor-chunks/unicorn-magic","vendor-chunks/signal-exit","vendor-chunks/npm-run-path","vendor-chunks/subtitle","vendor-chunks/multipipe","vendor-chunks/inherits","vendor-chunks/yoctocolors","vendor-chunks/strip-final-newline","vendor-chunks/pretty-ms","vendor-chunks/parse-ms","vendor-chunks/is-unicode-supported","vendor-chunks/is-stream","vendor-chunks/is-plain-obj","vendor-chunks/figures","vendor-chunks/@sindresorhus","vendor-chunks/which","vendor-chunks/util-deprecate","vendor-chunks/string_decoder","vendor-chunks/shebang-regex","vendor-chunks/shebang-command","vendor-chunks/safe-buffer","vendor-chunks/process","vendor-chunks/process-nextick-args","vendor-chunks/path-key","vendor-chunks/miniget","vendor-chunks/core-util-is"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fvideo-notes%2Froute&page=%2Fapi%2Fvideo-notes%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fvideo-notes%2Froute.ts&appDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe%2Fsrc%2Fapp&pageExtensions=js&pageExtensions=jsx&pageExtensions=ts&pageExtensions=tsx&pageExtensions=mdx&rootDir=%2FUsers%2Fjanjedrach%2FCursor%2Feduscribe&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=standalone&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();